<!DOCTYPE html>


<html lang="zh-CN">

<head>
  <link rel="stylesheet" type="text/css" href="/css/matery.css">
  <meta charset="utf-8" />
    
  <meta name="description" content="交易费分级机制" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    论文记录-Tiered Mechanisms for Blockchain Transaction Fees |  左边
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-论文记录-Tiered Mechanisms for Blockchain Transaction Fees"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  论文记录-Tiered Mechanisms for Blockchain Transaction Fees
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2023/11/07/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Tiered%20Mechanisms%20for%20Blockchain%20Transaction%20Fees/" class="article-date">
  <time datetime="2023-11-07T07:05:40.000Z" itemprop="datePublished">2023-11-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BA%E6%96%87/">论文</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">7.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">31 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Tiered-Mechanisms-for-Blockchain-Transaction-Fees"><a href="#Tiered-Mechanisms-for-Blockchain-Transaction-Fees" class="headerlink" title="Tiered Mechanisms for Blockchain Transaction Fees"></a>Tiered Mechanisms for Blockchain Transaction Fees</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ol>
<li>证明了以太坊目前使用的交易费机制 EIP-1559 并不具有包容性，并通过实验证明其价格在拥堵期间会横向飙升</li>
<li>引入了一个能够捕捉区块链系统流量多样性的模型，以及一个能够实施更具包容性的交易政策的分级定价机制</li>
<li>从形式上证明了我们的机制可以实现稳定的预期价格，我们还提供了实验结果，证明对于低紧迫性交易来说，交易价格可以保持在较低水平，从而使进入区块链的交易类型多样化</li>
<li>并不一定会牺牲收益，因为由于机制的价格歧视能力，低紧急交易价格的降低可以从高紧急交易中得到补偿</li>
</ol>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><ol>
<li>背景：用户的收益与交易上链时间相关，不同类型应用的交易有不同的紧迫性要求，例如在一个Layer 2支付系统中，DeFi交易更紧急，而结算交易紧迫性较低。理想的交易收费机制自然应该能满足各种应用对不同紧迫性的要求。</li>
<li>现状：主流交易费方法以价格拍卖为主，这导致网络拥塞时，紧急交易加价，连带非紧急交易也需要加价，这样的系统有失公平。</li>
<li>问题：让用户指定交易的紧迫度不现实，还需要考虑沟通成本、激励设计等</li>
<li>本文：分层交易方案<ol>
<li>动态确定层的数量、每一层的延迟和价格，用户自行选择去哪一层</li>
<li>提出了一种新型模型，用于捕捉客户对区块链处理的需求，该模型利用单调递减函数将延迟映射为价值，概括一下就是关注了交易延迟导致的用户收益下降</li>
</ol>
</li>
<li>目标：当系统遇到拥堵时，有一种政策可以在多种类型的用户之间平衡服务，由此考虑符合公开共享和商定的多样性政策的交易费机制，例如规定平均将一个区块中 20% 的交易空间用于低急迫性交易</li>
<li>优势：从流量多样性的角度对分层机制进行了分析，并证明在 “无点质量 “分布的标准假设和预期需求连续的合理假设下，分层机制可以实施丰富多样的政策</li>
<li>实验：研究分层机制如何收敛到一组价格，以及在需求波动时的表现<ol>
<li>研究了需求激增超过网络容量一段时间的重要情况</li>
<li>与 EIP-1559 协议进行了比较</li>
<li>实验结论：<ol>
<li>价值不会随时间显著下降的交易（也就是低紧迫度的交易）价格可以保持在较低水平，从而使进入区块链的交易类型多样化，并根据紧急程度进行适当的价格区分。</li>
<li>EIP-1559 中的价格在整个网络拥堵期间横向飙升。</li>
<li>研究了系统对收入的影响，证明分层定价没牺牲收益。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><h3 id="区块链稳态"><a href="#区块链稳态" class="headerlink" title="区块链稳态"></a>区块链稳态</h3><ol>
<li>用户所提交交易的特点：具有随延迟而变化的价值，每个交易都与一个从延迟到价值的映射的函数$v_i: R_{\geq 1}\rightarrow R_{\geq 0}$有关，延迟最小是1，表示交易在下一个块就上链。如果$d\lt d’$，则$v(d)\gt v(d’)$，意味着延迟越小价值越高。</li>
<li>区块链吞吐量：B，衡量一个块里有多少交易</li>
<li>进入区块链系统的交易价值函数独立同分布，服从分布F，单位区块的交易到达率是$n$，为了模拟高持续需求，这里假设$n\gt B$</li>
<li>区块链交易机制$M(v_i|n,F)=(d,p)$是从交易到价格和延迟的映射，机制与用户身份无关</li>
<li>给定价值是$v$的交易，其收益是$u(v|M,n,F)=v(d)-p$，也就是延迟之后的交易价值减去为了让交易上链而需要付的价格</li>
<li>需求约束：$D=\{v\in supp(F)|v(d)−p\geq 0 for (d,p)=M(v|n,F)\}$</li>
<li>收益非负的交易会以略低于吞吐量的速率到达，$n\cdot Pr[D]\leq B$</li>
<li>例1：机制1：以太坊的机制例子（EIP-1559）：将前一个区块$p$的价格及其满载率$f$作为输入，并输出新的价格，计算公式：$p(1+\frac{1}{8}\frac{f-targetLoad}{targetLoad})$</li>
<li>为了满足需求约束，机制所提供的价格$p_0$必须使得：$B=n\cdot Pr[D]=n\cdot Pr[v(0)\geq p_0]$，由此，机制转变为：$M(v|F)=(0,p_0)$</li>
<li>定义1：稳态近似真实性：对于所有的$n,F,v,v’\neq v$，都有$v(d)−p\geq v(d’)−p’$，其中$(d,p)=M(v|F)$且$(d’,p’)=M(v’|F)$，则称机制M满足真实性。</li>
<li>命题1：稳态近似真实性特征：当且仅当对于所有的$n,F,v_1,v_2$，$d_1\geq d_2\Rightarrow p_1\leq p_2$时机制M是真实的，$M(v_1|F)=(d_1,p_1)$且$M(v_2|F)=(d_2,p_2)$。此外，如果$d_1=d_2$则$p_1=p_2$。</li>
<li>我的问题：交易价值函数服从的分布F，和负载F是一回事吗？分布为什么会变成负载？<ol>
<li>$n$表示每个区块新生成的交易数量。它反映了进入区块链的交易流量和需求。</li>
<li>$F$表示交易价值函数$v$的分布。它描述了不同交易的价值函数$v$以何种概率分布出现。</li>
<li>$(n,F)$表示每隔一个区块有n个新交易生成，这些交易的价值函数v按照分布F进行独立同分布抽样。即n控制交易流量，F控制交易类型组成比例。它们一起描述了区块链面对的总体交易负载情况。</li>
</ol>
</li>
</ol>
<h2 id="Traffic-Diversity"><a href="#Traffic-Diversity" class="headerlink" title="Traffic Diversity"></a>Traffic Diversity</h2><ol>
<li>现有机制倾向于满足具有特定紧迫性要求的交易，而没能让不同紧急程度的交易有效利用平台。</li>
<li>本文引入机制应实施的多样性策略概念来抽象定义什么是多样性的机制，不涉及策略的具体选择。</li>
<li>通过检查交易价值在适当延迟后是否仍高于阈值来区分紧迫度，直观来说，延迟增加时，高紧迫度的交易价值会迅速下降，而低紧迫度则不会。</li>
<li>多样性策略由一组条款组成，这些条款描述了区块链中包含的交易$a_i$的百分比，这些交易在特定延迟$d_i$下的价值超过了某个阈值$p_i$。</li>
<li>定义2：多样化策略：一个多样化策略P是一个集合$\{(a_i,d_i,p_i)\}_{i\in N}$，其中$a_i,d_i,p_i$分别属于$(0,1],R_{\geq 1},(0,1]$。P中的三元组$(a_i,d_i,p_i)$被称为策略条款。</li>
<li>定义3：执行：一个机制M在负载F执行了一个多样性策略$P:=\{(a_i,d_i,p_i)\}_{i\in N}$当且仅当对于所有$i\in N$，$E[|\{j|u(v_j|M,F)\geq v_j(d_i)-p_i\gt 0,(v_1,…,v_n)\leftarrow F\}|]\geq a_i\cdot B$都成立。</li>
<li>例2：给定F，EIP-1559 机制会找到一个值$p$，即当延迟等于 1 时，在期望值上正好有B个交易的价值至少为$p$。因此，它在负载F下执行策略$P:=\{(1, 1, p)\}$（假设 p 存在）。</li>
</ol>
<h2 id="A-Diverse-Mechanism"><a href="#A-Diverse-Mechanism" class="headerlink" title="A Diverse Mechanism"></a>A Diverse Mechanism</h2><h3 id="EIP-1559不满足多样性"><a href="#EIP-1559不满足多样性" class="headerlink" title="EIP-1559不满足多样性"></a>EIP-1559不满足多样性</h3><ol>
<li>机制设计者希望机制能够满足包含某些策略条款$(a,d,p)$的策略P，其中$a\gt 0,d\gt 1$</li>
<li>在给定$(a, d, p)$的情况下，存在一个具有两个紧迫度的价值分布F（如下图），EIP-1559 在$(a, d, p)\in P$的情况下不执行任何策略 P。主要原因是会优先选择小费更高的交易，因而忽略了小费较低的不那么紧迫的交易。<br> <img src="https://github.com/likun1208/image/blob/master/tiered-1.png?raw=true" alt="image"></li>
<li>定义4：图里的负载分布定义：给定参数$a,d,p$，使得$d\gt 1,a,p\gt 0$<ol>
<li>0.5的概率，F输出价值函数$v(1):=2p$和$v(d):=0.2p$</li>
<li>0.5的概率，F输出价值函数$v(1):=\frac{3p}{2}$和$v(d):=p$</li>
<li>两个函数都是单调的</li>
</ol>
</li>
<li>命题2：令$(a,d,p)$作为一个策略条款，其中$d\gt 1,a,p\gt 0$，在前述负载F下，EIP-1559不会实现任何包含$(a,d,p)$的策略P。<br> 证明：按我的理解，这里意思是说，网络拥塞的时候，交易很多，EIP-1559就会把交易费上限设置为接近2p的价格，尽可能打包更多交易，通过提高交易费来试图降低交易量，这样价格较低的第二类交易就不可能被选中。而第一类交易在延迟为d时的价值是0.2p，并不满足策略条款。</li>
</ol>
<h3 id="分层定价机制"><a href="#分层定价机制" class="headerlink" title="分层定价机制"></a>分层定价机制</h3><ol>
<li>将区块内可用空间划分为最多$k$层，每层有各自的延迟$d_i,i\in[k]$和价格$p_i,i\in[k]$，随延迟增加价格下降。第一层的延迟固定为1，是最小延迟，意味着下一块就上链，其他层的延迟和所有层的价格由一组参数控制动态变化。</li>
<li>机制设计目标：该尽量选择最小的满足约束的延迟和价格，同时尽量增加层级数量和使用率。</li>
<li>延迟和价格的计算方式：<script type="math/tex; mode=display">
 d_{j+1}\geq \lambda_jd_j,\lambda_j\gt 1,p_{j+1}\leq \mu_jd_j,\mu_j\gt 1\tag{1}</script> 其中$\lambda_j,\mu_j,j\in[k-1]$是机制的参数。当约束不满足时，机制回改变至少一个层参数（延迟，价格，层数）从而满足约束。</li>
<li>初始状态下，机制只有大小为B的一层。</li>
<li>每次生成新区块时，会根据上一个块的负载调整不同层级的价格。</li>
<li>不同层的延迟变化频率较低（每过dFreq个块，改变一次延迟），以便价格调整能跟得上负载变化。延迟的变化基于连续层价格的关系，如果$p_{i+1}\gt \mu_i-p_i$，则第$i+1$层的延迟就增加，从而使得$p_{i+1}$减小，来满足约束。否则，$d_{i+1}\geq \lambda_i-d_i$，第$i+1$层的延迟会以一定概率减少1，来避免不必要的延迟，提高系统效率。</li>
<li>层的数量变化的频率更低（每tFreq个块改一次），如果最后一层的价值大于$addTierPrice$，且当前层数$m$小于$k$，就会新增一个尺寸为$a_{m+1}B$的层，价格是$newTierPrice$，延迟是$\lambda_md_m$。第$m+1$层的空间是从第1层挪出来的。类似的，如果最后一层的价格小于$removeTierPrice$，且当前层数大于1，则删去最后一层并把空间还给第一层。</li>
<li>延迟惩罚：为了避免用户加入最便宜的层级然后谎报偏好，机制通过延迟处理包含在层级中的交易来实现惩罚，延迟量为层级的延迟量，也就是说，就所有分类账而言，在产生的区块的时间戳超过包含区块的延迟量之前，交易将被忽略。因此，添加到层级中的交易需要支付与层级价格相等的费用。</li>
</ol>
<h2 id="Tiered-Pricing-is-Diverse"><a href="#Tiered-Pricing-is-Diverse" class="headerlink" title="Tiered Pricing is Diverse"></a>Tiered Pricing is Diverse</h2><h3 id="Tiered-Transaction-Mechanisms"><a href="#Tiered-Transaction-Mechanisms" class="headerlink" title="Tiered Transaction Mechanisms"></a>Tiered Transaction Mechanisms</h3><ol>
<li>区块分为$\{0,1,2,…,k\}$个层，除了第0层，每层的尺寸是$B=(B_1,B_2,…,B_k)$，延迟是$d=(d_1,d_2,…,d_k)$，所有层的尺寸加起来是B，B表示区块吞吐量。</li>
<li>第0层是特殊的，用来存放没上链的交易，尺寸$B_0=\infty$。</li>
<li>索引越大，延迟越高，服务越差。</li>
<li>$n\geq B$是新交易的数量，新交易为$\{t_1,t_2,…,t_n\}$，对于交易$t_i$，如果它被放到第$j$层且$j\neq 0$，则效用为：$u(i,j)=v_i(d_j)-p_j,0\lt j\leq k$，如果$j=0$则$u(i,j)=0$。收益反映出每个交易仅在ddl之前上链才能产生价值。</li>
<li>给定延迟d和价格p，交易$i$的效用记作$u_i(d,p)$。</li>
<li>元组$(B,d,p)$表示某特定区块链。</li>
<li><p>分层交易机制M将交易分配到不同层使得总效用最大。可能存在两层效用相同的情况，这时交易随机挑一层分。$X_{ij}$表示交易$i$被分到第$j$层，给定交易$i$的期望效用最大化层级随机集合$D_i=\{j\in\{0\}\cup[k]|u(t_i,j)\geq u(t_i,j’) \forall j’\}$，我们可以定义$X_{ij}$的分布：</p>
<script type="math/tex; mode=display">
 X_{i j}=\left\{\begin{array}{ll}
1 \text { with probability } \frac{B_j}{\sum_{j \in D_i} B_j} & \text { if } j \in D_i \\
0 & \text { otherwise }
\end{array} .\right.\tag{5}</script></li>
<li><p>在确定了交易如何选择层级之后，我们将每个层级的需求量（或已用空间）定义为</p>
</li>
</ol>
<script type="math/tex; mode=display">
    T_j=\sum_{i \in[n]} X_{i j}\tag{6}</script><p>除了第0层外，每层预期需求量最多应与所分配的层级规模相当</p>
<script type="math/tex; mode=display">
    \mathbb{E}\left[T_j\right] \leq B_j\tag{7}</script><p>而第0层的需求量是    </p>
<pre><code>$$
\mathbb{E}\left[T_0\right]=n-\sum_{j \in[k]} \mathbb{E}\left[T_j\right]\tag{8}
$$
</code></pre><h3 id="Distributional-Assumptions"><a href="#Distributional-Assumptions" class="headerlink" title="Distributional Assumptions"></a>Distributional Assumptions</h3><ol>
<li>定义5：需求正则：如果生成的价值可以参数化为元组$(v_0,h)$，则价值函数分布F是需求正则的，其中$v_0\in[0,1]$是无延迟时的价值，$h:R_{\geq 1}\rightarrow [0,1]$是折扣因子函数，形式为$v(d|v_0,h)=v_0h(d)$。同时需要以下条件成立：<ol>
<li>$h(d)$连续且单调减</li>
<li>$lim_{d\rightarrow\infty}h(d)=0$</li>
<li>$v_0$的边缘分布的概率密度函数始终存在，其定义为$f\left(v_0 \mid h\right)=\frac{d \operatorname{Pr}\left[v \leq v_0 \mid h\right]}{d v_0}$</li>
<li>对于$v_0\in[0,1]$，$f(v_0|h)\gt 0$</li>
</ol>
</li>
<li>引理1：对于任意区块链$(B,d,p)$和正则需求$n,F$，$E[T_i]$在p和d中是连续的，即便去掉最后一个假设这个引理也是成立的。</li>
</ol>
<h3 id="Compatible-Blockchains"><a href="#Compatible-Blockchains" class="headerlink" title="Compatible Blockchains"></a>Compatible Blockchains</h3><ol>
<li>定义6：兼容：如果公式7（期望需求小于层尺寸）对于所有层都成立，则称区块链$(B,d,p)$在负载n和F下是兼容的。</li>
<li>定义7：EIP-1559稳定区块链：如果一个区块链$(B,d,p)$在负载$n,F$下是兼容的，且每一层都满足<script type="math/tex; mode=display">
 \frac{\mathbb{E}\left[T_j\right]}{B_j}\lt 1 \Rightarrow p_j=0\tag{9}</script> 则称其是稳定的。</li>
<li><p>观察1：假设$B_1=B_2=1,d_1=0,d_2=1,n=3$，F是：</p>
<ul>
<li>概率$\frac{1}{3}$，延迟小于1时，$v_0$服从$[0,1]$的均匀分布，否则$v_0=0$。</li>
<li><p>概率$\frac{2}{3}$，$v_0$服从$[0,1]$的均匀分布。</p>
<p>如果$p_1\neq p_2$，则$p_1\gt p_2$。否则所有交易都会去选择$B_1$，这样$B_2$就是空的，而根据定义7，$p_2=0$，那么$p_1\lt p_2=0$就与$p_1$非负矛盾了。由此得出两个选项：</p>
</li>
<li>$p_1\gt p_2$。这种情况下，所有d=2的交易都会选择支付$p_2$，为了实现稳定，就需要$p_2\gt 0.5$。但是$p_1\gt p_2\gt 0.5$对于填充$B_1$有些大了。</li>
<li>$p_1=p_2$。这种情况，$B_1$的需求比$B_2$高，因为它会被所有d=1的交易和一半d=2的交易选择。因为$B_1=B_2$，那么在$p_1=p_2$的情况下不可能让交易均匀填充两个区块。因为未填满的区块价格需要设置为0，所以$p_1=p_2\gt 0$是不可能出现的。</li>
</ul>
</li>
<li>总结：<ol>
<li>兼容意思是区块链的交易处理能力可以满足交易的需求量，具体就是每个区块$j$的交易需求量$E[T_j]$小于等于该区块的处理上限$B_j$。这保证了区块链可以流畅运行,不会积压交易造成拥堵。</li>
<li>在兼容的基础上，又满足如果某个区块j的需求量比上限低,则价格$p_j=0$。这反映了EIP-1559的目标——在降低费用的同时,也要最大化区块空间的利用率，不浪费区块资源。</li>
<li>观察1中的分布函数F不连续和大于0，不满足前面分布假设中的要求，所以不稳定。</li>
</ol>
</li>
</ol>
<h3 id="Properties-of-Compatible-and-EIP-1559-Stable-blockchains"><a href="#Properties-of-Compatible-and-EIP-1559-Stable-blockchains" class="headerlink" title="Properties of Compatible and EIP-1559 Stable blockchains"></a>Properties of Compatible and EIP-1559 Stable blockchains</h3><ol>
<li>命题3：有着EIP-1559的以太坊在任何负载下都是兼容的。特别的，对于任意$B,n,F$，都存在价格p使得$(B,d,p)$在负载$n,F$下是兼容的。<br> 证明：在以太坊中，$B=B_1,d_1=0$，显然根据定义5，$p_1=0$可得$E[T_1]=n$。因为$p_1\gt 1$可得$E[T_1]=0$（因为每个交易的最大效用是1），且$E[T_1]$在$p_1$是连续的，所以存在$p_1\gt 0$使得$E [Tj]=B\lt n$，以满足定义6。</li>
<li>兼容性和 EIP-1559 稳定性的结合意味着更直观的属性。</li>
<li>命题4：对于在需求$n,F$下兼容且EIP-1559稳定的任意区块链$(B,d,p)$，对于所有$j\in[k]$，$E[T_j]=B_j$都成立。<br> 证明：如果对于某些层$j$而言， $E[T_j]\lt B_j$ （这是可能兼容的），EIP-1559稳定的性质会使得该层的价格为0。然而，在这种情况下，任何交易都会因加入该层而产生正效用。因为 $n\gt \sum_{j\in[k]}B_j$，这一层会至少有 $n-(\sum_{l\in[k]}B_l-B_j)\gt B_j$ 的需求，因此并不兼容。</li>
<li>引理2：对于任意区块链$(B,d,p)$，和正则需求$n,F$，如果$p_j=1$，则$E[T_j]=0$。</li>
</ol>
<p>证明：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbb{E}\left[T_j\right]=n \cdot \operatorname{Pr}\left[t \in T_j\right] & \leq n \cdot \operatorname{Pr}\left[v_0 \cdot h\left(d_j\right)-p_j \geq 0\right] \\
& \leq n \cdot \operatorname{Pr}\left[v_0 \geq p_j\right] \\
& =0
\end{aligned}</script><p>其中第一个不等式：进入第$j$层的交易效用必须非负。最后一个等式：两个分布假设决定（即，$v_0$分布在$[0,1]$中，并且等于1的概率为零）。</p>
<ol>
<li>引理3：对于任意区块链$(B,d,p)$，和正则需求$n,F$，如果 $p_j=0$，则 $\sum_{j\in[k]}E[T_j]\lt B$。</li>
</ol>
<p>证明：如果$p_j=0$，几乎可以肯定，每笔交易都会在$j$层产生正效用，因此将包含在某个层中（应该是说所有交易都加入这一层）。只要到达率高于吞吐量$n \gt  B$，就能证明这一点。</p>
<ol>
<li>引理4：对于任意区块链$(B,d,p)$，和正则需求$n,F$，其中$p$是EIP-1559稳定的，可得：对于所有$1\leq j\lt k$ 都有$p_j\geq p_{j+1}$。</li>
</ol>
<p>证明：假设对于$1\leq j\lt k$都有$p_j\lt p_{j+1}$，在这种情况下，第$j$层会有比第$j+1$层更低的价格和更低的延迟。因此，根据公式3，我们可得对于任意交易$i$而言，$u(i,j)\gt u(i,j+1)$，这使得$T_{j+1}=\emptyset$。但是，$p_{j+1}\gt p_j\geq 0$会导致矛盾，因为空层的价格一定是0。</p>
<ol>
<li>引理5：令$f:[0,1]^k\rightarrow R^k_{\geq 0}$是一个具有以下属性的函数：<ol>
<li>$f(x_1,x_2,…,x_k)$是在$x$上均匀连续的，且随$x_j,j\in[k]$递减。</li>
<li>如果$x_j=1$，则$f_j(x)=0$，其中$f_j$是$f(x)$的第j个坐标。</li>
<li>如果$x_j=0$，则$\sum_{j\in[k]}f_j(x)\gt B$</li>
<li>对于$y=x+\delta e_j$使得$x,y\lt 1$，可得当$l\neq j$时$f_j(y)\lt  f_j(x)$且$f_l(y)\geq f_l(x)$。</li>
<li>因此，对于任意满足$\sum_{j\in[k]}B_j=B$的$B_1,B_2,…,B_k\gt 0$，对于任意$j\in[k]$，都存在一些$x\in[0,1]^n$使得$f_j(x)=B_j\gt 0$。</li>
</ol>
</li>
<li>定理1：对于任意有着固定$B,d$和任意$n,F$的区块链，都存在$p$使得$(B,d,p)$是兼容且EIP-1559稳定的。</li>
<li>引理6：给定$B,d,n,F$，和两个不同的价格向量$p\geq p’$（即每个$p$中的价格都大于等于$p’$中对应的价格），我们可得对于所有$j\in[k]$都有$\sum_{j\in[k]}T_j\leq\sum_{j\in[k]}T’_j$。</li>
</ol>
<p>证明：令S表示一组估值，如果这些估值被包含在它们最喜欢的区块链层级$(B,d,p’)$中，将会带来正效用。显然如果将它们纳入$(B,d,p)$而不是同一层级，它们的效用都会增加。类似地定义$S’$，可得$S’\subseteq S\Rightarrow Pr[S’]\leq Pr[S]$。因为$S$和$S’$能根据每个交易的首选层被划分为不相交的集合$S_j$，这样$Pr[S_j]=T_j$乘以$n$就得到了所要求的结果。</p>
<ol>
<li>定理2：对于有着固定B和d以及任意$n,F$的区块链，如果存在$p$使得$(B,d,p)$是兼容且EIP-1559稳定，则$p$是独一无二的。</li>
</ol>
<p>证明：假设存在两个不同的价格向量$p\neq p’$使得$(B,d,p)$和$(B,d,p’)$都是在需求$n,F$下兼容且EIP-1559稳定。因为$p\neq p’$，我们可以把价格集合划分为两部分：$P^{+}=\{j\in[k]|p’_j\gt p_j\}$和$P^{-}=\{j\in[k]|p’_j\leq p_j\}$。</p>
<p>我们用$T_j$和$T’_j$表示$(B,d,p)$和$(B,d,p’)$的层级划分。</p>
<p>假设$P^{-}=\emptyset$，我们只需要说明对于$(B,d,p’)$和需求$n,F$可得</p>
<script type="math/tex; mode=display">
    \sum_{j\in[k]}E[T'_j]\lt \sum_{j\in[k]}B_j\tag{10}</script><p>就可以确定价格$p’$并非EIP-1559稳定，因为它们都是正数且一些层没满。</p>
<p>为了得到这一矛盾，我们假设等式10成立。令$\delta=min_j\{p’_j-p_j|j\in[k]\}$并定义一个新的价格向量$\hat{p}=p+\delta$。通过价格兼容性和引理6，可得：</p>
<script type="math/tex; mode=display">
    \sum_{j \in[k]} B_j=\sum_{j \in[k]} \mathbb{E}\left[T_j^{\prime}\right] \geq \sum_{j \in[k]} \mathbb{E}\left[\widehat{T}_j\right] \geq \sum_{j \in[k]} \mathbb{E}\left[T_j\right]=\sum_{j \in[k]} B_j\tag{11}</script><p>因此，如果所有价格恰好增加$\delta$，则总需求保持不变。事实上，因为效用是拟线性的，并且所有价格变化量相同，所以每一层的需求保持和$(B,d,p)$一样。此外，任何价值$v$的首选层在$(B,d,p)$和$(B,d,\hat{p})$中都是一样的。我们将证明这违反了分布假设。</p>
<p>令$S_j$表示F的支持子集，其中包含在价格$p$下倾向于$T_j$层的交易。</p>
<script type="math/tex; mode=display">
S_j=\left\{\left(v_0, h\right) \in F \mid v_0 \cdot h\left(d_j\right)-p_1 \geq v_0 \cdot h\left(d_j^{\prime}\right)-p_j \text { for all } j^{\prime} \neq j\right\}</script><p>我们可得</p>
<script type="math/tex; mode=display">
\mathbb{E}\left[T_j\right]=n \cdot \operatorname{Pr}\left[S_j\right] \Rightarrow \operatorname{Pr}\left[S_j\right]=\frac{B_j}{n}</script><p>令 S 为F的支持子集，其中包含将加入$p$下某个层的有着相似$\hat{S}$的交易：</p>
<script type="math/tex; mode=display">
S=\left\{\left(v_0, h\right) \in F \mid v_0 \cdot h\left(d_j\right)-p_j \geq 0 \text { for some } j \in[k]\right\}</script><p>当然，$S=\cup_{j\in[k]}S_j$且每个$S_j$都不相交，从公式11可以推出：</p>
<script type="math/tex; mode=display">
\sum_{j \in[k]} \mathbb{E}\left[\widehat{T}_j\right]=\sum_{j \in[k]} \mathbb{E}\left[T_j\right] \Rightarrow \sum_{j \in[k]} \mathbb{E}\left[\widehat{T}_j\right] / n=\sum_{j \in[k]} \mathbb{E}\left[T_j\right] / n \Rightarrow \sum_{j \in[k]} \operatorname{Pr}\left[\widehat{S_j}\right]=\sum_{j \in[k]} \operatorname{Pr}\left[S_j\right]\tag{12}</script><p>令$\mathbb{1}_{t\in S}$表示交易t加入S的指示变量。因为所有$S_j$都不相交：</p>
<script type="math/tex; mode=display">
\sum_{j \in[k]} \operatorname{Pr}\left[\widehat{S_j}\right]=\sum_{j \in[k]} \operatorname{Pr}\left[S_j\right] \Rightarrow \operatorname{Pr}\left[\cup_{j \in[k]} \widehat{S_j}\right]=\operatorname{Pr}\left[\cup_{j \in[k]} S_j\right] \Rightarrow \mathbb{E}\left[\mathbb{1}_{t \in \widehat{S}}\right]=\mathbb{E}\left[\mathbb{1}_{t \in S}\right]</script><p>为了简化计算，我们可以在价值的折扣函数$h$条件下使用全期望定律。把所有内容合起来可得：</p>
<script type="math/tex; mode=display">
\sum_{j \in[k]} \mathbb{E}\left[\widehat{T}_j\right]=\sum_{j \in[k]} \mathbb{E}\left[T_j\right] \Rightarrow \mathbb{E}\left[\mathbb{E}\left[\mathbb{1}_{t \in \widehat{S}} \mid h\right]\right]=\mathbb{E}\left[\mathbb{E}\left[\mathbb{1}_{t \in S} \mid h\right]\right]\tag{13}</script><p>然后得到：</p>
<script type="math/tex; mode=display">
\mathbb{E}\left[\mathbb{1}_{t \in S} \mid h\right]=\operatorname{Pr}\left[v_0 \geq V_h \mid h\right] \quad \text { and } \quad \mathbb{E}\left[\mathbb{1}_{t \in \widehat{S}} \mid h\right]=\operatorname{Pr}\left[v_0 \geq \widehat{V_h} \mid h\right]</script><p>这是因为以$h$为条件，价值随$v_0$增加，因此存在一个最小的$V_h$，高于该值的每个$v_0$都会加入某个层。可以看出，对于$v_0=\hat{V_h}$（被包含在$\hat{p}$下的某层$j$），可得：</p>
<script type="math/tex; mode=display">
\widehat{V_h} \cdot h\left(d_j\right)-\left(p_j+\delta\right) \Rightarrow \widehat{V_h} \cdot h\left(d_j\right)-p_j \geq \delta\gt 0</script><p>因此，存在某价值$v_h-\varepsilon$使得$\left.\widehat{V_h}-\varepsilon\right) \cdot h\left(d_j\right)-p_j\gt 0$。由此在价格$p$下，对于折扣函数$h$，任何$\hat{V_h}\geq v_0 \geq \hat{V_h}-\varepsilon$都会被包含进某层：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\operatorname{Pr}\left[v_0 \geq V_h \mid h\right] & \geq \operatorname{Pr}\left[v_0 \geq \widehat{V_h}-\varepsilon \mid h\right] \\
& \geq \operatorname{Pr}\left[\widehat{V_h}\gt v_0 \geq \widehat{V_h}-\varepsilon \mid h\right]+\operatorname{Pr}\left[v_0 \geq \widehat{V_h} \mid h\right] \\
& \gt \operatorname{Pr}\left[v_0 \geq \widehat{V_h} \mid h\right] .
\end{aligned}</script><p>这意味着$E[\mathbb{1}_{t\in S}|h]\gt E[\mathbb{1}_{t\in \hat{S}}|h]$，无论采用哪边的期望价值都与公式13矛盾。</p>
<p>对于$P^{-}\neq \emptyset$的情况，显然，$(B,d,p’)$对应的任意层$j\in P^+$的需求只会严格小于$(B,d,p)$对应的需求，随着这些层的价格上涨，而其余层价格保持不变或下降。在证明过程中，我们对之前的分析稍作修改，增加了一种情况，即$P^+$的价格并不稳定，而是有可能有一些需求溢出到 P 层，使得新的价格与需求不符。</p>
<ol>
<li>总结：这一部分说的是兼容且稳定的区块链具有的性质。<ol>
<li>命题3很好理解，直观来说就是在其他因素不变的情况下，价格变化会引起期望需求改变，而最小和最大分别是n和0，B恰好在这个区间上，这个变化是连续的，显然中间肯定存在一个值，对应了期望效用是B的情况。</li>
<li>命题4也好理解，如果一个区块链是兼容且稳定的，这意味着每一层的期望需求应该恰好等于这一层的容量。如果是大于的情况，则不满足兼容的定义；如果是小于的情况，则按照稳定的性质，这一层价格应该为0，这使得还没加入的交易都会争相加入，而在本文的场景下交易数量大于区块链所有层的总容量，去掉放到其他层的交易以后，剩下的交易都想加入这一层，而这个需求必然大于这一层的容量，因此与兼容冲突了。</li>
<li>引理2这里，这篇论文应该是用1表示最高价，从公式可以看出如果某一层价格很高，那它的期望需求就是0。</li>
<li>引理3和EIP-1559稳定感觉说的是一个意思，价格为0就意味着这一层还有空，期望需求小于它的容量。</li>
<li>引理4也很显然，兼容且稳定时，延迟低的层价格会高。</li>
<li>引理5有点抽象，通俗来说，函数f()可以看作是从层级的价格p到这一层的预期需求$E(T_k)$的映射，引理5表明可以通过调整价格使得预期需求量等于这层的容量$B_k$，从而满足兼容且稳定的需求。</li>
<li>定理1可以从引理5引申出来。</li>
<li>引理6直观来看，价格上涨就会导致需求下降，很容易理解。它是为后面证明价格唯一性做支撑的。</li>
<li>定理2的证明比较多，这个定理本身的含义可以概括为：对于确定的区块大小和延迟，如果存在可以使区块链平稳运行的价格，那么这组价格就是唯一的。用的反证法：<ol>
<li>假设存在两个不同的价格$p$和$p’$都能让同一个区块链兼容且稳定；</li>
<li>把价格可能取值的集合划分为p’高于p的$P^+$集合，以及p’低于or等于p的$P^-$集合；</li>
<li>如果$P^-$是空的，意味着只存在p’大于p的情况，根据引理6，如果p是兼容且稳定的，则意味着p’对应的期望需求会更小，如果p’也兼容且稳定，那价格一定是0，这使得p要小于0，而这又违背了定义，所以这种情况不存在（证明部分的公式比这个复杂）；</li>
<li>如果$P^-$非空，在$P^+$集合，价格从p涨到p’，会导致期望需求下降，感觉和前面一样，都是要么不兼容要么不稳定。</li>
<li>总的来说这个定理的意思就是，在区块大小和延迟不怎么改变的情况下，需求波动后会带来价格的波动，从而使得不改变大小和延迟的情况下还能兼容稳定。<h3 id="Steady-state-of-the-Tiered-Pricing-Mechanism"><a href="#Steady-state-of-the-Tiered-Pricing-Mechanism" class="headerlink" title="Steady-state of the Tiered Pricing Mechanism"></a>Steady-state of the Tiered Pricing Mechanism</h3></li>
</ol>
</li>
</ol>
</li>
<li>在负载$n,F$和固定的$B$下，分层定价机制旨在找到$(B,d,p)$，使得：<script type="math/tex; mode=display">
d_{j+1} \geq \lambda_j \cdot d_j \text { for } \lambda_j\gt 1 \text {, and } p_{j+1} \leq \mu_j \cdot p_j \text { for } \mu_j\lt 1\tag{14}</script></li>
<li>定理3：对于任意B，因子$\lambda_j,\mu_j$和正则需求$n,F$，都存在一个区块链$B,d,p$既兼容和EIP-1559稳定，也满足不等式14。</li>
</ol>
<p>证明：将$d_1$设置为0，由此定义：</p>
<script type="math/tex; mode=display">
    d_{j+1}=\max \{\lambda_{j} \cdot d_{j}, \underset{d}{\operatorname{argmin}}\{\operatorname{Pr}\left[h(d)\lt \mu_{j} \cdot h\left(d_{j}\right) / 2\right]\gt 1-\delta \cdot \frac{1}{k-1} \cdot \frac{1}{n}\}\}</script><p>本质上，$d_{j+1}$远大于$d_j$，因此几乎所有交易产生的折扣因子至少比$d_j$小$\lambda_j/2$。我们可以用以下 的集合来描述这个“几乎所有”属性：</p>
<pre><code>$$
H_{j+1}=\{(v_{0}, h) \in \operatorname{supp}(F) \mid h(d_{j+1})\lt \mu_{j} \cdot h(d_{j})\}
$$
</code></pre><p>且$H=\cap_{j\geq 1}^kH_j$。在$n$个交易的样本中，我们观察到没有一个交易的折扣函数位于集合H之外的概率是：    </p>
<script type="math/tex; mode=display">
    \begin{aligned}
\operatorname{Pr}\left[\forall i \in[n] t_{i} \in H\right] & =1-\operatorname{Pr}\left[\exists i \in[n] \text { s.t. } t_{i} \in H^{C}\right] \\
& \geq 1-n \cdot \operatorname{Pr}\left[\cup_{j \geq 1}^{k} H_{j}^{C}\right] \\
& \geq 1-n \cdot \sum_{j \geq 1}^{k} \delta /(k-1) / n=1-\delta .
\end{aligned}</script><p>因此，可以将延迟$d_{j+1}$设置得足够高，这样在概率至少为$1-\delta$的情况下，样本中所有交易的折扣函数都会使连续层级的价值至少降低$\mu_j$倍。</p>
<p>对于我们刚才描述的延迟$d_1, d2, …,d_k$，让$p$成为保证存在的兼容和 EIP-1559 稳定的价格。根据命题 4，我们知道，对于这些价格，每个层级都必须完全满员。因此，对于任何层级$j$，都必须存在一个$h\in H$ 且使得层级$j+1$优于$j$的$v_0$的交易，且其效用为正。用公式来表述：</p>
<script type="math/tex; mode=display">
\begin{aligned}
v_{0} \cdot h\left(d_{j}\right)-p_{j} & <v_{0} \cdot h\left(d_{j+1}\right)-p_{j+1} \\
\Rightarrow v_{0} \cdot h\left(d_{j+1}\right) / \mu_{j}-p_{j} & <v_{0} \cdot h\left(d_{j+1}\right)-p_{j+1} \\
\Rightarrow v_{0} \cdot h\left(d_{j+1}\right) & <\frac{p_{j}-p_{j+1}}{1 / \mu_{j}-1} .
\end{aligned}</script><p>因为效用为正（即$v_0\cdot h(d_{j+1})-p_{j+1}\gt 0$），可以进一步得到：</p>
<pre><code>$$
\begin{aligned}
</code></pre><p>p_{j+1} &amp; &lt;\frac{p_{j}-p_{j+1}}{1 / \mu_{j}-1} \\<br>\Rightarrow p_{j+1} &amp; &lt;p_{j} \cdot \mu_{j} .<br>\end{aligned}</p>
<pre><code>$$
</code></pre><p>因此，对于适当选择的延迟，可以保证价格也将遵循我们的约束条件。</p>
<p>上述定理可以转换为分层定价机制执行不等式 14 所定义的政策的能力。</p>
<ol>
<li>推论1：对于任意正则需求$n,F$以及任意$k\geq B$，和任意参数集$\{(a_j,\lambda_j,\mu_j)\}_{j\in[k-1]}$，其中$a_j\in(0,1],\lambda_j\in R_{&gt;1},\mu_j\in(0,1)$，对于$j\in[k-1]$且$\sum_j a_i=1$，有着相同参数和$tFreq:=\infty$的分层定价机制执行策略$P:=\{(a_i,d_i,p_i)\}_{i\in[k]}$，其子句满足不等式14.</li>
<li>遗憾的是，有很多 p 和 d 对都能满足这些特性。例如，最后一级的延迟总是可以增加（降低相应的价格），同时保持我们的保证。然而，我们的分层定价机制能找到局部最小解，不会不必要地增加延迟。</li>
<li>定理4：对于任何$B$、因子$\lambda_j,\mu_j$和需求$n,F$，都存在一个兼容、EIP-1559 稳定且满足不等式 14 的区块链$(B,d,p)$。此外，在不牺牲任何保证的情况下，任何延迟都可以被独立降低。</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://likun1208.github.io/2023/11/07/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Tiered%20Mechanisms%20for%20Blockchain%20Transaction%20Fees/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blockchain/" rel="tag">blockchain</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/defi/" rel="tag">defi</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/11/24/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Privacy-Preserving%20Prompt%20Tuning%20for%20Large%20Language%20Model%20Services/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            论文记录-Privacy-Preserving Prompt Tuning for Large Language Model Services
          
        </div>
      </a>
    
    
      <a href="/2023/11/07/%E8%AE%BA%E6%96%87%E7%95%A5%E8%AF%BB%E8%AE%B0%E5%BD%95/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">论文略读记录</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "VqvB5y0diPuBd9JFy4kQbHxz-gzGzoHsz",
    app_key: "Gmmb4mTXjSDf8ndcJ0ex4Ufi",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2024
        <i class="ri-heart-fill heart_icon"></i> Kun Li
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer.png" alt="左边"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/cv-ch">个人简历</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/cv-en">Resume</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
<div id="waifu">
    <div id="waifu-message"></div>
    <div class="waifu-tool">
        <span class="icon-next"></span>
        <span class="icon-home"></span>
        <span class="icon-message"></span>
        <span class="icon-camera"></span>
        <span class="icon-volumeup"></span>
        <span class="icon-volumedown"></span>
        <span class="icon-about"></span>
        <span class="icon-cross"></span>
    </div>
    <canvas id="live2d2" style="top:150px"></canvas>
    <canvas id="live2d4" style="top:150px"></canvas>
</div>
<!--    src 中改为你存放的路径    -->
<script src="/dist/live2d_bundle.js"></script>
<script async type="module" src="/js/waifu-tips.js"></script>

</body>

</html>