<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>论文记录-空间众包任务分配总结</title>
    <url>/2024/03/25/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-%E7%A9%BA%E9%97%B4%E4%BC%97%E5%8C%85%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="空间众包任务分配总结"><a href="#空间众包任务分配总结" class="headerlink" title="空间众包任务分配总结"></a>空间众包任务分配总结</h1><h2 id="1-A-PLAN-for-Tackling-the-Locust-Crisis-in-East-Africa-Harnessing-Spatiotemporal-Deep-Models-for-Locust-Movement-Forecasting"><a href="#1-A-PLAN-for-Tackling-the-Locust-Crisis-in-East-Africa-Harnessing-Spatiotemporal-Deep-Models-for-Locust-Movement-Forecasting" class="headerlink" title="1 - A PLAN for Tackling the Locust Crisis in East Africa Harnessing Spatiotemporal Deep Models for Locust Movement Forecasting"></a>1 - A PLAN for Tackling the Locust Crisis in East Africa Harnessing Spatiotemporal Deep Models for Locust Movement Forecasting</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>crowdsourcing</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-SIGMA: Secure GPT Inference with Function Secret Sharing</title>
    <url>/2024/03/21/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-SIGMA%20Secure%20GPT%20Inference%20with%20Function%20Secret%20Sharing/</url>
    <content><![CDATA[<h1 id="SIGMA-Secure-GPT-Inference-with-Function-Secret-Sharing"><a href="#SIGMA-Secure-GPT-Inference-with-Function-Secret-Sharing" class="headerlink" title="SIGMA: Secure GPT Inference with Function Secret Sharing"></a>SIGMA: Secure GPT Inference with Function Secret Sharing</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>安全两方计算</li>
<li>现有的安全推理解决方案面临着高延迟和通信开销的问题，尤其是transformer</li>
<li>函数秘密共享（FSS）是一种通过预处理阶段获得高效 2PC 协议的最新范例</li>
<li>本文：SIGMA——第一个基于 FSS 的安全transformer推理端到端系统<ul>
<li>通过为复杂的机器学习功能（例如 Softmax 和 GeLU）构建新的基于 FSS 的协议，并加速它们在 GPU 上的计算，SIGMA 将 Transformer 安全推理的延迟比使用现有技术的现有技术提高了 11 − 19 倍预处理和 GPU。</li>
<li>我们提出了生成式预训练 Transformer (GPT) 模型的第一个安全推理。特别是，SIGMA 在 7.4 秒内执行了 13 亿个参数的 GPT-Neo，在 1.6 秒内执行了 HuggingFace 的 GPT2。<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2>对安全推理问题的定义：</li>
</ul>
</li>
<li>模型提供商拥有专有的机器学习 (ML) 模型，将其作为服务提供</li>
<li>客户希望了解其敏感数据的推理结果</li>
<li>安全要求是除了推理输出之外，客户端不应了解任何有关模型的信息，并且模型提供者不应了解有关客户端输入的任何信息</li>
</ul>
<p>2PC的发展：</p>
<ol>
<li>具有数千个参数的模型扩展到[10]、[39]、[48]、[50]–[52]、[55]、[58]、[60] ]、[62]、[72]</li>
<li>具有数百万个参数的模型 [20]、[32]、[35]、[38]、[42]、[59]、[73]、[76]</li>
<li>到目前为止具有数亿个参数的 BERT 模型 [7]、[19]、[33]、[41]、[45]</li>
<li>本文：提供具有数十亿参数的生成预训练 Transformer (GPT) 模型的安全推理</li>
</ol>
<p>用于安全机器学习推理的系统必须满足以下要求：</p>
<ol>
<li>准确性：即安全推理下的准确性应与明文的准确性相匹配</li>
<li>安全性：即系统应提供标准的2PC安全性</li>
<li>效率：即，安全推理的延迟和通信开销应该很低</li>
<li>可扩展性：即，系统必须扩展到具有数十亿个参数的模型。</li>
</ol>
<p>这里列了几个安全transformer推理模型和缺点，survey中可以对比。</p>
<p>本文贡献：和CipherGPT差不多，也是针对各操作设计了安全计算协议，包括矩阵乘法、激活函数等。</p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><ol>
<li>$\lambda$：计算安全参数</li>
<li>$N=2^n,L=2^l$</li>
<li>$\mathbb{R}$：实数集，$\mathbb{U}_{2^n}$：n位无符号整数集</li>
<li>用2补数表示$\mathbb{U}_{N}$中的有符号数</li>
<li>对于$x\in\mathbb{U}_N$，$int_n(x),uint_n(x)$分别表示$\mathbb{Z}$中的有符号整数和无符号整数</li>
<li>粗体表示数字，普通字体带$[i]$表示第i个元素，如$\mathbf{a}=\lbrace a[0],a[1],a[2]… \rbrace$</li>
<li>定点数表示法：由位宽n和精度f参数化，将实数$r\in\mathbb{R}$编码为一个n位整数$x\in\mathbb{U}_N$使得$x=\lfloor r\cdot 2f \rfloor/\ mod\ N$。反过来，精度为f的n位定点数x解码为一个实数$\frac{int_n(x)}{2^f}$</li>
<li>操作符：对于谓词$b$，如果b为真，则$1\lbrace b\rbrace\in\lbrace 0,1\rbrace$返回1，否则返回0。</li>
<li>对于$n\lt l,x\in\mathbb{U}_N$，$extend_{n,l}(x)$返回x左侧附加$(l-n)$个0。</li>
<li>对于$x\in\mathbb{U}_N$，$MSB_n(x)\in\lbrace 0,1\rbrace$表示 x 的最高有效位。</li>
<li>秘密共享：对于$x\in\mathbb{U}_N$，秘密共享是对随机共享$x_0,x_1\in\mathbb{U}_N$的采样，使得$x=x_0+x_1\ mod\ N$成立，并用$share(x)$表示。当$P_0$持有$x_0$且$P_1$持有$x_1$时，我们用$reconstruct(x_b), b\in\lbrace 0,1\rbrace$表示交换共享并将其相加从而重构基础值的过程。</li>
</ol>
<h3 id="威胁模型"><a href="#威胁模型" class="headerlink" title="威胁模型"></a>威胁模型</h3><p>这项工作考虑了预处理模型中的标准二方安全计算 [8, 9, 14, 22, 37]，在安全机器学习领域也受到了大量关注 [32, 38, 41, 63, 64, 76]。也就是说，存在两个方$P_0$和$P_1$，其输入为$x_0$和$x_1$，希望计算公共函数$y = f(x_0, x_1)$，而不向对方透露任何超出函数输出y之外的信息。在预处理阶段独立于函数输入$x_0$和$x_1$，相关随机性被生成并提供给$P_0$和$P_1$。这种随机性可以通过多种方式生成 —— 可信第三方 [11, 14, 32, 38, 41, 63, 64, 76]，通用的2PC协议 [28, 78]，或者更高效的专用2PC协议 [24]。在这项工作中，我们考虑第一种方法。我们的所有协议都满足标准的模拟安全性定义 [17, 28, 47]，在半诚实的静态多项式时间(PPT)攻击者模型下提供安全性，该攻击者破坏$P_0$或$P_1$中的一个。</p>
<h3 id="FSS"><a href="#FSS" class="headerlink" title="FSS"></a>FSS</h3><p>函数秘密共享是一对算法<code>(Gen, Eval)</code>，Gen将函数g拆分为两个函数份额$(g_0,g_1)$，Eval则输入$b\in\lbrace 0,1\rbrace$、函数$g_0$和x，并返回$g_b(x)$。一个FSS方案的正确性要求$g_0(x)+ g_1(x)= g(x)$对于所有的$x$成立。安全性要求则是每个函数份额$g_b$会隐藏底层函数$g$。</p>
<p>定义1：一个两方FSS方案是一对算法<code>(Gen,Eval)</code>使得：</p>
<ul>
<li>$Gen(1^\lambda,\hat{g})$是一个PPT（概率多项式时间）密钥生成算法，它接受安全参数$1^\lambda$和函数g的描述$\hat{g}\in\lbrace 0,1\rbrace^*$，输出一对密钥$(k_0, k_1)$。我们假设$\hat{g}$明确地包含输入和输出群$\mathbb{G}^{in}, \mathbb{G}^{out}$的描述。</li>
<li>$Eval(b,k_b,x)$是多项式时间评估算法，输入计算方索引$b\in\lbrace 0,1\rbrace$、$g_b:\mathbb{G}^{in}\rightarrow\mathbb{G}^{out}$定义的密钥$k_0$和$g_b$的输入$x\in\mathbb{G}^{in}$，输出$g_b(x)$的值$y_0\in\mathbb{G}^{out}$。</li>
</ul>
<p>$(k_0, k_1)$被称为FSS密钥。用于存储一个FSS密钥所需要的比特数称为密钥大小。</p>
<h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>考虑具有门$\lbrace g_i\rbrace_i$和线$\lbrace w_i\rbrace_i$的电路的安全计算，我们分两阶段描述使用了[14]中的FSS进行预处理的2PC协议。</p>
<p>离线阶段。对于每个线$w_i$，从适当的组中采样一个随机掩码$r_i$，然后，对于每个具有输入线$w_i$和输出线$w_j$的门$g$，为其偏移函数$g^{[r_i,r_j]}(x)=g(x-r_i)+r_j$生成一个FSS密钥，并为每一方提供一个密钥。对于属于<code>b</code>方电路的输入和输出线，该方还知道与这些线相关联的掩码。</p>
<p>在线阶段。对于b方拥有的值为$x_i$的每条输入线$w_i$，b方计算$\hat{x}_i=x_i+r_i$并发送给1-b方。现在，双方按拓扑顺序评估电路门。为了评估有着输入和输出线$w_i$和$w_j$的门，双方评估$\hat{x}_i$上相应的FSS密钥，以获得$\hat{x}_j=g^{[r_i,r_j]}(\hat{x}_i)=g(\hat{x}_i-r_i)+r_j=g(x_i)+r_j$。然后各方重建份额以获得掩码值$\hat{x}_j$。对于输出线，拥有线的一方减去相应的掩码即可得到最终的输出值。</p>
<p>协议结构和FSS协议的安全性。我们使用$(\hat{\cdot})$表示掩码值。考虑一个函数F和输入x能使得$y=F(x)$。针对F的协议记作$\Pi^F$，有两个阶段$Gen^F$和$Eval^F$。</p>
<ul>
<li>前者在预处理阶段对输入和输出掩码$r^{in},r^{out}$执行，以生成可用于$P_0,P_1$的预处理材料或密钥。存储$\Pi^F$的密钥所需的位数称为密钥大小，用$keysize(\Pi^F)$表示。</li>
<li>后者是$P_0,P_1$于在线阶段在掩码输入$\hat{x}=x+r^{in}$和它们各自密钥上运行的协议。在该阶段结束时，$P_0,P_1$学习掩码输出值$\hat{y}=y+r^{out}$。</li>
</ul>
<p>本文提出的所有协议都具有上述结构。</p>
<p>安全性通过以下两个交互定义：</p>
<ul>
<li>真实交互。$Gen^F$在预处理阶段执行（输入和输出掩码为$r^{in},r^{out}$），$P_0,P_1$使用预处理阶段获取的密钥于在现阶段执行$Eval^F$。该交互发生在存在对手A和环节Z的情况下。</li>
<li>理想交互。$P_0,P_1$发送输入到能诚实计算功能的功能（即，去掩码$\hat{x}$以得到<code>x</code>，计算$y=F(x)$，计算$\hat{y}=y+r^{out}$并提供$\hat{y}$的份额给$P_0,P_1$）。</li>
</ul>
<p>如果对于真实交互中的每个对手A，在理想交互中都存在对手S（称为模拟器），使得没有环境Z能区分这两种交互，我们就说协议$\Pi^F$安全地实现了功能F。</p>
<h3 id="DPF"><a href="#DPF" class="headerlink" title="DPF"></a>DPF</h3><p>点函数$f_{\alpha,\beta}^{\bullet}:\mathbb{U}_N\rightarrow \mathbb{G}^{out}$输入$x\in\mathbb{U}_N$，如果$x=\alpha$则输出$\beta\in\mathbb{G}^{out}$，反之则输出0。点函数对应的FSS方案被称为分布点函数。</p>
<p>$(k_0^{\bullet},k_1^{\bullet})\leftarrow Gen_n^{\bullet}(1^\lambda,\alpha,\beta,\mathbb{G}^{out})$</p>
<p>$y_b=Eval_n^{\bullet}(b,k_b^{\bullet},x),x\in\mathbb{U}_N$</p>
<p>对于所有协议，取$\mathbb{G}^{out}=\lbrace 0,1\rbrace,\beta=1$就够了，这使得我们可以利用带有提前终止优化的分布式点函数构造(这适用于小负载)。</p>
<p>定理1（DPF的成本）给定PRG $G:\lbrace 0,1\rbrace^\lambda\rightarrow\lbrace0,1\rbrace^{2\lambda+2}$并令$v=\log_2(\lambda+1)$。当$n\gt v$，存在一个$f_{\alpha,1}^{\bullet}$的DPF：$\mathbb{U}_N\rightarrow\lbrace 0,1\rbrace$，其密钥大小是$(n-v)\cdot(\lambda+2)+2\lambda$。在$Gen_n^{\bullet}$中PRG的调用次数是$2(n-v)$，在$Eval_n^{\bullet}$中的用次数是$n-v$。当$n\leq v$时，需要$2^n$的keysize以及$Gen_n^{\bullet},Eval_n^{\bullet}$PRG调用次数为0。</p>
<p>与其他FSS的工作类似，我们设$\lambda=127$，并在计数器模式下使用两次AES-128调用来实现所需的长度加倍 PRG。正如之前所观察到的，单个 AES 调用足以满足$Eval_n^{\bullet}$，因为仅使用了一半的输出。从现在开始，我们将其称为半 PRG 调用。</p>
<h3 id="使用DPF密钥比较"><a href="#使用DPF密钥比较" class="headerlink" title="使用DPF密钥比较"></a>使用DPF密钥比较</h3><p>比较函数$f_{\alpha,\beta}^{\lt}:\mathbb{U}_N\rightarrow\mathbb{G}^{out}$输入$x\in\mathbb{U}_N$，如果$x\lt\alpha$则返回$\beta\in\mathbb{G}^{out}$，否则返回0。之前的研究都用一个特殊的名为DCF的FSS方案来实现这个功能。最近一个研究展示了当$\mathbb{G}^{out}=\lbrace 0,1\rbrace,\beta=1$时，FSS方案可以通过DPF来构造。</p>
<p>定理2：使用DPF的FSS方案。存在一个算法$Eval_n^\lt$使得$\forall x,\alpha\in\mathbb{U}_N$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \left(k_0^{\bullet}, k_1^{\bullet}\right) \leftarrow \operatorname{Gen}_n^{\bullet}\left(1^\lambda, \alpha, 1,\{0,1\}\right) \\
\Longrightarrow & \operatorname{Eval}_n^{<}\left(0, x, k_0^{\bullet}\right)+\operatorname{Eval}_n^{<}\left(1, x, k_1^{\bullet}\right)=f_{\alpha, 1}^{<}(x)
\end{aligned}</script><p>且$Eval_n^\lt$调用了DPF half-PRG $\max(n-v,0)$次。因此，$(Gen_n^\bullet,Eval_n^\lt)$是比较函数的FSS方案。</p>
<p>与[11]中需要长度四倍的 PRG 的 DCF 构造相比，上述构造导致计算成本降低 2 倍以上。</p>
<h2 id="Transformer概要"><a href="#Transformer概要" class="headerlink" title="Transformer概要"></a>Transformer概要</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>LLM</tag>
        <tag>Privacy</tag>
        <tag>Security</tag>
        <tag>MPC</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-PUMA: Secure Inference Of LLaMa-7b In Five Minutes</title>
    <url>/2024/03/21/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-PUMA%20SECURE%20INFERENCE%20OF%20LLAMA-7B%20IN%20FIVE%20MINUTES/</url>
    <content><![CDATA[<h1 id="PUMA-Secure-Inference-Of-LLaMa-7b-In-Five-Minutes"><a href="#PUMA-Secure-Inference-Of-LLaMa-7b-In-Five-Minutes" class="headerlink" title="PUMA: Secure Inference Of LLaMa-7b In Five Minutes"></a>PUMA: Secure Inference Of LLaMa-7b In Five Minutes</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>LLM</tag>
        <tag>Privacy</tag>
        <tag>Security</tag>
        <tag>MPC</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Secure Transformer Inference</title>
    <url>/2024/03/21/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-SECURE%20TRANSFORMER%20INFERENCE/</url>
    <content><![CDATA[<h1 id="Secure-Transformer-Inference"><a href="#Secure-Transformer-Inference" class="headerlink" title="Secure Transformer Inference"></a>Secure Transformer Inference</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>LLM</tag>
        <tag>Privacy</tag>
        <tag>Security</tag>
        <tag>MPC</tag>
      </tags>
  </entry>
  <entry>
    <title>生活记录-20240315</title>
    <url>/2024/03/15/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95-20240315/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="3886436fc82ea4f2e9838558a9f2929dee7ecbdb6daa8a335efc56375279d61f">37677482e0ad0b0303755495d26d33f4a93b1a1e589fb3af150bbc5463635ce9ef6df5bae457b232868338a82128f0c08bae19896c8202e5eb8bf94db73505b3b52277511f522b5e84d71795a485550515a86374b2d0823794c96c8bbb2c143aaeaef08acce81e1c365d021298c872afd98282b9f55c1e58f58409a946b42ec4ba8663b4b55a3bc269dc2c69ef682d33ffd8babfd5b0d96b378442d0aaf373f4bee2e8c13bc21ddb42e3661f11bb98d154647eaf903dd3cb9af92d5c5614509916e27db3113bcaf5e7fa7869d988fe605cb8c18248af28b455191493d1c16a5b52436d42f21c360e6672637399d061588b4a6a25acc0c6dd353868abd2b61f973fe1773f5f24d7a15b06e9207a3d8a109c515087c0d9e47fe0be50c517da9cbef54cac36d064b24b49a9fb9a0682c8d7e1f31859c261b9ac108d868d35b88a7d1b52246ea267a5e099a59a90c3ae70c4fde792c1c93079902f6da6360b92c587091557be009dcf102d54af7e488ecd1899a0c05873771e238fb32f605e9c55f4d5b506b1ce6603619b288e95177e6c7e3b8282e476d726230a4a1152275ce8046c63789318bd846ea8d954a27bf31350178d350eae0a494ddff6e61b5cc79071265a88ae7a419d0a8366a9576c814611afe2dc3b62b4abbf70495108ee6ee3b47d488d7ab5187b8542c881d6340bb37d659ee2ef0c16966336637eab1bdbca2785c16dfc7028d3762346e25e3cd9fa5682a48066d323403b36631cd7ef1177a4890bcea53c9020410a11a290fa9e03b91efd7d42c9722f77299af5406b84edc2489217704a9407f3dc0857c8572bfd0532c64b851ea6977aab048258e0a45e8e531fa8641229227cdd4766b9b3600ada8da28bcf3ad8e0ce8c4fa1b39f7a2cc0f6d10199dde78bd15901f5d3e56e948ffb34282ff24967155063922f62a757146aa01b6735fce076db80eb9540d41b632d6f194e3a88c560f7c90319621ed8df42b794005920084903ee7842fed7231bf1d8ed149f3268ef88c74c51f9bdda5fb76303b4e3c7fe4cbf6b5eb6500f0d923e6365c1ff2b44cc5b5f2eae2b2c644ecddedba87cf1ddfd682e6a1b66b38d9ee21aa84f81fddc69f41a598427680f0dfa1a7016530049fc03fc4a249956966530d9c4257c396821933ef271c690ff5791372de28482376ba87cd6bf83c20ca39c42063ec5b4d388003cb370d4828f0df5a6f30f18f517ed4c989e1f5c698a1193d399651fbe8b2ca98e698f4639b79f67572b0566a8d629f17526f56e101929c234c989ae248c5da8cbaf23d4ab5d94c054ae3ac01f3f1c519dce057a5da77554fc92036d6af29c9cf0955a934d8b93197f70f1715135928a4b7c83afa1da1b2ac54eb1fc9ae01bf52cdc03eea8e80ffec5f0bc1a2b19bb29216d6dd227734b8998ad8d8b84448872d32cd56498881cfc76909357850add481154eaf071244e5d99a21ccc1f7e1742fdc25d11c58e2840f9b9a47cbaa3b88ab1d1f119c0f85fa3623fc304bfaf0e6a1e35cc245b862a33b13c4367a3c8aae7ec0e298b28c3d005d815fe60604f8b851d7d614baf565f307ed5ece54969919b9add9f569bc01432a8d3c03763f51547d07e3760f5eaca948cb2700eb880d896ae4211717394e93f5282b3be45e15db1fead16dccab8365eddec5ebacdacdf6e1f6cdf5005cd0a6d17cd8b3d4ad946fe64c7323168a54d36526f63d24f7970b739c30ea5cf266144ed67ada2e6af07ceed4fcf8d4bf5de072906c4387ce04e940793bbee4a468276bfffd338c5feb767c1c3b6a5407b50e9d9d093ce53736d3d526f14e1e16e047566fa8d48c4889f2dd76086c02230b942c53b1f9ea7c0abd818a5ccb352ae0de7db8c28c3a534a5410eaff456d8322720f492011a14636e3390b000eaa431b91cf24ae78ee8fe5f9bee83e97f6d9225c5054ae2d868fc3bb57023b8bdaa46f43a1d673b1ecd5d547cc850221fa812e0075ca76cee74b8bd46de7cc80a4bb7c06cff6ff976eaec01760e0741f79c49c50b7b50af12b38fd9f049c4138f69f7f97bc7fd13e2277b2ea8c90daba1bc01f588b6a52f003ff913371aba7cde0d06095a6db2012a5dd37c96892d56d1139f6ae04d67348748b7c5248532d2b88060c14dcc9b48dff31235cabe8cc0c7ea595cc7bb2ab38ad1d70f7fa4c8b67859c2f1de153dc3cb38d845a08439f44b5abd36d758e47c8caa09cf9cb5670831b3d1de6384a2a8f6c3c1beba40c06b1f9cdd82370a21dea7ab2c55404c3a5144258e48eb870cecead06ae74bb5d59694dcaa3d6c8cced0811172782fe2ca74a151ad1846f2abb82eae509f429ed5a7df70d2fbcb93a69ee0f49a0ee0aa0ca02038de0398de3109cf5118391994ce216ad66ec56268c20bffb2fe5dd75cf540da6420e14234529747f9338ee6d4c1b9d29edc8b5767dd2240d855f3fa2e3725cc591ffce866e95c6d9576e9cdaceea345904131d4165f9a65c02e1ab39147824c580103d52fcb6f3b3c7301b87a146bbec4dd96bfd2cbe57f2e230459b48141471c2a609f60c47cdcb1f20d40ac7bba53e5b8c8e291eba5b3e4f61657ace294c75f29e481e5ab10944facf5a74fea039a941f451c16cd03e64ed4ba727a8d142d814282e2e7d2febce4829e040ddd86bb242ab2ef95056aed6504b14abf43c41157ea4cbe852be8f53bfcf7315388efba5b3cf0f9469266e1b479f563c852ead97805dc347c6f67940f03dfc6e560ec03c7067db80d9af4bd0150031f6b8c983f3c0ab6897718865d78017198f14bcd425f1dc7400ed7e39e78d114123c9ba473c0e1c7212108a1ed09675562028e7dc67797eadc0714b7c61a096e30460f2e82073201e7396424d5f380979c21da3ba7c7a7437efb360837de4374962e9eff28d41964deec6c3f24fe782f806b9b276a755fa5034ca842d4b9f901bb94f1f0cf9d0cbed11f53e39441a945aa66743efd9359001a2ecf39885bcdfc8244ea10f2dbffa1b56244844a5d1a60644c8f276aa1b1698f8809a7c8c3589a933642f6869507a862454e61403fe62f5711afffcfb581ecc9355b9a72584ec868b240e0569d0a3ab10c79d719911c41e601f7148a2227875a9e0a625a1cc9a0ff675d805d7e910f619390e398954b033c0f6574c3e3927ddab444d6a409fe4fd51d3bab9e89393825eb9e7606a939cc67f9ddcd4c4000257deb127cba76494e36605d0fc9306a80bf452ce2caab7c03259e41ef62a12892ba4bd4b23eb9d4f964e9b33b7fb4d58de338f78e0726389f1e234e2d21faaf41e51a033c956125b42de74176bf7f32adeb5c939d424c85e5dad736139133da66fb522c1c7e278cd5f1e1ae4c8a2e48bbf911d8be9d62d57d4cfa5c25fc91d9f39d98a4463aa89199c04ab106efbd2114729acaa64bc5b5e28b9e782af560ac251f00fc5f0a5918c5c1a5c73494564c0b2cc19652c67357eeea5c452e9b7c56f141a8263e92c08d509c46138f6c04aca671f898f630abb796a48e645a3b192edb90054668b50566face8357e045a10b2076df6d4522e19eee45c45504c94f6b25f757d9587b7688126b7b26b4580774fbe5d84fb3031ad591b1a4111cce645431f7a941c518cb65f3f164d2682adff16c8ee0d957b4b42acb05aac49cd6a2d3bda86cae18737a062b3ba7cfb119094fc60756651ed6d5724fc257e834e6d926d0510d5d6503f354bdefb26dba2d10195db5ba9c239731cc4338d8390f006f29759ec31c90deb73d7aaa8d8f08350205abeddc7e00f2e1c88dd6bf06a762fa6275492c727f649216dd51360265f678ea651bc0e488244a0d8fc966258c0e7c33e12387bd6d8fb42466be99979bd537d40ea5d9421e4b688220d33392c97d302bb870401d94669df41cd1a3fb4fa979a80ca3ae1f01714a4e87e30e0530f37a62c9c1b63a9d476cd5b681785a1e2701e95d911c7e0ebe99fbc741e750203fcdbc3c0001c0f67b7f6538366dc3bec0699deccc64acebede1f5562851a41a1cd7748de01970b7132c9a08eb9a015c9ffdcebe95b3dc476b27f659ce8b3b46bbc7a75e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Privacy-Preserved Data Disturbance and Truthfulness Verification for Data Trading</title>
    <url>/2024/02/15/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Privacy-Preserved%20Data%20Disturbance%20and%20Truthfulness%20Verification%20for%20Data%20Trading/</url>
    <content><![CDATA[<h1 id="Privacy-Preserved-Data-Disturbance-and-Truthfulness-Verification-for-Data-Trading"><a href="#Privacy-Preserved-Data-Disturbance-and-Truthfulness-Verification-for-Data-Trading" class="headerlink" title="Privacy-Preserved Data Disturbance and Truthfulness Verification for Data Trading"></a>Privacy-Preserved Data Disturbance and Truthfulness Verification for Data Trading</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>两种数据交易方式：初始交易和转卖交易</li>
<li>面临问题：交易数据的真实性无法通过隐私保护的方式得到保证<ul>
<li>数据生成者为了保护隐私而给数据添加的扰动是独立随机的，数据消费者无法在其所要求的扰动参数下验证交易数据是否受到扰动，而不会给数据生成者带来隐私泄露</li>
<li>由于允许转售交易，DC在保护其购买隐私的同时，在数据转售商（DR）的欺骗下很难验证交易数据的来源真实性</li>
</ul>
</li>
<li>本文提出：数据交易的隐私保护数据干扰和真实性验证<ul>
<li>引入了一个诚实但好奇的交易服务器（TS）来辅助我们设计的隐私可验证印记嵌入式干扰方法，其中印记是盲目的</li>
<li>TS 通过构建嵌入印记的个人验证公式，并要求被验证的参与者解密公式结果，来实现自适应真实性验证</li>
<li>被验证的参与者无法通过盲目的印记值来伪造正确的结果，从而确保了所设计验证方法的准确性</li>
</ul>
</li>
<li>理论分析和实验表明了有效性</li>
</ul>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><ul>
<li>几个角色定位：<ul>
<li>数据消费者DC：广告商、服务提供商等</li>
<li>数据生成者DG</li>
<li>数据转卖者DR：DC买到数据以后可以再卖给其他人</li>
</ul>
</li>
<li>允许数据生成者以受干扰的版本发布数据从而保护隐私（我理解的就是差分隐私）</li>
<li>数据交易面临挑战：无法以隐私保护的方式同时保证交易数据的干扰真实性和来源真实性<ul>
<li>DG可能不按扰动参数添加噪声，而是添加更多噪声，而这难以被其他人验证，同时也存在干扰验证方法，会导致数据隐私泄露</li>
<li>DR会谎报数据来源以获取更高收益，一些研究通过添加数字水印的方法来确保数据来源可追溯，但带来了较大开销，而基于区块链的方法则暴露了DC的交易行为，带来新的隐私问题。</li>
</ul>
</li>
<li>本文：数据交易的隐私保护数据干扰和真实性验证<ul>
<li>引入了一个诚实但好奇的交易服务器（TS）来监督DG的独立数据干扰，这使得DG的干扰真实性可验证，同时保护DG的原始数据不被暴露。 </li>
<li>TS针对参与者多样化的不真实策略，通过设计的加密验证公式来验证交易数据的扰动性和来源真实性，不会带来任何DG的原始数据隐私成本或DC的购买隐私泄露。</li>
</ul>
</li>
<li>贡献：<ul>
<li>私人可验证的印记嵌入干扰方法：参考差分隐私，TS生成带验证位的噪声，DG基于隐私检索给数据添加随机噪声</li>
<li>自适应真实性验证方法：TS参考同态加密，构造嵌入印记的个人验证密文公式，并要求验证参与者解密公式结果，同时保留DG的原始数据和DC的购买隐私</li>
<li>理论分析和实验</li>
</ul>
</li>
</ul>
<h2 id="研究现状"><a href="#研究现状" class="headerlink" title="研究现状"></a>研究现状</h2><p>略过</p>
<ul>
<li>扰动真实性方面的研究：博弈论来确定扰动参数，但是DG可能不按照这个参数来添加，有研究做了可验证的扰动参数设置，但又带来隐私泄露的问题。也有真值挖掘和对等预测的方法，但数据交易中的真实数据可能不唯一。另一些通过博弈论设计约束机制的研究，但是DG和DC往往利益冲突，无解。</li>
<li>数据源真实性方面的研究：<ul>
<li>设计执行环境限制原始数据交易：限制交易灵活性</li>
<li>找第三方做相似性比较：可信第三方不好找</li>
<li>区块链：几个研究本身的场景有局限，方法倒是没问题</li>
<li>数字水印：几个研究没设计具体算法</li>
</ul>
</li>
</ul>
<h2 id="问题形式"><a href="#问题形式" class="headerlink" title="问题形式"></a>问题形式</h2><h3 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h3><ul>
<li>DG生成数据，并按照TS提供的噪声给数据添加扰动</li>
<li>DC获取指定扰动参数的数据，并借助TS验证扰动和来源的真实性</li>
<li>DR买了数据再转卖，这一过程中要验证扰动和来源的真实性</li>
<li>TS负责监管，给TS产生噪声，并自适应地验证其扰动和来源的真实性</li>
</ul>
<p>整个流程如下：</p>
<ol>
<li>TS生成噪声，DG用加法同态加密结合噪声给数据加密，隐私检索使得噪声对于大家都是未知的</li>
<li>TS构造加密验证公式，要求交易参与方解密公式结果，只有扰动和来源都真实的情况下才能得到正确结果<h3 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h3></li>
</ol>
<ul>
<li>$\varepsilon$表示DC希望的隐私参数</li>
<li>$d$：DG的原始数据</li>
<li>$\tilde{d}^{(a)}$：DG加扰动后的数据</li>
<li>$\eta$：添加的扰动噪声（这里感觉是写错了，原文用的是where，但是前面没出现这个字母，而后文扫了一下也没有）</li>
<li>$O_{\tilde{d}^{(a)}}^{c}$是数据$\tilde{d}^{(a)}$声称的来源，而 $O_{\tilde{d}^{(a)}}^{t}$和 $O_{\tilde{d}^{(a)}}^{u}$分别是真实来源和假来源</li>
</ul>
<p>存在的恶意行为：</p>
<ol>
<li>DG添加比隐私参数要求更多的噪声</li>
<li>DC转卖数据时谎报来源</li>
</ol>
<p>定义1：隐私保护的扰动真实性的可验证性：在不暴露原数据和噪声的情况下，DC可以验证扰动后的数据=原数据+噪声，也能验证噪声满足差分隐私的要求。</p>
<p>定义2：隐私保护的来源真实性的可验证性：DC收到数据后可以在不暴露交易隐私的情况下验证数据来源。</p>
<h3 id="威胁模型"><a href="#威胁模型" class="headerlink" title="威胁模型"></a>威胁模型</h3><p>TS是诚实但好奇的第三方：TS会遵循协议设计噪声等，但对DG的原数据感兴趣，甚至会和DC串通获取原数据</p>
<p>TS的攻击方式：泄露原数据、泄露噪声</p>
<p>DG的攻击方式：加更多噪声</p>
<p>DR的攻击方式：谎报数据来源和扰动参数</p>
<h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><ol>
<li>交易数据的扰动真实性和来源真实性</li>
<li>DG原数据的隐私和DC购买行为的隐私</li>
</ol>
<h2 id="本文方案"><a href="#本文方案" class="headerlink" title="本文方案"></a>本文方案</h2><ol>
<li>TS用DC提供的公钥生成一组噪声，每个噪声都带一个验证位，验证的时候，对噪声和验证位分别用DG的公钥加密，然后对两个加密后的数据进行某种运算，就可以得到由扰动参数决定的相关函数$f(\varepsilon)$，运算方式和函数都由TS决定，且每轮都会改变。</li>
<li>DG生成$n$维密文向量$\omega$，其中第$k$项$w_k$是对1使用DG公钥加密后的密文，而其他位是对0加密的密文。</li>
<li>TS对$\omega$和前面第一条中带验证的噪声执行内积，得到的结果就是DG需要的随机噪声（DG公钥加密版），由此，DG可以用自己的私钥解密得到使用DC公钥加密的噪声，接着DG通过同态加密对数据添加扰动，这样DG并不知道DC要加多少噪声，也不知道噪声具体是什么样的，但实现了指定噪声量的添加。</li>
<li>接下来TS构造一个函数，按照函数的运算结果，第一次卖和转卖算出来的会不一样，从而确保来源可追溯。</li>
</ol>
<p>概括来说就是分两部分：</p>
<ol>
<li>干扰嵌入：这部分的功能是实现保护数据隐私和噪声量隐私的前提下实现对数据的扰动嵌入。具体流程其实前面已经介绍两次了，DC提出指定的差分隐私扰动参数，TS基于参数生成噪声+验证位，DG生成密文向量并发给TS，TS对密文向量和噪声+验证位做内积，得到最终添加的扰动，发给DG，DG可以用私钥解密得到噪声+验证位，然后DG将原数据与噪声相加（注意验证位并不加进去）。当然DG可以在这里添加不满足参数要求的噪声。</li>
<li>自适应真实性验证：这部分是实现真实性的验证，如前文所说，包括添加噪声量的真实性和来源的真实性。<ol>
<li>噪声量真实性：简单来说就是构造一个可以用同态加密计算的公式，公式大致是扰动后数据-扰动噪声-原数据+TS随机选的一个数（保密），公式中的每个部分都先用DC公钥加密再用DG公钥加密，TS将公式计算结果先发给DG，DG用私钥解密，解密结果再发给DC，DC再用私钥解密，如果扰动参数没问题，根据同态加密，这样解密完的结果就是TS随机选的那个数。</li>
<li>来源真实性：计算步骤和前面是一致的，核心思想就是如果这个DG并不是数据的真实来源，那他不可能算出正确结果。</li>
</ol>
</li>
</ol>
<p>接下来的内容基本上是各功能的证明，以及实验。实验部分用了真实的传感数据，不过自定义了诚实的概率，实验表明本文的方法比baseline更能发现不诚实的交易。</p>
<h2 id="最终意见"><a href="#最终意见" class="headerlink" title="最终意见"></a>最终意见</h2><p>小修</p>
<p>summary:<br>The paper presents a novel approach to enhance privacy and truthfulness in data trading. It introduces a system incorporating privacy-preserved data disturbance and truthfulness verification mechanisms to ensure data integrity and confidentiality in trading scenarios. The methodology involves an honest-but-curious trading server to oversee data disturbance, allowing for the verification of data truthfulness while protecting raw data from exposure. The paper also proposes an encrypted verification formula that verifies traded data’s truthfulness without imposing privacy costs on participants.</p>
<p>strength:</p>
<ol>
<li>Innovative Approach: The paper’s proposal for a privacy-preserved data disturbance mechanism coupled with truthfulness verification is novel and addresses significant concerns in data trading.</li>
<li>Privacy Protection: The methodology ensures that the privacy of the data is maintained throughout the trading process, which is crucial for sensitive or personal information.</li>
<li>Verification without Privacy Cost: The verification process designed does not add any privacy cost to trading participants, promoting a secure trading environment.</li>
</ol>
<p>weakness:</p>
<ul>
<li>Related work中两部分的内容都是一长段话，建议分类总结一下，增强可读性</li>
<li>一些符号和表示方法没有解释，需要补充</li>
<li>Section IV.B, “Based on the above two modules including the private-verifiable imprint-embedded disturbance and private-verifiable imprint-embedded disturbance,”重复了</li>
<li>补充一个问题：$\omega$向量的第k位是用DG公钥加密的1，而其余位是用DG公钥加密的0，那么收到向量的TS只需要对比一下哪一位和其他位不同，就可以判断出哪一位是1了吧，这能起到保密作用吗？还是说没有按位加密而是整个向量一起加密？</li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>审稿意见</tag>
      </tags>
  </entry>
  <entry>
    <title>2023年10月1日-12月31日决算及2024上半年预算</title>
    <url>/2024/01/02/2023%E5%B9%B410%E6%9C%881%E6%97%A5-12%E6%9C%8831%E6%97%A5%E5%86%B3%E7%AE%97%E5%8F%8A2024%E4%B8%8A%E5%8D%8A%E5%B9%B4%E9%A2%84%E7%AE%97/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2c7846542512aac88e14912684a1c97aca27235a44eaad5a56e9e841ba397dd8">37677482e0ad0b0303755495d26d33f407982f4f557b758dcd94013b69a128a829e6799c6a65f4d2d4a5dac46b2354ce0f1c21f86061cba124aa131e72f4ea66b5ee9506d853c95b57a653e968531e1ba9249e311bfefd60c465213b777417cb7e8f5de080069628266ec575a8f0a7f5cef60ac150f3e98ed8095c8568e103b44cd6fd3f8febb56466a3364cfce3b5b6a203779b9fea8734bc2787a31a9f5d968608f10093f970e18f9269bad06cf195ee495319bee0df51a335f654032627afc57b5251bf1d98d2a7cd8dd1ff5cb28dbdcef675a4388c39fd55af51cd5673b5d5936d6b7e171a57855d82421f392634df86c07ac6b7e1e6bfc267f162808565b13f81028f301e3c479c88768bbc32667f736d2d3511bf59c365d763caf68749b3a47e200de9f2e09a9df9565db65bb8e56868e6eaa2fc308659aa346669d46ac488ed7b59a35ba9aaf5d8a176f671d37d03c51028a2eccccd8a380e9942e8cf24fe84871fb423ca650557f8067ff92dbd40eb971e03429dc6e15a8f2b3fa541a4ea25dba75d48af63a09015f7b4b4ef26ef6b1addf310e864be7a9214c976e7526de2d524723a409b86879147317b1acf42aa57634467ee25986c8a99d552c4ac2c9d9898fefb5d044673886e9f3af89c84f94e797924540d519f1ea1be3034d97c9b880fb189ecbb0e6051046e9a56497f599c85111ea19edd9a432898ddeb7a2194d90b58787d4e9d68ebf4e29508543d03e94ad43d537dffa61f0df7da9a55556e115247b0c1e08c3ca8ed6b698109174615f897ea786fd1480264c1d2ac4486ec3bf85af10e69156190a5295c0e3cd9f6e2433fbceb39fc976a915f5e48e37a3110488116bd73f4631a000493191817b68bb16325e1e00fc4281df97a0351881396446f8fad9226f64f22261f3109709a01158615288e8a3e7627b1c1926959f370c8b544189aaf56407d4962186a76a09b095790844710879da81d6a3aa8df09e837288370809c13b281609eb42c216bed971841639d982df4479c5320802ff185048dcf097f9d51c81f94b864392ceddd11e27d79c40ca8b244b7c8807e19af525ec84712443caf330e4321caae267ceabd445dbcda96521f35a6a02795bfdac654c1b0ca64a76a1a5f99c42a91066c4684ef2d6b6efdec9293db220a32b6b9ae39f01a57854c1ff12ddb375b620ad32927c20b0383dcfd71f7ca38462a4097d4009441e8ee53ea35761a40965ca0f82e5eed872a75ea1155a1ab2c6fbbdb4b0db0b37848246c79a1d9498b097b739550cdaf0a388c60997819db093b55d62d67208b8347c915d4c063e68b21f50d83cc2a45c976f9c2c039f0ded64df98dbfe6680db50e88d7cc25b2dfc2dc4c63b3180d388f10c8e109c36bbcd7809246a3dc9501f4764306935c3703f0291e30fd37aa7fa9150598d92b3ebfa61ba5c8d4813646f73f0b7346c967625ebd497d4e3777b4200c3c3db2bba646fc6203b7dda43d414da51e62ccf65d174928e2fa630047a6c9e99b574f9fb72b33985216ac965aeb1b1767aeb8f2cd3530fa0b62cd97c12048583b8de269f0b9ef0b3d264d290591eee0d081bef2a35a5d6a01a78e988469ae08dd657ab38c4f4a8a5aa9043d95c2141790740384637ebec16ea89ce0e821b94120447fb965e260d27bb5ee2fed06f724771bd76534fbd5255c283ccd742e3699c2e22d9f111d09583e0f53a6e848b8f70bfaffe7349be27be6bdec28b9472079bb9633c0abdf6bd88ca73210c4de2024751b13e8b5a9651ad3b0b5222aacca08a128b6f3067c1c77b70a956cbd081f611f4000112bb4cf20873f2019458ac2385fa99d6441a6d43555b30857bd28d327269fbfac0e7eaed31571849d045ea62d5787ed555ed081895090fc59d6c379b67f786d20ee960c15c32ad2bb1539186fe890bec733aa74ffc4a44a78b7ad9be0e8603de17f19c1b1c46cf586ae6f0ffbc32a5b8b3d2f58570916dc52930c5b8275f3d2ccc82b5f7fb2d248787b71b4a8b62d755cc85d6e8a569a459ce8b2dd188a8906c06a7417629540629462a96cacbc73ae74bc02b07937e1c7fbb5b65ff03d41cff8a0b204b095c7e19e04e82b225c5ddc4a5f718ba255bb71198b806ea62a45d7f2ca82642a6139cb7f4cbc6ce4df35f2a13f2f5dd42fce3b320f4acf4b6327e4192d0fcc6c723325b2a1a535cc3df8455d30caa24218517d88549cc4311b87f02068691e89f73399245ba6037d906bc5617364991862c286f79ebf428edd28a1df92c6337b2ab0d6a796768184aa7de70d6b8399a4c8573299a22bd8a97bfabe0e5b41e4ec4763a068acb3ca71a5c307b12ac9498e54d71a89913fd2c226b5cdfe1e5662a46319a84278cbfdc50bd4135d1b3fb50b017550329616915f39307bc6d558c968d2c62dbae200c6aa70212fc7904ff025055d733af4fa9a04f70fc59dba01444e749c894ed1095cdd19136dc3f6628e291f220a59c68d570ad24e29e892eeb3331fb10d4974586298bd2f2e4ef2f701778bdd5fe942d06fc8daede35b708a3b4aa307ee809fea0a12cc837eddd39d99ea6c64396f00493294a5ee8c5b59153888c273fbc53a6a1992ff299bc985cf264efcac200c18689724a6b6b29ed16d605a83075ba6032c35a028aced2c0e6d5bc6532c36f73a39e2ca5efe0caa5b3785d43ba2faa8bdb58885baec25c12086f49a99700dde335532aa9a40e6c44f9987e83a90db0ae7290bf7137471e13129803ea159bc42aa0edcf20a8638118d2d784056bcca855ce0a109ee71fd43a89ce07f6eb9d8bf7d89489f73e8baf6bc20bdde271d3dadfa03ba5a55742a4c41b39c45891bfb84f522925adcca2e663a9ab304f5540eb60efc99e573c8e8638d20cfe8f42ab14cad5eb3bbc2f05923dde231281783f36738a70043dbb05071a3bd1ebf547fa0124324cdfb24d578d56c11b2baf843e0a63d8ac1eeeb2916caffa0eb6e30a45e1ee4e52c85bcb97a9449ee24aa6d3bde96f83e4c6122ff0d3a8e60d150efade3f494db665b5dcfef744a368db51ea8ac718bfe2573bff76697c3ad53af524dff638577285a55f3103c6d49accee47a45389201b41ce362377c6ef12074842d093a02b24ce9b67aa215f5c9aeced9518d28cf258d0daa388e1b0df1a603178b52d5bf2acf48c998fdaf8ae5672f5ddebaf466dabb04c7f9bd8956f2f50a8bf67b16f1d9d702f8776cb17fc670c2f1e655a775dfe994c72a30f9a7ff5d97bad667a1ebfaae44877eb51466e75b395e1c1048b238c5d73067bce3f09c91d6782d6749e4fe102a087a0ba1302cb14614d0feb839a42971e592fb2a04ab5062f6e53573867add16ff1647c1c8b60b5da2aec62bf364ba6c034eafe680981068c2587d89686b4bcc02b24c7b51b51078cca3e8649f13fbf3bfc468b91084b5de4c3685291feaef55425f572d2789f63c21bead06102268b853040ed0b49b6108997b33d3fac494e816b13e6487f4bac237ecd98756b5858ec742041b18831fc8ef1e2121a154ec829d1207a49a47936aae66b7d794e7012bb704da4fcafb227f816957f7898ff7bb6d3b38829d6c1e3179d5d4a20376bdd8c34c7f97f200e70d22d4bc044a54fac447ab3cc6e49a1257ca6fa0e4cb75c46adb38e000126fbf04edfa607aa72ca302bf803346f8ff2f234205c19821be78cdfe994ca102456c618d75909eb7a179df297575e53a52e2e1e3af9b2efb27d9b2bf4806db33a729d8a6a32b95009f3807b23dc0f0c9d355ed453917dbabefbb29d6a8546b83315f6ecf64409c9ad5a662d7d0d006a6d0d45825ca1ea01eb529c894bc0e4102e0c60490a1cad86feed9b3b5dfbec0a5e06c926f2f56b561c31dfc327441c9432d4afc12ccfe315e481f83ca22754ecaef10af954d34b94cbd53eff07af1d04c71daacc9f80324b0b79acd63bc0a07e902374ee268de246a40dac60a02ce0f921d91cf4ec177d833fcafe8770da05366698cb44cea14dfaf7a2a22e5fcbea5f800e15b3025c35f813b6b5612de3f5320da972049def6d1e6303bf52f8374d100729cd438d41dd4bdf7485395ff74c97a93169249adfc750e5cf7a089e28b14fded2abea88dc02c001619966ce49b06d0ed48c556430934a800663046d516ab7572e32ab8fa4aa0241b5dfc37c3fb4252cf92bd3292393418ac4dacd3f0856dea52be6eff230c440d78245b45c7504ff5b06c6198c8b21a31d5c19b21dad2bebe2df5ca928a2e7a858ca8fa6845354e7816fd1d35045715631074694db33e8d09caa202c7badb5ad3ffb14111581d3d827309c6ac691f1bf0a98225921c589e86d1e85335d6d9b61b44d00eed09fe9d5a21880cc885052884035b1f53414f4c708773735b6d4ce0398d2502f830b38fe2dd2abb94fdc4cbed207b01f8c132c4da8e0c3197017df32cc998ff0d3a2a203a517d523fe57bef21fe73144791600aaa82ea0e1a92cd88d807cf4fc651527f924ae31f43658f333a64874dee1345def2b406111c31d771e1d1fd90ff68df661fb68903d576105da7c257cf3a6c9cddcdbb5dcd5f861b8e25501e62fc544b5d1e118dc3cfb0b2fdc9efb207d15a6b1737cb4da8a653521422222f1f6635a803c48f44ebb4ba25f3c87915f87cf9d96a4fc842d06b5ac69e6476bc9a32fe25b1b23f01cff4e10a0b94b1e89b25d8583d8cdd81a722977c661acc24b58f64117fd69333c48a5c20eb9d62a87491e54337e9b563749d4b5c14c2cc13d801f477b2d0906d4e153b4f3c311cb73a7fb6c5bcdfcf90549b07ebc28c3168309ecc8a226e732f4113dcede84f2fa92c04c66fe726824c57b63ec7b17d7c52fbd096d3eba3faacebf39598157f2e2a86a68275bd35cac4e885c690f81f20e37d55ad1ba20030e9eaffa687242f64adaabbfac0c30571564f10944b8fc51a1f1b06e9a6e09f749848f7067bee823773dc456a8525473a47ec7dad08405d1753cac6d24d097bc3e654fe9c8e67ea4d68f00a7969f78bf638510e95ac2ef33db2d60ffdf1b732a0dd1cef3600400a59f798438b7da6a0530ed6152d7f8f6ec84f915504875777e2490c5542428def4c92c72bbb34e9d72a3e4b89117a52020985900f4eca405d1dbb42af5a9cace0cb68ea1123d40ba4267190b0b908bb12b913172aba6b61b028ffa39a099b4c7fd76f94ef2bda9bf14488f0803f52194c7db2974050e49afc82a5bbf3896db67d35ad1a66afbad6064e84bc06209246a7d82aa68c5f7b0f6711b2aaff4f094f95cec5ba95b10ea8b67b11f76f1a6350e061b156105107525e0798c742e42e3d6d3ade4f8e3d2129662629fd3db15dd9da524386d8f016e01a8f24043b5ace57522edc2df9749c5b805239d9770700b2b41722e4bb0c8a9e50951c01f0d8266677d07d10f87f0016d6c3c88b8b07e0c93d47a398fa236a8125baffd4c16a791f8756c0f48310b686adb7c9d57175aac2bfef9e9ee4eddcbe01234583b93d4b6708ccd48629b6f8ac5414ee4fb5c139599d38b927d1fb9c5adda849daad128c33c379decc9115e4bd163ee12fe387e303051e74388e7a3402b538026b6ede037c963fb4de646502241662aeb22972863118dc9e1f18bea0e75b0dce1b2c692ccfdfc06b71056f10bb22334c0863f29df4685959c5e15e330d67aa9d971eb2d74b68cdd5843e812d0a7574da47b2fd5d9cf984ed539e659aa5050f86800ca39d1c61b35e1e52cefa4dbcae8601c5d3f8403e5b48ef189b9496651f3dec307b5418ec05a2a92ce30d5cbe90a7241f9b62f983d7b7fcb17ec23de3ece90950dadc5e532dc0cef9ce790f221482c5cd06572f66be7892796c2974446c87fff8f55c860f20ae525f202e6082a9ea0215d6a45332f7484aeb3ee0958c9fd31fc5fe8f97774e07d3d35828284605058bb38b0df0d49b8facf766f9d269bcb44997e9836e57bdbb7c1855a2171a8fa8bdd3a49a5662986c73a03c1687d920d33b6029fb80122fc222319061209d2787df20e3352db99e4c918a6522ebc019a4240209639cae789b27682354720af9a436c9e54aba5137170e3125ff733017dddc6687665ed75b16dc56d222a13af0bd839098636658684d57629b01144ae363e27274949d426a6f7ed39c7b035c8ea10749092d5d562a8a711a85d5850f1cba5067204343c73a620a240a5278b305f5338ef319cf0853422981c5b2fd62c378a066c245be46e7f61cf41511a88cb903179f9d8fff0358e200f6c8cb14c8d86c3aed5ee0fbdb1fd7a6ac5abe5e9df905f24d34125d01f8788aa6851dc1ebba02366457648f88bbecca12ab7a07074b892782d487c4cc511077b4205f40932972d51a4770be620cf8f07c23cf89c4ebbe86d7a9f562403c370a1637b62f7b9173174ac7bb89ca98c095406a2726edf013f908f55f8e808abc718316f65ef18e0e7a756c85f2b13afc94c45781bd26593064a121f35d9f6f84d4e23a3639e90f6dec17aed6ec90183fe277aa4eacb06f5c8150657b0f914714f9dc1abbcc9c903cc7099096b9b51dc9ede43798907c7c4384cfc8c9b63891576206f9ed3da04d423f0c27746e84b88212bb40b5051e511ded5591ef621283d70fa7ccaf614feaa38f86cf107a80ccbfb56898c96d1bc64cbeb83a189fd50f32c7d2fd30026da51d1c2f1a91ef804a3e2a9f4dd83f38897101c56580a679cbef4b81b7edaee0e7469231164ba9e42434a444a554afd80776f64cf1ae2a5e35bad8b20b3b1948ae8b19ffceeddf284d3cacabaf7227dde149b859618f4fbaa3a910ad8e53cc82dbdd6258117b978964438ef6e97db1efd880ab8e5550f45b26d453291f932a28782eca49052c2cdb9905af43da00ffa68a119acfeee47e45b1dac367cb39c5b401621b2cd79ec1aec3089b6a34f86187dbd790a527b58ecbe3f30595a3c4f45c02542d975d83532305eca432e46038a7fc50c16a8b968aba59a8987d6c50c8e0345408ad0dff8bc5a4e314640ff18f0b4fb27bf62fa14663821585e9f69d03aa4e15c2bf97d70db66758f0026b9f4d96a490bebd74c2fe91f58c74b4efa3737794e78bc53df442235d99a1e05ab5f651296bdcd48f2e7e0d6b24b4eff779676ae4e9af3febf5c86690da42355d2513f8d88ab1de28dd57b7cccc86fbb963d857b5a8d1c3bd9a72e50ed07db80e1e3b9934eb357083155642569d66901a96a799420b47a0b27f28775b82f7145eea01ea1dd39e2338aa1d63519df23c8697491ad660506d3c39d808b95ad86593078d60099e68d9dbc888ec9eb6897028be1c54def2a4e169778e58e9239bf60dd8e62c498e647ab04161387ca3fbf90be85ee7e890049b9749f37a78e27e3143706989141e4f13e807041b402e3ba60d705f2d6a9fac5aecf5cd3ca8ea2d814dd2900044b55cd0feb66b08b501d4714a7ea1d96d3d077f4081abda8b8ecaf2ec7ba81b507bed7e7ef238063f8428edbbf70a5d94367f294a3e47dca6320020e8c2e887c38c277a7d35beceac2c3b49d3719edf113b09b447396fcbf85cc5880ba73c78f4fe12e29ba559208fef73261c4dc8a6e0b9f4aa68e24065be8c169b526428c5590f7ffa9331b94eea2db895effd110706c8fa492bdc1e94acef3b70b21ff8394fc44031df441f5f5a272745a6f9752d5c9abe6c832877db8cecccf86dbfe88927a5aa2c5ecaa9136998bfa15f40770c8fdd46ba36b4ed5b51d61c179bd0f7ca76da1a89992507cb6397011ea3ebfc15b2bb75dc958162c6ef91db95e0cc0f7ebb1e6446e4386520c7cda991b5385910558bedf9d9917283039b243df22859330a0c556e95612d6b3b0e910bd8f3b996985e7d4c5ab1994baf9b09c3a7b670289d42da3aa33275456b892a01fcd0bf653633ce34f9e354263a1fbed9da02aba7d0ac3c999821586eb0b84cb7df6f3202d9d23cd2dd4e24ee447e1dc70faa0dacc8505ed344c862a03175fd9894d0c5d4025acd2a94916ba147505bea69f206512a57ad0e0e84e326b283c226120234365a6f45e6429655c12ae38ae88313ca5e6970733bebaa7621fff1b829fbe21986d97cbb581d454a1e3bd464585ab2aa0f49acabcda6965f522c94112a1b033431608e1bac5c3d10b4ae3a8c85d6734f79b660780180fb87088013f990ed95f546319c44bb60663451b3b78df708e0fe89d3908a8a6deb5083bc70dc346dea3de5c2709b4d84dd0ec53ca4c009a5edce5d8c5a20</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>预算决算</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-LLM+Privacy Survey总结</title>
    <url>/2023/12/22/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-LLM+Privacy%20Survey%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="LLM-Privacy-Survey总结"><a href="#LLM-Privacy-Survey总结" class="headerlink" title="LLM+Privacy Survey总结"></a>LLM+Privacy Survey总结</h1><h2 id="1-A-Survey-on-Large-Language-Model-LLM-Security-and-Privacy-The-Good-the-Bad-and-the-Ugly"><a href="#1-A-Survey-on-Large-Language-Model-LLM-Security-and-Privacy-The-Good-the-Bad-and-the-Ugly" class="headerlink" title="1 - A Survey on Large Language Model (LLM) Security and Privacy: The Good, the Bad, and the Ugly"></a>1 - A Survey on Large Language Model (LLM) Security and Privacy: The Good, the Bad, and the Ugly</h2><p>Yifan Yao, Jinhao Duan, Kaidi Xu, Yuanfang Cai, Eric Sun and Yue Zhang</p>
<ol>
<li>这篇survey探讨的是LLM对安全与隐私的影响，分别从以下三方面讨论：<ol>
<li>Good：利用LLM来解决一些安全隐私问题，例如用LLM查代码漏洞；</li>
<li>Bad：利用LLM来完成攻击，例如社工；</li>
<li>Ugly：探讨LLM的漏洞和防御，这部分和我们要关注的隐私推断相关，因此接下来只看这部分。</li>
</ol>
</li>
<li>对几个LLM模型的对比方面，这篇论文列了<code>Date Provider</code>、<code>Open-Source</code>、<code>Params</code>和<code>Tunability</code>这四方面，对比了<code>gpt-4,gpt-3.5-turbo,gpt-3,cohere-medium,cohere-large,cohere-xlarge,BERT,T5,PaLM,LLaMA,CTRL,Dolly 2.0</code>这几个模型，没有很详细介绍。我觉得我们可以加上谷歌的<code>claude,bard,gemini</code>和一些国产模型。</li>
<li>论文的图表都挺好，有参考价值</li>
</ol>
<h3 id="LLM的漏洞和威胁"><a href="#LLM的漏洞和威胁" class="headerlink" title="LLM的漏洞和威胁"></a>LLM的漏洞和威胁</h3><h4 id="AI模型固有漏洞"><a href="#AI模型固有漏洞" class="headerlink" title="AI模型固有漏洞"></a>AI模型固有漏洞</h4><ol>
<li>对抗性攻击：用于故意操纵或欺骗机器学习模型的技术和策略<ol>
<li>文本下毒：向训练数据集中注入恶意数据来影响训练过程</li>
<li>后门攻击：恶意操纵训练数据和模型处理，从而创建一个漏洞，攻击者可以将隐藏的后门嵌入到模型中</li>
</ol>
</li>
<li>推理攻击：攻击者试图通过对模型进行特定查询或观察来获取有关机器学习模型或其训练数据的敏感信息或见解<ol>
<li>属性推理：攻击者试图通过分析机器学习模型的行为或响应来推断个人或实体的敏感或个人信息</li>
<li>成员推理：在给定对模型和特定数据记录的白/黑盒访问的情况下，确定数据记录是否是模型训练数据集的一部分</li>
</ol>
</li>
<li>提取攻击：攻击者试图从机器学习模型或其相关数据中提取敏感信息或见解。提取攻击和推理攻击有相似之处，但具体重点和目标不同。提取攻击旨在直接获取特定资源（例如模型梯度、训练数据）或机密信息。推理攻击通常通过观察模型的响应或行为来获取有关模型或数据特征的知识或见解。</li>
<li>偏见与不公平：模型表现出偏见结果或歧视行为的现象</li>
<li>指令调整攻击：指令调优，也称为基于指令的微调，是一种机器学习技术，用于通过在微调过程中提供显式指令或示例来训练和调整特定任务的语言模型。在 LLM 中，指令调优攻击是指针对指令调优 LLM 的一类攻击或操纵。这些攻击旨在利用 LLM 中的漏洞或限制，这些漏洞或限制已通过特定任务的特定指令或示例进行了微调。<ol>
<li>越狱：绕过安全功能，以响应其他受限或不安全的问题，解锁通常受安全协议限制的功能</li>
<li>提示词注入：操纵 LLM 行为以引发意外且可能有害的响应的方法。该技术涉及以绕过模型的保护措施或触发不需要的输出的方式制作输入提示。</li>
<li>这两个的区别是什么？我查了一些资料显示这俩是一回事。</li>
</ol>
</li>
</ol>
<h4 id="非AI模型固有漏洞"><a href="#非AI模型固有漏洞" class="headerlink" title="非AI模型固有漏洞"></a>非AI模型固有漏洞</h4><p>包括LLM可能遇到的外部威胁和新漏洞（在传统人工智能模型中尚未观察到或调查过），可能与人工智能模型的内部机制没有复杂的联系，但它们可能会带来重大风险，涉及系统级漏洞（例如远程代码执行）。</p>
<ol>
<li>远程代码执行（RCE）：针对软件应用程序、Web 服务或服务器中的漏洞来远程执行任意代码。虽然 RCE 攻击通常不适用于 LLM，但如果 LLM 集成到 Web 服务中并且该服务的底层基础设施或代码中存在 RCE 漏洞，它可能会导致LLM环境受到损害。</li>
<li>边信道攻击（SCA）：虽然 LLM 本身通常不会通过传统的侧信道（例如功耗或电磁辐射）泄漏信息，但在实际部署场景中，它们可能容易受到某些侧信道攻击。</li>
<li>Insure Plugins：用于LLM的第三方插件本身的安全问题。</li>
</ol>
<h3 id="LLM的防御"><a href="#LLM的防御" class="headerlink" title="LLM的防御"></a>LLM的防御</h3><p>本节重点关注训练阶段实施的方法，例如优化和训练语料库，以及推理阶段使用的方法，包括提示的预处理和生成的输出的后处理。</p>
<ol>
<li>训练阶段的防御策略：暂略</li>
<li>推断阶段的防御策略：测试时防御包括一系列策略，包括预处理提示和指令以过滤或修改输入，检测可能表示滥用或有问题的查询的异常事件，以及后处理生成的响应以确保它们遵守安全和伦理指南。<ol>
<li>指令处理（预处理）：指令预处理对用户发送的指令进行转换，以破坏潜在的对抗性上下文或恶意意图。它发挥着至关重要的作用，因为它能阻止大多数恶意使用，并防止大语言模型接收可疑指令。一般来说，指令预处理方法可分为指令操作 [228、212、130、109、297]、净化 [152] 和防御演示 [158、177、282]。Jain 等人[109] 和 Kirchenbauer 等人[130] 评估了多种针对越狱攻击的基线预处理方法，包括重授权和解析。Li 等人[152]提出通过先屏蔽输入令牌，然后用其他大语言模型预测被屏蔽的令牌来净化指令。预测出的标记将作为纯化后的指令。Wei 等人[282]和 Mo 等人[177]证明，在指令中插入预定义的防御演示可有效防御大语言模型的越狱攻击。</li>
<li>恶意检测（处理中）：恶意检测提供了关于给定指令的大语言模型中间结果（如神经元激活）的深入检查，对恶意使用更敏感、更准确、更具体。Sun 等人[247]提出利用后向概率检测后向指令。Xi 等人[291]从掩码敏感性的角度区分了正常指令和中毒指令。Shao 等人[228]根据文本相关性识别可疑词语。Wang 等人[279]根据多代之间的语义一致性来检测对抗性实例，Duan 等人[65]在大语言模型的不确定性量化方面对此进行了探索。除了大语言模型的内在属性外，也有研究利用语言统计属性的工作，如检测离群词[202]。</li>
<li>生成处理（处理后）：生成后处理指的是检查生成答案的属性（如有害性）并在必要时进行修改，这是向用户提供回复前的最后一步。Chen 等人[33]建议通过与多个候选模型进行比较来减轻生成的毒性。Helbling 等人[96]结合了单个大语言模型来识别生成答案的有害性，这与 Xiong 等人[296]和 Kadavath 等人[121]的想法相似，他们揭示了可以提示大语言模型回答有关生成回复的保密性。</li>
</ol>
</li>
</ol>
<p>对于 LLM 训练的防御，目前很少有研究来检验模型架构对 LLM 安全性的影响，这可能是由于与训练或微调大型语言模型相关的计算成本很高。我们观察到，安全指令调整是一个相对较新的发展，值得进一步研究和关注。</p>
<p>说明：这里关注的并非推断过程中的隐私泄露，而是推断过程对大模型的攻击，与我们要讨论的没有关系。</p>
<h3 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h3><ol>
<li>已有大模型的survey侧重点各有不同（例如，大语言模型的演变和分类[30, 326, 288, 89, 290, 23]、软件工程[75, 101]和医学[255, 43]）。</li>
<li>本文的主要重点是大语言模型的安全和隐私方面。<ol>
<li>Peter J. Caven [29]专门探讨了大语言模型（尤其是 ChatGPT）如何通过融合技术和社会方面来改变当前的网络安全格局。他们的重点更倾向于社会方面。</li>
<li>Muna 等人[5]和 Marshall 等人[171]讨论了 ChatGPT 对网络安全的影响，强调了它的实际应用（如代码安全、恶意软件检测）。</li>
<li>Dhoni 等人[61]展示了大语言模型如何协助安全分析师针对网络威胁制定安全解决方案。不过，他们的工作并未广泛涉及大语言模型可能带来的潜在网络安全威胁。</li>
<li>一些调查（如 [88, 58, 229, 49, 59, 210, 222, 223, 7]）强调了针对大语言模型的威胁和攻击。与我们的工作相比，它们没有用那么多的篇幅讨论大语言模型可能存在的漏洞。相反，他们的主要关注点在于安全应用领域，因为他们深入研究了利用大语言模型发动网络攻击的问题。</li>
<li>Attia Qammar 等人[201]和 Maximilian 等人[180]讨论了网络犯罪分子利用的漏洞，特别关注与大语言模型相关的风险。他们的著作强调需要制定战略和措施来减少这些威胁和漏洞。</li>
<li>李浩然等人[154]分析了当前大语言模型上的隐私问题，根据对手的能力对其进行了分类，并探讨了现有的防御策略。</li>
<li>Glorin Sebastian[224]探讨了如何应用已有的隐私增强技术（如差分隐私[68]、联合学习[317]和数据最小化[199]）来保护大语言模型的隐私。</li>
<li>Smith 等人[237]也讨论了大语言模型的隐私风险。</li>
</ol>
</li>
<li>我们的研究全面考察了大语言模型的安全性和隐私性，从三个方面对大语言模型的文献进行了广泛的回顾：有益的安全应用（如漏洞检测、安全代码生成）、不利的影响（如网络钓鱼攻击、社会工程学）和漏洞（如越狱攻击、提示攻击），以及相应的防御措施。</li>
</ol>
<h2 id="2-Privacy-in-Large-Language-Models-Attacks-Defenses-and-Future-Directions"><a href="#2-Privacy-in-Large-Language-Models-Attacks-Defenses-and-Future-Directions" class="headerlink" title="2 - Privacy in Large Language Models: Attacks, Defenses and Future Directions"></a>2 - Privacy in Large Language Models: Attacks, Defenses and Future Directions</h2><p>Haoran Li, Yulin Chen, Jinglong Luo, Yan Kang, Xiaojin Zhang, Qi Hu, Chunkit Chan, Yangqiu Song</p>
<ol>
<li>从互联网上提取的自由格式文本存在数据质量差和无意中泄露个人信息的问题。例如，与模型的简单交互可能会导致个人身份信息 (PII) 的意外传播（有参考文献）。</li>
<li>将不同的应用程序整合到LLM中是一种日益增长的趋势，旨在增强其知识基础能力。这些集成使LLM能够有效地解决数学问题（例如 ChatGPT Wolfram Alpha）、读取格式化文件（例如 ChatPDF）以及使用搜索引擎（例如 New Bing）对查询提供响应。当LLM与搜索引擎等外部工具结合使用时，会出现额外的特定领域隐私和安全漏洞。</li>
<li>本文：<ol>
<li>与已有survey相比，提供了更全面、更系统的分析。我们超越了以往的研究，纳入了大语言模型的最新进展。</li>
<li>研究了保护用户隐私的新技术和策略，例如差分隐私、安全多方计算和联邦学习，目的是深入了解它们的有效性和局限性。</li>
<li>讨论了未来未研究的隐私漏洞以及解决该问题的潜在补救措施。</li>
</ol>
</li>
<li>对LLM的介绍：从transformer说起，没具体介绍和对比已有的模型。</li>
<li>对Privacy的介绍：介绍了隐私的概念和保护隐私的重要性，介绍了DP和SMPC</li>
<li>LLM中的隐私问题：<ol>
<li>训练数据隐私：如果训练数据包含个人或敏感信息，则存在通过模型响应无意中暴露该信息的风险。</li>
<li>推断数据隐私：在为下游任务部署经过训练的语言模型后，用户输入和查询通常会被记录并存储一段时间。对于敏感域，这些数据可以包括个人信息、私人对话和潜在的敏感详细信息。</li>
<li>再识别：即使用户信息被匿名化，仍然存在被重新识别的风险。通过结合来自多次交互的看似无害的信息，有可能识别个人或提取本应隐藏的个人详细信息。</li>
</ol>
</li>
</ol>
<h3 id="隐私攻击"><a href="#隐私攻击" class="headerlink" title="隐私攻击"></a>隐私攻击</h3><h4 id="后门攻击"><a href="#后门攻击" class="headerlink" title="后门攻击"></a>后门攻击</h4><p>数据中毒是指仅操纵一部分训练数据的较弱攻击。这种操纵的目的是在模型的训练过程中引入偏见或误导性信息。相反，后门攻击涉及插入或修改特定的输入模式，从而触发模型行为不当或产生目标输出。此外，如果对手可以操纵LLM的部分训练语料库，它可能会通过数据中毒向受害者模型注入后门。</p>
<h4 id="提示词注入"><a href="#提示词注入" class="headerlink" title="提示词注入"></a>提示词注入</h4><p>概括起来就是恶意提示词，包括越狱等，和前一节与后一节都有共通性。</p>
<h4 id="训练数据提取"><a href="#训练数据提取" class="headerlink" title="训练数据提取"></a>训练数据提取</h4><p>包括PII提取、越狱、对抗性提示词等。</p>
<h4 id="成员推理"><a href="#成员推理" class="headerlink" title="成员推理"></a>成员推理</h4><p>判断给定样本是否在训练数据中。列举了一些涉及成员推理的论文。</p>
<h4 id="额外信息攻击"><a href="#额外信息攻击" class="headerlink" title="额外信息攻击"></a>额外信息攻击</h4><p>是针对向量表示和梯度的攻击，主要是在联邦学习的场景出现，包括：</p>
<ol>
<li>属性推理攻击：从嵌入推测数据集的敏感属性</li>
<li>嵌入反转攻击：从给定的嵌入恢复原始数据</li>
<li>梯度泄露：在可以访问其相应模型梯度的情况下恢复输入文本</li>
</ol>
<h4 id="其他攻击"><a href="#其他攻击" class="headerlink" title="其他攻击"></a>其他攻击</h4><p>以下几类攻击的研究尚不充分。</p>
<ol>
<li>提示词提取攻击：看内容就是提示词注入，不过提到了一个论文是prompt extraction attacks，可能和我们要总结的有关系。</li>
<li>对抗性攻击：利用模型对原始输入的小扰动的不稳定性。</li>
<li>侧信道攻击：只有一篇论文，和前面那个survey一样，没人研究这个。</li>
<li>解码算法窃取：窃取超参数解码。</li>
</ol>
<h3 id="隐私防御"><a href="#隐私防御" class="headerlink" title="隐私防御"></a>隐私防御</h3><h4 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h4><ol>
<li>基于DP的预训练：基于DP的预训练可以进一步增强LM对随机噪声扰动的鲁棒性</li>
<li>基于DP的微调：用公开数据预训练，再用敏感数据结合DP来微调</li>
<li>基于DP的Prompt调优：由于模型规模庞大，参数高效的调优方法（例如提示调优）被广泛采用来调优各种下游任务的模型</li>
<li>基于DP的合成文本生成：生成式 LLM 自然可以通过基于采样的解码算法生成多个响应。对于 DP 调整的 LLM，从 LLM 中采样文本满足后处理定理并保留相同的隐私预算</li>
<li>这里3和4应该算我们的总结范畴，不过也还需要再探讨推断的范围。</li>
</ol>
<p>需要补充一下，Prompt调优其实也算微调fine tune，查到<a href="https://zhuanlan.zhihu.com/p/620618701" target="_blank" rel="noopener">一篇文章</a>介绍三种调整方式的区别，简要概括如下：</p>
<ol>
<li>Fine-tuning是一种在自然语言处理（NLP）中使用的技术，用于将预训练的语言模型适应于特定任务或领域。Fine-tuning的基本思想是采用已经在大量文本上进行训练的预训练语言模型，然后在小规模的任务特定文本上继续训练它。</li>
<li>参数高效的fine-tuning，简称PEFT，旨在在尽可能减少所需的参数和计算资源的情况下，实现对预训练语言模型的有效微调。它是自然语言处理（NLP）中一组用于将预训练语言模型适应特定任务的方法，其所需参数和计算资源比传统的fine-tuning方法更少。例如知识蒸馏。</li>
<li>prompt-tuning是一种更近期的精调预训练语言模型的方法，重点是调整输入提示（input prompt）而非修改模型参数。这意味着预训练模型保持不变，只有输入提示被修改以适应下游的任务。通过设计和优化一组提示，可以使预训练模型执行特定任务。</li>
<li>prompt-tuning和传统的fine-tuning的主要区别在于预训练模型被修改的程度。fine-tuning修改模型的权重，而提示调整只修改模型的输入。因此，prompt-tuning调整比精调的计算成本低，需要的资源和训练时间也更少。此外，prompt-tuning比精调更灵活，因为它允许创建特定任务的提示，可以适应各种任务。</li>
<li>我们在后续的研究中是否重点放在prompt tuning而非fine tuning也还需要再斟酌。</li>
</ol>
<h4 id="安全多方"><a href="#安全多方" class="headerlink" title="安全多方"></a>安全多方</h4><p>SMPC主要用于LLM的推理阶段，以保护模型参数和推理数据。然而，保护 LLM 隐私的一个主要挑战在于非线性操作所带来的限制，例如 Softmax、GeLU、LayerNorm 等，这些操作与 SMPC 不兼容。为了解决这个问题，出现了两种技术方法：模型结构优化和SMPC协议优化。</p>
<ol>
<li>模型结构优化：旨在通过利用LLM的鲁棒性并修改其结构来提高推理效率，直接点说就是替换掉那几个非线性运算。</li>
<li>SMPC协议优化：指利用先进的SMPC协议来提高LLM隐私保护推理的效率，同时保持原有的模型结构，也就是针对非线性运算设计SMPC协议，提到的方法有混淆电路、FSS、分段多项式拟合等。</li>
</ol>
<h4 id="联邦学习"><a href="#联邦学习" class="headerlink" title="联邦学习"></a>联邦学习</h4><p>使多方能够协作训练或微调其LLM，而无需共享参与方拥有的私有数据。和推理阶段没什么关系。</p>
<p>采用任何隐私保护的 FL 算法在半诚实的数据推理攻击下存在泄露数据隐私的风险，半诚实对手遵循联邦学习协议，但可以根据观察到的信息推断参与方的隐私数据，而恶意对手可能在联邦学习过程中恶意更新中间训练结果或模型架构，以提取参与方的隐私信息。所以大部分FL会结合DP等隐私方案。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>前面几节都是通用的防御方式，本节介绍针对某一具体攻击的防御手段，包括针对后门攻击和数据提取攻击的。</p>
<h3 id="未来方向"><a href="#未来方向" class="headerlink" title="未来方向"></a>未来方向</h3><h4 id="当前局限"><a href="#当前局限" class="headerlink" title="当前局限"></a>当前局限</h4><ol>
<li>隐私攻击不切实际：很多攻击在现实里没动机，例如不会有访问权限、只在有限的用例中能有作用等，一些数据集的分布假设也不现实。</li>
<li>DP在LLM的局限性：DP是现阶段的主流隐私方案，但是有以下问题：<ol>
<li>理论上的最坏情况边界。根据定义，基于差异隐私的LLM假设有一个强大的对手可以操纵整个训练数据。隐私参数 (ϵ, δ) 提供最坏情况下的隐私泄露边界。然而，在实际场景中，并不能保证对手完全控制LLM的训练数据。因此，实际攻击与根据差分隐私进行隐私泄露的最坏情况概率分析之间仍然存在巨大差距。</li>
<li>实用性下降。 DP 调整通常用于相对较小规模的 LM，用于特别简单的下游数据集。尽管一些作品声称，通过仔细的超参数调整，基于 DP 的 LM 可以在某些下游分类任务上实现与不使用 DP 的正常调整类似的性能。然而，当下游任务变得复杂时，大多数工作仍然表现出明显的效用恶化。效用的降低削弱了基于DP的微调的动机。</li>
</ol>
</li>
</ol>
<h4 id="未来方向-1"><a href="#未来方向-1" class="headerlink" title="未来方向"></a>未来方向</h4><ol>
<li>针对提示词注入</li>
<li>SMPC的提升：模型结构优化（MSO）和SMPC协议优化（SPO）。 MSO 和 SPO 各自具有独特的优势。 MSO 通常在效率方面表现出色，但可能面临隐私保护推理和模型多功能性方面的限制。另一方面，SPO专注于优化SMPC协议，可以提高效率。不幸的是，SPO 可能需要修改模型结构，并且现有的预训练权重无法重复使用。挑战在于找到一种方法来整合 MSO 和 SPO 的优势，旨在为LLM设计一种高效、高性能、高度通用的隐私保护推理算法。克服这一挑战仍然是一项持续的研究工作。</li>
<li>隐私与人类感知的一致性：多数隐私研究工作都集中在具有预定义隐私表述的简单情况，这些简单的表述利用现有工具将所有提取的预定义命名实体视为敏感信息，然后模糊或替换。这样的做法一方面会导致涉及这些信息的推断精确性下降，另一方面并不满足广义的隐私。</li>
<li>实证隐私评估：简而言之除了DP的最差边界，没其他隐私衡量指标，一些工作开始使用经验隐私攻击作为隐私评估指标。</li>
<li>走向情境化的隐私判断：和前面第3条有些类似，是指即便模糊掉隐私信息，仍然可能通过上下文推测出来。</li>
</ol>
<p>和第一个相比，这篇文章的分类感觉有点混乱，有些分类是应该合并的，也没啥自己的见解，就汇总起来概括了一下内容。这篇没有related work。</p>
<h2 id="3-Challenges-and-Remedies-to-Privacy-and-Security-in-AIGC-Exploring-the-Potential-of-Privacy-Computing-Blockchain-and-Beyond"><a href="#3-Challenges-and-Remedies-to-Privacy-and-Security-in-AIGC-Exploring-the-Potential-of-Privacy-Computing-Blockchain-and-Beyond" class="headerlink" title="3 - Challenges and Remedies to Privacy and Security in AIGC: Exploring the Potential of Privacy Computing, Blockchain, and Beyond"></a>3 - Challenges and Remedies to Privacy and Security in AIGC: Exploring the Potential of Privacy Computing, Blockchain, and Beyond</h2><p>CHUAN CHEN, ZHENPENG WU, YANYI LAI, and WENLIN OU, TIANCHI LIAO and ZIBIN ZHENG, 中山大学</p>
<p>这篇不局限于LLM，而是扩展到了AIGC（人工智能生成内容），代表模型分文本和图像：</p>
<ol>
<li>LLM：ChatGPT等</li>
<li>图像：stable diffusion和midjourney</li>
</ol>
<p>AIGC基本步骤：</p>
<ol>
<li>收集数据并完成数据预处理步骤。</li>
<li>借助训练数据集完成模型的训练，根据不同的需求对模型进行微调，然后推断模型的效果。</li>
<li>完成模型的发布阶段，发布预训练的模型。</li>
</ol>
<p>数据安全和隐私问题最容易出现在数据收集的第一步，模型开发者可能会使用一些未经授权的数据来完成模型的训练，从而导致数据泄露问题。</p>
<p>AIGC面临的问题：用户输入数据泄露、模型攻击、数据爬取以及生成内容的不安全等。这篇列举了相关政策法规，可供参考，提到了国内外数据安全法规，对浪潮项目或许也有用，不过看名字都是之前调研到的。此外，信通院有针对AIGC的白皮书，LLM或许也有这方面的市场调研报告，可以找找。</p>
<p>这篇论文的组织结构和第一篇很像，只是每部分名字不同，第一部分介绍用AIGC造假，第二部分呢介绍AIGC本身产出的内容不够好，第三部分介绍受限于模型漏洞而遭遇的攻击。针对第三部分：介绍了区块链和隐私计算在提高 AIGC 安全性方面的重要作用，并提供了使用区块链、联邦学习和数字水印等技术的说明性案例与 AIGC 的结合，展现了它们在解决 AIGC 数据隐私、内容安全和知识产权问题方面的巨大潜力。</p>
<p>拉了一个大表格和其他survey对比，但是对比的范围和维度感觉有点奇怪。</p>
<p>背景介绍中对AIGC的介绍过于充分了，对Privacy的介绍提到了FL、SMPC、TEE和区块链，不知道为啥没DP。</p>
<p>第3章基本是介绍AI带来的负面问题，例如生成内容失真等。</p>
<h3 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h3><ol>
<li>去重：不仅文本有用，图像的去重也有用。</li>
<li>FL：包括了DP和安全聚合，这个分类不太合适。</li>
<li>区块链：结合了移动计算、边缘计算等，提供框架来保护流通中的数据的隐私。提供框架，记录资源和服务交易，鼓励节点之间的数据共享，形成值得信赖的AIGC生态系统。有结合Web3.0的，不过说真的我想不到这东西有什么技术点。也有和FL结合的。还有做NFT的，AIGC 的多模式输出可以被铸造为 NFT，然后记录在区块链上。</li>
</ol>
<h3 id="针对攻击的防御"><a href="#针对攻击的防御" class="headerlink" title="针对攻击的防御"></a>针对攻击的防御</h3><ol>
<li>针对成员推理攻击：权重标准化、Dropout、DPSGD、改模型架构、扩展训练集</li>
<li>针对模型提取攻击：数字水印（嵌入网络参数中，只能提供产权证明，没法防止模型被盗）、输出扰动、输入扰动</li>
<li>针对逃逸攻击(Evasion Attacks)：攻击者在不改变目标机器学习系统的情况下，通过构造特定输入样本以完成欺骗目标系统的攻击。一般发生在模型已经完成训练，在预测时。平滑VAE（主要针对的是图像）、修改模型结构</li>
</ol>
<p>总的来说这篇没怎么提推断的事情，无参考意义。</p>
<h2 id="4-Security-and-Privacy-on-Generative-Data-in-AIGC-A-Survey"><a href="#4-Security-and-Privacy-on-Generative-Data-in-AIGC-A-Survey" class="headerlink" title="4 - Security and Privacy on Generative Data in AIGC: A Survey"></a>4 - Security and Privacy on Generative Data in AIGC: A Survey</h2><p>Tao Wang, Yushu Zhang, Shuren Qi, Ruoyu Zhao, Zhihua Xia, and Jian Weng</p>
<p>这篇也是AIGC的，分图像和语言</p>
<p>和其他survey的对比：</p>
<ol>
<li>我们的工作针对的是生成数据而不是AIGC。之前的工作还探讨了数据收集中的隐私和模型的安全性问题。然而，这些问题对于人工智能安全来说是普遍存在的，这已经在一些作品中进行了讨论 [16, 17]。 </li>
<li>以往的工作针对具体问题提出了相应的技术，但忽略了同一种技术可以解决多个问题的事实。例如，水印可用于保护版权，同时检测虚假数据。相反，我们从信息安全的基本属性来讨论安全和隐私，信息安全的存在是通过特定的技术来保证的。 </li>
<li>我们补充了以前的工作中没有讨论的安全问题，包括访问控制和生成检测。此外，我们探索使用生成数据来支持真实数据的隐私保护。</li>
<li>表一显示了我们的工作与现有调查的比较。对比了隐私（AIGC中的隐私和为AIGC设计的隐私）、控制（访问控制和可追溯）、真实性（生成检测和生成归因）、合规（无毒和真实）。</li>
</ol>
<p>AIGC的阶段划分：</p>
<ol>
<li>准备训练数据</li>
<li>训练模型</li>
<li>用模型生成数据，这个阶段应该就是推断阶段</li>
<li>生成数据分析，主要是检查质量、真实性等</li>
</ol>
<p>生成数据的安全与隐私问题：和前面对比那里的4个维度划分一致</p>
<ol>
<li>隐私：生成数据可能泄露训练数据的隐私；生成数据包含虚拟内容，可以用来替换真实数据中的敏感内容，从而在保持数据实用性的同时降低隐私泄露的风险。</li>
<li>控制：控制对生成数据的访问；实现对生成过程和后续使用的追踪。</li>
<li>真实性：判断数据是否由AI生成；数据到模型的归因，从而实现问责制。</li>
<li>合规：生成数据不包含法律法规禁止的东西；生成数据是真实的，不会被群众误解。</li>
</ol>
<p>总的来说这个总结有点混乱，和我们相关的应该只有第一部分。</p>
<h3 id="生成数据的隐私"><a href="#生成数据的隐私" class="headerlink" title="生成数据的隐私"></a>生成数据的隐私</h3><p>生成数据对隐私的负面影响：模型会记住训练数据造成隐私泄露<br>正面影响：AIGC用虚拟数据替换敏感数据避免隐私泄露</p>
<p>第二部分概括来说就是AI在隐私保护的应用，和我们的研究不怎么相关，先不看了。</p>
<h4 id="Privacy-for-AIGC"><a href="#Privacy-for-AIGC" class="headerlink" title="Privacy for AIGC"></a>Privacy for AIGC</h4><ol>
<li>隐私威胁：就是模型记忆训练数据的详细说明，包括文本和图像</li>
<li>对策：<ol>
<li>记忆拒绝：放弃与训练数据接近重复的生成数据</li>
<li>数据去重</li>
<li>DP</li>
<li>检测重复内容：检测生成数据是否在训练集中出现——感觉这方法不合适</li>
<li>知识遗忘</li>
</ol>
</li>
</ol>
<p>总结下来这几篇都没具体到推断这个环节，很多方法是针对训练数据的，也有一些不区分是不是inference</p>
<p>待确认：</p>
<ul>
<li>[x] 调优（Fine-tuning）属于推断吗？</li>
<li>[x] 推断的范畴：<ul>
<li>[x] 发生在推断过程中，针对prompt的应该算，例如DP和MPC</li>
<li>[x] 隐私攻击是在推断中进行的，但针对的是泄露训练数据，例如成员推断、属性推断等。针对这类攻击的是否符合要求？</li>
<li>[x] 发生在推断前，和AI以及隐私计算其实都没什么关系，例如本地计算、边缘计算等，但确实保护了推断数据的隐私，不过没保护模型和训练数据的隐私，是否符合要求？</li>
<li>[x] 发生在推断中，针对训练数据的隐私保护是否符合要求？例如通过输入来实现的知识遗忘【In-Context Unlearning: Language Models as Few Shot Unlearners】。p.s. 没找到关于遗忘prompt的论文，只有个别帖子提到了有这方面需求，论文【 <a href="https://arxiv.org/abs/2310.12523" target="_blank" rel="noopener">Privacy Preserving Large Language Models: ChatGPT Case Study Based Vision and Framework</a>】中提到了让GPT忘掉之前的prompt等，但不涉及什么技术。</li>
</ul>
</li>
<li>[ ] 调研范围或许应该加上generate，它和inference的区别是什么？——待确定</li>
<li>[ ] 针对隐私对象的分类（训练数据、prompt、模型数据）应该不太可行了——待确定</li>
<li>[ ] 按阶段分要看范畴的定义，再筛选论文。</li>
</ul>
<p>预训练：大数据输入给深度学习算法，输出大模型例如gpt——和推断无关<br>调优数据：小领域的小规模数据集或者prompt，输入给大模型（如gpt），得到其响应结果——推断前<br>模型数据：大模型本身的向量、梯度、服务器参数等等——推断中<br>推断后：对响应结果做处理</p>
<p>问题：调优数据算推断吗？不算，只考虑promt调整</p>
<p>大模型阶段：训练、调优、推断or生成，本文针对第三阶段的隐私安全展开研究</p>
<p>分类方法：</p>
<ol>
<li>按时间阶段：推断前、中、后</li>
<li>按隐私保护的对象：预训练数据、调优数据（prompt）、模型数据（向量、梯度等）</li>
<li>按隐私方案优化的对象：调优数据（prompt）、模型数据（向量、梯度、函数等）、生成数据（推断后的检测、知识遗忘）、其他（硬件设备、本地计算等，考虑放到调优数据中）——首选</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>LLM</tag>
        <tag>Privacy</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-CipherGPT: Secure Two-Party GPT Inference</title>
    <url>/2023/12/08/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-CipherGPT%20Secure%20Two-Party%20GPT%20Inference/</url>
    <content><![CDATA[<h1 id="CipherGPT-Secure-Two-Party-GPT-Inference"><a href="#CipherGPT-Secure-Two-Party-GPT-Inference" class="headerlink" title="CipherGPT: Secure Two-Party GPT Inference"></a>CipherGPT: Secure Two-Party GPT Inference</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ol>
<li>GPT面临隐私问题；</li>
<li>由于数据量大、激活函数复杂，现有的安全方案不支持GPT；</li>
<li>本文：CipherGPT——第一个安全两方GPT框架<ol>
<li>提出了一种专为 GPT 推理定制的安全矩阵乘法，与 SOTA 相比，速度提高了 2.5 倍，带宽减少了 11.2 倍</li>
<li>提出了一种用于安全计算 GELU 的新协议，在运行时间、通信量和精度方面分别比 SOTA 提高了 4.2 倍、3.4 倍和 10.9 倍</li>
<li>提出了首个 top-k 采样协议</li>
</ol>
</li>
</ol>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><ol>
<li>介绍ChatGPT及其面临的隐私问题</li>
<li>安全推理：一种两方加密协议，运行推理阶段的方式如下：<ol>
<li>服务器 (S) 对客户端的输入一无所知，而客户端 (C) 除了推理结果之外对模型一无所知。</li>
<li>协议通过让 S 和 C 运用同态加密和秘密共享等定制加密技术在加密输入上运行加密模型来进行。</li>
<li>通常引入预处理阶段来准备一些昂贵且与输入无关的工作，以便在线阶段可以高效地完成。</li>
</ol>
</li>
<li>现有安全推理应用到GPT的问题：<ol>
<li>一些技术只针对某种网络结构，而不支持GPT；</li>
<li>LLM需要大量高维矩阵乘法和复杂的数学函数（例如 GELU）。</li>
</ol>
</li>
<li>本文贡献：CipherGPT<ol>
<li>基于 VOLE 的矩阵乘法</li>
<li>基于样条的GELU</li>
<li>基于洗牌的前K项选择</li>
<li>安全采样</li>
</ol>
</li>
</ol>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="安全推理和威胁模型"><a href="#安全推理和威胁模型" class="headerlink" title="安全推理和威胁模型"></a>安全推理和威胁模型</h3><p>安全推理是一种两方加密协议，有助于客户端 C 和服务器 S 之间的模型推理。该协议确保 C 只获得有关模型架构和推理结果的知识，同时隐藏 S 模型的所有其他细节。类似地，S 仍然不知道 C 的输入以及推理的输出。在 GPT 推理的上下文中，C 的输入是提示，S 的模型包含 Transformer 解码器的多次迭代以及 vec2word 层。</p>
<p>我们假设 C 或 S 可以是半诚实对手，它遵循协议规范，但尝试在协议执行期间收集尽可能多的信息。我们假设对手在计算上是有限的，并且使用$\lambda$来表示计算安全参数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$C$</td>
<td style="text-align:left">客户端</td>
</tr>
<tr>
<td style="text-align:center">$S$</td>
<td style="text-align:left">服务器</td>
</tr>
<tr>
<td style="text-align:center">$n$</td>
<td style="text-align:left">每层输入向量的长度</td>
</tr>
<tr>
<td style="text-align:center">$L$</td>
<td style="text-align:left">初始输入左移位</td>
</tr>
<tr>
<td style="text-align:center">$l$</td>
<td style="text-align:left">输入左移后的位长</td>
</tr>
<tr>
<td style="text-align:center">${\langle x\rangle}^l$</td>
<td style="text-align:left">$(\langle x \rangle_S^l,\langle x \rangle_C^l)$使得$x=\langle x \rangle_S^l+\langle x \rangle_C^l$ mod $2^l$</td>
</tr>
<tr>
<td style="text-align:center">$F_{Mult}$</td>
<td style="text-align:left">密钥共享乘法的理想功能：将$g$位整数与$h$位整数相乘得到$l=(g+h)$位输出，且无溢出</td>
</tr>
<tr>
<td style="text-align:center">$F_{CMP}$</td>
<td style="text-align:left">比较$b\leftarrow CMP(x,y)$的理想功能：如果$x\geq y$，则$b=1$，反之则$b=0$</td>
</tr>
<tr>
<td style="text-align:center">$F_{MUX}$</td>
<td style="text-align:left">多路复用器$y\leftarrow MUX(x,b)$的理想功能：如果$b=1$，则$y=x$，如果$b=0$，则$y=0$</td>
</tr>
<tr>
<td style="text-align:center">$F_{Trunc}$</td>
<td style="text-align:left">截断$y\leftarrow Trunc(x,s)$的理想功能：对于$x,y\in\mathbb{Z}_{2^l}$，$y=x\gg s$</td>
</tr>
<tr>
<td style="text-align:center">$F_{TR}$</td>
<td style="text-align:left">截断后减少$y\leftarrow TR(x,s)$的理想功能：对于$x\in\mathbb{Z}_{2^l}$和$y\in \mathbb{Z}_{2^{l-s}}$，$y=x\gg s$</td>
</tr>
<tr>
<td style="text-align:center">$F_{LUT}$</td>
<td style="text-align:left">查找表$T[i]\leftarrow LUT(T,i)$的理想功能</td>
</tr>
<tr>
<td style="text-align:center">$F_{Shuffle}$</td>
<td style="text-align:left">洗牌的理想功能</td>
</tr>
<tr>
<td style="text-align:center">$\alpha$</td>
<td style="text-align:left">$y:=GELU(x)$的分割：当$x&lt;-\alpha$时$y:=0$；当$-\alpha\leq x \leq \alpha$时$y:=GELU(x)$；当$x&gt;\alpha$时$y:=x$</td>
</tr>
<tr>
<td style="text-align:center">$s$</td>
<td style="text-align:left">$2^s$是在$[\\alpha,\alpha]$内的间隔数的数量</td>
</tr>
<tr>
<td style="text-align:center">$(a_i,d_i)$</td>
<td style="text-align:left">$y=a_ix+d_i$是每个间隔内逼近$GELU(x)$的线性函数</td>
</tr>
<tr>
<td style="text-align:center">$g$</td>
<td style="text-align:left">$a_i$的位长度</td>
</tr>
<tr>
<td style="text-align:center">$t$</td>
<td style="text-align:left">响应词（输入矩阵）</td>
</tr>
<tr>
<td style="text-align:center">$N$</td>
<td style="text-align:left">FHE中的多项式模度</td>
</tr>
<tr>
<td style="text-align:center">$M$</td>
<td style="text-align:left">注意力头</td>
</tr>
<tr>
<td style="text-align:center">$T$</td>
<td style="text-align:left">温度</td>
</tr>
</tbody>
</table>
</div>
<h3 id="密码学原语"><a href="#密码学原语" class="headerlink" title="密码学原语"></a>密码学原语</h3><ol>
<li>秘密共享：我们在不同的2次幂环上使用2-2附加秘密共享方案。对于$x\in\mathbb{Z}_{2^t}$，我们用$\langle x \rangle^l=(\langle x \rangle^l_S,\langle x \rangle^l_C)s.t.x=\langle x \rangle^l_S+\langle x \rangle^l_C mod 2^l$表示其shares。为了简化表达，当上下文无关时我们省略上标的$l$。</li>
<li>非均匀位宽乘法：理想功能$F_{Mult}$以$\langle x \rangle^g$和$\langle y \rangle^h$为输入，返回$\langle z \rangle^l$，其中$z=xy$且$l=g+h$。一个实现该功能的简单方法是首先将输入都扩展到$l$位，然后使用标准协议进行统一位宽的秘密共享乘法。SIRNN提供了一个协议，其性能比这个简单的解决方啊高1.5倍。该协议的通信复杂度是$\mu(\lambda+\mu/2+1/2)+mn$，其中$\mu=min(m,n)$。</li>
<li>安全比较：理想功能$F_{CMP}$以$\langle x \rangle^l$和$\langle y \rangle^l$为输入，返回$\langle b \rangle^l$，其中若$x\geq y$则$b=1$，否则$b=0$。$CrypTFlow2$为$F_{CMP}$提供了一个有效的协议，其通信成本小于$\lambda l+14l$位和$\log l$轮。</li>
<li>安全多路复用器：理想功能$F_{MUX}$以$\langle x \rangle^l$和$\langle b \rangle^l$为输入，返回$\langle y \rangle^l$，其中如果$b=1$则$y=x$，如果$b=0$则$y=0$。本文采用的安全多路复用器是SIRNN提出的，通信要求$2(\lambda+l)$位。</li>
<li>安全截断：理想功能$F_{Trunc}$以$\langle x \rangle^l$和$s$为输入，返回$\langle y \rangle^l$，其中$y=x\gg s$。SIRNN提供了安全截断的协议，通信要求小于$\lambda(l+3)+15l+s+20$位和$\log l+3$轮。</li>
<li>截断后减小：理想功能$F_{TR}$以$\langle x \rangle^l$和$s$为输入，返回$\langle y \rangle^{l-s}$，其中$y=x\gg s$。需要注意，这个和前一个的区别在于这个会通过右移操作将输出减少到一个更小的环上，而前一个则将输出保留在原始环上。SIRNN提供了协议，通信成本小于$\lambda(s+1)+l+13s$位。</li>
<li>查表：理想功能$F_{LUT}$以$\langle i \rangle$为输入，返回$\langle T[i] \rangle$，其中$T$是有M个条目的表。该函数通过对$\tbinom{M}{1}-OT$的单次调用来实现。更有效的解决方案是先将LUT描述转换为布尔表达式，然后使用多扇入内积对其进行评估。该协议在预处理阶段需要$(mt+4)(2^M-M-1)$位通信，在在线阶段需要$2\sigma$位。</li>
<li>秘密共享洗牌：理想功能$F_{Shuffle}$以$\langle \mathbf{x} \rangle$和$\langle\pi\rangle$为输入，返回$\langle\pi(\mathbf{x})\rangle$，其中$\pi$是排列函数。Chase等提出了使用OT和PRG等轻量级原语来实现该功能的高效构造。该方法涉及使用PRF来构建排列共享协议，该协议允许两方使用一方选择的排列来排列输入向量。这个排列和共享协议运行两次，每方各选一次。为了混洗$n$个$l$位元素，该协议的通信成本与$\lambda n\log n+nl\log n/\log T$成正比，计算成本位$(nT\log n/\log T)(l/\lambda)$对称密钥操作，其中$T$在16和256之间。</li>
<li>子域向量遗忘线性评估：VOLE是一个两方功能，它从发送方获取标量$x\in\mathbb{F}_p$并生成 VOLE 相关性：<script type="math/tex; mode=display">
w = ux + v \tag{1}</script>接收方学习$(\mathbf{u},\mathbf{v})\in_R \mathbb{F}_p^n\times\mathbb{F}_p^n$，发送方学习$w\in_R\mathbb{F}_p^n$。VOLE 通常基于带噪声奇偶校验（LPN）和可标点 PRFs 来构建，因此其复杂性几乎与$n$无关。子域VOLE(sVOLE)是VOLE的广义化，其中$\mathbf{u}\in_R\mathbb{F}_p^n,x\in\mathbb{F}_q,\mathbf{w,v}\in_R\mathbb{F}_q^n,q=p^m$。sVOLE 实现的任务与运行 m 个普通 VOLE 实例相同，但成本更低。VOLE 和 sVOLE 最初是针对有限域提出的。Baum 等人提出了在有限环（如$\mathbb{Z}_{2^l}$）上运行的方法。</li>
<li>同态加密：全同态加密（FHE）是一种允许对加密数据进行任意操作的加密方案 。在实践中，它通常以分级的方式使用：操作只能在有限的时间内进行，否则密文无法解密。在大多数 FHE 密码系统中，明文被编码为来自商环$\mathbb{Z}_p[x]/(x^N +1)$的多项式，其中$N$是 2 的幂次，$p$是明文的模数。然后将明文多项式加密为密文多项式$\mathbb{Z}_q[x]/(x^N+1)$，其中$q$是密文模数，它决定了密文的安全级别以及可执行操作的次数。</li>
</ol>
<h2 id="安全矩阵乘法"><a href="#安全矩阵乘法" class="headerlink" title="安全矩阵乘法"></a>安全矩阵乘法</h2><p>MatrixMul运算分别从C和S获取两个矩阵$\mathbf{X}\in\mathbb{Z}_{2^l}^{n\times m}$和$\mathbf{Y}\in\mathbb{Z}_{2^l}^{m\times k}$作为输入，输出$\langle \mathbf{Z}\rangle$，其中$\mathbf{Z}=\mathbf{XY}\in\mathbb{Z}_{2^l}^{n\times k}$。大多数已有方案用同态乘法和加法来实现上述共识的隐私计算。SIMD 技术通常用于通过将 N 个元素批处理为单个 RLWE 密文来摊销成本，但它需要昂贵的同态旋转来求和。Cheetah用系数填充代替 SIMD，以消除昂贵的旋转。尽管如此，仍然需要传输$\geq \frac{2n\sqrt{mk}}{\sqrt{N}}$ RLWE密文，并执行$\geq \frac{nmk}{N}$密文-明文同态乘法。</p>
<p>回想一下，GPT 需要自回归生成响应词。因此，单个 GPT 推理需要对具有相同Y的不同X运行 MatrixMul。我们的目标是通过利用 GPT 的这一特性来降低 MatrixMul 的摊销成本。</p>
<p>$\mathbf{X}=[\mathbf{x}_1,\mathbf{x}_2,…,\mathbf{x}_m](\mathbf{x}_i\in\mathbb{Z}_{2^l}^n$ 是 $\mathbf{X}$ 的每一列)，$\mathbf{Y}^T=[\mathbf{y}’_1,\mathbf{y}’_2,…,\mathbf{y}’_m](\mathbf{y}’_i\in\mathbb{Z}_{2^l}^k$是$\mathbf{Y}$的每一行)，则$\mathbf{Z}=\sum_{i=1}^m(\mathbf{x}_i\otimes\mathbf{y}’_i)$。假设S和C需要生成t个响应词，即有t个输入矩阵：</p>
<script type="math/tex; mode=display">
\begin{align}
\mathbf{X}_1=&[\mathbf{x}_{1,1},\mathbf{x}_{1,2},...,\mathbf{x}_{1,m}],\\
\mathbf{X}_2=&[\mathbf{x}_{2,1},\mathbf{x}_{2,2},...,\mathbf{x}_{2,m}],\\
&... ... \\
\mathbf{X}_t=&[\mathbf{x}_{t,1},\mathbf{x}_{t,2},...,\mathbf{x}_{t,m}].
\end{align}</script><p>令$\mathbf{x}’_i=\mathbf{x}_{1,i}|\mathbf{x}_{2,i}|…|\mathbf{x}_{t,i},\forall i\in[1,m]$，则<br>$\mathbf{x}’_i\otimes\mathbf{y}’_i=(\mathbf{x}_{1,i}\otimes\mathbf{y}’_i)|(\mathbf{x}_{2,i}\otimes\mathbf{y}’_i)|…|(\mathbf{x}_{t,i}\otimes\mathbf{y}’_i)$.</p>
<p>可得</p>
<script type="math/tex; mode=display">
\sum_{i=1}^m(\mathbf{x}'_{i}\otimes\mathbf{y}'_i)=\mathbf{Z}_1\|\mathbf{Z}_2\|...\|\mathbf{Z}_t.</script><p>因此，我们可以通过m个外积来计算t次矩阵乘法。</p>
<p>给定已经提前知道的$\mathbf{Y}$，我们可以引入一个预处理阶段，让S和C生成m个sVOLE相关性：</p>
<script type="math/tex; mode=display">
\mathbf{W_i}=\mathbf{u_i}\otimes\mathbf{y}'_i+V_i,\forall i\in[1,m].</script><p>其中C持有$\mathbf{u}_i\in\mathbb{Z}_{2^l}^{t\cdot n}$，是一个长为$t\cdot n$的向量，和$\mathbf{V}_i\in\mathbb{Z}_{2^l}^{t\cdot n}\times k$。S持有$\mathbf{y}’_i\in\mathbb{Z}_{2^l}^{k}$，且$\mathbf{W}_i\in\mathbb{Z}_{2^l}^(t\cdot n)\times k$。</p>
<p>在在现阶段，对于一个输入矩阵$\mathbf{X}_j=[\mathbf{x}_{j,1},\mathbf{x}_{j,2},…,\mathbf{x}_{j,m}]$，C将$\langle\mathbf{x_{j,i}}_S:=\mathbf{x}_{j,i}-\mathbf{u}_i[(j-1)n+1,…,j\cdot n]\forall i\in[1,m]\rangle$发送给S，然后计算：</p>
<script type="math/tex; mode=display">
\begin{align}
\langle\mathbf{x}_{j,i}\rangle_S\otimes \mathbf{y}'_i&=(\mathbf{x}_{j,i}-\mathbf{u}_i[(j-1)n+1,...,j\cdot n])\otimes \mathbf{y}'_i\\
&=\mathbf{x}_{j,i}\otimes\mathbf{y}'_i-\mathbf{u}_i[(j-1)n+1,...,j\cdot n]\otimes \mathbf{y}'_i
\end{align}</script><p>然后可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbf{x}_{j, i} \otimes \mathbf{y}_i^{\prime}= & \left\langle\mathbf{x}_{j, i}\right\rangle_{\mathrm{S}} \otimes \mathbf{y}_i^{\prime}+\mathbf{u}_i[(j-1) n+1, \cdots, j \cdot n] \otimes \mathbf{y}_i^{\prime} \\
= & \left\langle\mathbf{x}_{j, i}\right\rangle_{\mathrm{S}} \otimes \mathbf{y}_i^{\prime}+\mathbf{W}_i[(j-1) k n+1, \cdots, j \cdot k \cdot n] \\
& -\mathbf{V}_i[(j-1) k n+1, \cdots, j \cdot k \cdot n]
\end{aligned}</script><p>注意S持有：</p>
<script type="math/tex; mode=display">
\left\langle\mathbf{x}_{j, i}\right\rangle_{\mathrm{S}} \otimes \mathbf{y}_i^{\prime}+\mathbf{W}_i[(j-1) k n+1, \cdots, j \cdot k \cdot n]</script><p>C持有：</p>
<script type="math/tex; mode=display">
\mathbf{V}_i[(j-1) k n+1, \cdots, j \cdot k \cdot n]</script><p>这意味着S和C秘密共享$\mathbf{x}_{j,i}\otimes\mathbf{y}’_i$，因此它们可以本地计算$\mathbf{Z}_{j}=\sum_{i=1}^m\left(\mathbf{x}_{j, i} \otimes \mathbf{y}_i^{\prime}\right)$的秘密共享。它们可以由此计算所有Z。</p>
<p>对比了本文矩阵乘法和已有的两个矩阵乘法的成本，说明本文方法的成本与n无关，因此n较大时本方法更能节省成本。</p>
<h2 id="安全GELU"><a href="#安全GELU" class="headerlink" title="安全GELU"></a>安全GELU</h2><h3 id="直觉"><a href="#直觉" class="headerlink" title="直觉"></a>直觉</h3><p>GELU的曲线：当$x$值较小时，它从零开始，当$x$约为$-\alpha$时，它开始偏离零。随着$x$进一步增加，GELU(x)逐渐逼近线性函数$y=x$。由此可以将曲线划分为以下三部分：</p>
<ul>
<li>当$x\lt -\alpha$时$y=0$；</li>
<li>当$-\alpha\leq x\leq \alpha$时$y=GELU(x)$；</li>
<li>当$x\gt -\alpha$时$y=x$。</li>
</ul>
<p>第1和第3部分很容易计算，在第二部分，我们用多项式样条来近似GELU曲线。如图所示，我们将这个区间划分为几个小区间，并使用线性函数$y=ax+d$来逼近小区间内的曲线。我们参考[30]中的第 5.3.2 节了解查找线性函数的详细过程。值得注意的是，这种近似不需要对模型的训练阶段进行任何修改。</p>
<p><img src="https://github.com/likun1208/image/blob/master/Cipher-1.png?raw=true" alt="GELU曲线图"></p>
<p>我们可以使用$LUT$找到x所在的小区间，并以秘密共享的方式计算相应的线性函数。然而，对于$[−\alpha,\alpha]$，我们必须先确定$x$的正负性，然后分别在区间$[−\alpha, 0]$和$[0,\alpha]$中查找。为了避免这种情况，我们将整个曲线右移$\alpha$，如图 1（右）所示，之后第二个区间变为$[0, 2\alpha]$，从而允许我们执行单次查找。</p>
<h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><p>算法1详细说明了我们如何实现安全计算$y:= GELU(x)$：</p>
<p><img src="https://github.com/likun1208/image/blob/master/Cipher-2.png?raw=true" alt="GELU算法"></p>
<p>请注意，模型的初始输入已左移$L$位，这反过来又影响$x$的值，导致$x$也左移$L$位。为了保持所需的对齐，我们将$\alpha$放大$2L$倍（第 1 行）。那么，分割值就变成$\alpha’:=2^L\alpha$。</p>
<p>曲线右移还需要考虑比例因子。也就是说，我们不应该直接将曲线右移$\alpha$，而应该将其右移$\alpha’$。同样，为了确保正确对齐，GELU 的输入应调整为$x’:=x\alpha’$，这可以通过将$\alpha’$添加到$x$的任何份额来实现（第 2 行）。</p>
<p>处理小区间：令$\beta:=2\alpha’$，则第二个大区间可转换为$[0,\beta]$。假设$x’\in[0,\beta]$，我们只需要考虑$x’$的较低$h:=\log \beta$位。此，我们让S和C提取$\langle x’\rangle^l$的低$h$位并得到$\langle x’\rangle^h$（第5行），这可以在本地完成，无需任何通信。</p>
<p>假设$[0,\beta]$被分成$2s$个小区间，那么我们可以通过检查它的高$s$位来找到$\langle x’ \rangle^h$的区间。为此我们让S和C在$\langle x’\rangle^h$上运行截断后减小协议（第6行），由此可以得到$\langle i\rangle^s$，其中$i\in\mathbb{Z}_{2^n}$表示$x’$所属的小区间索引。</p>
<p>S持有表T，其中每个条目存储对应于各自小区间的线性函数的系数，获得$i\in\mathbb{Z}_{2^n}$后，S和C执行LUT从而通过$(\langle a_i\rangle^g,\langle d_i\rangle^l)$的秘密共享得到$T$的第$i$个条目（第7行）。然后在$\langle a_i\rangle^g$和$\langle x’\rangle^h$上运行非均匀位宽乘法（第8行），得到$\langle ax\rangle^l,l=g+h$。将$\langle d_i\rangle^l$和$\langle ax\rangle^l$相加可得$\langle z\rangle^l$，这很可能就是GELU(x)的结果。</p>
<p>处理大区间：上述处理小区间的过程仅在$x’\in[0,\beta]$时有效，事实上，当$x’\notin[0,\beta]$时，第5行的截断会导致$x’$信息丢失。因此，我们使用多路复用器来确保当$x’\notin[0,\beta]$时不会返回$\langle z\rangle^l$。</p>
<p>S和C首先安全比较$x’$和$beta$的大小并得到$b$（第10行），若$x’\geq\beta$则$b=1$，否则$b=0$。然后他们安全比较$x’$和0的大小并得到$b’$（第11行），若$x’\geq 0$则$b’=1$，否则$b’=0$。注意，$b, b’$的组合只有以下三种可能性：</p>
<ul>
<li>$b=1,b’=1$</li>
<li>$b=0,b’=1$</li>
<li>$b=0,b’=0$</li>
</ul>
<p>第二种情况$b\oplus b’=1$表示$x’\in[0,\beta]$，而另外两种情况$b\oplus b’=0$表示$x\notin[0,\beta]$。因此，我们可以用$b\oplus b’$作为控制信号来实现$z$的多路复用器。具体来说，S和C将$\langle z\rangle^l$和$\langle b\rangle^l\oplus \langle b’\rangle^l$输入到多路复用器，得到$\langle u\rangle^l$（第12行），如果$b\oplus b’=1$则$u=z$，否则$u=0$。</p>
<p>然后，S和C将$\langle x\rangle^l$和$\langle b\rangle^l$输入给另一个多路复用器得到$\langle v\rangle^l$（第13行），如果$b=1$则$v=x$，否则$v=0$。该多路复用器判断$x’\lt\beta$是否成立，如果成立则$v=x’$。$GELU(x)$最终结果是$\langle y\rangle^l:=\langle u\rangle^l+\langle v\rangle^l$。注意这里并不需要额外的多路复用器来处理$x’&lt;0$的情况，因为此时$y=0$。</p>
<p>SIRNN [36]、Iron [25] 和我们的安全 GELU 解决方案之间的加密操作数量。显然，我们的解决方案更加轻量级。此外，我们的解决方案在精度上也更好：SIRNN 和 Iron 中的多步过程分别涉及求幂和倒数近似，在每一步都会引入精度误差；这些误差在整个过程中不断累积，导致整体误差很大，而我们的单步方法不会出现这种情况。我们的实验结果验证了这个猜想。</p>
<h2 id="安全前K项选取"><a href="#安全前K项选取" class="headerlink" title="安全前K项选取"></a>安全前K项选取</h2><p>在 vec2word 层，GPT 模型生成一个包含所有可能单词概率的向量。需要从该向量中选出概率最大的前$K$个，并根据所选概率对最终响应词进行采样。本节将重点讨论从长度为$n$的向量中选出$K$个最大概率值的过程。</p>
<p><img src="https://github.com/likun1208/image/blob/master/Cipher-3.png?raw=true" alt="TopK算法"></p>
<p>算法 2 提供了我们的 TopK 协议的详细描述。在高层，输入元素首先被安全地打乱（第 1 行）；然后采用基于比较的选择来从打乱的列表中识别前 K 个元素（第 2 行）。</p>
<p>算法2中的选择函数以递归方式运行。在每次递归中，选择向量的最后一个元素作为主元（第 5 行）；向量被划分为两部分：小于主元的元素，表示为$S_L$，以及大于或等于主元的元素，表示为$S_R$（第 6-15 行）。为了分割向量，将其所有元素与主元进行比较（第 8 行）。可以在不损害原始元素隐私的情况下揭示比较结果（第 9 行）。这是因为原始元素已被打乱，因此比较结果与实际值无关。</p>
<p>如果$S_R$的大小（用$K’$表示）正好是$K$，则意味着$S_R$中的所有元素都是我们要选择的前$K$个最大元素（第19行）。如果$K’&gt;K$，则对$S_R$执行下一次递归以进一步缩小选择范围（第 21 行）。另一方面，如果$K’\lt K$，则执行下一次递归以从$S_L$中选择前 ($K-K’$) 个元素，然后将其与$S_R$组合以获得前$K$个元素的最终集合（第 21 行）。</p>
<p>值得一提的是，只有 CMP（第 8 行）需要 S 和 C 之间的交互；该算法的其余步骤可以由各方在本地执行，无需任何交互。选择函数需要$\mathcal{O}(n) CMP$。</p>
<h2 id="安全采样"><a href="#安全采样" class="headerlink" title="安全采样"></a>安全采样</h2><p>在本节中，我们将详细解释我们的安全采样协议。它以$K$个秘密共享概率$(p_1,…,p_K)$作为输入，其中每个概率通过乘以$2^L$并去掉小数部分而缩放为整数$x_i$。协议的输出是秘密共享索引$j$：</p>
<script type="math/tex; mode=display">
\operatorname{Pr}(j=i)=x_i / \sum_{k=1}^K x_k</script><p>我们将在第 7.5 节中解释如何将此索引映射到响应词。</p>
<p><img src="https://github.com/likun1208/image/blob/master/Cipher-4.png?raw=true" alt="Sampling算法"></p>
<p>算法3提供了安全采样协议的详细描述。其基于的观察是，对于随机$p’\in [0,1]$，所选索引$j$满足：</p>
<script type="math/tex; mode=display">
\sum_{k=1}^{j-1} p_k \leq p^{\prime}<\sum_{k=1}^j p_k .</script><p>由于$(p_1,…,p_K)$已经按$2^L$缩放，$p’$应该也跟着缩放。为此，我们让C在$[0,2^L-1]$采样一个整数$v$（第1行），S和C安全比较$v$和每个$\sum_{k=1}^ix_k,\forall i\in[1,K]$（第2-6行），由此得到一个秘密共享的位向量$\langle\mathbf{b}\rangle$，满足：</p>
<script type="math/tex; mode=display">
b_i=1 \forall 1 \leq i<j \text { and } b_i=0 \forall j \leq i \leq K \text {. }</script><p>我们的下一步是构建另一个秘密共享位向量$\langle\mathbf{b}’\rangle$，它满足：</p>
<script type="math/tex; mode=display">
b_i^{\prime}=0 \forall i \neq j \text { and } b_j^{\prime}=1</script><p>这一步可以通过在$\langle\mathbf{b}\rangle$的每一对相邻位上执行异或操作来实现（第7-10行）。那么，所需的索引为：$\langle j \rangle:=\sum_{i=1}^K F_{MUX}(i,\langle b’_i\rangle)$（第11行）。</p>
<p>我们注意到$v$由$C$单独采样是可以接受的，因为最终输出 j 对 C 来说仍然未知。</p>
<h2 id="CipherGPT框架"><a href="#CipherGPT框架" class="headerlink" title="CipherGPT框架"></a>CipherGPT框架</h2><p>CiperGPT架构和流程：它需要一个单词序列，将它们编码成单词嵌入，然后将它们传递给转换器解码器的多次迭代2。每次迭代都涉及一个自注意力层和一个前馈神经网络。 Transformer 解码器的输出被馈送到 vec2word 层，该层生成预测的响应词。<br><img src="https://github.com/likun1208/image/blob/master/Cipher-5.png?raw=true" alt="框架图"></p>
<h3 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h3><p>它首先将每个输入单词映射到长度为 m 的数值向量，称为单词嵌入，这是通过在嵌入矩阵中定位相应行来实现的。接下来，每个单词嵌入都会增加一个位置嵌入，该位置嵌入由单词在输入序列中的位置确定。位置嵌入是预定义的，并按元素添加到词嵌入中。我们使用加法同态加密（AHE）来完成词嵌入和位置嵌入：</p>
<ol>
<li>S使用AHE来加密嵌入矩阵的每一行，并将所有得到的密文传输到 C。实际上，我们通过将整行表示为RLWE密文的多项式系数来加密整行。请注意，词嵌入是浮点数；S 通过将它们左移 L 位并删除小数部分来将它们缩放为整数。</li>
<li>C根据输入的单词定位对应的密文，为每个密文添加一个随机数$r_i:E(w_1+r_1),····,E(w_n+r_n);$并将它们返回给S。</li>
<li>S解密密文得到$w_1+r_1,…,w_n+r_n;$添加位置嵌入$w_1+r_1+p_1,…,w_n+r_n+p_n$。</li>
<li>由此，每个嵌入都是秘密共享的，$\langle x_i\rangle_C=-r_i,\langle x_i\rangle_S=w_i+r_i+p_i$。</li>
</ol>
<p>我们注意到，步骤 1 只需执行一次，并且可以无限期地使用，除非嵌入矩阵发生变化。</p>
<h3 id="层归一"><a href="#层归一" class="headerlink" title="层归一"></a>层归一</h3><p>嵌入编码后，$n$个输入词称为一个秘密共享矩阵$\langle \mathbf{X}\rangle, \mathbf{X}\in\mathbb{Z}_{2^l}^{n\times m}$。然后需要对每行$\mathbf{x}\in\mathbb{Z}_{2^l}^{n\times m}$执行层归一化操作。具体来说$\mathbf{x}$中的每个元素$x_i$如下归一：</p>
<script type="math/tex; mode=display">
x_i:=\frac{x_i-\mathrm{E}[\mathbf{x}]}{\sqrt{\operatorname{Var}[\mathrm{x}]+c}} \cdot \gamma+\beta</script><p>其中$E[\mathbf{x}]=\frac{1}{n}\sum x_i, Var[\mathbf{x}]=\frac{1}{n-1}\sum(x_i-E[\mathbf{x}])^2$，$\gamma,\beta$是学习参数，$\epsilon$是避免除数为0的小值。为了安全计算层归一化，我们让S和C运行如下：</p>
<ol>
<li>运行$F_{Mult}$计算每个$var_i:=(x_i-E[\mathbf{x}])^2$</li>
<li>运行$F_{LUT}$计算$\frac{1}{\sqrt{Var[\mathbf{x}]+\epsilon}}$</li>
<li>运行$F_{Mult}$计算$\frac{x_i-E[\mathbf{x}]}{\sqrt{Var[\mathbf{x}]+\epsilon}}$</li>
<li>运行$F_{Mult}$计算$\frac{x_i-E[\mathbf{x}]}{\sqrt{Var[\mathbf{x}]+\epsilon}}\cdot\gamma$</li>
<li>运行$F_{TR}$将比例减小到L位并将宽度截断为$l$位</li>
</ol>
<p>原则上，S和C需要使用“均匀位宽乘法”来乘以两个秘密共享值，然后运行安全截断（对于每个乘法）以将规模保持在L位。然而，为了减少精度损失，我们让S和C使用“非均匀位宽乘法”（$F_{Mult}$）进行乘法，并且在LayerNorm计算后仅运行一次“truncatethen-reduce”（$F_{TR}$）。</p>
<h3 id="掩码自注意力"><a href="#掩码自注意力" class="headerlink" title="掩码自注意力"></a>掩码自注意力</h3><p>自注意力是一种通过关联序列中不同位置来计算序列表示的机制。计算自注意力的第一步是创建三个矩阵：查询矩阵Q、键矩阵K和值矩阵V，通过将归一化嵌入$X\in\mathbb{Z}_{2^l}^{n\times m}$与三个训练过程中获取的矩阵（$W_Q\in\mathbb{Z}_{2^l}^{m\times m}, W_K\in\mathbb{Z}_{2^l}^{m\times m}, W_V\in\mathbb{Z}_{2^l}^{m\times m}$）相乘而得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \langle\mathbf{Q}\rangle:=\langle\mathbf{X}\rangle\left\langle\mathbf{W}_Q\right\rangle \\
& \langle\mathbf{K}\rangle:=\langle\mathbf{X}\rangle\left\langle\mathbf{W}_K\right\rangle \\
& \langle\mathbf{V}\rangle:=\langle\mathbf{X}\rangle\left\langle\mathbf{W}_V\right\rangle
\end{aligned}</script><p>由于$W_Q,W_K,W_V$事先已知，因此可以通过第 3 节中描述的基于 sVOLE 的解决方案来计算此类 MatrixMul。在 MatrixMul 之后，S 和 C 需要运行$F_Trunc$以确保缩放保持在 L 位。为了简单起见，我们在本节的其余部分中省略了提及的截断。</p>
<p>多头注意力：每个$\langle Q\rangle,\langle K\rangle,\langle V\rangle$都会随后被划分为M段，称为多头注意力，其中M表示注意力头的数量。令$m’=\frac{m}{M}$，可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&
\left\langle\mathbf{q}_1\right\rangle\|\cdots\|\left\langle\mathbf{q}_M\right\rangle=\langle\mathbf{Q}\rangle \text {, with each } \mathbf{q}_i \in \mathbb{Z}_{2^l}^{n \times m^{\prime}} \\
& \left\langle\mathbf{k}_1\right\rangle\|\cdots\|\left\langle\mathbf{k}_M\right\rangle=\langle\mathbf{K}\rangle, \text { with each } \mathbf{k}_i \in \mathbb{Z}_{2^l}^{n \times m^{\prime}} \\
& \left\langle\mathbf{v}_1\right\rangle\|\cdots\|\left\langle\mathbf{v}_M\right\rangle=\langle\mathbf{V}\rangle, \text { with each } \mathbf{v}_i \in \mathbb{Z}_{2^l}^{n \times m^{\prime}}
\end{aligned}</script><p>通过查询矩阵和关键矩阵的乘积来计算得分矩阵：</p>
<script type="math/tex; mode=display">
\left\langle\mathbf{s}_i\right\rangle:=\left\langle\mathbf{q}_i\right\rangle\left\langle\mathbf{k}_i^T\right\rangle \forall i \in[M]</script><p>$s_i\in\mathbb{Z}_{2^l}^{n\times n}$中的每个分数决定了在对当前单词进行编码时对其他单词的关注程度。在这种情况下，如果事先不知道 qi 和 ki，则无法应用我们基于 sVOLE 的 MatrixMul。相反，我们采用[25]中提出的基于 AHE 的 MatrixMul。</p>
<p>自注意力掩码。在多头注意力之后，应用自注意力掩码来将每个$s_i$的上三角形清零。因此，左边的每个单词的注意力分数都比右边的单词高得多，因此模型在实践中只关注前面的单词。此步骤可以由 S 和 C 在本地完成，无需任何交互。</p>
<p>Softmax。将softmax运算逐行应用于每个$\langle s_i\rangle$，确保分数在该行内标准化，所有值均为正数且总和为1。为了安全计算softmax，我们优化了[25]中的方法，如下：</p>
<ol>
<li>给定一行$\mathbf{x}\in\mathbb{Z}_{2^l}^n$作为输入，我们首先标准化每个$x_i:x’_i=x_i-max(\mathbf{x})$，然后得到一个负值向量。</li>
<li>我们通过仅考虑区间$[−16, 0]$来优化负值的指数协议。即，我们使用 $F_{CMP}$ 将$x’_i$与$−16\times 2^l$进行比较，如果$x’_i\lt -16\times 2^l$，使用$F_{MUX}$将$e^{x’_i}$的结果设置为 0。</li>
</ol>
<p>原始指数协议运行具有$2^l$个条目的$F_{LUT}$，而我们只需要具有$2^{L+4}$个条目的$F_{LUT}$。</p>
<p>输出。在 self-attention 的最后一步中，softmaxed分数用于对值矩阵中的值进行加权：</p>
<script type="math/tex; mode=display">
\left\langle\mathbf{z}_i\right\rangle:=\left\langle\mathbf{s}_i\right\rangle\left\langle\mathbf{v}_i\right\rangle \quad \forall i \in[M]</script><p>这再次由基于 AHE 的 MatrixMul 完成[25]。然后，所有z被重新组合在一起：</p>
<script type="math/tex; mode=display">
\langle\mathbf{Z}\rangle:=\left\langle\mathbf{z}_1\right\rangle\|\cdots\|\left\langle\mathbf{z}_n\right\rangle .</script><p>自注意力的输出是：</p>
<script type="math/tex; mode=display">
\langle\mathbf{X}\rangle:=\langle\mathbf{X}\rangle+\langle\mathbf{Z}\rangle .</script><h3 id="前馈"><a href="#前馈" class="headerlink" title="前馈"></a>前馈</h3><p>自注意力的输出经过LayerNorm操作。然后将所得归一化值输入前馈神经网络，该网络由两个全连接 (FC) 层和一个激活层组成。</p>
<p>第一个FC层计算如下：</p>
<script type="math/tex; mode=display">
\left\langle\mathbf{X}_1\right\rangle:=\langle\mathbf{X}\rangle\left\langle\mathbf{W}_1\right\rangle+\mathbf{B}_1</script><p>其中$\mathbf{X} \in \mathbb{Z}_{2^l}^{n \times m}, \mathbf{W}_1 \in \mathbb{Z}_{2^l}^{m \times k}, \mathbf{B}_1 \in \mathbb{Z}_{2^l}^{n \times k}, \mathbf{X}_1 \in \mathbb{Z}_{2^l}^{n \times k}$。然后对$\mathbf{X}_1$的每个元素应用GELU算法得到$\mathbf{X}’_1$。第二个FC层计算如下：</p>
<script type="math/tex; mode=display">
\left\langle\mathbf{X}_2\right\rangle:=\left\langle\mathbf{X}_1^{\prime}\right\rangle\left\langle\mathbf{W}_2\right\rangle+\mathbf{B}_2,</script><p>其中$\mathbf{X}’_1 \in \mathbb{Z}_{2^l}^{n \times k}, \mathbf{W}_2 \in \mathbb{Z}_{2^l}^{k \times m}, \mathbf{B}_2 \in \mathbb{Z}_{2^l}^{n \times m}, \mathbf{X}_1 \in \mathbb{Z}_{2^l}^{n \times m}$。请注意，$W_1$和$W_2$是预先已知的，因此我们基于 sVOLE 的 MatrixMul（参见第 3 节）可以应用于两个 FC 层。</p>
<p>输出将再次经历自注意力和前馈的多次迭代，每次迭代采用不同的权重，同时保留相同的结构。</p>
<h3 id="向量转词"><a href="#向量转词" class="headerlink" title="向量转词"></a>向量转词</h3><p>经过多次自我关注和前馈迭代后，所得输出将通过 vec2word 层以生成预测的响应词。 vec2word 中的初始操作涉及 MatrixMul 来为所有可能的单词生成 one-hot 编码：</p>
<script type="math/tex; mode=display">
\langle\mathbf{y}_0\rangle:=\langle\mathbf{x}\rangle\langle\mathbf{W}\rangle</script><p>其中$\mathbf{W}\in\mathbb{Z}_{2^l}^{m\times k},\mathbf{y}_0\in\mathbb{Z}_{2^l}^{k},\mathbf{x}\in\mathbb{Z}_{2^l}^{m}$是$\mathbf{X}\in\mathbb{Z}_{2^l}^{n\times m}$的最后一行（由于 GPT 采用的推理时间优化）。这次，k代表所有可能的单词的数量，它是相当大的。我们基于 sVOLE 的 MatrixMul 不适合这里，因此我们采用基于 AHE 的 MatrixMul [25]。</p>
<p>TopK。为了保持多样性和准确性之间的平衡，从$y_0$中选择K个最大值：</p>
<script type="math/tex; mode=display">
\langle \mathbf{y}_1\rangle\leftarrow\Pi_{TopK}(\langle\mathbf{y}_0\rangle),\mathbf{y}_1\in\mathbb{Z}_{2^l}^K</script><p>这部分由第五章提出的协议来完成。</p>
<p>温度。温度T决定了GPT生成文本的创造性和多样性：较高的温度（例如，$T=1.5$）会产生更加多样化和创造性的文本，而较低的温度（例如，$T=0.5$）会产生更加集中和确定性的文本。它是由 S 持有的超参数，并与$y_1$中的每个值相乘。这可以通过 AHE 轻松实现：</p>
<ol>
<li>C给S发送其AHE加密后的共享$E(\langle y_{1,1}\rangle_C),…,E(\langle y_{1,K}\rangle_C)$。实际上，我们通过将它们表示为RLWE密文的多项式系数来进行整体加密。</li>
<li>S将其份额添加到密文中：$E(\langle y_{1,1}\rangle_C+\langle y_{1,1}\rangle_S),…,E(\langle y_{1,K}\rangle_C+\langle y_{1,K}\rangle_S)$</li>
<li>S对所有密文乘T：$E(T\cdot y_{1,1}),…,E(T\cdot y_{1,K})$</li>
<li>S给所有密文加上随机数：$E(T\cdot y_{1,1}+r_1),…,E(T\cdot y_{1,K}+r_K)$</li>
<li>S将生成的密文返回C</li>
<li>S 解密密文，现在用 y2 表示的温度值是秘密共享的：<script type="math/tex; mode=display">
\langle y_{2,i}\rangle_C:=T\cdot y_{1,i}+r_i,\langle y_{2,i}\rangle_S:-r_i,\forall i\in[K].</script></li>
</ol>
<p>随机采样。对$y_2$进行softmax运算，得到$y_3$表示的概率向量，然后根据该概率向量对响应词进行随机采样。这种随机采样确保生成的输出既多样化又与上下文相关。</p>
<p>我们采用第 6 节中描述的安全采样协议来获取索引：$\langle j \rangle\leftarrow\Pi_{Sample}(y_3)$</p>
<p>考虑到词向量是公开的，如果C学习了索引，它就可以从词向量中检索出最终的响应词。然而，天真地将 j 透露给 C 有两个问题：</p>
<ul>
<li>在算法3（第1 行）中，值v 由C 采样。因此，如果 C 学习了 j，它可能会获得有关输入 x 的一些信息。 </li>
<li>索引j 不是正确的索引，因为概率向量已在算法2（第1 行）中被打乱。</li>
</ul>
<p>回想一下，算法 2 中的洗牌过程大致如下：</p>
<ol>
<li>C生成随机排列$\pi_C$；S和C共同将$\pi_C$应用于输入向量，获得相应的秘密份额。</li>
<li>S生成随机排列$pi_S$； S和C共同将$pi_S$应用于$pi_C$的输出，获得相应的秘密份额。</li>
</ol>
<p>一个关键的观察结果是算法3第11行的<code>i</code>是公开的。为此，我们让S计算$i’:=\pi_{S}^{-1}(i)$并秘密共享$i’$。然后我们将算法3的第11行替换为：</p>
<script type="math/tex; mode=display">
\langle j\rangle:=\sum_{i=1}^K F_{MUX}(\langle i'\rangle,\langle b'_i\rangle^l)</script><p>由此，向C透漏j不会透露有关输入的任何信息，因为C不知道$\pi_{S}^{-1}(i)$。获得j后，C计算$j’:=\pi_C^{-1}(j)$，这是词向量中的正确索引。</p>
<h2 id="实验评估"><a href="#实验评估" class="headerlink" title="实验评估"></a>实验评估</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>LLM</tag>
        <tag>Privacy</tag>
        <tag>Security</tag>
        <tag>MPC</tag>
      </tags>
  </entry>
  <entry>
    <title>LLM+隐私保护总结</title>
    <url>/2023/12/06/LLM+%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="LLM-隐私保护总结"><a href="#LLM-隐私保护总结" class="headerlink" title="LLM+隐私保护总结"></a>LLM+隐私保护总结</h1>]]></content>
      <categories>
        <category>slides</category>
      </categories>
      <tags>
        <tag>LLM</tag>
        <tag>Privacy</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Cryptography课程记录-Week 1: Course overview and stream ciphers</title>
    <url>/2023/12/04/Cryptography%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-Week%201_Course%20overview%20and%20stream%20ciphers/</url>
    <content><![CDATA[<h1 id="Section-1-what-is-cryptography-about"><a href="#Section-1-what-is-cryptography-about" class="headerlink" title="Section 1: what is cryptography about?"></a>Section 1: what is cryptography about?</h1><h2 id="Course-Overview"><a href="#Course-Overview" class="headerlink" title="Course Overview"></a>Course Overview</h2><p>课程目标：</p>
<ul>
<li>密码学原理</li>
<li>如何正确使用密码学原语和安全性证明</li>
</ul>
<p>密码学的应用案例：</p>
<ul>
<li>安全通信：Alice和Bob试图使用HTTPS通信，起到安全作用的是SSL，也称为TLS，确保网络中传输的数据既不会被窃听也不会被篡改。<ul>
<li>网络通信：HTTPS</li>
<li>无线通信：802.11i WPA2, GSM, Bluetooth</li>
<li>SSL(Secure Sockets Layer)/TLS由两部分组成：<ol>
<li>握手协议：构造共享密钥，采用公钥技术</li>
<li>记录层：如何使用密钥传输数据</li>
</ol>
</li>
</ul>
</li>
<li>磁盘加密文件：EFS, TrueCrypt<ul>
<li>对磁盘上的文件加密，保证既不会被窃取也不会被篡改【保密性和完整性】</li>
</ul>
</li>
<li>内容保护（例如DVD, Blu-ray）：CSS, AACS</li>
<li>用户认证 等等</li>
</ul>
<p>安全通信的基石：对称加密系统（sym.encryption）</p>
<ul>
<li>Alice和Bob使用共享密钥<code>k</code>通信，攻击者不知道<code>k</code></li>
<li>使用公开的加密算法<code>E</code>和解密算法<code>D</code>，<code>E</code>的输入是明文消息<code>m</code>和密钥<code>k</code>，输出密文消息<code>c</code>；<code>D</code>的输入是密文消息<code>c</code>和密钥<code>k</code>，输出明文消息<code>m</code>。</li>
</ul>
<p>对称加密系统的两种情况：</p>
<ul>
<li>一次性密钥：只用来加密单条消息，例如加密邮件的时候，每个邮件都生成一个新密钥</li>
<li>重复使用密钥：用来加密多条消息，例如加密文件的时候，一个密钥用于若干个文件，需要一些额外工作确保这样的加密系统是安全的</li>
</ul>
<p>密码学的局限性：</p>
<ul>
<li>并不能完全保证安全，对软件漏洞和社工无效</li>
<li>需要正确使用，一个例子是加密WiFi通信的WEP</li>
<li>使用密码学原语，而非创造</li>
</ul>
<h2 id="What-is-Cryptography"><a href="#What-is-Cryptography" class="headerlink" title="What is Cryptography?"></a>What is Cryptography?</h2><p>密码学核心：安全通信</p>
<ul>
<li>安全密钥构造</li>
<li>安全通信</li>
</ul>
<p>密码学的其他应用：</p>
<ul>
<li>数字签名</li>
<li>匿名通信</li>
<li>匿名数字货币<ul>
<li>支付数字货币而保持匿名</li>
<li>实现该功能的同时避免双花</li>
</ul>
</li>
<li>结合抽象协议<ul>
<li>选举：既知道被选中的是谁，又不知道每个人投了谁——引入选举中心计票</li>
<li>私有拍卖：采用Victory拍卖（价高者得，二价支付），需要公开出价最高的身份和出价第二高的价格，其余信息保密——引入拍卖中心统计</li>
<li>安全多方计算：输出函数计算的值，而对函数输入信息保密，例如前两个涉及的选票计算和拍卖计算——在密码学中可信第三方是不可靠的，系统也不应当引入这样的第三方，而是通过一些协议完成计算。</li>
</ul>
</li>
<li>其他不太相关的应用<ul>
<li>私有外包计算：Alice将一串关键词加密后发送给Google，Google无需知道原文即可根据加密关键词检索到加密结果并返回给Alice，Alice自行解密得到查询结果。</li>
<li>零知识证明：Alice知道一个大数字N，也知道该数字可由两个素数P和Q相乘得到；Bob也知道N，但不知道P和Q，Alice可通过某方法向Bob证明自己确实知道P和Q，而无需让Bob也知道P和Q。</li>
</ul>
</li>
</ul>
<p>密码学的三个步骤：</p>
<ul>
<li>精确说明威胁模型，例如数字签名中的威胁模型是：攻击者如何对数字签名发起攻击，攻击者发动攻击的动机</li>
<li>提出构造方案</li>
<li>证明在特定威胁模型条件下，任何攻击者对该构造发起攻击都相当于求解一个很复杂的难题。</li>
</ul>
<h2 id="History-of-Cryptography"><a href="#History-of-Cryptography" class="headerlink" title="History of Cryptography"></a>History of Cryptography</h2><p>Alice和Bob试图安全对话，攻击者试图窃听，为确保安全，A和B使用加密器<code>(E,D)</code>，前者是加密算法，后者是解密算法。</p>
<p>对称加密：加密和解密使用相同的密钥：</p>
<ul>
<li>$c=E(k,m)$表示用算法$E$和密钥$k$对消息$m$加密得到密文$c$</li>
<li>$m:=D(k,c)$表示用算法$D$和密钥$k$对密文$c$解密得到消息$m$</li>
</ul>
<p>一些已破解的对称加密：</p>
<ul>
<li>替换加密：不同字母之间替换    </li>
<li>凯撒密码是类似的方式。破解方式：字母频率、字母组合频率</li>
<li>Vigener密码：密钥复制到明文的长度，明文的每一位和密钥的每一位相加再模26，破解方式也是频率</li>
<li>转轮机（Rotor machine）</li>
<li>数据加密标准DES</li>
</ul>
<p>一些仍有效的密码：AES、Salsa20 等</p>
<h2 id="Section-2-crash-course-in-discrete-probability"><a href="#Section-2-crash-course-in-discrete-probability" class="headerlink" title="Section 2: crash course in discrete probability"></a>Section 2: crash course in discrete probability</h2><h3 id="Discrete-Probability"><a href="#Discrete-Probability" class="headerlink" title="Discrete Probability"></a>Discrete Probability</h3><p>定义：$U$：有限集，通常是$n$位二进制字符串集，用$\lbrace0,1\rbrace^n$表示，例如$\lbrace0,1\rbrace^2=\lbrace 00,01,10,11 \rbrace$</p>
<p>定义：全集$U$上的概率分布是函数$P:U\rightarrow[0,1]$，该函数为全集中的每个元素分配一个0到1之间的数，该数称为该元素在全集中的权重或概率，$\sum_{x\in U}P(X)=1$</p>
<p>分布的例子：</p>
<ul>
<li>均匀分布：各元素概率相等，即对于所有$x\in U$，$P(X)=1/|U|$</li>
<li>在$x_0$的点分布：取值为$x_0$时概率为1，其他时候概率为0</li>
</ul>
<p>所有元素的概率分布都列出来可组成一个分布向量</p>
<p>定义：考虑全集的一个子集$A$，$Pr[A]=\sum_{x\in A}P(X)\in[0,1]$，子集A被称为<strong>事件</strong>。注意：$Pr[U]=1$</p>
<p>例：$U=\lbrace0,1\rbrace^8, A=\lbrace all\ x\ in\ U such\ that\ lsb_2(x)=11\rbrace\subseteq U$，$lsb_2$是最低两位的意思，这里A是最低两位是11的8位二进制数，若$U$是均匀分布，则$Pr[A]=0.25$</p>
<p>定义：联合边界：对于事件$A_1$和$A_2$，$Pr[A_1\cup A_2]\leq Pr[A_1]+Pr[A_2]$，当且仅当$A_1\cap A_2=\emptyset$时取等号。</p>
<p>例：$A_1=\lbrace all\ x\ in\ \lbrace 0,1\rbrace^n \ s.t.\ lsb_2(x)=11\rbrace, A_1=\lbrace all\ x\ in\ \lbrace 0,1\rbrace^n \ s.t.\ msb_2(x)=11\rbrace$</p>
<p>$Pr[lsb_2(x)=11\ or\ msb_2(x)=11]=Pr[A_1\cap A_2]\leq\frac{1}{4}+\frac{1}{4}=\frac{1}{2}$</p>
<p>定义：随机变量：一个随机变量$X$是一个从全集映射到某个集合V的函数$X:U\rightarrow V$，集合V被称为随机变量的值域。</p>
<p>例：$X:\lbrace0,1\rbrace^n\rightarrow\lbrace0,1\rbrace$; $X(y)=lsb(y)\in\lbrace0,1\rbrace$，对于该映射，当U是均匀分布时，可知$Pr[X=0]=Pr[X=1]=\frac{1}{2}$</p>
<p>更一般地，一个随机变量X从集合V中取值，则该随机变量实际上生成了集合V的概率分布：$Pr[X=v]:=Pr[X^{-1}(v)]$，含义：随机变量输出v的概率等同于从全集中随机抽取一个元素，对其施加函数X，然后判断其输出v的概率。换言之，我们X输出v的概率，就等于从全集中抽一个元素，正好落在v在函数X下的原像中。</p>
<p>定义：均匀随机变量：假定U是某有限集，例$\lbrace 0,1 \rbrace^n$，则用$r\stackrel{R}\leftarrow U$表示U上的均匀随机变量，对于所有$a\in U: Pr[r=a]=1/|U|$。这里$\stackrel{R}\leftarrow$表示均匀抽样。正式来说，$r$是恒等函数，对于所有$x\in U$而言，$r(x)=x$。</p>
<ul>
<li>确定性算法：给定输入，总产生固定的输出：$y\leftarrow A(m)$</li>
<li>随机化算法：输入的除了给定的m，还有一个隐形参数r，每次执行算法时会重新抽取，因此每次输出会改变，$y\leftarrow A(m;r)\ where\ r\stackrel{R}\leftarrow \lbrace 0,1 \rbrace^n$，即$y\stackrel{R}\leftarrow A(m)$</li>
</ul>
<p>例：用随机字符串k来加密输入的消息m，$A(m;k)=F(k,m), y\stackrel{R}\leftarrow A(m)$</p>
<p>定义：独立性：当$Pr[A\ and\ B]=Pr[A]\cdot Pr[B]$时，事件A和B独立。当$\forall a,b\in V:Pr[X=a\ and\ Y=b]=Pr[X=a]\cdot Pr[Y=b]$时，从集合V中取值的随机变量X和Y独立。</p>
<p>例：$U=\lbrace 0,1\rbrace^2=\lbrace 00,01,10,11 \rbrace$且$r\stackrel{R}\leftarrow U$，定义随机变量X和Y为$X=lsb(r),Y=msb(r)$，则$Pr[X=0\ and\ Y=0]=Pr[r=00]=\frac{1}{4}=Pr[X=0]\cdot Pr[Y=0]$</p>
<p>定义：异或XOR：两个$\lbrace 0,1\rbrace^n$上的字符串执行异或操作是指按位加并模2，例如$0110111\oplus 1011010=1101101$。</p>
<p>定理：异或的属性：Y是$\lbrace 0,1\rbrace^n$上的随机变量，X是$\lbrace 0,1\rbrace^n$上的独立均匀分布变量，则$Z:=Y\oplus X$是$\lbrace 0,1\rbrace^n$上的均匀变量。</p>
<p>证明（$n=1$）：$Pr[Y=0]=P_0,Pr[Y=1]=P_1, Pr[X=0]=Pr[X=1]=0.5$，联合分布如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Y</th>
<th>X</th>
<th>Pr</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>$0.5P_0$</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>$0.5P_0$</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>$0.5P_1$</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>$0.5P_1$</td>
</tr>
</tbody>
</table>
</div>
<p>$Pr[Z=0]=Pr[(0,0)or(1,1)]=0.5P_0+0.5P_1=0.5$，类似地，$Pr[Z=1]=0.5$。</p>
<p>生日悖论：令$r_1,…,r_n\in U$表示独立同分布的随机变量，则当$n=1.2\times |U|^{\frac{1}{2}}$时$Pr[\exists i\neq j:r_i=r_j]\geq \frac{1}{2}$。</p>
<p>例：$U=\lbrace 0,1 \rbrace^{128}$，采样约$2^{64}$随机消息，则其中两个消息很有可能相同。</p>
<p>现实一些的例子：多少人聚在一起会有至少两个人的生日相同？一年365天，因此是$1.2\sqrt{365}\approx 23$</p>
<h2 id="Stream-Ciphers-1-the-one-time-pad-and-stream-ciphers"><a href="#Stream-Ciphers-1-the-one-time-pad-and-stream-ciphers" class="headerlink" title="Stream Ciphers 1: the one-time pad and stream ciphers"></a>Stream Ciphers 1: the one-time pad and stream ciphers</h2><h3 id="Information-Theoretic-Security-and-The-One-Time-Pad"><a href="#Information-Theoretic-Security-and-The-One-Time-Pad" class="headerlink" title="Information Theoretic Security and The One Time Pad"></a>Information Theoretic Security and The One Time Pad</h3><h3 id="Stream-Ciphers-and-Pseudo-Random-Generators"><a href="#Stream-Ciphers-and-Pseudo-Random-Generators" class="headerlink" title="Stream Ciphers and Pseudo Random Generators"></a>Stream Ciphers and Pseudo Random Generators</h3>]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Privacy-Preserving Prompt Tuning for Large Language Model Services</title>
    <url>/2023/11/24/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Privacy-Preserving%20Prompt%20Tuning%20for%20Large%20Language%20Model%20Services/</url>
    <content><![CDATA[<h1 id="Privacy-Preserving-Prompt-Tuning-for-Large-Language-Model-Services"><a href="#Privacy-Preserving-Prompt-Tuning-for-Large-Language-Model-Services" class="headerlink" title="Privacy-Preserving Prompt Tuning for Large Language Model Services"></a>Privacy-Preserving Prompt Tuning for Large Language Model Services</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol>
<li>LLM的Prompt会泄露隐私</li>
<li>现有方法基本分为两类：<ol>
<li>中心化隐私保护：找个服务商解决问题，但是服务商也可能会泄露</li>
<li>本地隐私保护：本地处理文本使其尽可能不泄露信息，但是会降低模型效果</li>
</ol>
</li>
<li>本文：<ol>
<li>基于即时调优，我们提出了隐私保护即时调优（RAPT），这是一个为LLM服务提供隐私保证的框架。 </li>
<li>RAPT采用本地隐私设置，允许用户通过本地差分隐私在本地对其数据进行私有化。</li>
<li>由于直接在私有化数据上训练时提示调整表现不佳，因此我们引入了一种新颖的私有化token重建任务，该任务与下游任务联合训练，使LLM能够学习更好的依赖于任务的表示。</li>
</ol>
</li>
</ol>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>首先引入文本到文本私有化，它用于用户在本地私有化他们的数据。</p>
<p>然后，我们描述如何使用我们的提示方法定制和利用带有私有化数据的LLM服务。</p>
<h3 id="Text-to-Text-Privatization"><a href="#Text-to-Text-Privatization" class="headerlink" title="Text-to-Text Privatization"></a>Text-to-Text Privatization</h3><ol>
<li>本地加密可以避免窃听攻击等。</li>
<li>大多数LLM采用文本到文本的推断，因此本文采用文本到文本的隐私保护。</li>
<li>文本到文本的隐私保护基于$d_{\mathcal{X}}$隐私，是局部差分隐私的基于距离的松弛形式，广泛用于保护文本内容的隐私。</li>
<li>对于给定输入集$\mathcal{X}$和输出集$\mathcal{Y}$，$d_{\mathcal{X}}$是一个定义在$\mathcal{X}$上的距离函数。</li>
<li><p>随机机制$M:\mathcal{X}\rightarrow\mathcal{Y}$满足$d_{\mathcal{X}}$隐私，当且仅当，对于任意$x\in\mathcal{X}$且$x’\in\mathcal{X}$，输出$M(x)$和$M(x’)$的分布受限于：</p>
<script type="math/tex; mode=display">
\frac{P(M(x)=y)}{P\left(M\left(x^{\prime}\right)=y\right)} \leq e^{\eta d_{\mathcal{X}}\left(x, x^{\prime}\right)}, \quad \forall \boldsymbol{y} \in \mathcal{Y}\tag{1}</script><p>其中，$\eta\geq 0$是隐私参数，控制了隐私保护程度。</p>
</li>
<li><p>为了应用文本到文本的隐私化，需要一个嵌入模型把单词映射到向量。给定序列$x=[x_1,…,x_n]$和嵌入模型$E\in \mathbb{R}^{|V|d}$，其中$|V|$和$d$是词汇大小和嵌入维度。嵌入模型将$x$映射到向量$[x_1,…,x_n]$的序列。</p>
</li>
<li>假设使用$L_2$距离作为距离函数，将隐私参数为$\eta$的$d_{\mathcal{X}}$应用于一个词嵌入$x_t\in\mathbb{R}^d$可以通过给$x_t$添加随机噪声$z\sim exp(-\eta |z|)$来实现。令$z=lv$，采样$z$就等价于先采样标量$l\sim \Gamma(d,\frac{1}{\eta})$再从单位球空间$\mathbb{B}^d$中均匀地采样向量$v$。因此，$x_t$的隐私化表达$M(x_t)$可以形式化地表达为<script type="math/tex; mode=display">
M(x_t)=x_t+z\tag{2}</script></li>
<li>接下来我们将$x_t$替换为嵌入空间中最接近$x_t$的单词$x’_t$：<script type="math/tex; mode=display">
x'_t=argmin_k\|w_k-M(w_t)\|\tag{3}</script>通过重复替换序列$x$中的单词，我们获得$x$的隐私化文本$M(x)$。</li>
</ol>
<h3 id="LLM-Customization"><a href="#LLM-Customization" class="headerlink" title="LLM Customization"></a>LLM Customization</h3><p>整体场景：假设用户通过及时调整API来定制LLM服务，将其私有化培训数据上传给服务提供商。</p>
<h4 id="Prompt-Tuning"><a href="#Prompt-Tuning" class="headerlink" title="Prompt Tuning"></a>Prompt Tuning</h4><p>$f$表示LLM模型的主干网络。一个长度为N的提示词$P\in\mathbb{R}^{N\times h}$是连续向量$[p_1,…,p_N]$中的序列，其中$p_i\in\mathbb{R}^h$是可调整的虚拟token嵌入，$h$是主干网络的隐藏层维度。给定输入序列$\mathrm{x}=[x_i,…,x_n]$，提示词被添加到$X\in\mathbb{R}^{n\times h}$之前，其中$X=[x_1,…,x_n]$是词嵌入的序列，$x\in\mathbb{R}^h$。由此可以通过使用LLM得到激活序列：</p>
<script type="math/tex; mode=display">
H=f([\![P;X]\!])\tag{4}</script><p>其中$[![P;X]!]$表示两个序列P和X的串联，$H\in\mathbb{R}^{n\times h}$是激活序列。H用于预测任务依赖的标签，通常通过语言模型的head。</p>
<h4 id="Privatized-Token-Reconstruction"><a href="#Privatized-Token-Reconstruction" class="headerlink" title="Privatized Token Reconstruction"></a>Privatized Token Reconstruction</h4><ol>
<li>直接在隐私化的数据上进行提示词调优会显著降低LLM在下游任务上的性能，说明提示词调优对这种文本到文本的隐私化带来的随机扰动很敏感。</li>
<li>一些研究发现掩码语言模型目标有助于学习可分离的深度表示。</li>
<li>受此启发本文提出了隐私化token重建任务，与下游任务联合训练，提高LLM在隐私保护的下游任务上的性能。</li>
<li>token重建类似于掩码语言模型，为了保护隐私不能直接重建单词，但是可以在训练数据中的每个输入前添加一系列token（称为普通token），它由任意选择的token组成，可以安全发送而不会引起隐私泄露。</li>
<li>普通token记作$k=[k_1,…,k_m]$</li>
<li>训练例子记作$\mathcal{D}=\{\left \langle x_i,y_i \right \rangle|i=1,…,|\mathcal{D}|\}$，其中$|\mathcal{D}|$表示训练数据的尺寸</li>
<li>用户首先在每个输入$x_i$的前面加入$k$，然后进行加密得到隐私化的版本$z=M([![k;x_i]!])=[k’_1,…,k’_m,x’_1,…,x’_n]$</li>
<li>LLM使用提示P和输入z生成激活序列G：<script type="math/tex; mode=display">
G=f([\![P;Z]\!])\tag{5}</script>其中Z是z的词嵌入序列，$G\in\mathbb{R}^{(m+n)\times h}$</li>
<li>得到G后，我们使用其中的前m个向量$G_{1:m}=[g_1,…,g_m]$重建普通token，为了实现这一过程，我们引入了一个附加的重建head，由两个线性层组成。预测第$i$个token在普通token里的概率分布是：<script type="math/tex; mode=display">
p_i=softmax(W_1W_2g_i)\tag{6}</script>其中$W_1\in \mathbb{R}^{|T|\times c},W_2\in\mathbb{R}^{c\times h}$，都是重建head的参数，c是重建head的隐藏层的尺寸，$|T|$表示重建head的词汇量。隐私化token重建任务的损失函数是<script type="math/tex; mode=display">
\mathcal{L}_{rec}=-\sum_{i=1}^m log p_i[j_i]\tag{7}</script>其中，$j_i$是$k_i$在重建head词汇表中的索引，$p_i[j_i]$是向量$p_i$中的第$j_i$个标量。重建head的词汇表和LLM的词汇表不需要一致。</li>
<li>剩下的n个激活函数$G_{n:m+n}$被用于预测任务相关的标签。假设下游任务使用交叉熵损失，$y_i\in\{0,1\}^{|C|}$是关联标签，$y_j$表示第j类标签，$|C|$是类别数量。</li>
<li>下游任务的目标函数是：<script type="math/tex; mode=display">
p=g(G_{m:m+n})\tag{8}</script><script type="math/tex; mode=display">
\mathcal{L}_{task}=-\sum_{i=1}^{|C|}y_ilogp[i]\tag{9}</script>其中g是语言模型head的函数。</li>
<li>由此，训练RAPT的损失函数是：<script type="math/tex; mode=display">
\mathcal{L}=\mathcal{L}_{task}+\mathcal{L}_{rec}\tag{10}</script></li>
<li>在推理阶段，用户端也会应用文本到文本私有化来保护隐私信息，并从 LLM 服务中获取预测结果。我们注意到，推理阶段不使用重建head，因此$\{W_1, W_2\}$可以在训练后丢弃。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>这篇文章主要的贡献是做了token重建，帮助LLM学习可分离的深度表示，提升了LLM在加密文本数据上的性能，而加密过程则是直接用了已有的本地差分隐私算法。</li>
<li>加了一个普通token为什么能提升性能这一点我还没理解。</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>LLM</tag>
        <tag>Privacy</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Tiered Mechanisms for Blockchain Transaction Fees</title>
    <url>/2023/11/07/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Tiered%20Mechanisms%20for%20Blockchain%20Transaction%20Fees/</url>
    <content><![CDATA[<h1 id="Tiered-Mechanisms-for-Blockchain-Transaction-Fees"><a href="#Tiered-Mechanisms-for-Blockchain-Transaction-Fees" class="headerlink" title="Tiered Mechanisms for Blockchain Transaction Fees"></a>Tiered Mechanisms for Blockchain Transaction Fees</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ol>
<li>证明了以太坊目前使用的交易费机制 EIP-1559 并不具有包容性，并通过实验证明其价格在拥堵期间会横向飙升</li>
<li>引入了一个能够捕捉区块链系统流量多样性的模型，以及一个能够实施更具包容性的交易政策的分级定价机制</li>
<li>从形式上证明了我们的机制可以实现稳定的预期价格，我们还提供了实验结果，证明对于低紧迫性交易来说，交易价格可以保持在较低水平，从而使进入区块链的交易类型多样化</li>
<li>并不一定会牺牲收益，因为由于机制的价格歧视能力，低紧急交易价格的降低可以从高紧急交易中得到补偿</li>
</ol>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><ol>
<li>背景：用户的收益与交易上链时间相关，不同类型应用的交易有不同的紧迫性要求，例如在一个Layer 2支付系统中，DeFi交易更紧急，而结算交易紧迫性较低。理想的交易收费机制自然应该能满足各种应用对不同紧迫性的要求。</li>
<li>现状：主流交易费方法以价格拍卖为主，这导致网络拥塞时，紧急交易加价，连带非紧急交易也需要加价，这样的系统有失公平。</li>
<li>问题：让用户指定交易的紧迫度不现实，还需要考虑沟通成本、激励设计等</li>
<li>本文：分层交易方案<ol>
<li>动态确定层的数量、每一层的延迟和价格，用户自行选择去哪一层</li>
<li>提出了一种新型模型，用于捕捉客户对区块链处理的需求，该模型利用单调递减函数将延迟映射为价值，概括一下就是关注了交易延迟导致的用户收益下降</li>
</ol>
</li>
<li>目标：当系统遇到拥堵时，有一种政策可以在多种类型的用户之间平衡服务，由此考虑符合公开共享和商定的多样性政策的交易费机制，例如规定平均将一个区块中 20% 的交易空间用于低急迫性交易</li>
<li>优势：从流量多样性的角度对分层机制进行了分析，并证明在 “无点质量 “分布的标准假设和预期需求连续的合理假设下，分层机制可以实施丰富多样的政策</li>
<li>实验：研究分层机制如何收敛到一组价格，以及在需求波动时的表现<ol>
<li>研究了需求激增超过网络容量一段时间的重要情况</li>
<li>与 EIP-1559 协议进行了比较</li>
<li>实验结论：<ol>
<li>价值不会随时间显著下降的交易（也就是低紧迫度的交易）价格可以保持在较低水平，从而使进入区块链的交易类型多样化，并根据紧急程度进行适当的价格区分。</li>
<li>EIP-1559 中的价格在整个网络拥堵期间横向飙升。</li>
<li>研究了系统对收入的影响，证明分层定价没牺牲收益。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><h3 id="区块链稳态"><a href="#区块链稳态" class="headerlink" title="区块链稳态"></a>区块链稳态</h3><ol>
<li>用户所提交交易的特点：具有随延迟而变化的价值，每个交易都与一个从延迟到价值的映射的函数$v_i: R_{\geq 1}\rightarrow R_{\geq 0}$有关，延迟最小是1，表示交易在下一个块就上链。如果$d\lt d’$，则$v(d)\gt v(d’)$，意味着延迟越小价值越高。</li>
<li>区块链吞吐量：B，衡量一个块里有多少交易</li>
<li>进入区块链系统的交易价值函数独立同分布，服从分布F，单位区块的交易到达率是$n$，为了模拟高持续需求，这里假设$n\gt B$</li>
<li>区块链交易机制$M(v_i|n,F)=(d,p)$是从交易到价格和延迟的映射，机制与用户身份无关</li>
<li>给定价值是$v$的交易，其收益是$u(v|M,n,F)=v(d)-p$，也就是延迟之后的交易价值减去为了让交易上链而需要付的价格</li>
<li>需求约束：$D=\{v\in supp(F)|v(d)−p\geq 0 for (d,p)=M(v|n,F)\}$</li>
<li>收益非负的交易会以略低于吞吐量的速率到达，$n\cdot Pr[D]\leq B$</li>
<li>例1：机制1：以太坊的机制例子（EIP-1559）：将前一个区块$p$的价格及其满载率$f$作为输入，并输出新的价格，计算公式：$p(1+\frac{1}{8}\frac{f-targetLoad}{targetLoad})$</li>
<li>为了满足需求约束，机制所提供的价格$p_0$必须使得：$B=n\cdot Pr[D]=n\cdot Pr[v(0)\geq p_0]$，由此，机制转变为：$M(v|F)=(0,p_0)$</li>
<li>定义1：稳态近似真实性：对于所有的$n,F,v,v’\neq v$，都有$v(d)−p\geq v(d’)−p’$，其中$(d,p)=M(v|F)$且$(d’,p’)=M(v’|F)$，则称机制M满足真实性。</li>
<li>命题1：稳态近似真实性特征：当且仅当对于所有的$n,F,v_1,v_2$，$d_1\geq d_2\Rightarrow p_1\leq p_2$时机制M是真实的，$M(v_1|F)=(d_1,p_1)$且$M(v_2|F)=(d_2,p_2)$。此外，如果$d_1=d_2$则$p_1=p_2$。</li>
<li>我的问题：交易价值函数服从的分布F，和负载F是一回事吗？分布为什么会变成负载？<ol>
<li>$n$表示每个区块新生成的交易数量。它反映了进入区块链的交易流量和需求。</li>
<li>$F$表示交易价值函数$v$的分布。它描述了不同交易的价值函数$v$以何种概率分布出现。</li>
<li>$(n,F)$表示每隔一个区块有n个新交易生成，这些交易的价值函数v按照分布F进行独立同分布抽样。即n控制交易流量，F控制交易类型组成比例。它们一起描述了区块链面对的总体交易负载情况。</li>
</ol>
</li>
</ol>
<h2 id="Traffic-Diversity"><a href="#Traffic-Diversity" class="headerlink" title="Traffic Diversity"></a>Traffic Diversity</h2><ol>
<li>现有机制倾向于满足具有特定紧迫性要求的交易，而没能让不同紧急程度的交易有效利用平台。</li>
<li>本文引入机制应实施的多样性策略概念来抽象定义什么是多样性的机制，不涉及策略的具体选择。</li>
<li>通过检查交易价值在适当延迟后是否仍高于阈值来区分紧迫度，直观来说，延迟增加时，高紧迫度的交易价值会迅速下降，而低紧迫度则不会。</li>
<li>多样性策略由一组条款组成，这些条款描述了区块链中包含的交易$a_i$的百分比，这些交易在特定延迟$d_i$下的价值超过了某个阈值$p_i$。</li>
<li>定义2：多样化策略：一个多样化策略P是一个集合$\{(a_i,d_i,p_i)\}_{i\in N}$，其中$a_i,d_i,p_i$分别属于$(0,1],R_{\geq 1},(0,1]$。P中的三元组$(a_i,d_i,p_i)$被称为策略条款。</li>
<li>定义3：执行：一个机制M在负载F执行了一个多样性策略$P:=\{(a_i,d_i,p_i)\}_{i\in N}$当且仅当对于所有$i\in N$，$E[|\{j|u(v_j|M,F)\geq v_j(d_i)-p_i\gt 0,(v_1,…,v_n)\leftarrow F\}|]\geq a_i\cdot B$都成立。</li>
<li>例2：给定F，EIP-1559 机制会找到一个值$p$，即当延迟等于 1 时，在期望值上正好有B个交易的价值至少为$p$。因此，它在负载F下执行策略$P:=\{(1, 1, p)\}$（假设 p 存在）。</li>
</ol>
<h2 id="A-Diverse-Mechanism"><a href="#A-Diverse-Mechanism" class="headerlink" title="A Diverse Mechanism"></a>A Diverse Mechanism</h2><h3 id="EIP-1559不满足多样性"><a href="#EIP-1559不满足多样性" class="headerlink" title="EIP-1559不满足多样性"></a>EIP-1559不满足多样性</h3><ol>
<li>机制设计者希望机制能够满足包含某些策略条款$(a,d,p)$的策略P，其中$a\gt 0,d\gt 1$</li>
<li>在给定$(a, d, p)$的情况下，存在一个具有两个紧迫度的价值分布F（如下图），EIP-1559 在$(a, d, p)\in P$的情况下不执行任何策略 P。主要原因是会优先选择小费更高的交易，因而忽略了小费较低的不那么紧迫的交易。<br> <img src="https://github.com/likun1208/image/blob/master/tiered-1.png?raw=true" alt="image"></li>
<li>定义4：图里的负载分布定义：给定参数$a,d,p$，使得$d\gt 1,a,p\gt 0$<ol>
<li>0.5的概率，F输出价值函数$v(1):=2p$和$v(d):=0.2p$</li>
<li>0.5的概率，F输出价值函数$v(1):=\frac{3p}{2}$和$v(d):=p$</li>
<li>两个函数都是单调的</li>
</ol>
</li>
<li>命题2：令$(a,d,p)$作为一个策略条款，其中$d\gt 1,a,p\gt 0$，在前述负载F下，EIP-1559不会实现任何包含$(a,d,p)$的策略P。<br> 证明：按我的理解，这里意思是说，网络拥塞的时候，交易很多，EIP-1559就会把交易费上限设置为接近2p的价格，尽可能打包更多交易，通过提高交易费来试图降低交易量，这样价格较低的第二类交易就不可能被选中。而第一类交易在延迟为d时的价值是0.2p，并不满足策略条款。</li>
</ol>
<h3 id="分层定价机制"><a href="#分层定价机制" class="headerlink" title="分层定价机制"></a>分层定价机制</h3><ol>
<li>将区块内可用空间划分为最多$k$层，每层有各自的延迟$d_i,i\in[k]$和价格$p_i,i\in[k]$，随延迟增加价格下降。第一层的延迟固定为1，是最小延迟，意味着下一块就上链，其他层的延迟和所有层的价格由一组参数控制动态变化。</li>
<li>机制设计目标：该尽量选择最小的满足约束的延迟和价格，同时尽量增加层级数量和使用率。</li>
<li>延迟和价格的计算方式：<script type="math/tex; mode=display">
 d_{j+1}\geq \lambda_jd_j,\lambda_j\gt 1,p_{j+1}\leq \mu_jd_j,\mu_j\gt 1\tag{1}</script> 其中$\lambda_j,\mu_j,j\in[k-1]$是机制的参数。当约束不满足时，机制回改变至少一个层参数（延迟，价格，层数）从而满足约束。</li>
<li>初始状态下，机制只有大小为B的一层。</li>
<li>每次生成新区块时，会根据上一个块的负载调整不同层级的价格。</li>
<li>不同层的延迟变化频率较低（每过dFreq个块，改变一次延迟），以便价格调整能跟得上负载变化。延迟的变化基于连续层价格的关系，如果$p_{i+1}\gt \mu_i-p_i$，则第$i+1$层的延迟就增加，从而使得$p_{i+1}$减小，来满足约束。否则，$d_{i+1}\geq \lambda_i-d_i$，第$i+1$层的延迟会以一定概率减少1，来避免不必要的延迟，提高系统效率。</li>
<li>层的数量变化的频率更低（每tFreq个块改一次），如果最后一层的价值大于$addTierPrice$，且当前层数$m$小于$k$，就会新增一个尺寸为$a_{m+1}B$的层，价格是$newTierPrice$，延迟是$\lambda_md_m$。第$m+1$层的空间是从第1层挪出来的。类似的，如果最后一层的价格小于$removeTierPrice$，且当前层数大于1，则删去最后一层并把空间还给第一层。</li>
<li>延迟惩罚：为了避免用户加入最便宜的层级然后谎报偏好，机制通过延迟处理包含在层级中的交易来实现惩罚，延迟量为层级的延迟量，也就是说，就所有分类账而言，在产生的区块的时间戳超过包含区块的延迟量之前，交易将被忽略。因此，添加到层级中的交易需要支付与层级价格相等的费用。</li>
</ol>
<h2 id="Tiered-Pricing-is-Diverse"><a href="#Tiered-Pricing-is-Diverse" class="headerlink" title="Tiered Pricing is Diverse"></a>Tiered Pricing is Diverse</h2><h3 id="Tiered-Transaction-Mechanisms"><a href="#Tiered-Transaction-Mechanisms" class="headerlink" title="Tiered Transaction Mechanisms"></a>Tiered Transaction Mechanisms</h3><ol>
<li>区块分为$\{0,1,2,…,k\}$个层，除了第0层，每层的尺寸是$B=(B_1,B_2,…,B_k)$，延迟是$d=(d_1,d_2,…,d_k)$，所有层的尺寸加起来是B，B表示区块吞吐量。</li>
<li>第0层是特殊的，用来存放没上链的交易，尺寸$B_0=\infty$。</li>
<li>索引越大，延迟越高，服务越差。</li>
<li>$n\geq B$是新交易的数量，新交易为$\{t_1,t_2,…,t_n\}$，对于交易$t_i$，如果它被放到第$j$层且$j\neq 0$，则效用为：$u(i,j)=v_i(d_j)-p_j,0\lt j\leq k$，如果$j=0$则$u(i,j)=0$。收益反映出每个交易仅在ddl之前上链才能产生价值。</li>
<li>给定延迟d和价格p，交易$i$的效用记作$u_i(d,p)$。</li>
<li>元组$(B,d,p)$表示某特定区块链。</li>
<li><p>分层交易机制M将交易分配到不同层使得总效用最大。可能存在两层效用相同的情况，这时交易随机挑一层分。$X_{ij}$表示交易$i$被分到第$j$层，给定交易$i$的期望效用最大化层级随机集合$D_i=\{j\in\{0\}\cup[k]|u(t_i,j)\geq u(t_i,j’) \forall j’\}$，我们可以定义$X_{ij}$的分布：</p>
<script type="math/tex; mode=display">
 X_{i j}=\left\{\begin{array}{ll}
1 \text { with probability } \frac{B_j}{\sum_{j \in D_i} B_j} & \text { if } j \in D_i \\
0 & \text { otherwise }
\end{array} .\right.\tag{5}</script></li>
<li><p>在确定了交易如何选择层级之后，我们将每个层级的需求量（或已用空间）定义为</p>
</li>
</ol>
<script type="math/tex; mode=display">
    T_j=\sum_{i \in[n]} X_{i j}\tag{6}</script><p>除了第0层外，每层预期需求量最多应与所分配的层级规模相当</p>
<script type="math/tex; mode=display">
    \mathbb{E}\left[T_j\right] \leq B_j\tag{7}</script><p>而第0层的需求量是    </p>
<pre><code>$$
\mathbb{E}\left[T_0\right]=n-\sum_{j \in[k]} \mathbb{E}\left[T_j\right]\tag{8}
$$
</code></pre><h3 id="Distributional-Assumptions"><a href="#Distributional-Assumptions" class="headerlink" title="Distributional Assumptions"></a>Distributional Assumptions</h3><ol>
<li>定义5：需求正则：如果生成的价值可以参数化为元组$(v_0,h)$，则价值函数分布F是需求正则的，其中$v_0\in[0,1]$是无延迟时的价值，$h:R_{\geq 1}\rightarrow [0,1]$是折扣因子函数，形式为$v(d|v_0,h)=v_0h(d)$。同时需要以下条件成立：<ol>
<li>$h(d)$连续且单调减</li>
<li>$lim_{d\rightarrow\infty}h(d)=0$</li>
<li>$v_0$的边缘分布的概率密度函数始终存在，其定义为$f\left(v_0 \mid h\right)=\frac{d \operatorname{Pr}\left[v \leq v_0 \mid h\right]}{d v_0}$</li>
<li>对于$v_0\in[0,1]$，$f(v_0|h)\gt 0$</li>
</ol>
</li>
<li>引理1：对于任意区块链$(B,d,p)$和正则需求$n,F$，$E[T_i]$在p和d中是连续的，即便去掉最后一个假设这个引理也是成立的。</li>
</ol>
<h3 id="Compatible-Blockchains"><a href="#Compatible-Blockchains" class="headerlink" title="Compatible Blockchains"></a>Compatible Blockchains</h3><ol>
<li>定义6：兼容：如果公式7（期望需求小于层尺寸）对于所有层都成立，则称区块链$(B,d,p)$在负载n和F下是兼容的。</li>
<li>定义7：EIP-1559稳定区块链：如果一个区块链$(B,d,p)$在负载$n,F$下是兼容的，且每一层都满足<script type="math/tex; mode=display">
 \frac{\mathbb{E}\left[T_j\right]}{B_j}\lt 1 \Rightarrow p_j=0\tag{9}</script> 则称其是稳定的。</li>
<li><p>观察1：假设$B_1=B_2=1,d_1=0,d_2=1,n=3$，F是：</p>
<ul>
<li>概率$\frac{1}{3}$，延迟小于1时，$v_0$服从$[0,1]$的均匀分布，否则$v_0=0$。</li>
<li><p>概率$\frac{2}{3}$，$v_0$服从$[0,1]$的均匀分布。</p>
<p>如果$p_1\neq p_2$，则$p_1\gt p_2$。否则所有交易都会去选择$B_1$，这样$B_2$就是空的，而根据定义7，$p_2=0$，那么$p_1\lt p_2=0$就与$p_1$非负矛盾了。由此得出两个选项：</p>
</li>
<li>$p_1\gt p_2$。这种情况下，所有d=2的交易都会选择支付$p_2$，为了实现稳定，就需要$p_2\gt 0.5$。但是$p_1\gt p_2\gt 0.5$对于填充$B_1$有些大了。</li>
<li>$p_1=p_2$。这种情况，$B_1$的需求比$B_2$高，因为它会被所有d=1的交易和一半d=2的交易选择。因为$B_1=B_2$，那么在$p_1=p_2$的情况下不可能让交易均匀填充两个区块。因为未填满的区块价格需要设置为0，所以$p_1=p_2\gt 0$是不可能出现的。</li>
</ul>
</li>
<li>总结：<ol>
<li>兼容意思是区块链的交易处理能力可以满足交易的需求量，具体就是每个区块$j$的交易需求量$E[T_j]$小于等于该区块的处理上限$B_j$。这保证了区块链可以流畅运行,不会积压交易造成拥堵。</li>
<li>在兼容的基础上，又满足如果某个区块j的需求量比上限低,则价格$p_j=0$。这反映了EIP-1559的目标——在降低费用的同时,也要最大化区块空间的利用率，不浪费区块资源。</li>
<li>观察1中的分布函数F不连续和大于0，不满足前面分布假设中的要求，所以不稳定。</li>
</ol>
</li>
</ol>
<h3 id="Properties-of-Compatible-and-EIP-1559-Stable-blockchains"><a href="#Properties-of-Compatible-and-EIP-1559-Stable-blockchains" class="headerlink" title="Properties of Compatible and EIP-1559 Stable blockchains"></a>Properties of Compatible and EIP-1559 Stable blockchains</h3><ol>
<li>命题3：有着EIP-1559的以太坊在任何负载下都是兼容的。特别的，对于任意$B,n,F$，都存在价格p使得$(B,d,p)$在负载$n,F$下是兼容的。<br> 证明：在以太坊中，$B=B_1,d_1=0$，显然根据定义5，$p_1=0$可得$E[T_1]=n$。因为$p_1\gt 1$可得$E[T_1]=0$（因为每个交易的最大效用是1），且$E[T_1]$在$p_1$是连续的，所以存在$p_1\gt 0$使得$E [Tj]=B\lt n$，以满足定义6。</li>
<li>兼容性和 EIP-1559 稳定性的结合意味着更直观的属性。</li>
<li>命题4：对于在需求$n,F$下兼容且EIP-1559稳定的任意区块链$(B,d,p)$，对于所有$j\in[k]$，$E[T_j]=B_j$都成立。<br> 证明：如果对于某些层$j$而言， $E[T_j]\lt B_j$ （这是可能兼容的），EIP-1559稳定的性质会使得该层的价格为0。然而，在这种情况下，任何交易都会因加入该层而产生正效用。因为 $n\gt \sum_{j\in[k]}B_j$，这一层会至少有 $n-(\sum_{l\in[k]}B_l-B_j)\gt B_j$ 的需求，因此并不兼容。</li>
<li>引理2：对于任意区块链$(B,d,p)$，和正则需求$n,F$，如果$p_j=1$，则$E[T_j]=0$。</li>
</ol>
<p>证明：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbb{E}\left[T_j\right]=n \cdot \operatorname{Pr}\left[t \in T_j\right] & \leq n \cdot \operatorname{Pr}\left[v_0 \cdot h\left(d_j\right)-p_j \geq 0\right] \\
& \leq n \cdot \operatorname{Pr}\left[v_0 \geq p_j\right] \\
& =0
\end{aligned}</script><p>其中第一个不等式：进入第$j$层的交易效用必须非负。最后一个等式：两个分布假设决定（即，$v_0$分布在$[0,1]$中，并且等于1的概率为零）。</p>
<ol>
<li>引理3：对于任意区块链$(B,d,p)$，和正则需求$n,F$，如果 $p_j=0$，则 $\sum_{j\in[k]}E[T_j]\lt B$。</li>
</ol>
<p>证明：如果$p_j=0$，几乎可以肯定，每笔交易都会在$j$层产生正效用，因此将包含在某个层中（应该是说所有交易都加入这一层）。只要到达率高于吞吐量$n \gt  B$，就能证明这一点。</p>
<ol>
<li>引理4：对于任意区块链$(B,d,p)$，和正则需求$n,F$，其中$p$是EIP-1559稳定的，可得：对于所有$1\leq j\lt k$ 都有$p_j\geq p_{j+1}$。</li>
</ol>
<p>证明：假设对于$1\leq j\lt k$都有$p_j\lt p_{j+1}$，在这种情况下，第$j$层会有比第$j+1$层更低的价格和更低的延迟。因此，根据公式3，我们可得对于任意交易$i$而言，$u(i,j)\gt u(i,j+1)$，这使得$T_{j+1}=\emptyset$。但是，$p_{j+1}\gt p_j\geq 0$会导致矛盾，因为空层的价格一定是0。</p>
<ol>
<li>引理5：令$f:[0,1]^k\rightarrow R^k_{\geq 0}$是一个具有以下属性的函数：<ol>
<li>$f(x_1,x_2,…,x_k)$是在$x$上均匀连续的，且随$x_j,j\in[k]$递减。</li>
<li>如果$x_j=1$，则$f_j(x)=0$，其中$f_j$是$f(x)$的第j个坐标。</li>
<li>如果$x_j=0$，则$\sum_{j\in[k]}f_j(x)\gt B$</li>
<li>对于$y=x+\delta e_j$使得$x,y\lt 1$，可得当$l\neq j$时$f_j(y)\lt  f_j(x)$且$f_l(y)\geq f_l(x)$。</li>
<li>因此，对于任意满足$\sum_{j\in[k]}B_j=B$的$B_1,B_2,…,B_k\gt 0$，对于任意$j\in[k]$，都存在一些$x\in[0,1]^n$使得$f_j(x)=B_j\gt 0$。</li>
</ol>
</li>
<li>定理1：对于任意有着固定$B,d$和任意$n,F$的区块链，都存在$p$使得$(B,d,p)$是兼容且EIP-1559稳定的。</li>
<li>引理6：给定$B,d,n,F$，和两个不同的价格向量$p\geq p’$（即每个$p$中的价格都大于等于$p’$中对应的价格），我们可得对于所有$j\in[k]$都有$\sum_{j\in[k]}T_j\leq\sum_{j\in[k]}T’_j$。</li>
</ol>
<p>证明：令S表示一组估值，如果这些估值被包含在它们最喜欢的区块链层级$(B,d,p’)$中，将会带来正效用。显然如果将它们纳入$(B,d,p)$而不是同一层级，它们的效用都会增加。类似地定义$S’$，可得$S’\subseteq S\Rightarrow Pr[S’]\leq Pr[S]$。因为$S$和$S’$能根据每个交易的首选层被划分为不相交的集合$S_j$，这样$Pr[S_j]=T_j$乘以$n$就得到了所要求的结果。</p>
<ol>
<li>定理2：对于有着固定B和d以及任意$n,F$的区块链，如果存在$p$使得$(B,d,p)$是兼容且EIP-1559稳定，则$p$是独一无二的。</li>
</ol>
<p>证明：假设存在两个不同的价格向量$p\neq p’$使得$(B,d,p)$和$(B,d,p’)$都是在需求$n,F$下兼容且EIP-1559稳定。因为$p\neq p’$，我们可以把价格集合划分为两部分：$P^{+}=\{j\in[k]|p’_j\gt p_j\}$和$P^{-}=\{j\in[k]|p’_j\leq p_j\}$。</p>
<p>我们用$T_j$和$T’_j$表示$(B,d,p)$和$(B,d,p’)$的层级划分。</p>
<p>假设$P^{-}=\emptyset$，我们只需要说明对于$(B,d,p’)$和需求$n,F$可得</p>
<script type="math/tex; mode=display">
    \sum_{j\in[k]}E[T'_j]\lt \sum_{j\in[k]}B_j\tag{10}</script><p>就可以确定价格$p’$并非EIP-1559稳定，因为它们都是正数且一些层没满。</p>
<p>为了得到这一矛盾，我们假设等式10成立。令$\delta=min_j\{p’_j-p_j|j\in[k]\}$并定义一个新的价格向量$\hat{p}=p+\delta$。通过价格兼容性和引理6，可得：</p>
<script type="math/tex; mode=display">
    \sum_{j \in[k]} B_j=\sum_{j \in[k]} \mathbb{E}\left[T_j^{\prime}\right] \geq \sum_{j \in[k]} \mathbb{E}\left[\widehat{T}_j\right] \geq \sum_{j \in[k]} \mathbb{E}\left[T_j\right]=\sum_{j \in[k]} B_j\tag{11}</script><p>因此，如果所有价格恰好增加$\delta$，则总需求保持不变。事实上，因为效用是拟线性的，并且所有价格变化量相同，所以每一层的需求保持和$(B,d,p)$一样。此外，任何价值$v$的首选层在$(B,d,p)$和$(B,d,\hat{p})$中都是一样的。我们将证明这违反了分布假设。</p>
<p>令$S_j$表示F的支持子集，其中包含在价格$p$下倾向于$T_j$层的交易。</p>
<script type="math/tex; mode=display">
S_j=\left\{\left(v_0, h\right) \in F \mid v_0 \cdot h\left(d_j\right)-p_1 \geq v_0 \cdot h\left(d_j^{\prime}\right)-p_j \text { for all } j^{\prime} \neq j\right\}</script><p>我们可得</p>
<script type="math/tex; mode=display">
\mathbb{E}\left[T_j\right]=n \cdot \operatorname{Pr}\left[S_j\right] \Rightarrow \operatorname{Pr}\left[S_j\right]=\frac{B_j}{n}</script><p>令 S 为F的支持子集，其中包含将加入$p$下某个层的有着相似$\hat{S}$的交易：</p>
<script type="math/tex; mode=display">
S=\left\{\left(v_0, h\right) \in F \mid v_0 \cdot h\left(d_j\right)-p_j \geq 0 \text { for some } j \in[k]\right\}</script><p>当然，$S=\cup_{j\in[k]}S_j$且每个$S_j$都不相交，从公式11可以推出：</p>
<script type="math/tex; mode=display">
\sum_{j \in[k]} \mathbb{E}\left[\widehat{T}_j\right]=\sum_{j \in[k]} \mathbb{E}\left[T_j\right] \Rightarrow \sum_{j \in[k]} \mathbb{E}\left[\widehat{T}_j\right] / n=\sum_{j \in[k]} \mathbb{E}\left[T_j\right] / n \Rightarrow \sum_{j \in[k]} \operatorname{Pr}\left[\widehat{S_j}\right]=\sum_{j \in[k]} \operatorname{Pr}\left[S_j\right]\tag{12}</script><p>令$\mathbb{1}_{t\in S}$表示交易t加入S的指示变量。因为所有$S_j$都不相交：</p>
<script type="math/tex; mode=display">
\sum_{j \in[k]} \operatorname{Pr}\left[\widehat{S_j}\right]=\sum_{j \in[k]} \operatorname{Pr}\left[S_j\right] \Rightarrow \operatorname{Pr}\left[\cup_{j \in[k]} \widehat{S_j}\right]=\operatorname{Pr}\left[\cup_{j \in[k]} S_j\right] \Rightarrow \mathbb{E}\left[\mathbb{1}_{t \in \widehat{S}}\right]=\mathbb{E}\left[\mathbb{1}_{t \in S}\right]</script><p>为了简化计算，我们可以在价值的折扣函数$h$条件下使用全期望定律。把所有内容合起来可得：</p>
<script type="math/tex; mode=display">
\sum_{j \in[k]} \mathbb{E}\left[\widehat{T}_j\right]=\sum_{j \in[k]} \mathbb{E}\left[T_j\right] \Rightarrow \mathbb{E}\left[\mathbb{E}\left[\mathbb{1}_{t \in \widehat{S}} \mid h\right]\right]=\mathbb{E}\left[\mathbb{E}\left[\mathbb{1}_{t \in S} \mid h\right]\right]\tag{13}</script><p>然后得到：</p>
<script type="math/tex; mode=display">
\mathbb{E}\left[\mathbb{1}_{t \in S} \mid h\right]=\operatorname{Pr}\left[v_0 \geq V_h \mid h\right] \quad \text { and } \quad \mathbb{E}\left[\mathbb{1}_{t \in \widehat{S}} \mid h\right]=\operatorname{Pr}\left[v_0 \geq \widehat{V_h} \mid h\right]</script><p>这是因为以$h$为条件，价值随$v_0$增加，因此存在一个最小的$V_h$，高于该值的每个$v_0$都会加入某个层。可以看出，对于$v_0=\hat{V_h}$（被包含在$\hat{p}$下的某层$j$），可得：</p>
<script type="math/tex; mode=display">
\widehat{V_h} \cdot h\left(d_j\right)-\left(p_j+\delta\right) \Rightarrow \widehat{V_h} \cdot h\left(d_j\right)-p_j \geq \delta\gt 0</script><p>因此，存在某价值$v_h-\varepsilon$使得$\left.\widehat{V_h}-\varepsilon\right) \cdot h\left(d_j\right)-p_j\gt 0$。由此在价格$p$下，对于折扣函数$h$，任何$\hat{V_h}\geq v_0 \geq \hat{V_h}-\varepsilon$都会被包含进某层：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\operatorname{Pr}\left[v_0 \geq V_h \mid h\right] & \geq \operatorname{Pr}\left[v_0 \geq \widehat{V_h}-\varepsilon \mid h\right] \\
& \geq \operatorname{Pr}\left[\widehat{V_h}\gt v_0 \geq \widehat{V_h}-\varepsilon \mid h\right]+\operatorname{Pr}\left[v_0 \geq \widehat{V_h} \mid h\right] \\
& \gt \operatorname{Pr}\left[v_0 \geq \widehat{V_h} \mid h\right] .
\end{aligned}</script><p>这意味着$E[\mathbb{1}_{t\in S}|h]\gt E[\mathbb{1}_{t\in \hat{S}}|h]$，无论采用哪边的期望价值都与公式13矛盾。</p>
<p>对于$P^{-}\neq \emptyset$的情况，显然，$(B,d,p’)$对应的任意层$j\in P^+$的需求只会严格小于$(B,d,p)$对应的需求，随着这些层的价格上涨，而其余层价格保持不变或下降。在证明过程中，我们对之前的分析稍作修改，增加了一种情况，即$P^+$的价格并不稳定，而是有可能有一些需求溢出到 P 层，使得新的价格与需求不符。</p>
<ol>
<li>总结：这一部分说的是兼容且稳定的区块链具有的性质。<ol>
<li>命题3很好理解，直观来说就是在其他因素不变的情况下，价格变化会引起期望需求改变，而最小和最大分别是n和0，B恰好在这个区间上，这个变化是连续的，显然中间肯定存在一个值，对应了期望效用是B的情况。</li>
<li>命题4也好理解，如果一个区块链是兼容且稳定的，这意味着每一层的期望需求应该恰好等于这一层的容量。如果是大于的情况，则不满足兼容的定义；如果是小于的情况，则按照稳定的性质，这一层价格应该为0，这使得还没加入的交易都会争相加入，而在本文的场景下交易数量大于区块链所有层的总容量，去掉放到其他层的交易以后，剩下的交易都想加入这一层，而这个需求必然大于这一层的容量，因此与兼容冲突了。</li>
<li>引理2这里，这篇论文应该是用1表示最高价，从公式可以看出如果某一层价格很高，那它的期望需求就是0。</li>
<li>引理3和EIP-1559稳定感觉说的是一个意思，价格为0就意味着这一层还有空，期望需求小于它的容量。</li>
<li>引理4也很显然，兼容且稳定时，延迟低的层价格会高。</li>
<li>引理5有点抽象，通俗来说，函数f()可以看作是从层级的价格p到这一层的预期需求$E(T_k)$的映射，引理5表明可以通过调整价格使得预期需求量等于这层的容量$B_k$，从而满足兼容且稳定的需求。</li>
<li>定理1可以从引理5引申出来。</li>
<li>引理6直观来看，价格上涨就会导致需求下降，很容易理解。它是为后面证明价格唯一性做支撑的。</li>
<li>定理2的证明比较多，这个定理本身的含义可以概括为：对于确定的区块大小和延迟，如果存在可以使区块链平稳运行的价格，那么这组价格就是唯一的。用的反证法：<ol>
<li>假设存在两个不同的价格$p$和$p’$都能让同一个区块链兼容且稳定；</li>
<li>把价格可能取值的集合划分为p’高于p的$P^+$集合，以及p’低于or等于p的$P^-$集合；</li>
<li>如果$P^-$是空的，意味着只存在p’大于p的情况，根据引理6，如果p是兼容且稳定的，则意味着p’对应的期望需求会更小，如果p’也兼容且稳定，那价格一定是0，这使得p要小于0，而这又违背了定义，所以这种情况不存在（证明部分的公式比这个复杂）；</li>
<li>如果$P^-$非空，在$P^+$集合，价格从p涨到p’，会导致期望需求下降，感觉和前面一样，都是要么不兼容要么不稳定。</li>
<li>总的来说这个定理的意思就是，在区块大小和延迟不怎么改变的情况下，需求波动后会带来价格的波动，从而使得不改变大小和延迟的情况下还能兼容稳定。<h3 id="Steady-state-of-the-Tiered-Pricing-Mechanism"><a href="#Steady-state-of-the-Tiered-Pricing-Mechanism" class="headerlink" title="Steady-state of the Tiered Pricing Mechanism"></a>Steady-state of the Tiered Pricing Mechanism</h3></li>
</ol>
</li>
</ol>
</li>
<li>在负载$n,F$和固定的$B$下，分层定价机制旨在找到$(B,d,p)$，使得：<script type="math/tex; mode=display">
d_{j+1} \geq \lambda_j \cdot d_j \text { for } \lambda_j\gt 1 \text {, and } p_{j+1} \leq \mu_j \cdot p_j \text { for } \mu_j\lt 1\tag{14}</script></li>
<li>定理3：对于任意B，因子$\lambda_j,\mu_j$和正则需求$n,F$，都存在一个区块链$B,d,p$既兼容和EIP-1559稳定，也满足不等式14。</li>
</ol>
<p>证明：将$d_1$设置为0，由此定义：</p>
<script type="math/tex; mode=display">
    d_{j+1}=\max \{\lambda_{j} \cdot d_{j}, \underset{d}{\operatorname{argmin}}\{\operatorname{Pr}\left[h(d)\lt \mu_{j} \cdot h\left(d_{j}\right) / 2\right]\gt 1-\delta \cdot \frac{1}{k-1} \cdot \frac{1}{n}\}\}</script><p>本质上，$d_{j+1}$远大于$d_j$，因此几乎所有交易产生的折扣因子至少比$d_j$小$\lambda_j/2$。我们可以用以下 的集合来描述这个“几乎所有”属性：</p>
<pre><code>$$
H_{j+1}=\{(v_{0}, h) \in \operatorname{supp}(F) \mid h(d_{j+1})\lt \mu_{j} \cdot h(d_{j})\}
$$
</code></pre><p>且$H=\cap_{j\geq 1}^kH_j$。在$n$个交易的样本中，我们观察到没有一个交易的折扣函数位于集合H之外的概率是：    </p>
<script type="math/tex; mode=display">
    \begin{aligned}
\operatorname{Pr}\left[\forall i \in[n] t_{i} \in H\right] & =1-\operatorname{Pr}\left[\exists i \in[n] \text { s.t. } t_{i} \in H^{C}\right] \\
& \geq 1-n \cdot \operatorname{Pr}\left[\cup_{j \geq 1}^{k} H_{j}^{C}\right] \\
& \geq 1-n \cdot \sum_{j \geq 1}^{k} \delta /(k-1) / n=1-\delta .
\end{aligned}</script><p>因此，可以将延迟$d_{j+1}$设置得足够高，这样在概率至少为$1-\delta$的情况下，样本中所有交易的折扣函数都会使连续层级的价值至少降低$\mu_j$倍。</p>
<p>对于我们刚才描述的延迟$d_1, d2, …,d_k$，让$p$成为保证存在的兼容和 EIP-1559 稳定的价格。根据命题 4，我们知道，对于这些价格，每个层级都必须完全满员。因此，对于任何层级$j$，都必须存在一个$h\in H$ 且使得层级$j+1$优于$j$的$v_0$的交易，且其效用为正。用公式来表述：</p>
<script type="math/tex; mode=display">
\begin{aligned}
v_{0} \cdot h\left(d_{j}\right)-p_{j} & <v_{0} \cdot h\left(d_{j+1}\right)-p_{j+1} \\
\Rightarrow v_{0} \cdot h\left(d_{j+1}\right) / \mu_{j}-p_{j} & <v_{0} \cdot h\left(d_{j+1}\right)-p_{j+1} \\
\Rightarrow v_{0} \cdot h\left(d_{j+1}\right) & <\frac{p_{j}-p_{j+1}}{1 / \mu_{j}-1} .
\end{aligned}</script><p>因为效用为正（即$v_0\cdot h(d_{j+1})-p_{j+1}\gt 0$），可以进一步得到：</p>
<pre><code>$$
\begin{aligned}
</code></pre><p>p_{j+1} &amp; &lt;\frac{p_{j}-p_{j+1}}{1 / \mu_{j}-1} \\<br>\Rightarrow p_{j+1} &amp; &lt;p_{j} \cdot \mu_{j} .<br>\end{aligned}</p>
<pre><code>$$
</code></pre><p>因此，对于适当选择的延迟，可以保证价格也将遵循我们的约束条件。</p>
<p>上述定理可以转换为分层定价机制执行不等式 14 所定义的政策的能力。</p>
<ol>
<li>推论1：对于任意正则需求$n,F$以及任意$k\geq B$，和任意参数集$\{(a_j,\lambda_j,\mu_j)\}_{j\in[k-1]}$，其中$a_j\in(0,1],\lambda_j\in R_{&gt;1},\mu_j\in(0,1)$，对于$j\in[k-1]$且$\sum_j a_i=1$，有着相同参数和$tFreq:=\infty$的分层定价机制执行策略$P:=\{(a_i,d_i,p_i)\}_{i\in[k]}$，其子句满足不等式14.</li>
<li>遗憾的是，有很多 p 和 d 对都能满足这些特性。例如，最后一级的延迟总是可以增加（降低相应的价格），同时保持我们的保证。然而，我们的分层定价机制能找到局部最小解，不会不必要地增加延迟。</li>
<li>定理4：对于任何$B$、因子$\lambda_j,\mu_j$和需求$n,F$，都存在一个兼容、EIP-1559 稳定且满足不等式 14 的区块链$(B,d,p)$。此外，在不牺牲任何保证的情况下，任何延迟都可以被独立降低。</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
        <tag>defi</tag>
      </tags>
  </entry>
  <entry>
    <title>论文略读记录</title>
    <url>/2023/11/07/%E8%AE%BA%E6%96%87%E7%95%A5%E8%AF%BB%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>从今天开始，找到的论文先略读做个记录，再决定是否细看</p>
<a id="more"></a>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><ol>
<li>作者、期刊、发表时间：</li>
<li>关键词：</li>
<li>研究背景和问题：</li>
<li>研究方法：</li>
<li>论文结论：</li>
<li>创新与贡献：</li>
<li>我的问题：</li>
<li>是否详细阅读：</li>
</ol>
<h1 id="Cooperative-game-for-coordination-of-a-green-closed-loop-supply-chain"><a href="#Cooperative-game-for-coordination-of-a-green-closed-loop-supply-chain" class="headerlink" title="Cooperative game for coordination of a green closed-loop supply chain"></a>Cooperative game for coordination of a green closed-loop supply chain</h1><ol>
<li>作者、期刊、发表时间：Tooba Asghari, Ata Allah Taleizadeh, Fariborz Jolai, Mohammad Sadegh Moshtagh, Journal of Cleaner Production, Volume 363, 2022.</li>
<li>关键词：Environmental responsibility; Inventory; Pricing; Cooperative game theory; Green design.</li>
<li>研究背景和问题：在绿色闭环供应链中，制造商、零售商和回收商要决定三方在整个供应链过程中的贡献和利润分配。</li>
<li>研究方法：合作博弈，包括核解机制（NSM）和沙普利值机制（SVM），以及不同的契约结构，包括成本分摊（CS）、收入分摊（RS）和两部分关税（TPT）契约</li>
<li>论文结论：<ol>
<li>合作博弈和契约机制都为所有主体提供了双赢的条件</li>
<li>从供应链的角度看，不同机制有不同的经济效益，零售商更倾向于合作机制，回收商更喜欢契约机制</li>
<li>消费者的认识对三方也有激励</li>
<li>回收商二手交易能降低环保产品售价，提高其需求</li>
</ol>
</li>
<li>创新与贡献：<ol>
<li>考察了 GCLSC 的两种协调策略，并在经济和环境绩效方面比较了这两类策略，对每个成员的场景进行优先级排序，并确定每个机制下的受益人。</li>
<li>所有三个成员的环境责任被分开考虑</li>
<li>分别考虑了消费者对绿色制造商、绿色零售商和回收商所做努力的敏感度，并比较了它们对供应链决策的影响。</li>
<li>除了考虑CLSC文献中常见的废旧绿色产品的收集和回收用于再制造外，还假设收集的一部分产品将作为二手绿色产品在二级市场上供应并在不同场景下考察二手产品交易对会员决策的影响。此外，还考虑了给予退回旧产品的消费者的优惠券对需求函数的影响。</li>
<li>总的来说就是场景更细致了</li>
</ol>
</li>
<li>我的问题：<ol>
<li>收益函数的设计</li>
<li>几个契约具体是怎么做的</li>
</ol>
</li>
<li>是否详细阅读：让学生看一下，也许能用到数据交易方面</li>
</ol>
<h1 id="Blockchain-and-Zero-Sum-Game-based-Dynamic-Pricing-Scheme-for-Electric-Vehicle-Charging"><a href="#Blockchain-and-Zero-Sum-Game-based-Dynamic-Pricing-Scheme-for-Electric-Vehicle-Charging" class="headerlink" title="Blockchain and Zero-Sum Game-based Dynamic Pricing Scheme for Electric Vehicle Charging"></a>Blockchain and Zero-Sum Game-based Dynamic Pricing Scheme for Electric Vehicle Charging</h1><ol>
<li>作者、期刊、发表时间：R. Kakkar, S. Agrawal, R. Gupta and S. Tanwar, IEEE INFOCOM 2022 - IEEE Conference on Computer Communications Workshops (INFOCOM WKSHPS)</li>
<li>关键词：Blockchain, Electric vehicle, Zero-sum gametheory, Profit, Payoff, Latency</li>
<li>研究背景和问题：<ol>
<li>为了避免电价波动，需要一种合理的充电方案。</li>
<li>集中式的电动车充电方案面临各类安全问题，如修改攻击、完整性攻击、中间人攻击。因此很多研究提出了基于区块链的充电方案。</li>
<li>但是现有研究普遍面临延迟、成本效率、系统的最佳回报以及电动汽车和电动汽车的利润等问题，且缺乏对动态收费以获得最佳回报的讨论。</li>
<li>需要提出一种基于区块链的6G网络动态定价方案，以提高系统的延迟和效率。</li>
</ol>
</li>
<li>研究方法：构建了零和博弈模型，分别列出电动车和充电站的收益函数，然后找均衡。</li>
<li>论文结论：本文方法在成本效率、盈利能力、低延迟和高可靠性方面优于传统系统。</li>
<li>创新与贡献：<ol>
<li>提出了一种安全高效的区块链，与基于 IPFS 的动态定价方案相结合，用于通过 6G 通信网络充电的电动汽车。</li>
<li>制定零和博弈方法来优化电动车和CS的利润，使系统盈利。</li>
<li>考虑延迟、系统的最佳回报以及电动汽车和CS 的利润等参数来评估所提议系统的性能。</li>
</ol>
</li>
<li>我的问题：<ol>
<li>实验是模拟的还是真实环境？</li>
<li>场景模型还不太清楚。</li>
</ol>
</li>
<li>是否详细阅读：让学生大致看看。</li>
</ol>
<h1 id="Game-Theoretic-Rating-in-N-player-general-sum-games-with-Equilibria"><a href="#Game-Theoretic-Rating-in-N-player-general-sum-games-with-Equilibria" class="headerlink" title="Game Theoretic Rating in N-player general-sum games with Equilibria"></a>Game Theoretic Rating in N-player general-sum games with Equilibria</h1><ol>
<li>作者、期刊、发表时间：Marris, L.; Lanctot, M.; Gemp, I.; Omidshafiei, S.; Mcaleer, S.; Connor, J.; Tuyls, K.; Graepel, T. 是arxiv的论文，2022年的，目前应该还没发。</li>
<li>关键词：无</li>
<li>研究背景和问题：传统的策略评级方法局限于二人零和博弈。需要拓展到N人广义和博弈设置。</li>
<li>研究方法：<ol>
<li>提出了博弈论支付评级(payoff rating)的定义,它利用联合策略分布条件化的期望支付来评价策略。</li>
<li>证明在二人零和游戏中,当使用最大熵纳什均衡时,支付评级等价于纳什均值(Nash Average)。</li>
<li>提出了使用关联均衡和粗略关联均衡进行支付评级。这更适合N人广义和博弈。</li>
<li>通过最大熵选择准则,支付评级具有策略分组、重复策略一致性等好的性质。</li>
</ol>
</li>
<li>论文结论：评级模型是有用的</li>
<li>创新与贡献：最大熵评级模型</li>
<li>我的问题：其实看了半天没看明白这个是游戏中的评级，还是博弈的评级，还是用博弈论做通用评级的场景</li>
<li>是否详细阅读：否</li>
</ol>
<h1 id="Supply-chain-equilibrium-on-a-game-theory-incentivized-blockchainnetwork"><a href="#Supply-chain-equilibrium-on-a-game-theory-incentivized-blockchainnetwork" class="headerlink" title="Supply chain equilibrium on a game theory-incentivized blockchainnetwork"></a>Supply chain equilibrium on a game theory-incentivized blockchainnetwork</h1><ol>
<li>作者、期刊、发表时间：Jianbin Gao, Bonsu Adjei-Arthur, Emmanuel Boateng Sifah, Hu Xia, Qi Xia*. Journal of Industrial Information Integration（一区，不是CCF）. 2022</li>
<li>关键词：Supply chain; Game-theory; Blockchain; Smart contract; IoT.</li>
<li>研究背景和问题：传统供应链依赖第三方在零售商和供应商之间构建契约来实现合作，但是面临一些问题：<ol>
<li>基于第三方的契约机制由于缺乏自我强制的信任而导致交易双方之间难以建立关系。</li>
<li>由于交易方的复杂性和自私程度，建立平衡也极具挑战性。在很多情况下，参与者必须对既定的投标协议做出妥协，以确保和维持合同双方之间的可信度，从而导致交易参与者不满意。</li>
<li>契约机制也存在恶意篡改、谈判过程不透明等问题。</li>
<li>同时预测和监控交易方的活动具有挑战性。决策的改变会严重影响整个供应链并造成巨大损失，需要有自动化的契约建立机制和透明的谈判媒介。</li>
</ol>
</li>
<li>研究方法：<ol>
<li>提出了一个结合区块链特征的新颖框架，以确保透明度并确保供应链的平衡。</li>
<li>我们激励供应链环境中的交易各方共同行动并做出最佳决策，以确保各方有效建立均衡。</li>
<li>我们提出的解决方案中的交易信息流提供了做出有效决策所需的能力，有助于确保多个缔约方之间的平衡。</li>
<li>为了更好地理解网络上各方的行为及其行为的后果，我们结合了博弈论模型来表明使用区块链网络可以更好地实现供应链平衡。</li>
<li>用了stackelberg博弈</li>
</ol>
</li>
<li>论文结论：方法是可行的</li>
<li>创新与贡献：<ol>
<li>通过在基于区块链的供应链系统上设计一种新颖的方法来扩展[6]和[1]的工作，通过基于博弈论的方法促进供应商和零售商之间的交易，并在供应链网络上的各方之间建立平衡。</li>
<li>设计了一个投标系统，将供应链网络中的多方聚集在一起。招标系统利用区块链功能规范供应链上的所有行为，通过请求和谈判为供应链上的多方提供透明度。</li>
<li>开发了一种预测机制，确保对供应商和零售商进行有效的选择过程，从而避免供应链上的中断和供应不确定性问题，确保为交易过程选择最好的实体，从而提高供应商的供应水平。可以建立平衡。</li>
<li>利用与区块链兼容的签约机制，这些机制可以有效地协同工作，并利用区块链功能在供应链各方之间建立重要的关系。</li>
<li>对每个玩家在博弈论激励的区块链网络上的行为进行了详细分析。通过分析每个策略的执行情况以及每个时间点发生的变化对系统的影响，我们证明我们提出的想法可以满足连续、重复和无限博弈等复杂情况，同时保持各方之间的透明度。</li>
<li>实现供应链上主要重要流程的自动化，并利用区块链功能提供良好的激励方案，使多方能够观察供应链上的正确行为。</li>
<li>从数学上证明，区块链更擅长在各方和物联网设备之间建立纳什均衡，并为供应链上的各方提供信任机制。</li>
<li>利用标准区块链网络提供概念证明，以证明我们提出的想法的可行性。</li>
</ol>
</li>
<li>我的问题：<ol>
<li>很好奇这个数学证明和概念证明是什么样的</li>
<li>博弈方是哪些，收益函数是怎么设计的</li>
</ol>
</li>
<li>是否详细阅读：让学生看，结合前面绿色供应链的。</li>
</ol>
<h1 id="Experimental-relativistic-zero-knowledge-proofs"><a href="#Experimental-relativistic-zero-knowledge-proofs" class="headerlink" title="Experimental relativistic zero-knowledge proofs"></a>Experimental relativistic zero-knowledge proofs</h1><ol>
<li>作者、期刊、发表时间：Alikhani, P., Brunner, N., Crépeau, C. et al. nature 2021</li>
<li>关键词：无</li>
<li>研究背景和问题：泄漏秘密对于证明身份or证明陈述正确性是否是必要的？</li>
<li>研究方法：零知识证明的实验实现，是针对三色图问题做的实验</li>
<li>论文结论：零知识证明协议在实验上是可靠的</li>
<li>创新与贡献：从实验角度证明了零知识证明？</li>
<li>我的问题：完全没理解零知识证明是怎么和量子计算产生的联系，感觉这篇论文更偏向物理学</li>
<li>是否详细阅读：否</li>
</ol>
<h1 id="Privacy-Preserving-Prompt-Tuning-for-Large-Language-Model-Services"><a href="#Privacy-Preserving-Prompt-Tuning-for-Large-Language-Model-Services" class="headerlink" title="Privacy-Preserving Prompt Tuning for Large Language Model Services"></a>Privacy-Preserving Prompt Tuning for Large Language Model Services</h1><ol>
<li>作者、期刊、发表时间：Yansong Li, Zhixing Tan, and Yang Liu. arxiv. 2023</li>
<li>关键词：</li>
<li>研究背景和问题：LLM的prompt可能会泄露隐私，现有的隐私保护一方面依赖于服务提供商，另一方面不可避免地导致模型性能下降。</li>
<li>研究方法：<ol>
<li>基于即时调优，我们提出了隐私保护即时调优（RAPT），这是一个为LLM服务提供隐私保证的框架。 </li>
<li>RAPT采用本地隐私设置，允许用户通过本地差分隐私在本地对其数据进行私有化。</li>
<li>由于直接在私有化数据上训练时提示调整表现不佳，因此我们引入了一种新颖的私有化令牌重建任务，该任务与下游任务联合训练，使LLM能够学习更好的依赖于任务的表示。</li>
</ol>
</li>
<li>论文结论：实验表明 RAPT 在跨任务中实现了有竞争力的性能，同时提供了针对对手的隐私保证。</li>
<li>创新与贡献：设计了隐私保护框架</li>
<li>我的问题：对这个领域了解太少，还要再多看看</li>
<li>是否详细阅读：是</li>
</ol>
<h1 id="Privacy-Preserving-Large-Language-Models-ChatGPT-Case-Study-Based-Vision-and-Framework"><a href="#Privacy-Preserving-Large-Language-Models-ChatGPT-Case-Study-Based-Vision-and-Framework" class="headerlink" title="Privacy   Preserving Large Language Models: ChatGPT Case Study Based Vision and Framework"></a>Privacy   Preserving Large Language Models: ChatGPT Case Study Based Vision and Framework</h1><ol>
<li>作者、期刊、发表时间：Imdad Ullah, Najm Hassan, Sukhpal Singh Gill, Basem Suleiman, Tariq Ahamed Ahanger, Zawar Shah, Junaid Qadir, and Salil S. Kanhere. arxiv, 2023年10月</li>
<li>关键词：Artificial Intelligence, Generative AI tools, Privacy, ChatGPT, Large Language Models (LLMs), Machine learning</li>
<li>研究背景和问题：LLM对用户隐私造成威胁</li>
<li>研究方法：<ol>
<li>提出了称为 PrivChatGPT 的概念模型，由两个主要组成部分组成，即在数据管理/预处理期间保护用户隐私，以及保护私有上下文和大规模数据的私有训练过程。</li>
<li>采用了差分隐私和使用强化学习（RL）的私有训练。一旦应用差分隐私，我们就会测量隐私损失并评估不确定性或随机性的度量。在每次更新期间，当出于训练目的添加新信息时，它进一步递归地评估隐私保护的水平以及公共数据库和资源的不确定性度量。</li>
<li>为了批判性地评估差分隐私对LLM的使用，我们假设比较了其他机制，例如区块链、私人信息检索、随机化、混淆、匿名化，以及使用 ToR 进行各种性能衡量，例如模型性能和准确性、计算复杂性、隐私与实用性、训练延迟、易受攻击的漏洞以及资源消耗。</li>
</ol>
</li>
<li>论文结论：<ol>
<li>差分隐私、随机化和混淆会影响训练模型的实用性和性能</li>
<li>相反，ToR、区块链和 PIR 的使用可能会带来额外的计算复杂性和高训练延迟</li>
</ol>
</li>
<li>创新与贡献：引入 PrivChatGPT<ol>
<li>数据管理和预处理过程中保护用户隐私，纳入私有上下文</li>
<li>利用从 PrivChatGPT 第一部分获得的私有数据，使用大规模数据确保整个训练过程中的隐私保护</li>
</ol>
</li>
<li>我的问题：<ol>
<li>差分隐私的具体应用方式</li>
<li>和其他机制比较的时候是怎么做的</li>
</ol>
</li>
<li>是否详细阅读：先大致读一遍，不做记录</li>
</ol>
<h1 id="EW-Tune-A-Framework-for-Privately-Fine-Tuning-Large-Language-Models-with-Differential-Privacy"><a href="#EW-Tune-A-Framework-for-Privately-Fine-Tuning-Large-Language-Models-with-Differential-Privacy" class="headerlink" title="EW-Tune: A Framework for Privately Fine-Tuning Large Language Models with Differential Privacy"></a>EW-Tune: A Framework for Privately Fine-Tuning Large Language Models with Differential Privacy</h1><ol>
<li>作者、期刊、发表时间：Rouzbeh Behnia, Mohammadreza (Reza) Ebrahimi, Jason Pacheco. arxiv, 2022年10月</li>
<li>关键词：Differential privacy, large language models, ﬁnetuning, Edgeworth accountant</li>
<li>研究背景和问题：大模型容易受到成员推断、模型反演和训练数据提取这三类隐私攻击</li>
<li>研究方法：提出了基于差分隐私的通用框架EW-Tune，计算需要添加到随机梯度下降中的噪声量，以保证一定的隐私预算</li>
<li>论文结论：EW-Tune 能够通过引入比现有方法更少的噪声来提供有限样本隐私保证</li>
<li>创新与贡献：<ol>
<li>在相同的隐私预算下，EW-Tune 与最先进的方法相比，能减少 SGD 的噪声。这直接提高了模型的学习能力和准确性。</li>
<li>在文本分类、引申检测和问题解答等几个重要的下游基准任务中，EW-Tune 与最近的多种替代方法相比，在提高 LLM 的私密性的同时，还能保持其实用性/准确性，对提升技术水平做出了显著贡献。</li>
<li>总体而言，EW-Tune 将 SGD 的噪声系数降低了 5.6%。EW-Tune 还将最先进模型的准确率提高了 1.1%。</li>
</ol>
</li>
<li>我的问题：粗略看了一下方法，似乎核心是一个叫Edgeworth Accountant的算法，查了一下另一篇论文提出的方法，似乎还没发表。之后可能要看看。</li>
<li>是否详细阅读：否</li>
</ol>
<h1 id="Differentially-Private-Decoding-in-Large-Language-Models"><a href="#Differentially-Private-Decoding-in-Large-Language-Models" class="headerlink" title="Differentially Private Decoding in Large Language Models"></a>Differentially Private Decoding in Large Language Models</h1><ol>
<li>作者、期刊、发表时间：Jimit Majmudar Christophe Dupuy Charith Peris Sami Smaili Rahul Gupta Richard Zemel. arxiv. 2022年9月</li>
<li>关键词：无</li>
<li>研究背景和问题：一方面大语言模型面临隐私泄露的问题，另一方面，隐私保护算法往往需要重头开始训练模型，成本过高</li>
<li>研究方法：一种简单、易于解释且计算量轻的扰动机制，可应用于解码阶段已训练的模型。我们的扰动机制与模型无关，可以与任何LLM结合使用。</li>
<li>论文结论：所提出的机制具有差分隐私的特性，实验结果显示隐私与效用之间的权衡。</li>
<li>创新与贡献：<ol>
<li>我们提出了一种基于输出概率分布扰动的 LLM 中 DP 预测的简单且计算量轻的方法，并表明我们的方法是差分隐私的。</li>
<li>我们将我们的方法应用于预训练的LLM，并比较对性能和隐私的影响。</li>
</ol>
</li>
<li>我的问题：简单来说是在预测阶段用差分隐私，具体怎么实现的还没细看。</li>
<li>是否详细阅读：否</li>
<li>补充解释：具体来说，语言模型预测下一个词时，会输出一个概率分布向量，表示各个词被预测作为下一个词的概率。该机制将这个概率向量与均匀分布向量进行线性插值，得到一个扰动后的概率分布。然后根据这个扰动后的分布随机采样，得到预测词。理论证明了，这种扰动机制满足差分隐私的定义。因为扰动后的概率分布不太依赖于训练数据中的单个数据点，所以对抗性查询的输出也不会泄露单个训练数据点的信息。</li>
</ol>
<h1 id="Deduplicating-Training-Data-Mitigates-Privacy-Risks-in-Language-Models"><a href="#Deduplicating-Training-Data-Mitigates-Privacy-Risks-in-Language-Models" class="headerlink" title="Deduplicating Training Data Mitigates Privacy Risks in Language Models"></a>Deduplicating Training Data Mitigates Privacy Risks in Language Models</h1><ol>
<li>作者、期刊、发表时间：Nikhil Kandpal, Eric Wallace, Colin Raffel. arxiv. 2022年12月</li>
<li>关键词：无</li>
<li>研究背景和问题：大规模语言模型容易泄露其训练数据的隐私信息。Carlini等人(2021)提出的模型反转攻击就是利用语言模型生成大量文本,然后利用成员推断方法判断哪些生成序列来自训练数据。本文研究这种攻击的成功与训练数据中序列级重复的关系。</li>
<li>研究方法：<ol>
<li>分析重复次数与模型再生训练序列的关系;</li>
<li>分析重复次数与成员推断方法的检测效果关系;</li>
<li>直接测试在去重数据上重新训练的模型的隐私风险。</li>
</ol>
</li>
<li>论文结论：<ol>
<li>模型再生训练序列与序列在训练数据中的重复次数呈超线性关系;</li>
<li>成员推断方法主要检测出重复多次的序列;</li>
<li>在去重数据上训练的模型泄露的训练数据更少，成员推断效果较差。</li>
</ol>
</li>
<li>创新与贡献：首次系统研究训练数据重复与语言模型隐私攻击成功率之间的关系,提出训练数据重复是模型反转攻击成功的一个重要原因,训练数据去重可以降低隐私风险。</li>
<li>我的问题：<ol>
<li>近似重复的影响如何？本文只研究完全相同序列的重复；</li>
<li>图像和代码训练数据中重复与隐私攻击的关系需要进一步理解。</li>
</ol>
</li>
<li>是否详细阅读：略读</li>
</ol>
<h1 id="ProPILE-Probing-Privacy-Leakage-in-Large-Language-Models"><a href="#ProPILE-Probing-Privacy-Leakage-in-Large-Language-Models" class="headerlink" title="ProPILE: Probing Privacy Leakage in Large Language Models"></a>ProPILE: Probing Privacy Leakage in Large Language Models</h1><ol>
<li>作者、期刊、发表时间：Siwon Kim, Sangdoo Yun, Hwaran Lee, Martin Gubri, Sungroh Yoon, Seong Joon Oh. arxiv. 2023年7月</li>
<li>关键词：无</li>
<li>研究背景和问题：随着大语言模型(LLMs)的快速发展和广泛应用,人们越来越担心这些模型可能会泄露个人身份信息(PII)。这些模型通常使用从网络上大规模抓取的数据进行训练,这些数据可能无意中包含了个人网页、社交媒体、论坛个人信息以及企业内部邮件等中的敏感个人数据。</li>
<li>研究方法：提出了一个新颖的工具ProPILE,用于探测LLM服务中潜在的PII泄露。ProPILE让数据主体可以根据自己的PII构建提示,来评估LLM泄露PII的可能性。作者演示了在Pile数据集上训练的OPT-1.3B模型上的应用案例。</li>
<li>论文结论：<ol>
<li>通过精心设计的提示,可以泄露训练数据中包含的多种类型的PII的很大一部分。</li>
<li>通过改进提示、获取模型参数以及利用几百个训练数据点,可以显著放大PII泄露程度。</li>
</ol>
</li>
<li>创新与贡献：ProPILE可以让数据主体和LLM服务提供商有效评估自己的PII泄露程度。</li>
<li>我的问题：是不是应该在训练阶段就去掉涉及身份信息的数据？</li>
<li>是否详细阅读：之后看一下具体的攻击模型</li>
</ol>
<h1 id="Privacy-Preserving-Recommender-Systems-with-Synthetic-Query-Generation-using-Differentially-Private-Large-Language-Models"><a href="#Privacy-Preserving-Recommender-Systems-with-Synthetic-Query-Generation-using-Differentially-Private-Large-Language-Models" class="headerlink" title="Privacy-Preserving Recommender Systems with Synthetic Query Generation using Differentially Private Large Language Models"></a>Privacy-Preserving Recommender Systems with Synthetic Query Generation using Differentially Private Large Language Models</h1><ol>
<li>作者、期刊、发表时间：ALDO GAEL CARRANZA,  REZSA FARAHANI, NATALIA PONOMAREVA,  ALEX KURAKIN, MATTHEW JAGIELSKI, MILAD NASR. arxiv. 2023年5月</li>
<li>关键词：large language models, differential privacy, synthetic data generation, recommender systems</li>
<li>研究背景和问题：推荐系统存在隐私泄露问题</li>
<li>研究方法：用了基于差分隐私的LLM来做推荐查询。<ol>
<li>采用基于使用 DP 大语言模型 (LLM) 的合成数据生成框架来开发一种私有文本数据共享方法，用于训练具有查询级隐私的任何下游推荐系统。</li>
<li>使用 DP 训练方法来微调（或第二阶段预训练）在文档条件查询生成任务上公开预训练的生成 LLM，给定由匹配的查询文档对组成的私人推荐数据集。</li>
<li>微调时采用差分私有随机梯度下降（DP-SGD）</li>
</ol>
</li>
<li>论文结论：更大的模型可以在相同的隐私级别下提高性能。隐私合成文本生成代表了隐私保护大规模推荐系统发展的重要一步</li>
<li>创新与贡献：<ol>
<li>我们提出了一种训练查询级隐私保护推荐系统的新方法。我们的方法涉及使用 DP 微调的 LLM 生成合成查询数据，并使用此私有合成数据来训练下游推荐系统，而无需对标准训练流程进行任何修改。 </li>
<li>总的来说，我们的方法提出了一种为具有非示例可分解损失的模型获得 DP 保证的新方法，例如大规模多阶段推荐系统中普遍存在的对比损失。 </li>
<li>通过大量的实验，我们凭经验证实我们的方法生成的合成数据确实是查询级隐私保护的，并且我们证明使用这种私有合成数据训练的下游深度检索模型与标准 DP 训练方法相比具有出色的性能。</li>
</ol>
</li>
<li>我的问题：概括理解一下应该是用LMM做数据生成，然后再用生成的数据训练模型来做推荐。没有什么问题。</li>
<li>是否详细阅读：否</li>
</ol>
<h1 id="The-imperative-for-regulatory-oversight-of-large-language-models-or-generative-AI-in-healthcare"><a href="#The-imperative-for-regulatory-oversight-of-large-language-models-or-generative-AI-in-healthcare" class="headerlink" title="The imperative for regulatory oversight of large language models (or generative AI) in healthcare"></a>The imperative for regulatory oversight of large language models (or generative AI) in healthcare</h1><ol>
<li>作者、期刊、发表时间：Bertalan Meskó, Eric J. Topol. nature digital medicine. 2023年6月</li>
<li>关键词：无</li>
<li>研究背景和问题：近年来LLM如OpenAI的GPT-4和谷歌的Bard等的快速发展,为医疗保健带来了巨大的应用潜力。同时也带来了各种风险,如提供不可靠或错误信息、偏见、数据隐私等。因此亟需建立监管框架,确保LLM的安全和道德使用。</li>
<li>研究方法：总结了LLM与已监管的其他AI技术的区别,概述了FDA对AI技术的现有监管情况,讨论了LLM在医疗中的应用实例,指出LLM监管面临的挑战,并提出了监管建议。</li>
<li>论文结论：<ol>
<li>LLM有别于其他AI技术,需要建立独特的监管类别</li>
<li>监管应关注可能的未来迭代,不仅包括文本,还包括声音、图像等</li>
<li>监管应聚焦于开发LLM的公司,而不是每个迭代版本</li>
</ol>
</li>
<li>创新与贡献：深入剖析了LLM的独特特征,系统地讨论了其在医疗保健中的应用与风险,并提出了切实可行的监管建议。</li>
<li>我的问题：这篇没啥技术内容，没有问题</li>
<li>是否详细阅读：否</li>
</ol>
<h1 id="Just-Fine-tune-Twice-Selective-Differential-Privacy-for-Large-Language-Models"><a href="#Just-Fine-tune-Twice-Selective-Differential-Privacy-for-Large-Language-Models" class="headerlink" title="Just Fine-tune Twice: Selective Differential Privacy for Large Language Models"></a>Just Fine-tune Twice: Selective Differential Privacy for Large Language Models</h1><ol>
<li>作者、期刊、发表时间：Weiyan Shi, Ryan Shea, Si Chen, Chiyuan Zhang, Ruoxi Jia, Zhou Yu. arxiv. 2022年10月</li>
<li>关键词：</li>
<li>研究背景和问题：与隐私保护相关的大语言模型面临泄露隐私信息的风险。然而,应用差分隐私来保护这些模型仍面临模型效用与隐私损失之间的权衡。语言数据中的敏感信息往往比较稀疏,这为选择性地只保护敏感信息提供了可能。</li>
<li>研究方法：作者提出了“Just Fine-tune Twice”(JFT)方法,它包含两个微调阶段<ol>
<li>首先用去识别敏感信息的数据微调模型;</li>
<li>然后用包含敏感信息的原始数据和隐私优化器继续微调模型。</li>
<li>该方法可以为大型语言模型实现选择性差分隐私。作者还设计了不同级别的隐私检测器,研究它们对结果模型的影响。</li>
</ol>
</li>
<li>论文结论：结果表明,即使在保守的上下文检测器下(30%以上的标记被编辑),JFT仍能取得比简单的差分隐私SGD更好的结果。尽管数据规模小,使用手动筛选的定域数据仍能提高模型效用。加上轻噪声优化器和隐私放大,也能保护未检测到的敏感标记。</li>
<li>创新与贡献：论文为大型语言模型实现了选择性差分隐私,设计了不同级别的秘密检测器,研究了它们的影响,并解决了未检测到的敏感标记的问题。</li>
<li>我的问题：其实没看明白两次调优是怎么结合的，看起来是对敏感信息加密，其他信息不加密，然后参与训练调优。</li>
<li>是否详细阅读：否</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Cooperative Multi-Agent Game Based on Reinforcement Learning</title>
    <url>/2023/10/18/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Cooperative%20Multi-Agent%20Game%20Based%20on%20Reinforcement%20Learning/</url>
    <content><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><ol>
<li>多主体控制研究普遍用计算机游戏来测试</li>
<li>现有多智能体强化学习算法面临问题;<ol>
<li>需要大量资源和时间</li>
<li>没有重视智能体之间的通信</li>
<li>难以应对奖励少的挑战</li>
</ol>
</li>
<li>本文：关注智能体协作，分为三阶段策略：<ol>
<li>具有反事实基线的中央评估网络，评估每个智能体的独立动作，同时大大降低了计算复杂度</li>
<li>图双层注意力网络：管理智能体之间的通信信号，通过促进有效的沟通，该网络提高了决策的准确性和效率</li>
<li>基于势函数的奖励塑造方法，旨在提高算法的收敛速度和稳定性，同时适应奖励稀疏的环境<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1></li>
</ol>
</li>
<li>评委网络：<ol>
<li>输入其他智能体的动作、环境的状态、智能体的观察、正在计算的智能体的数量以及当前智能体在前一次的动作</li>
<li>输出当前智能体的每个动作的一组动作值函数</li>
</ol>
</li>
<li>演员网络：输入来自环境的观察向量并输出每个动作的概率分布。计算出向量后，可以使用贪婪策略或探索策略来选择动作</li>
<li>通信单元：使用循环神经网络对每个智能体的观察进行编码，并将其作为通信信号在智能体之间传输信息<h2 id="具有反事实基线的评委网络"><a href="#具有反事实基线的评委网络" class="headerlink" title="具有反事实基线的评委网络"></a>具有反事实基线的评委网络</h2>这部分直接用了文献23的算法，目前来看没创新，简单记录一下：</li>
<li>传统MAAC算法在智能体变多时，网络规模指数增长；</li>
<li>文献23的算法解决了这个问题。</li>
</ol>
<p>不过根据我查到的资料，似乎MAAC是在文献23的基础上做的，感觉不太对劲。</p>
<h2 id="具有图注意力网络的演员网络"><a href="#具有图注意力网络的演员网络" class="headerlink" title="具有图注意力网络的演员网络"></a>具有图注意力网络的演员网络</h2><p>基于图形注意力网络设计了一种带有通信模块的Actor网络结构，在保持Agent独立性的同时增加了处理通信信号的能力。</p>
<h1 id="具有反事实基线的多主体演员-评委"><a href="#具有反事实基线的多主体演员-评委" class="headerlink" title="具有反事实基线的多主体演员-评委"></a>具有反事实基线的多主体演员-评委</h1><h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><ol>
<li>MADDPG引入策略梯度算法，但是有局限性，不能解决去中心化问题，且网络很大，训练成本高</li>
<li>为了解决这个问题，文献27设计了参数共享</li>
<li>基于一些原因，本文目标：设计一种AC算法<ol>
<li>Actor网络以agent的观察历史序列和动作历史序列作为输入，输出动作的概率分布； </li>
<li>Critic网络以所有智能体的全局状态、观察历史序列、联合动作历史序列和Actor网络的策略作为输入，输出智能体所采取的动作的状态值函数。</li>
</ol>
</li>
<li>Critic网络可以使用𝑇𝐷(𝜆)[28]进行训练。它根据当前状态的奖励和接下来𝑛步骤获得的奖励计算加权累积收益，并可以根据从当前状态到终止状态的所有状态更新当前状态的状态值函数。</li>
<li>Actor网络直接使用策略梯度方法来更新网络，但是这样集中式的训练使得大家共享同一个网络，没考虑信用值，有误差</li>
<li>文献29引入了差异奖励的思想，用了不同的奖励函数。</li>
<li>由此需要计算默认行为带来的奖励，然后和实际行为作比较。但是一般来说是没法获取默认行为的结果，因此文献23设计了反事实奖励函数</li>
<li>结合上述内容，本文设计了CMAC算法，算法主体采用MAAC结构。<ol>
<li>Critic网络获取当前时刻其他智能体的动作、状态、观察值、正在计算的智能体的数量以及当前智能体在上一时刻的动作，并为每个动作输出一组动作值现任代理人。 </li>
<li>Actor网络获取环境的观察向量并输出每个动作的概率分布。可以使用贪婪策略或探索策略来选择操作。<h1 id="基于图注意力网络的通信模块"><a href="#基于图注意力网络的通信模块" class="headerlink" title="基于图注意力网络的通信模块"></a>基于图注意力网络的通信模块</h1></li>
</ol>
</li>
<li>总体而言：<ol>
<li>首先，我们使用硬注意力网络来过滤需要通信的代理</li>
<li>然后使用自注意力[30]网络对通信信号进行加权</li>
<li>通过两阶段注意力，我们通过降低计算成本和提高信息的信噪比来整合复杂的通信信号，从而在不影响Actor网络的情况下实现Agent之间的通信</li>
</ol>
</li>
<li>多智能体模型下，每个智能体存在局限性，会影响整个系统。因此通信是必要的。</li>
<li>本文提出图注意力通信单元：<ol>
<li>使用 BiGRU 的编码层，对观测信息编码</li>
<li>硬注意力层。该层通过编码层的编码输出$h_{i,j}$来决定$agent_i$和$agent_j$之间通信的必要性，用了文献31的方法</li>
<li>自注意力层。该层的输入是代理观察$e=[e_1,e_2, ⋯ ,e_n]$的编码，输入向量的注意力权重由自注意力网络计算。通过这个网络，来自不同代理的通信信号被加权。自注意力机制对过滤后的通信信号的重要性进行判断，使得重要信号在隐藏状态具有较高的权重。</li>
<li>输出层。它将隐藏状态$e$与前一层的$W_h$和$W_{sj}$ 输出聚合，并生成扩展的隐藏状态向量。然后它使用MLP对向量进行解码，并输出策略𝜋，它是代理每个可能动作的动作概率.<h1 id="基于势函数的奖励塑造"><a href="#基于势函数的奖励塑造" class="headerlink" title="基于势函数的奖励塑造"></a>基于势函数的奖励塑造</h1>本节设计了基于静态和动态势能的奖励塑造函数，以解决策略学习速度慢、效果差的问题。在引入先验知识和对环境的认知后，设计了一种人为增加势能差的奖励函数来辅助学习算法，将先验知识转化为额外的奖励，从而指导所提出的学习算法学习得更快更好。<h2 id="静态势函数"><a href="#静态势函数" class="headerlink" title="静态势函数"></a>静态势函数</h2>结构很简单，我方当前血量+我方存活单元-敌方当前血量-敌方存活单元。与仅从一种奖励函数中学习相比，智能体通过拉开智能体健康状况的距离来积累优势来学习如何玩游戏，而不是采取随机行动。<h2 id="动态势函数"><a href="#动态势函数" class="headerlink" title="动态势函数"></a>动态势函数</h2>动态势能函数则考虑到同一状态的势能可能随时间的推移而变化，同一状态转换可能具有不同的奖励，在静态函数的基础上增加了能量损失速度的控制变量和随时间变的权重函数（描述时间流所带来的敌人状态重要性的变化）。势函数的设计围绕一系列游戏规则展开。<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1></li>
</ol>
</li>
<li>在基于星际争霸2的游戏平台进行实验，和游戏内置AI对打</li>
<li>对比结果说明这个方法胜率高</li>
</ol>
<h1 id="总体意见"><a href="#总体意见" class="headerlink" title="总体意见"></a>总体意见</h1><ol>
<li><p>内容概述：<br>With the advancement of technology, multi-agent reinforcement learning (MARL) has been extensively applied across various domains. To effectively address challenges in MARL, this paper investigates a multi-agent Actor-Critic framework based on graph attention networks. By refining the reward allocation mechanism, communication and collaboration modality, as well as reward function design, this algorithm enhances performance. Experiments in the StarCraft multi-agent environment demonstrate over 95% winning rate.</p>
</li>
<li><p>strength：</p>
<ol>
<li>The paper proposes a novel algorithm GACMAC using graph attention networks to enhance collaboration among multiple agents in reinforcement learning.</li>
<li>The innovations of the paper lie in utilizing counterfactual baseline and graph attention networks to strengthen cooperation among agents, and incorporating potential-based reward shaping to accelerate algorithm convergence.</li>
<li>Experiments on the StarCraft multi-agent platform demonstrate the validity of the methods. The algorithm shows certain novelty and practical values.</li>
<li>The figures in the paper vividly illustrate the framework and architecture of the proposed algorithm, which helps explain the algorithm flow and components effectively.</li>
</ol>
</li>
<li><p>weakness：</p>
<ol>
<li>The paper does not sufficiently explain the main differences between the proposed GACMAC algorithm and existing algorithms such as MAAC and COMA in terms of theory, network structure, etc. It is recommended that the author adds more comparisons and discussions in this aspect.（去掉）</li>
<li>The references are not new enough, with most dated before 2021, failing to reflect the latest progress in the field over the past two years. It is recommended that the authors add some references from the last two years.</li>
<li>It is suggested that the notational representation used in this paper be introduced first in the System framework section, thus making it easier for the reader to understand the algorithmic framework illustrated in Figure 1.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>审稿意见</tag>
        <tag>reinforcement learning</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-SoK: Decentralized Finance (DeFi) Attacks</title>
    <url>/2023/10/11/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-SoK%20Decentralized%20Finance%20(DeFi)%20Attacks/</url>
    <content><![CDATA[<h1 id="SoK-Decentralized-Finance-DeFi-Attacks"><a href="#SoK-Decentralized-Finance-DeFi-Attacks" class="headerlink" title="SoK: Decentralized Finance (DeFi) Attacks"></a>SoK: Decentralized Finance (DeFi) Attacks</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文：</p>
<ol>
<li>建立通用的参考框架来系统地评估和比较 DeFi 事件，包括攻击和事故</li>
<li>很少有学术论文讨论“价格预言机攻击”和“未经许可的交互”，而我们的数据表明它们是两种最常见的事件类型</li>
<li>调查了潜在的防御，并发现：<ol>
<li>103 (56%) 的攻击不是自动执行的，为防御者提供了救援时间； </li>
<li>字节码相似性分析至少可以检测 31 个易受攻击的合约/23 个对抗性合约；</li>
<li>33 (15.3%) 的对手通过与中心化交易所交互而泄露了潜在的可识别信息。<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2></li>
</ol>
</li>
<li>提出了DeFi框架</li>
<li>区分攻击者和防御者</li>
<li>防御意外</li>
<li>追踪资金来源<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2></li>
</ol>
<h3 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h3><h4 id="网络层：传输数据"><a href="#网络层：传输数据" class="headerlink" title="网络层：传输数据"></a>网络层：传输数据</h4><ol>
<li>通信基础：TCP/IP、DNS等</li>
<li>区块链和P2P网络：节点如何加入、退出、发现其他节点</li>
<li>FaaS：让交易者不通过P2P广播的方式就能直接将交易提交给矿工，提供捆绑级原子状态转换<h4 id="共识层："><a href="#共识层：" class="headerlink" title="共识层："></a>共识层：</h4></li>
<li>共识机制：帮助区块链网络中的节点达成一致性<ol>
<li>一个抗 Sybil 攻击的Leader选举协议，例如PoW和PoS</li>
<li>最新链同步协议，例如最长链</li>
<li>CON激励机制：包括挖矿奖励和交易费在内的对良性共识的鼓励，</li>
</ol>
</li>
<li>节点及其操作协议：节点负责交易排序、区块生成、数据验证、数据传播，可分为以下两类<ol>
<li>排序器节点，即PoW中的矿工或PoS中的验证器，承担上述所有四个功能。排序器可以在协议允许的范围内插入、省略和重新排序其生成的区块中的交易； </li>
<li>普通节点，仅执行区块链数据传播，并且可以执行数据验证。<h4 id="合约层："><a href="#合约层：" class="headerlink" title="合约层："></a>合约层：</h4></li>
</ol>
</li>
<li>交易：用户在交易中指定财务操作以请求区块链状态转换。 SC层通常支持交易级原子状态转换，其中同一交易中的所有财务操作要么全部执行，要么集体失败。</li>
<li>状态：DeFi 系统状态 S 指明 (i) 用户的加密货币资产余额，(ii) 区块链信息，如时间戳、coinbase 地址、区块编号、区块气体限制（每个区块的最大计算单位），以及 (iii) DeFi 应用程序状态。</li>
<li>状态转换：$\mathcal{T}(S\in S,tx\in TX)\rightarrow S$是状态转换函数，表示执行交易tx后返回了新状态，其中TX表示所有有效DeFi交易集合。</li>
<li>智能合约：智能合约是将代码转换成一个或多个状态转换函数，然后由交易触发。智能合约还可以触发其他合约的功能。在部署时，构造函数可以初始化合约的状态。</li>
<li>区块状态转换（非通用）：以太坊和 BNB 智能链都用有序的区块列表记录交易。我们用 B 表示区块集合，用 $b_i\in B$ 表示高度为$i$的区块。每个区块$b_i$可能包括$n$个交易列表，用$\{tx^0_{b_i},…,tx^n_{b_i}\}$ 表示，$n\geq0$。区块状态$S(b_{i+1})$ 源自区块$b_{i+1}$ 中所有事务在$S(b_i)$上的顺序执行：$S(b_{i+1})=\mathcal{T}(…\mathcal{T}(\mathcal{T}(S(b_i),tx^0_{b_{i+1}}),tx^1_{b_{i+1}})…)$。</li>
<li>智能合约和L2激励机制（非通用）：DeFi 协议可以L2系统上运行，例如侧链、提交链或其灵感继承者optimistic-rollups和zk-rollups。由于 L2 系统是在第 1 层区块链（也称为 L1，如以太坊和 BNB 智能链）之上创建的，因此 L2 系统通常会在 L1 区块链的 SC 层上实施共识激励机制，以鼓励良性活动。<h4 id="协议层：部署在合约层的DeFi协议集合"><a href="#协议层：部署在合约层的DeFi协议集合" class="headerlink" title="协议层：部署在合约层的DeFi协议集合"></a>协议层：部署在合约层的DeFi协议集合</h4></li>
<li>加密货币协议：数字资产标准，如ERC-20</li>
<li>金融协议：区块链的独特功能（如透明度、原子性和离散批量交易执行）使得与CeFi不同的新颖设计成为可能</li>
<li>协议层激励机制：DeFi协议可能会引入PRO激励机制，以鼓励所需的用户行为。其中一个例子是空投治理代币，以换取在去中心化交易所中提供流动性<h4 id="辅助层：提供服务以提升系统效率"><a href="#辅助层：提供服务以提升系统效率" class="headerlink" title="辅助层：提供服务以提升系统效率"></a>辅助层：提供服务以提升系统效率</h4>辅助服务指任何需要或有助于提高 DeFi 效率，但不属于上述四个系统层（即 NET、CON、SC 和 PRO）的实体。例如，运行中的 DeFi 协议实施可能由以下部分组成： (i) 前端代码；(ii) 实现协议设计的项目开发人员；(iii) 具有管理权限的 “操作员”，例如部署代码、升级协议、冻结或停止运行中的 DeFi 协议活动的权限；(iv) 从中心化交易所同步价格数据到链上智能合约的链下 Oracle 服务等。<h3 id="威胁模型"><a href="#威胁模型" class="headerlink" title="威胁模型"></a>威胁模型</h3></li>
<li>DeFi事件：事件是指导致以下一个或多个实体遭受意外经济损失的一系列行为： (i) 用户； (ii) 流动性提供者； (iii) 投机者；或 (iv) 运营商。我们将事件分为以下两类：<ol>
<li>攻击：对手 A 可能会利用漏洞，试图禁用、延迟或改变 DeFi 协议的预期状态转换。尽管所有五个系统层都存在漏洞，但 DeFi 漏洞最常见于以下三个层：<ol>
<li>合约层：编码错误造成的，例如算术错误、转换错误、访问控制不一致、函数重入等</li>
<li>协议层：类似于金融市场操纵，而不是传统的系统漏洞（即协议设计缺陷，例如不安全的外部协议依赖性或交互）</li>
<li>辅助层：包括操作漏洞（例如链下预言机操纵、私钥泄露等）和“信息不对称”攻击（例如后门、蜜罐、网络钓鱼等）。一般来说，我们观察到用户在提供金融资产之前可能并不总是（或可能无法）检查和理解 DeFi 协议智能合约，更不用说评估其安全性和风险了。因此，用户对合约操作的理解可能主要基于营销传播，而不是实际的合约源代码，从而导致用户遇到不可预见或意外的情况。</li>
</ol>
</li>
<li>事故：任何未明确涉及主动对手的事件都被归类为 DeFi 事故。例如，由于无意的编码错误，用户的资金可能会被永久锁定在合约中。</li>
</ol>
</li>
<li>对抗效用目标：假设对抗者理性<ol>
<li>货币：货币效用函数定义为 A 的加密货币资产组合的市场价值总增量，对抗者旨在最大化该投资组合。</li>
<li>非货币：对抗者可能会最大化非货币效用，例如成就感或声誉。 DeFi 白帽黑客（也称为道德黑客）是非货币对抗的一个例子，他们发起对抗，试图将 DeFi 事件的损失降到最低</li>
</ol>
</li>
<li>对抗知识：对抗者具有的信息<ol>
<li>公开信息：<ol>
<li>原始链上数据，如区块、大区块、交易、账户、余额和已部署的智能合约代码；</li>
<li>原始网络数据，如 P2P 网络转发行为、待处理区块、已丢弃的过期区块、区块链节点 IP 地址、端口号、客户端版本字符串等； </li>
<li>公共侧渠道，如开源智能合约代码、社交媒体/聊天信息；</li>
<li>公开数据分析，如推断的网络拓扑结构、估计的序列器位置和反编译的智能合约字节码。</li>
</ol>
</li>
<li>排序器： 如果对抗者是/与排序器有联系，则对抗者会获得以下信息：<ol>
<li>来自私人通信渠道的待处理交易；</li>
<li>相应排序器的交易排序逻辑，包括贿赂偏好；</li>
<li>如果相应排序器生成下一个区块，则在广播前提前访问区块状态。</li>
</ol>
</li>
<li>内幕信息：例如，如果对抗者能提前获得外部市场价格、预言机更新或操作员的钱包密码，就可能出现特权信息不对称。</li>
</ol>
</li>
<li>对抗能力：具有不同知识水平的 A 可能能够实现相同的能力。例如，排序器可以控制其生成的块的交易顺序（K2），而没有排序器知识的对抗者也可以通过在公共区块链 P2P 网络上竞争来执行前/后运行（K1）。<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2>本文数据集来源于大量学术论文、审计报告、以太坊和BSC的区块链事件，就不记录具体细节了。<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2></li>
<li>事件频率随时间推移增加</li>
<li>分析了不同协议类型发生事件的比例，与稳定币和借贷相关的协议问题明显更多</li>
<li>用SEM分析了变量之间的因果关系，包括一个内生/因变量（即伤害）和三个外生/自变量（即资产、预防性防御和反应性防御）</li>
<li>探讨了紧急暂停机制的有效性（看起来没什么用）</li>
<li>分析了安全审计的有效性：有点用，但样本太少，不确定到底多有用。<h2 id="事件防御"><a href="#事件防御" class="headerlink" title="事件防御"></a>事件防御</h2></li>
<li>执行时间范围：过半的攻击不是自动执行的，因此有时间救援，最短一小时，最多25天</li>
<li>字节码相似度分析：用于识别对抗性合约</li>
<li>FaaS的使用：套利、私人对抗</li>
<li>资金追踪：追踪从地址X到Y的交易，目前没有基于账户的资金追踪。资金来源如下：<ol>
<li>中心化交易所：满足一定条件，反洗钱服务等会直接要求交易所泄露个人信息</li>
<li>混币器</li>
<li>跨链桥<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2></li>
</ol>
</li>
<li>DeFi事件：防御者试图最小化安全风险面，而攻击者则突破防御。</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
        <tag>defi</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-A Survey on Applications of Game Theory in Blockchain</title>
    <url>/2023/10/03/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-A%20Survey%20on%20Applications%20of%20Game%20Theory%20in%20Blockchain/</url>
    <content><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><ol>
<li>区块链引入博弈论的背景：<ol>
<li>区块链需要大量共识节点参与网络</li>
<li>理性节点会执行旨在最大化自身效用的行动或策略，恶意节点可能会攻击破坏区块链网络。</li>
<li>拜占庭容错（BFT）协议等共识协议可解决安全挑战，但需要集中的权限控制器，适用范围有限，不适用于去中心化的大规模系统的区块链网络。</li>
<li>马尔可夫决策过程（MDP）等优化方法用于分析和优化节点策略，但未考虑节点间相互作用。</li>
<li>由此引入博弈论作为区块链网络中的替代解决方案，解决节点间策略和相互作用问题。</li>
</ol>
</li>
<li>博弈论的运用：<ol>
<li>博弈论可以用来分析共识节点的策略以及它们之间的相互作用。通过博弈论分析，节点可以学习和预测彼此的挖矿行为，然后基于均衡分析制定最优的反应策略。</li>
<li>博弈论可用于开发激励机制，阻止节点执行不当行为或发起攻击。因此，博弈论自然适用于区块链网络中所有共识节点的决策。<h1 id="区块链基础"><a href="#区块链基础" class="headerlink" title="区块链基础"></a>区块链基础</h1></li>
</ol>
</li>
<li>区块链的优势：去中心、防篡改、交易透明、无需信任担保</li>
<li>区块链的数据组织：交易、区块、散列指针、Merkle Tree</li>
<li>区块链的分类：<ol>
<li>无许可，公链——PoW和PoS</li>
<li>许可链，联盟链和私链——BFT</li>
</ol>
</li>
<li>区块链中的激励相容<ol>
<li>共识协议的属性：正确性、一致性、可追溯性</li>
<li>各大共识都存在激励相容问题，节点可能会偏离协议以增加自己的效用。<h1 id="博弈论基础"><a href="#博弈论基础" class="headerlink" title="博弈论基础"></a>博弈论基础</h1></li>
</ol>
</li>
<li>博弈中的术语：玩家、效用、策略、理性<h2 id="非合作博弈"><a href="#非合作博弈" class="headerlink" title="非合作博弈"></a>非合作博弈</h2></li>
<li>玩家之间没有策略交流，自发采取策略，理性</li>
<li>区块链的场景：理性矿工作为玩家对计算能力进行战略性投资，以争夺成功采矿的奖励<ol>
<li>N个矿工，$P_i$是第$i$个矿工的策略集，$P=P_1\times … \times P_N$是各策略集的笛卡尔积</li>
<li>$p_i\in P_i$是第$i$个矿工的策略，N个矿工的策略向量$P=(p_1,…,p_n)$，对应的收益向量是$\pi=(\pi_1(p),…,\pi_N(p))\in R^n$，其中$\pi_i(p)$是第$i$个矿工的收益</li>
<li>综合考虑各矿工的策略和挖矿奖励，存在一组策略$\mathbf{p}^<em>=\left(p_1^</em>, \ldots, p_N^<em>\right) \in P$是纳什均衡，在这组策略下，任何矿工无法通过改变自己的策略来提高收益，即：$\forall i, p_i \in P_i: \pi_i\left(p_i^</em>, \overline{\mathbf{p}}_{\mathbf{i}}^<em>\right) \geq \pi_i\left(p_i, \overline{\mathbf{p}}_{\mathbf{i}}^</em>\right)$，其中$\overline{\mathbf{p}}_{\mathbf{i}}=\left(p_1, \ldots, p_{i-1}, p_{i+1}, \ldots, p_N\right)$是除了第$i$个矿工以外的其他矿工的策略</li>
<li>唯一性证明了严格凹博弈可以渐进地达到唯一的均衡。这里，凹博弈意味着玩家的效用函数是凹的，这可以通过计算效用函数的二阶导数来证明。（concave，指二阶导小于0）</li>
<li>应用案例：<ol>
<li>算力分配</li>
<li>分叉选择</li>
<li>矿池选择</li>
<li>用户和矿工的互动</li>
<li>区块扣留攻击<h2 id="扩展式博弈"><a href="#扩展式博弈" class="headerlink" title="扩展式博弈"></a>扩展式博弈</h2></li>
</ol>
</li>
</ol>
</li>
<li>对静态博弈的扩展：动态博弈，即博弈者的策略是按照一定的预定顺序制定的博弈。</li>
<li>博弈树：博弈者在不同点上做出的决定，并在每个分支的末端表示了他们的回报。可应用例子是描述分叉选择</li>
<li>分析过程：拆分成若干静态非合作子博弈，所有子博弈的均衡解表示了整个博弈的均衡，通常用逆向归纳法，从结尾倒推前一步的策略<h2 id="Stackelberg-Game"><a href="#Stackelberg-Game" class="headerlink" title="Stackelberg Game"></a>Stackelberg Game</h2></li>
<li>也是涉及玩家采取的某种预先定义的有序策略的博弈</li>
<li>参与者包括leader和follower。follower在观察leader的策略后决定自己的策略。leader和follower通常都是理性的，旨在最大化自己的效用</li>
<li>区块链分析案例：边缘计算网络<ol>
<li>参与者：<ol>
<li>服务商：提供算力设定价格出售</li>
<li>矿工：优化算力需求，买算力服务</li>
</ol>
</li>
<li>博弈过程：服务商设定价格，矿工决定需求</li>
</ol>
</li>
<li>分析过程：也是逆向归纳</li>
<li>应用：<ol>
<li>设置交易费用和选择矿工进行验证</li>
<li>确定网络保险价格</li>
<li>分析基于区块链的边缘计算平台中的供需关系<h2 id="Stochastic-Game"><a href="#Stochastic-Game" class="headerlink" title="Stochastic Game"></a>Stochastic Game</h2></li>
</ol>
</li>
<li>可以看作几个随时间重复的静态非合作博弈，每个静态非合作博弈称为博弈状态。</li>
<li>随机博弈在博弈状态之间执行随机转换，玩家可以根据其他玩家过去的行动和转变行为来改变策略</li>
<li>区块链分析案例：分析矿工对区块链结构转变的挖矿链选择<ol>
<li>博弈组成：<ol>
<li>有限玩家集I：矿工</li>
<li>状态空间M：区块链结构</li>
<li>策略集S</li>
<li>转移概率P</li>
</ol>
</li>
<li>矿工收益函数$g_n$，通常被视为阶段收益的贴现总和</li>
<li>博弈过程：<ol>
<li>从初始状态$m_1$开始</li>
<li>阶段$t$矿工观察区块结构$m_t$，选择策略$s_t^i$，即挑个链挖矿</li>
<li>每个矿工会立刻收到对应的收益$g_n^i$</li>
<li>博弈进入新状态$m+1$</li>
<li>如此循环直到进入MPE（马尔可夫完美均衡）</li>
</ol>
</li>
<li>矿工在最长链上挖矿就是这个场景的MPE<h1 id="博弈论在安全的应用"><a href="#博弈论在安全的应用" class="headerlink" title="博弈论在安全的应用"></a>博弈论在安全的应用</h1><h2 id="自私挖矿攻击"><a href="#自私挖矿攻击" class="headerlink" title="自私挖矿攻击"></a>自私挖矿攻击</h2></li>
</ol>
</li>
<li>攻击形式：攻击者（即恶意矿工或矿池）可能不会广播新开采的区块，而是选择 (i) 保留该区块或 (ii) 持有，然后在适当的时候释放该块。在这种情况下，诚实的矿工会浪费计算能力来寻找已经发现的区块，而恶意矿工则可以增加找到下一个区块的概率。矿池区块扣留（PBWH）攻击是一种常见的自私挖矿攻击。</li>
<li>分析方法：<ol>
<li>分析矿工和矿池的策略以及它们之间的相互作用</li>
<li>马尔可夫决策过程（MDP）可用于分析个体参与者（即矿工或矿池）的策略和效用</li>
<li>然而，MDP没有考虑多个参与者之间的交互，因此引入博弈论</li>
</ol>
</li>
<li>博弈论分析：<ol>
<li>对两个矿池之间的建模类似囚徒困境，解决方法如下：<ol>
<li>加入不发动PBWH攻击的矿池</li>
<li>运用零行列式策略，解决方案在[50]中提出，作者将两个矿工的挖矿案例建模为随机迭代博弈。我觉着这里也许可以看看矩阵最优回复结构那篇论文。</li>
<li>一些场景下，矿工可以在两个矿池之间迁移，使得场景更复杂</li>
</ol>
</li>
<li>多矿池的场景，可以引入计算功率分割（CPS）博弈模拟PBWH攻击，该场景没纯策略均衡，只有混合策略均衡</li>
</ol>
</li>
<li>上述研究仅考虑挖矿奖励，在考虑交易费用后，矿工可能不会立即向其他人广播交易以增加他们的预期利润，这称为自私传播攻击，需要针对性地设计激励机制，例如迭代去除主导策略。</li>
<li>在一些场景下，矿工为了最大化收益，会主动分叉，或者只挖矿不打包交易等。这个研究的场景大致应该是有传播费，然后逐层传递，矿工可以找最长链继承，并从剩下的费用里claim自己要收走的，也可以主动分叉，相当于是从再往前的一级那里继承，这样能claim的费用就多了。一个例子是：最长链的上一级给自己留了500，给当前矿工留了20，那么选项A是继承它，收20，不给后人留；选项B是直接分叉，自己从520中拿270，给后人留250。显然选项B更好。</li>
<li>其他类似形式的攻击就不细看了，大体思路都是矿工延迟可以提高自己的收益，针对性的方法是设计激励相容的奖励方式。<h2 id="多数攻击"><a href="#多数攻击" class="headerlink" title="多数攻击"></a>多数攻击</h2></li>
<li>概念：某个矿工持有51%及以上算力</li>
<li>存在问题：通常来说所有矿工在最长链上挖矿是最优的，但是当某矿工持有51%算力并强行分叉，则最长链不再是最优的</li>
<li>一些研究提出了新颖的攻击方式，使得多数攻击所需要的算力比51%还少。例如，攻击者利用其全部计算能力在其私有链上挖矿，同时发布智能合约交易。该合约交易包括一个散列谜题，即其私有链的 PoW 解法。任何解开谜题的矿工都可以从谜题的给出者（即攻击者）那里获得奖励，以换取谜题的解答。因此，当攻击者的私有链比公开链长时，攻击者可能会获得更多收益。每次攻击者通过智能合约发布散列谜题时，其他矿工有两种策略：(i) 处理合约中的谜题；(ii) 在公有链上挖矿。考虑到其他矿工的策略集，每个矿工都试图最大化自己的预期效用。因此，除了攻击者之外，其他矿工之间的互动可以建模为非合作博弈。当攻击者控制的计算能力超过网络总计算能力的 38.2% 时，矿工处理谜题的效用（概率 α）大于挖掘最长链的效用，因此攻击成功发起。这意味着每个矿工都会以概率 α 在谜题上工作，并以概率 1 - α 在公有链上挖矿。</li>
<li>也有提供贿赂来搞分叉的攻击方式</li>
<li>可以将诚实节点和恶意节点的攻防场景建模为随机博弈，然后分析双方策略及均衡</li>
<li>除了上述动力来自系统内的攻击，也还存在动力来自系统外的攻击：<ol>
<li>攻击者，即矿工，可以通过形成卡特尔来损害矿工之间的共识，即发起多数攻击，从而通过使加密货币贬值来获得一些效用</li>
<li>捍卫者，即其他矿工，打算保持货币的价值</li>
<li>为了防止货币贬值，防御者向攻击者提出出价，即类似于税收以保持货币的活力</li>
<li>与此同时，防御者会权衡出价成本和保留货币的利润</li>
<li>因此，可以使用非合作博弈来模拟攻击者和防御者之间的交互</li>
</ol>
</li>
<li>除了PoW以外，PoS也有多数攻击，该场景下代理可以通过持有加密货币来获得利息，为了提高利息代理会收购加密货币，当某代理持有加密货币超过50%，就可以进行多数攻击。建模成序贯博弈后，在博弈中，参与者包括一名攻击者和其他代理。攻击者将 CC 贬值的收益与出价成本和利益损失进行权衡。在 CC 贬值的收益大于持有 CC 的利息的情况下，利用反向归纳法证明博弈存在唯一的纳什均衡。在均衡状态下，攻击者有动机购买超过 50%的 CC 单位，而其他代理人也愿意将 CC 卖给攻击者，因为他们知道 CC 没有价值。然而，攻击者可以在出价之前向其他代理人宣布发动多数攻击，从而不付出任何代价就能攻击成功。原因在于，如果代理人认为攻击成功，那么无论攻击者出价多少，他们都会把 CC 卖给攻击者。在这种情况下，纳什均衡可能并不存在。</li>
<li>联盟链中也有多数攻击，可建模为stackelberg博弈<h2 id="阻断服务攻击（DoS攻击）"><a href="#阻断服务攻击（DoS攻击）" class="headerlink" title="阻断服务攻击（DoS攻击）"></a>阻断服务攻击（DoS攻击）</h2></li>
<li>概念：P2P网络受到某些攻击者的干扰或破坏，被攻击矿工可用于交易传播和验证的资源可能会被耗尽。因此，受攻击的矿工将无法完成挖矿过程来获得挖矿奖励和预期利润。</li>
<li>为了最大化挖矿奖励，矿池可以选择<ol>
<li>触发分布式 DoS (DDoS) 攻击，从而降低其他矿池的预期收益</li>
<li>投资额外的计算能力</li>
</ol>
</li>
<li>采用非合作博弈来分析不同规模池之间的相互作用</li>
<li>设计合适的奖励，使得矿池更愿意选择投资算力，而非发动dos攻击</li>
<li>DoS攻击也会造成其他影响，例如矿工迁移到其他矿池，影响下一阶段的算力分布。建模为序贯博弈，寻找存在均衡解的收益函数设计</li>
<li>一个研究增加了声誉系统的设计，只有收到邀请的才能在池里挖矿，从而保证矿工不发起DoS攻击</li>
<li>类似的，另一个研究做了基于区块链行为记录的惩罚方案<h2 id="其他安全问题"><a href="#其他安全问题" class="headerlink" title="其他安全问题"></a>其他安全问题</h2></li>
<li>基于区块链的数据共享：组织可以组成一个群组，共享信息并共同获得奖励，就像比特币系统中的矿池一样[75]。然而，一些组织成员可以组建一个子群，并加入另一个群组，通过不发布被加入群组的信息来获得更多收益。和PBWH是一样的。</li>
<li>用智能合约解决云计算的验证问题，避免共谋，实现交叉验证</li>
<li>商品交易过程的信任问题：智能合约+押金自动返还</li>
<li>网络保险：区块链公司购买网络保险，保险公司在区块链有安全问题后提供补偿，建模为stackelberg博弈<h1 id="博弈论在挖矿管理的应用"><a href="#博弈论在挖矿管理的应用" class="headerlink" title="博弈论在挖矿管理的应用"></a>博弈论在挖矿管理的应用</h1>这部分讨论的是矿工和矿池的管理，这种场景很适合运用博弈论。<h2 id="个人挖矿"><a href="#个人挖矿" class="headerlink" title="个人挖矿"></a>个人挖矿</h2><h3 id="算力分配"><a href="#算力分配" class="headerlink" title="算力分配"></a>算力分配</h3></li>
<li>矿工根据其他矿工的决策来决定自己是否投资算力——非合作博弈来分析矿工之间的交互</li>
<li>矿工可以随时选择加入某矿池，和离开某矿池，其策略也依赖于其他矿工的状态——建模为随机博弈，引入排队论</li>
<li>除了选择是否投资算力外，还可以选择投资多少算力——引入古诺博弈</li>
<li>上述情况是挖矿奖励为主，交易费用较少，当反过来交易费用更重要时，矿工的算力分配是时变的——建模为随机博弈，应该也有点排队论</li>
<li>也有和边缘计算结合，然后服务商提供挖矿算力，矿工选择买多少算力，这和区块链反而没啥关系，就是一个传统的移动计算场景，用的stackelberg博弈</li>
<li>还是边缘计算的场景，有研究结合了深度学习和拍卖理论</li>
<li>依旧是边缘计算，前面两个关注个体收益最大化，这篇关注社会福利最大化，将问题转化为背包约束<h3 id="分叉链选择"><a href="#分叉链选择" class="headerlink" title="分叉链选择"></a>分叉链选择</h3></li>
<li>矿工的效用是计算能力分布、获胜解决 PoW 的概率以及其他矿工对即将公开的谜题的信念的函数。建模成序贯博弈，后向归纳法寻找均衡解。</li>
<li>一些研究证明了最长链是均衡解。</li>
<li>另一些研究分析了矿工是否承认硬分叉的博弈。</li>
<li>除了矿工要选择，用户也要选，因此博弈更复杂。</li>
<li>也有研究分析这种场景下的矿工合作共谋问题。</li>
<li>上述分析是在PoW进行，有研究迁移到PoS进行。<h3 id="区块大小的设计"><a href="#区块大小的设计" class="headerlink" title="区块大小的设计"></a>区块大小的设计</h3></li>
<li>矿工打包的交易多，区块就会变大，交易费用固然挣得多，但共识速度也慢了，很可能没法成为主链，因此区块大小的设计也需要控制好。</li>
<li>过大的区块会影响吞吐量，反而降低比特币系统的性能。<h2 id="矿池挖矿"><a href="#矿池挖矿" class="headerlink" title="矿池挖矿"></a>矿池挖矿</h2><h3 id="矿池选择"><a href="#矿池选择" class="headerlink" title="矿池选择"></a>矿池选择</h3></li>
<li>矿工和矿池之间的交互用联盟博弈分析</li>
<li>矿工选矿池的过程类似多臂赌博机，由于矿工改变矿池会改变全网算力分布，因此使用进化博弈分析这个动态过程<h3 id="奖励分配"><a href="#奖励分配" class="headerlink" title="奖励分配"></a>奖励分配</h3></li>
<li>非合作博弈分析矿工和矿池管理者之间的交互，寻找能使得矿工挖出块就立刻报告的均衡解。</li>
<li>要避免矿工集中在一个矿池导致的中心化问题。<h1 id="博弈论在区块链平台的应用"><a href="#博弈论在区块链平台的应用" class="headerlink" title="博弈论在区块链平台的应用"></a>博弈论在区块链平台的应用</h1><h2 id="加密货币经济"><a href="#加密货币经济" class="headerlink" title="加密货币经济"></a>加密货币经济</h2></li>
<li>交易透明导致一些历史不太清白的大额交易被孤立，因此用户选择混合支付，拆分大额交易，用不同质量的小额交易支付，这样不清白交易对矿工损失也较小，矿工会愿意打包</li>
<li>但是混合交易支付使得资金流向更难查，对区块链系统不利（为什么会这样？系统透明按理说是一样的查找难度），一些研究设计了交易系统，寻找交易透明度的最佳水平</li>
<li>也有引入声誉系统的</li>
<li>总的来说就是权衡系统透明度和用户隐私保护度</li>
<li>不同加密货币价值不一样，矿工要决定挖哪个币，用势博弈分析</li>
<li>加密货币的价值与区块链系统内的算力和用户数量相关<h2 id="能源交易"><a href="#能源交易" class="headerlink" title="能源交易"></a>能源交易</h2>是关于分布式能源交易的方案设计，和区块链本身关系不大，本质上就是用户和服务商的博弈<h1 id="挑战与未来方向"><a href="#挑战与未来方向" class="headerlink" title="挑战与未来方向"></a>挑战与未来方向</h1><h2 id="博弈论方面的挑战"><a href="#博弈论方面的挑战" class="headerlink" title="博弈论方面的挑战"></a>博弈论方面的挑战</h2></li>
<li>纳什均衡的存在性，多种均衡之间的选择</li>
<li>博弈模型在区块链中的实现——平均场博弈、进化博弈、随机博弈<h2 id="博弈论在区块链方面的应用展望"><a href="#博弈论在区块链方面的应用展望" class="headerlink" title="博弈论在区块链方面的应用展望"></a>博弈论在区块链方面的应用展望</h2></li>
<li>提升吞吐量</li>
<li>设计更好的共识</li>
<li>联盟链中的节点选择</li>
<li>区块链在边缘计算、信息共享、能源交易等方面的应用</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
        <tag>game theory</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-CeFi vs. DeFi — Comparing Centralized to Decentralized Finance</title>
    <url>/2023/09/26/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-CeFi%20vs%20DeFi%20Comparing%20Centralized%20to%20Decentralized%20Finance/</url>
    <content><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><ol>
<li>与传统的中心化金融相比，DeFi的特征：<ol>
<li>透明。在 DeFi 中，用户可以查看金融资产和产品运行的精确规则。 DeFi 试图避免私人协议、反向交易和中心化，这些都是 CeFi 透明度的重要限制因素。 </li>
<li>控制。 DeFi 通过让用户仍然是其资产的托管人来为用户提供控制权，即未经用户同意，任何人都不得审查、转移或销毁用户的资产。 </li>
<li>可达性。任何拥有适度计算机、互联网连接和专业知识的人都可以创建和部署 DeFi 产品，而区块链及其分布式矿工网络则可以继续有效地运行 DeFi 应用程序。</li>
</ol>
</li>
<li>本文：<ol>
<li>比较两个领域的技术差异</li>
<li>深入研究它们的经济差异</li>
<li>对比了法律的特殊性</li>
</ol>
</li>
<li>本文贡献：<ol>
<li>CeFi和DeFi分类的决策树<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A&#123;金融资产是否由用户控制&#125;--No--&gt;B(CeFi)</span><br><span class="line">A--Yes--&gt;C&#123;有人能单独审查交易执行吗&#125;</span><br><span class="line">C--Yes--&gt;D(CeFi做中间人DeFi做决算)</span><br><span class="line">C--No--&gt;E&#123;有人能单独审查协议执行吗&#125;</span><br><span class="line">E--Yes--&gt;F(中心化管理的DeFi)</span><br><span class="line">E--No--&gt;G(DeFi)</span><br></pre></td></tr></table></figure></li>
<li>DeFi系统化</li>
<li>案例研究<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><h2 id="Finance"><a href="#Finance" class="headerlink" title="Finance"></a>Finance</h2></li>
</ol>
</li>
<li>金融机构：提供金融服务的金融中介机构</li>
<li>金融工具：货币资产，金融工具可以是代表涉及货币价值的法律协议的纸质文件或虚拟合同</li>
<li>金融市场：发生金融工具交易的任何市场<h2 id="Blockchain和DeFi"><a href="#Blockchain和DeFi" class="headerlink" title="Blockchain和DeFi"></a>Blockchain和DeFi</h2>这部分主要介绍DeFi能做什么，DeFi与区块链的关系。不细看了。<h2 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h2></li>
<li>公开验证：任意用户可查看状态转换、验证交易执行</li>
<li>托管：用户可在任意时间管理资产，没有营业时间限制，但是风险自担，由此出现了中心化的交易所来帮用户管理资产，这与CeFi是类似的</li>
<li>隐私：DeFi是匿名的，但不完全匿名，有很多方法可以从匿名地址中追溯身份，而中心化的交易所也使得匿名并不安全</li>
<li>原子性：区块链交易支持顺序操作，可以组合多种金融操作。这种组合可以被强制为原子的——这意味着事务要么完整执行其所有操作，要么集体失败。CeFi中并没有这么直接的原子性，但是个别场景下法律协议也可以在 CeFi 中强制执行原子性</li>
<li>执行顺序可变性：区块链中矿工和用户可以开展交易费用竞标竞赛来引导交易执行顺序，这种顺序可变性被证明会导致各种市场操纵策略。在 CeFi 中，监管机构对中心化的金融机构和服务实施严格的规则，规定必须如何执行交易排序。</li>
<li>交易成本：一般而言，DeFi 和区块链中的交易费用对于防止垃圾邮件至关重要。然而，在 CeFi 中，金融机构可以选择免费提供交易服务。</li>
<li>不间断的市场运行时间：CeFi有各自设定的营业时间，交易会有开盘收盘的情况，DeFi则没有。</li>
<li>匿名开发和部署：许多 DeFi 项目都是由匿名团队开发和维护的<h1 id="案例分析：法律"><a href="#案例分析：法律" class="headerlink" title="案例分析：法律"></a>案例分析：法律</h1><h3 id="合规性检查"><a href="#合规性检查" class="headerlink" title="合规性检查"></a>合规性检查</h3></li>
<li>CeFi依赖于KYC验证，也会需要AML验证</li>
<li>DeFi在资金追溯方面比CeFi要简单</li>
<li>如果用户只在DeFi操作，完全不进入CeFi，则从技术上来说能避开KYC；但是从合规角度来看，很难将没有KYC的资金从DeFi转移到CeFi<h3 id="资产可替代性"><a href="#资产可替代性" class="headerlink" title="资产可替代性"></a>资产可替代性</h3></li>
<li>这里提到了DeFi中矿工可能拒绝执行审查交易，例如在闪电网络[156]中，节点可能只是拒绝为特定交易提供服务，迫使用户要么选择另一个链下支付路径，要么通过常规比特币交易返回链上层。</li>
<li>现实法规中的一些约束要求某实体具有冻结和没收金融资产的能力，而这与DeFi从根本上是冲突的。</li>
<li></li>
</ol>
<h1 id="案例分析：服务"><a href="#案例分析：服务" class="headerlink" title="案例分析：服务"></a>案例分析：服务</h1><h1 id="案例分析：经济操纵"><a href="#案例分析：经济操纵" class="headerlink" title="案例分析：经济操纵"></a>案例分析：经济操纵</h1><h1 id="CeFi和DeFi的协同"><a href="#CeFi和DeFi的协同" class="headerlink" title="CeFi和DeFi的协同"></a>CeFi和DeFi的协同</h1>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
        <tag>defi</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Arthur Gervais论文略读记录</title>
    <url>/2023/09/25/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-ARTHUR%20GERVAIS%E8%AE%BA%E6%96%87%E7%95%A5%E8%AF%BB%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="1-A-Study-of-Inline-Assembly-in-Solidity-Smart-Contracts"><a href="#1-A-Study-of-Inline-Assembly-in-Solidity-Smart-Contracts" class="headerlink" title="1. A Study of Inline Assembly in Solidity Smart Contracts"></a>1. A Study of Inline Assembly in Solidity Smart Contracts</h1><p>这篇内容是关于Solidity内联汇编带来的安全性问题，对内联汇编的使用情况做了定量和定性分析。和DeFi没什么关系，先不看了。</p>
<h1 id="2-A-2MM-Mitigating-Frontrunning-Transaction-Reordering-and-Consensus-Instability-in-Decentralized-Exchanges"><a href="#2-A-2MM-Mitigating-Frontrunning-Transaction-Reordering-and-Consensus-Instability-in-Decentralized-Exchanges" class="headerlink" title="2. $A^2MM$: Mitigating Frontrunning, Transaction Reordering and Consensus Instability in Decentralized Exchanges"></a>2. $A^2MM$: Mitigating Frontrunning, Transaction Reordering and Consensus Instability in Decentralized Exchanges</h1><p>大致是实现了一个自动套利做市商，能增强共识安全性、降低sandwich攻击，提供经济利益，释放多出来的空间。可以细看一下。</p>
<h1 id="3-AMR-Autonomous-Coin-Mixer-with-Privacy-Preserving-Reward-Distribution"><a href="#3-AMR-Autonomous-Coin-Mixer-with-Privacy-Preserving-Reward-Distribution" class="headerlink" title="3. AMR: Autonomous Coin Mixer with Privacy Preserving Reward Distribution"></a>3. AMR: Autonomous Coin Mixer with Privacy Preserving Reward Distribution</h1><p>这篇讨论如何通过匿名混币服务实现隐私保护，大致思路是增加匿名集的大小和用户多样性，而用户则为隐私保护而付费，支付形式类似DeFi。这篇要细看。</p>
<h1 id="4-An-Empirical-Study-of-DeFi-Liquidations-Incentives-Risks-and-Instabilities"><a href="#4-An-Empirical-Study-of-DeFi-Liquidations-Incentives-Risks-and-Instabilities" class="headerlink" title="4. An Empirical Study of DeFi Liquidations: Incentives, Risks, and Instabilities"></a>4. An Empirical Study of DeFi Liquidations: Incentives, Risks, and Instabilities</h1><p>这篇是针对DeFi借贷清算系统的研究，细看一下。</p>
<h1 id="5-Attacking-the-DeFi-Ecosystem-with-Flash-Loans-for-Fun-and-Proﬁt"><a href="#5-Attacking-the-DeFi-Ecosystem-with-Flash-Loans-for-Fun-and-Proﬁt" class="headerlink" title="5. Attacking the DeFi Ecosystem with Flash Loans for Fun and Proﬁt"></a>5. Attacking the DeFi Ecosystem with Flash Loans for Fun and Proﬁt</h1><p>这篇是对闪电贷过程的描述和分析，介绍了过去的几次闪电贷攻击，应该是之前已经有所了解的内容，可以再看看。</p>
<h1 id="6-Blockchain-Censorship"><a href="#6-Blockchain-Censorship" class="headerlink" title="6. Blockchain Censorship"></a>6. Blockchain Censorship</h1><p>探讨了区块链审查制度的定义、定量评估、对中立性和安全性的影响以及不同共识对审查制度的限制，可以放后面细看一下。</p>
<h1 id="7-Blockchain-Large-Language-Models"><a href="#7-Blockchain-Large-Language-Models" class="headerlink" title="7. Blockchain Large Language Models"></a>7. Blockchain Large Language Models</h1><p>训练区块链大语言模型来检测异常交易。打算大致看一下。</p>
<h1 id="8-CeFi-vs-DeFi-Comparing-Centralized-to-Decentralized-Finance"><a href="#8-CeFi-vs-DeFi-Comparing-Centralized-to-Decentralized-Finance" class="headerlink" title="8. CeFi vs. DeFi Comparing Centralized to Decentralized Finance"></a>8. CeFi vs. DeFi Comparing Centralized to Decentralized Finance</h1><p>对cefi和defi比较分析，做了一些概念性的总结，细看。</p>
<h1 id="9-ConFuzzius-A-Data-Dependency-Aware-Hybrid-Fuzzer-for-Smart-Contracts"><a href="#9-ConFuzzius-A-Data-Dependency-Aware-Hybrid-Fuzzer-for-Smart-Contracts" class="headerlink" title="9. ConFuzzius A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts"></a>9. ConFuzzius A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts</h1><p>研究智能合约上的混合模糊测试工具，用于避免智能合约代码编写错误导致的各种损失。不看了。</p>
<h1 id="10-EXPLORING-THE-ADVANTAGES-OF-TRANSFORMERS-FOR-HIGH-FREQUENCY-TRADING"><a href="#10-EXPLORING-THE-ADVANTAGES-OF-TRANSFORMERS-FOR-HIGH-FREQUENCY-TRADING" class="headerlink" title="10. EXPLORING THE ADVANTAGES OF TRANSFORMERS FOR HIGH-FREQUENCY TRADING"></a>10. EXPLORING THE ADVANTAGES OF TRANSFORMERS FOR HIGH-FREQUENCY TRADING</h1><p>关注高频比特币-USDT交易的对数回报预测，研究新型深度学习 Transformers 架构，并将其与传统的长短期记忆模型进行了比较。不看了。</p>
<h1 id="11-Finding-Typing-Compiler-Bugs-Best-Paper-Best-Artifact-Award"><a href="#11-Finding-Typing-Compiler-Bugs-Best-Paper-Best-Artifact-Award" class="headerlink" title="11. Finding Typing Compiler Bugs (Best Paper + Best Artifact Award)"></a>11. Finding Typing Compiler Bugs (Best Paper + Best Artifact Award)</h1><p>这篇也是关于编译错误检查的，先不看了。</p>
<h1 id="12-High-Frequency-Trading-on-Decentralized-On-Chain-Exchanges"><a href="#12-High-Frequency-Trading-on-Decentralized-On-Chain-Exchanges" class="headerlink" title="12. High-Frequency Trading on Decentralized On-Chain Exchanges"></a>12. High-Frequency Trading on Decentralized On-Chain Exchanges</h1><p>针对去中心化交易所的攻击，主要是sandwich攻击，这篇论文介绍了攻击的形式等，细看一下。</p>
<h1 id="13-Mitigating-Decentralized-Finance-Liquidations-with-Reversible-Call-Options"><a href="#13-Mitigating-Decentralized-Finance-Liquidations-with-Reversible-Call-Options" class="headerlink" title="13. Mitigating Decentralized Finance Liquidations with Reversible Call Options"></a>13. Mitigating Decentralized Finance Liquidations with Reversible Call Options</h1><p>关注defi的清算系统，引入可逆看涨期权这一金融学的术语，用于defi借贷。可以看一下。</p>
<h1 id="14-On-How-Zero-Knowledge-Proof-Blockchain-Mixers-Improve-and-Worsen-User-Privacy"><a href="#14-On-How-Zero-Knowledge-Proof-Blockchain-Mixers-Improve-and-Worsen-User-Privacy" class="headerlink" title="14. On How Zero-Knowledge Proof Blockchain Mixers Improve, and Worsen User Privacy"></a>14. On How Zero-Knowledge Proof Blockchain Mixers Improve, and Worsen User Privacy</h1><p>零知识证明在混币器方面的应用分析。可以看一下。</p>
<h1 id="15-On-the-Just-In-Time-Discovery-of-Profit-Generating-Transactions-in-DeFi-Protocols"><a href="#15-On-the-Just-In-Time-Discovery-of-Profit-Generating-Transactions-in-DeFi-Protocols" class="headerlink" title="15. On the Just-In-Time Discovery of Profit-Generating Transactions in DeFi Protocols"></a>15. On the Just-In-Time Discovery of Profit-Generating Transactions in DeFi Protocols</h1><p>这篇也是做自动套利的，大致看看。</p>
<h1 id="16-Quantifying-Blockchain-Extractable-Value-How-dark-is-the-forest"><a href="#16-Quantifying-Blockchain-Extractable-Value-How-dark-is-the-forest" class="headerlink" title="16. Quantifying Blockchain Extractable Value: How dark is the forest?"></a>16. Quantifying Blockchain Extractable Value: How dark is the forest?</h1><p>研究三明治攻击、清算和去中心化交易所套利中提取美元来量化 BEV 的危险，细看一下。</p>
<h1 id="17-Security-of-Decentralized-Financial-Technologies-Dagstuhl-Seminar-22421"><a href="#17-Security-of-Decentralized-Financial-Technologies-Dagstuhl-Seminar-22421" class="headerlink" title="17. Security of Decentralized Financial Technologies (Dagstuhl Seminar 22421)"></a>17. Security of Decentralized Financial Technologies (Dagstuhl Seminar 22421)</h1><p>DeFi的安全性讨论，细看一下</p>
<h1 id="18-Smart-Contract-and-DeFi-Security-Insights-from-Tool-Evaluations-and-Practitioner-Surveys"><a href="#18-Smart-Contract-and-DeFi-Security-Insights-from-Tool-Evaluations-and-Practitioner-Surveys" class="headerlink" title="18. Smart Contract and DeFi Security Insights from Tool Evaluations and Practitioner Surveys"></a>18. Smart Contract and DeFi Security Insights from Tool Evaluations and Practitioner Surveys</h1><p>也是defi和智能合约的安全性讨论，细看一下</p>
<h1 id="19-SoK-Decentralized-Finance-DeFi-Attacks"><a href="#19-SoK-Decentralized-Finance-DeFi-Attacks" class="headerlink" title="19. SoK: Decentralized Finance (DeFi) Attacks"></a>19. SoK: Decentralized Finance (DeFi) Attacks</h1><p>对defi攻击的综述，细看。</p>
<h1 id="20-Speculative-Multipliers-on-DeFi-Quantifying-On-Chain-Leverage-Risks"><a href="#20-Speculative-Multipliers-on-DeFi-Quantifying-On-Chain-Leverage-Risks" class="headerlink" title="20. Speculative Multipliers on DeFi: Quantifying On-Chain Leverage Risks"></a>20. Speculative Multipliers on DeFi: Quantifying On-Chain Leverage Risks</h1><p>关于量化交易、自动做市商的安全性问题讨论，大致看看吧</p>
<h1 id="21-The-Blockchain-Imitation-Game"><a href="#21-The-Blockchain-Imitation-Game" class="headerlink" title="21. The Blockchain Imitation Game"></a>21. The Blockchain Imitation Game</h1><p>区块链模仿攻击，可以看看。</p>
<h1 id="22-The-Eye-of-Horus-Spotting-and-Analyzing-Attacks-on-Ethereum-Smart-Contracts"><a href="#22-The-Eye-of-Horus-Spotting-and-Analyzing-Attacks-on-Ethereum-Smart-Contracts" class="headerlink" title="22. The Eye of Horus: Spotting and Analyzing Attacks on Ethereum Smart Contracts"></a>22. The Eye of Horus: Spotting and Analyzing Attacks on Ethereum Smart Contracts</h1><p>在本文中，我们提出了 Horus，这是一个基于逻辑驱动和图形驱动的交易分析来自动检测和调查智能合约攻击的框架。略读吧。</p>
<h1 id="23-Time-to-Bribe-Measuring-Block-Construction-Markets"><a href="#23-Time-to-Bribe-Measuring-Block-Construction-Markets" class="headerlink" title="23. Time to Bribe: Measuring Block Construction Markets"></a>23. Time to Bribe: Measuring Block Construction Markets</h1><p>追踪以太坊区块构建过程，探讨存在的风险。大致看看。</p>
<h1 id="24-Towards-Automated-Security-Analysis-of-Smart-Contracts-based-on-Execution-Property-Graph"><a href="#24-Towards-Automated-Security-Analysis-of-Smart-Contracts-based-on-Execution-Property-Graph" class="headerlink" title="24. Towards Automated Security Analysis of Smart Contracts based on Execution Property Graph"></a>24. Towards Automated Security Analysis of Smart Contracts based on Execution Property Graph</h1><p>针对智能合约攻击设计的自动检测方法——执行属性图，我对这个方法有点兴趣，可以看看。</p>
<h1 id="25-Towards-Private-On-Chain-Algorithmic-Trading"><a href="#25-Towards-Private-On-Chain-Algorithmic-Trading" class="headerlink" title="25. Towards Private On-Chain Algorithmic Trading"></a>25. Towards Private On-Chain Algorithmic Trading</h1><p>自动化交易的机器人，大致看看。</p>
<h1 id="阅读规划"><a href="#阅读规划" class="headerlink" title="阅读规划"></a>阅读规划</h1><p>精读</p>
<ol>
<li>[ ] CeFi vs. DeFi Comparing Centralized to Decentralized Finance</li>
<li>[ ] Smart Contract and DeFi Security Insights from Tool Evaluations and Practitioner Surveys</li>
<li>[x] An Empirical Study of DeFi Liquidations: Incentives, Risks, and Instabilities</li>
<li>[ ] AMR: Autonomous Coin Mixer with Privacy Preserving Reward Distribution</li>
<li>[ ] High-Frequency Trading on Decentralized On-Chain Exchanges</li>
<li>[ ] Quantifying Blockchain Extractable Value: How dark is the forest?</li>
<li>[ ] Security of Decentralized Financial Technologies (Dagstuhl Seminar 22421)</li>
<li>[x] SoK: Decentralized Finance (DeFi) Attacks</li>
</ol>
<p>精读候选</p>
<ol>
<li>Towards Automated Security Analysis of Smart Contracts based on Execution Property Graph</li>
<li>The Blockchain Imitation Game</li>
<li>Blockchain Censorship</li>
<li>Mitigating Decentralized Finance Liquidations with Reversible Call Options</li>
<li>On How Zero-Knowledge Proof Blockchain Mixers Improve, and Worsen User Privacy</li>
<li>$A^2MM$: Mitigating Frontrunning, Transaction Reordering and Consensus Instability in Decentralized Exchanges</li>
</ol>
<p>略读</p>
<ol>
<li>Attacking the DeFi Ecosystem with Flash Loans for Fun and Proﬁt</li>
<li>The Eye of Horus: Spotting and Analyzing Attacks on Ethereum Smart Contracts</li>
<li>Time to Bribe: Measuring Block Construction Markets</li>
<li>On the Just-In-Time Discovery of Profit-Generating Transactions in DeFi Protocols</li>
<li>Speculative Multipliers on DeFi: Quantifying On-Chain Leverage Risks</li>
<li>Towards Private On-Chain Algorithmic Trading</li>
<li>Blockchain Large Language Models</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
        <tag>defi</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Truthful Mobile Crowd Sensing with Interdependent Valuations</title>
    <url>/2023/08/31/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Truthful%20Mobile%20Crowd%20Sensing%20with%20Interdependent%20Valuations/</url>
    <content><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><ol>
<li>阅读本文的原因：真值挖掘相关</li>
<li>本文研究目的：为移动众包系统设计激励机制，使得用户能够真实地报告它们的传感数据。</li>
<li>本文与我研究的相关性：也是防谎报的机制，感觉能迁移到其他场景</li>
<li>本文的潜在假设：用户的报酬函数会受到其他用户报告的传感数据的影响，即存在互相关联的报酬。</li>
<li>本文研究方法：设计了一个叫做T-SAB的机制，它包括两个阶段。在第一阶段，用户报告它们的传感数据。在第二阶段，用户根据一个代理函数提交出价，平台根据出价分配资源和确定支付。这种机制可以在用户的信息规模较小时实现资源的有效分配和近似的真实报告。</li>
<li>本文研究结论：随着用户数量的增加，用户扭曲报告的能力会降低，因此T-SAB机制可以实现真实报告的平衡。</li>
<li>是否进一步阅读：是</li>
</ol>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><ol>
<li>本文针对的场景：移动网络资源 MCS（如频谱感应、WiFi 热点和蜂窝网络覆盖）、交通监控和智能停车</li>
<li>该场景的特点：<ol>
<li>移动用户可以同时充当工作者和消费者；</li>
<li>MCS 平台既要收集感知数据，又要分配资源。即，用户通过完成移动通信服务任务来发现资源；基于感知数据，移动通信服务平台力求充分利用所发现的资源，激发用户的长期参与，例如，通过向用户有效分配资源来满足他们的需求。</li>
</ol>
</li>
<li>本文关注的挑战：资源发现 MCS 带来了估值相互依存的挑战，即每个用户对所分配资源/服务的估值取决于其他用户的私人感知数据。这样的相互依赖使得传统机制不可用，后续章节会具体分析。</li>
<li>关键问题1：在相互依存的评价环境中，平台应如何激励真实的传感数据报告？</li>
<li>已有研究：VCG机制可在信息量较小的情况下实现高效分配和近似真实</li>
<li>VCG不可用的原因：<ol>
<li>该机制假设用户的效用函数是全局已知的。然而，在实践中，用户的效用信息往往是私有的，用户也可能策略性地误报这些信息，从而操纵分配结果。</li>
<li>网络资源（如频谱和带宽）可以被分割（即可以无限分割），在这种情况下，每个用户的效用函数都是无限维的。在这种情况下，[13] 中的 VCG 型机制在大规模 MCS 系统中可能会产生令人望而却步的通信开销（在向其他用户完全描述效用函数方面）。</li>
</ol>
</li>
<li>关键问题2：在私人效用信息和相互依存的估值情况下，平台应如何设计一种机制，以实现高效分配和真实的传感数据报告？（感觉和关键问题1没区别啊）</li>
<li>本文贡献：设计了一种基于代理函数的机制，只需对每种资源进行一维信令，就能揭示用户的边际效用信息，因此通信开销很小。为了克服相互依赖的估价问题，我们证明了代理函数能带来有效的分配，同时每个用户的数据对分配的影响相当有限，从而阻止了用户的误报。<ol>
<li>问题表述： 我们提出了真实多传感器感知数据激发和有效分配的联合问题，其中考虑到了战略用户相互依赖的估值和私人效用信息。据我们所知，这是第一个研究 MCS 系统相互依存估值问题的论文。</li>
<li>T-SAB 机制： 我们设计了一种具有相互依赖估值和私人效用信息的 “真实感与出价”（T-SAB）机制。当用户的信息量较小时，该机制会产生一个完美贝叶斯均衡（PBE），它具有高效分配结果、近似真实性、个体理性和近似预算平衡，这在大型 MCS 系统中是一个合理的条件。</li>
<li>多资源扩展： 我们提出的 T-SAB 机制适用于多资源分配问题，它概括了 [30, 31] 中的单资源代理函数机制，克服了用户估值和决策耦合的难题。</li>
<li>数值结果与启示： 在认知无线电网络资源分配的示例中，我们的数值结果表明，当用户数量众多且个人感知数据准确时，T-SAB 机制是真实的，并且预算平衡。此外，与因潜在误报而未充分利用 MCS 的基准相比，T-SAB 机制的社会福利收益可达 20%。</li>
</ol>
</li>
</ol>
<h2 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h2><h2 id="SYSTEM-MODEL"><a href="#SYSTEM-MODEL" class="headerlink" title="SYSTEM MODEL"></a>SYSTEM MODEL</h2><ol>
<li>MCS系统包含一个平台（管理者）和一组用户集合$\mathcal{I}={1\leq i\leq I}$</li>
<li>MCS任务旨在估计一组可分割资源$\mathcal{N}={1\leq n\leq N}$的可访问性和质量</li>
<li>用户既是MCS任务的worker，也是资源的消费者<h3 id="System-Overview"><a href="#System-Overview" class="headerlink" title="System Overview"></a>System Overview</h3></li>
<li>世界状态：$\omega \triangleq\left\{\omega_n\right\}_{n \in \mathcal{N}}$表示未知随机的世界状态，$\Omega$表示所有可能的世界状态组成的有限集合，每个条目$\omega_n$代表资源$n$的质量和可用性，例如，无线信道$n$上的干扰级别或第$n个WiFi接入点的拥塞级别。</li>
<li>传感数据： 每个用户$i$获取随机传感数据$\theta_i\in \Theta_i$，可被用于估计世界状态$\omega$，需要提交给平台。上报的传感数据记作$\tilde{\theta}_i \in \Theta_i$，该数据可能是谎报的。$\theta_i$可能是多维的，$\theta \triangleq\left\{\theta_i\right\}_{i \in I} \in \Theta$表示用户传感数据概况。在所有其他用户的传感数据公开之前，每个用户对其他用户的数据$\theta_{-i} \triangleq\left\{\theta_j\right\}_{j \neq i}$有自己的先验信念，该信念用条件概率$P_{\Theta_{-i}}\left(\theta_{-i} \mid \theta_i\right)$来表示。通过收集所有用户的感官数据$\theta$，我们可以使用条件概率函数$P_{\Omega}(\omega \mid \theta)$来进行贝叶斯估计。</li>
<li><p>网络资源： 资源发现平台旨在有效地将资源集分配给用户。令$x_i=\left\{x_{i, n}\right\}_{n \in \mathcal{N}} \in \mathbb{R}_{+}^N$表示平台的分配决策，其中$x_{i, n}$表示分配给用户$i$的资源量$n$（例如，第$n$频谱通道分配给用户$i$的时间份额）。用$x=\left\{x_i\right\}_{i \in I}$表示分配概况，$\mathcal{X}$表示所有$x$的集合，则：        </p>
<script type="math/tex; mode=display">
     \mathcal{X}=\left\{x: \sum_{i \in \mathcal{I}} x_{i, n} \leq C_n, x_{i, n} \geq 0, \forall i \in \mathcal{I}, \forall n \in \mathcal{N}\right\} \tag{1}</script><p> 其中，$C_n$表示资源$n$的容量。</p>
</li>
<li>用户效用：用户$i$的效用函数$u_i(x_i,\omega)$，取决于世界状态$\omega$，是随$x_i$递增的Concave函数（凹函数，指二阶导小于0的那种，也就是增长速度越来越慢）。该函数表征了用户在特定状态$\omega$消耗分配资源所获得的收益。</li>
<li>期望效用：由于确切的世界状态$\omega$未知，每个用户根据自己的后验效用来评估分配到的$x_i$的价值，条件是$\theta$，即：<script type="math/tex; mode=display">
 \bar{U}_i\left(x_i \mid \theta\right)=\sum_{\omega \in \Omega} u_i\left(x_i, \omega\right) P_{\Omega}(\omega \mid \theta) \tag{2}</script> 这被称为相互依存估值，因为每个用户的效用都取决于所有用户的传感数据。这里的后验指的是 “$\theta$ 实现后”，而不是 “$\omega$ 实现后”。</li>
</ol>
<h3 id="Problem-Formulation"><a href="#Problem-Formulation" class="headerlink" title="Problem Formulation"></a>Problem Formulation</h3><p>MCS平台有两个目标：</p>
<ol>
<li>传感数据的真值揭示</li>
<li>网络资源的高效分配</li>
</ol>
<p>平台通过求解以下社会财富最大化问题来实现两个目标：</p>
<script type="math/tex; mode=display">
\text { (SWM) } \max _{x \in \mathcal{X}} \sum_{i \in I} \bar{U}_i\left(x_i \mid \theta\right) \tag{3}</script><p>该问题是一个凸优化问题。此外，$𝑢_𝑖(x_i,\omega)$ 随$x_i$的严格凹性意味着该函数的严格凹性，从而产生唯一的最优解$x^0$。</p>
<p>求解该SWM问题，需要平台了解完整且真实的$\theta$和$\left\{\overline{U}_i(\cdot|\cdot)\right\}$。然而，每个用户可能不愿意如实报告此类信息，因为操纵其报告可能会带来更有利的结果。因此，我们需要设计一种经济机制来有效地引发这种真实的传感数据报告并实现高效分配。理想情况下，这种机制应具有以下经济特性：</p>
<ol>
<li>(E1) 分配效率：存在对应了SWM问题最优解的均衡</li>
<li>(E2) 真实性：在均衡下所有用户会报告真实传感数据</li>
<li>(E3) 个体理性：每个用户不会因为参与机制而变得更糟</li>
<li>(E4) 弱预算平衡：用户支出总额为非负数，即不需要平台投入资金</li>
</ol>
<p>由于相互依赖的估值，设计满足这些属性的机制具有挑战性。从技术上讲，经济研究已经证明，一般来说，当存在相互依赖的估值时，（E1）和（E2）不可能同时实现。接下来我们将展示一个说明性示例。</p>
<h3 id="Winner’s-Curse-An-Illustrative-Example（赢者诅咒）"><a href="#Winner’s-Curse-An-Illustrative-Example（赢者诅咒）" class="headerlink" title="Winner’s Curse: An Illustrative Example（赢者诅咒）"></a>Winner’s Curse: An Illustrative Example（赢者诅咒）</h3><p>以下示例表明，相互依赖的估值给设计机制带来了新的挑战。</p>
<p>考虑一个认知无线电网络中的频谱感知示例，该网络有$I$个次级用户和一个信道。每个用户都会收到一个频谱感知数据点$\theta_i\in [0, 1]$，该数据点给出了用户$i$的信道值。频谱管理者（主要用户）计划采用二价拍卖的方式拍卖该信道：每个用户都必须出价、出价最高者赢得该信道、并支付次高出价。</p>
<p>考虑以下两种情况：</p>
<ol>
<li>私有价值：每个用户的效用是$\theta_i$，这是典型的情况，其中每个用户的频谱效用仅取决于其自己的信号。众所周知，二价拍卖会促使用户如实报告其私人信息$\theta_i$，并且每个用户都会获得非负收益（效用减去价格）。</li>
<li>公共价值：每个用户的效用是$\sum_{j=1}^I \theta_j / I$，这是一般相互依赖估值设置的特殊情况（其中用户具有相同的效用）。假设每个用户的信号$\theta_i$是服从$[0,1]$均匀分布的随机变量，每个用户都会向平台提交自己的信号$\theta_i$作为其出价。获胜者的付款是第二高的出价，遵循均匀分布的二阶统计，平均值为$(I−1)/(I+1)$。另一方面，该信道的期望效用是$\mathbb{E}\left[\sum_{i=1}^I \theta_i\right] / I=1 / 2$，这意味着当$I&gt;3$时赢者的期望收益是$1 / 2-(I-1) /(I+1)&lt;0$，且随$I$的增加而减少。也就是说，向用户宣布其获胜带来了“坏消息”。因此，每个用户都容易谎报$\theta_i$。在相互依赖的估值环境中，真实报告导致获胜者获得负收益的效果称为赢者诅咒。</li>
</ol>
<p>因此，上面的例子说明用户可能不愿意如实报告他们的私人感官数据。我们已经证明，第二价格拍卖（VCG 机制在这种情况下的一个特例）在相互依赖的估值环境中不起作用。为了克服这一挑战，我们接下来设计了一种机制，可以精确地实现（E1）和（E3），同时仅近似地实现（E2）和（E4）。</p>
<h2 id="MECHANISM-DESIGN-WITH-INTERDEPENDENT-VALUATIONS"><a href="#MECHANISM-DESIGN-WITH-INTERDEPENDENT-VALUATIONS" class="headerlink" title="MECHANISM DESIGN WITH INTERDEPENDENT VALUATIONS"></a>MECHANISM DESIGN WITH INTERDEPENDENT VALUATIONS</h2><p>在本节中，我们设计了真实感知和投标（T-SAB）机制，并表明，在所提出的方案和 MCS 系统的合理条件（用户信息量较小）下，它满足属性 (E1)-( E4）。</p>
<h3 id="The-T-SAB-Mechanism"><a href="#The-T-SAB-Mechanism" class="headerlink" title="The T-SAB Mechanism"></a>The T-SAB Mechanism</h3><p>在本小节中，我们介绍 T-SAB 机制，讨论其直观性以及与现有机制的差异，并介绍诱导均衡概念。</p>
<h4 id="机制描述"><a href="#机制描述" class="headerlink" title="机制描述"></a>机制描述</h4><p>如下图所示，T-SAB机制包含两阶段，在第一阶段，用户报告他们的传感数据（可能会谎报）。在第二阶段更新其估值后，每个用户进一步提交表明其私有效用信息的投标。根据提交的出价和预定义的代理函数，平台确定网络资源分配和用户支付，以实现高效、真实的均衡。</p>
<p><img src="https://github.com/likun1208/image/blob/master/T-SAB-1.png?raw=true" alt="T-SAB示意图"><br>机制形式化的写法如下：</p>
<ol>
<li>阶段一（传感阶段）：<ul>
<li>信息空间：每个用户向平台和所有其他用户提交一份自己传感数据的报告$\tilde{\theta}_i \in \Theta_i$（可能是假的）。</li>
</ul>
</li>
<li><p>阶段二（分配阶段）：</p>
<ul>
<li>代理函数：平台向所有用户公开一个代理函数$f(x, \lambda): \mathbb{R}_{+}^2 \rightarrow \mathbb{R}$</li>
<li>信息空间：每个用户向平台提交一个投标向量$\lambda_i=\left\{\lambda_{i, n}\right\}_{n \in \mathcal{N}} \in \mathbb{R}_{+}^N$，所有用户的投标记作$\lambda \triangleq\left\{\lambda_i\right\}_{i \in I}$</li>
<li><p>收益函数：给定报告上来的传感信号$\tilde\theta$和提交的$\lambda$，平台选择一个分配方案$x^*(\lambda)=\left\{x_i^\ast(\lambda)\right\}_{i\in\mathcal{I}}$，使得：</p>
<script type="math/tex; mode=display">
  x^*(\lambda)=\arg\max_{x\in\mathcal{X}}\sum_{i\in \mathcal{I}}\sum_{n\in\mathcal{N}}f(x_{i,n},\lambda_{i,n}). \tag{4}</script><p>每个用户$i$会被分配一笔支出</p>
<script type="math/tex; mode=display">
h_i(\boldsymbol{\lambda},\tilde{\boldsymbol{\theta}})=\max_{\boldsymbol{x}-i}\max_{\boldsymbol{j}\neq\boldsymbol{i}}\sum_{\boldsymbol{n}\in\boldsymbol{N}}f(x_{j,\boldsymbol{n}},\lambda_{j,\boldsymbol{n}})-\sum_{j\neq i}\sum_{n\in\mathcal{N}}f(x_{j,n}^*(\boldsymbol{\lambda}),\lambda_{j,n})-\epsilon\frac{P_{\Theta_{-i}}(\tilde{\boldsymbol{\theta}}_{-i}|\tilde{\boldsymbol{\theta}}_i)}{\left\|P_{\Theta_{-i}}(\tilde{\boldsymbol{\theta}}_{-i}|\tilde{\boldsymbol{\theta}}_i)\right\|_2}, \tag{5}</script></li>
</ul>
</li>
</ol>
<p>其中，$\epsilon\frac{P_{\Theta_{-i}}(\tilde{\theta}_{-i}|\tilde{\theta}_i)}{\left|P_{\Theta_{-i}}(\tilde{\theta}_{-i}|\tilde{\theta}_i)\right|_2}$是奖励函数，$\epsilon$是待设计的正近似系数，$x_{-i}=\{x_j\}_{j\neq i}$，且$\mathcal{X}_{-i}=\{x_{-i}:\sum_{j\in\mathcal{I},j\neq i}x_{j,n}\leq C_n,\forall n\in\mathcal{N},x_{j,n}\geq0,\forall n\in\mathcal{N},\forall j\neq i\}$。</p>
<h4 id="直观感受"><a href="#直观感受" class="headerlink" title="直观感受"></a>直观感受</h4><p>用户提交投标从而基于平台预设的代理函数$f(x,\lambda)$决定他们的分配和收益情况。给定函数$f(x,\lambda)$，用户仅需在第二阶段向平台提交N维信息，通信负担很小。此外，在均衡的情况下，满足一定条件的代理函数能够刺激用户提交其边际效用满足特定条件的出价，从而提高均衡时的分配效率（E1）。另一方面，(5) 中设计的支付结构限制了每个用户通过虚假报告操纵 (4) 和 (5) 中结果的能力（将在第 4.3 节中说明）；(5) 中的奖励函数用于诱导每个用户真实地获取感官数据 (E2)。(5) 中奖励函数的选择依赖于$P_{\Theta_i}(\cdot|\cdot)$的设计，可根据第 5 节中说明的系统模型推导得出。</p>
<h4 id="代理函数"><a href="#代理函数" class="headerlink" title="代理函数"></a>代理函数</h4><p>为了实现（或近似实现）属性（E1）-（E4），平台选择代理函数来满足以下正则条件：</p>
<p>定义1：正则。如果一个代理函数满足以下条件，则称它是正则的：</p>
<ol>
<li>$f(x,\lambda)$是严格凹函数、严格增函数，且在$x$上连续可导；</li>
<li>对于所有$\gamma\in(0,\infty)$且$x\geq 0$，都存在一个$\lambda&gt;0$使得$f’(x,\lambda)=\gamma$。</li>
</ol>
<p>一个正则函数的例子是$f(x,\lambda)=\lambda log(x)$。下面，我们将首先分析基于任意正则代用函数的 T-SAB 机制的特性，然后从第 4.3 节开始重点分析特定的正则函数。</p>
<h4 id="开销和与现有机制之间的差异"><a href="#开销和与现有机制之间的差异" class="headerlink" title="开销和与现有机制之间的差异"></a>开销和与现有机制之间的差异</h4><p>$T-SAB$机制的计算包含公式4中的一个优化问题以及公式5中的$I$个优化问题（每个用户一个）。给定根据定义1选择的严格凹的代理函数，上述$I+1$个优化问题都是凸的，可以高效求解。</p>
<p>接下来看通信开销。每个用户需要向平台和所有其他用户发送传感数据$\tilde{\theta_i}$，向平台发送报价$\lambda_i$，由此可得第一阶段的复杂度是$\mathcal{O}(|\Theta_i|\cdot I)$，第二阶段的复杂度是$\mathcal{O}(N)$。与之相反，参考文献12和13中假设用户的效用函数是全局公开的。我们注意到，12和13中考虑的经典 VCG 型机制需要报告携带无穷维信息的整个效用函数，这会产生难以承受的通信开销。</p>
<h4 id="信念系统和均衡概念"><a href="#信念系统和均衡概念" class="headerlink" title="信念系统和均衡概念"></a>信念系统和均衡概念</h4><p>尽管阶段1上报的传感数据$\tilde\theta_i$并没有出现在阶段2公式4的收益函数中，但报告的传感数据会影响每个用户的评价（由于评价相互依赖的特点），从而影响用户在阶段2的决策。为了描述这样的特点，我们引入了针对每个用户$i$的信念系统$\beta_i(\cdot|\cdot)$。具体来说，在阶段1中给定报告值$\tilde\theta_{-i}=\left\{\tilde\theta_j\right\}_{j\neq i}$的情况下，每个用户$i$选择一个关于真值$\theta_{-i}=\left\{\theta_j\right\}_{j\neq i}$的信念$\beta_i(\theta_{-i}|\tilde\theta_{-i})$，因此，阶段2中每个用户在其传感数据$\theta_i$和其他用户传感数据$\tilde\theta_{-i}$条件下的后验期望收益是：</p>
<script type="math/tex; mode=display">
J_{i}^{\beta_{i}}(\lambda|\theta_{i},\widetilde{\theta}_{-i})=\sum_{\theta_{-i}\in\Theta_{-i}}\bar{U}_{i}(x_{i}^{\ast}(\lambda)|\theta)\beta_{i}(\theta_{-i}|\widetilde{\theta}_{-i})-h_{i}(\lambda,\widetilde{\theta}). \tag{6}</script><p>因为我们关注所有用户都说真话的均衡，我们考虑下述真实均衡概念：</p>
<p>定义2：真实完美贝叶斯均衡（PBE）。一个真实PBE是一个三元组$(\widetilde{\theta}^{\ast},\lambda^{\ast}(\widetilde{\theta}^{\ast}),\{\beta_{i}^{\ast}\}_{i\in I})$，使得：</p>
<script type="math/tex; mode=display">
\lambda_i^*(\widetilde{\theta}^*)\in\arg\max_{\lambda_i\in\mathbb{R}^N},J_i^{\beta_i^*}(\lambda_i,\lambda_{-i}^*(\widetilde{\theta}^*)|\theta_i,\widetilde{\theta}_{-i}^*), \tag{7a}</script><script type="math/tex; mode=display">
\beta_i^*(\theta_{-i}|\tilde{\theta}_{-i})=\mathbb{I}(\theta_{-i}=\tilde{\theta}_{-i}), \tag{7b}</script><p>其中，$\mathbb{I}(X)$是指示函数，当X为真时该函数取值1，当X为假是该函数取值为0。另一方面，$\tilde\theta^\ast$满足：</p>
<script type="math/tex; mode=display">
\widetilde\theta_i^*\in\arg\max_{\tilde\theta_i\in\Theta_i}J_i^{\beta_i^*}(\lambda^*(\widetilde\theta_i,\widetilde\theta_{-i}^*)|\theta_i,\widetilde\theta_{-i}^*), \tag{8}</script><p>或：</p>
<script type="math/tex; mode=display">
\widetilde{\theta}_i^*\in\arg\max_{\widetilde{\theta}_i\in\Theta_i}\sum_{\theta_{-i}\in\Theta_{-i}}J_i^{\beta_i^*}(\lambda^*(\widetilde{\theta}_i,\widetilde{\theta}_{-i}^*)|\theta_i,\widetilde{\theta}_{-i}^*)P_{\Theta_{-i}}(\theta_{-i}|\theta_i). \tag{9}</script><p>为了理解定义 2，(7a) 与 (8) 或 (9) 一起表征了用户的理性，即每个用户的策略应该是与其信念相关的期望最优策略。此外，(7b) 意味着信念一致性，即每个用户都根据贝叶斯规则更新其信念[42]。因此，(7b) 意味着在一个真实的 PBE 中，所有用户都相信其他用户是真实报告的。</p>
<p>我们注意到，(8)和(9)描述了在存在相互依赖的估值时两种不同的可信的真实性概念[13, 43]。特别是，(8) 意味着事后真实性，而 (9) 意味着事前真实性。事后真实性表明，在所有用户的真实传感数据被揭示后，每个用户都应该发现真实报告是其最优策略；而事前真实性则意味着，每个用户都期望真实报告是其当前可用信息（自身传感数据）条件下的最优策略。</p>
<h3 id="Equilibrium-Analysis-in-Stage-II"><a href="#Equilibrium-Analysis-in-Stage-II" class="headerlink" title="Equilibrium Analysis in Stage II"></a>Equilibrium Analysis in Stage II</h3><p>我们接下来分析给出用户传感数据$\tilde\theta$的情况下，阶段2中的均衡$\lambda^\ast(\tilde\theta)$。为了简化表达，我们在本节中使用$\lambda^\ast$来代替$\lambda^\ast(\tilde\theta)$。</p>
<p>因为我们关注真实PBE，所以本文仅考虑每个用户都认为其他用户会说真话的情况，即采用(7b)的信念系统。为了刻画阶段2中的用户交互，我们定义了T-SAB机制的以下子博弈，对于给定$\tilde\theta$：</p>
<p>博弈1（阶段2竞价子博弈）：阶段2中的竞价子博弈包含：</p>
<ul>
<li>玩家：所有用户</li>
<li>策略空间：对于每个用户$i$都是$\lambda_{i}\in\mathbb{R}_{+}^{N}$</li>
<li>支付函数：每个用户$i$都是<script type="math/tex; mode=display">
J_i^{\boldsymbol{\beta}_i^*}\left(\boldsymbol{\lambda}\Big|\boldsymbol{\theta}_i,\widetilde{\boldsymbol{\theta}}_{-\boldsymbol{i}}\right)=\bar{U}_i\left(\boldsymbol{x}_i^*(\boldsymbol{\lambda})\Big|\boldsymbol{\theta}_i,\widetilde{\boldsymbol{\theta}}_{-\boldsymbol{i}}\right)-\boldsymbol{h}_i\left(\boldsymbol{\lambda},\widetilde{\boldsymbol{\theta}}\right) \tag{10}</script>其中，$x^{\ast}(\lambda)=\{x_{i}^{\ast}(\lambda)\}_{i\in I}$由公式4决定。</li>
</ul>
<p>上述竞价子博弈包含以下均衡概念$\lambda^\ast$：</p>
<p>定义3（纳什均衡 NE）：博弈 1 的纳什均衡是满足 (7a) 的策略集$\lambda^\ast$。</p>
<p>假设其他用户都说真话，我们设计了一个NE来实现能最大化聚合期望效用的分配方案$x^\ast(\lambda^\ast)$，也就是说，我们将证明 NE 是以下问题的最优解：</p>
<script type="math/tex; mode=display">
\max _{x \in \mathcal{X}} \sum_{i \in I} \bar{U}_i\left(x_i \mid \theta_i, \tilde{\theta}_{-i}\right)  \tag{11}</script><p>我们从以下引理开始。</p>
<p>引理1：向量$\lambda$是博弈1的NE，当且仅当：</p>
<script type="math/tex; mode=display">
x^*(\lambda) \in \arg \max _{x \in \mathcal{X}}\left[\bar{U}_i\left(x_i \mid \theta_i, \tilde{\theta}_{-i}\right)+\sum_{n \in \mathcal{N}} \sum_{j \neq i} f\left(x_{j, n}, \lambda_{j, n}\right)\right], \forall i \in I \tag{12}</script><p>我们在附录 7.1 中给出了引理 1 的简要证明。直观上，(4) 和 (5) 中类似 VCG 的支付和分配结果会产生一个 NE，在该 NE 处，每个用户的兴趣与 (12) 中的问题一致。基于引理 1 以及 (12) 和 (11) 的 Karush-Kuhn-Tucker (KKT) 条件，我们有： </p>
<p>推论 1（存在性）。博弈 1 存在一个NE  $\lambda^\ast$，可得出 (11) 中问题的最优解。</p>
<p>因此，使用正则代理函数$f(x,\lambda)$，每个用户选择$\lambda_i^\ast$表示其边际预期效用，就对应于一个 NE。我们可以进一步证明，所有 NE 都对应于 (11) 的最优解。</p>
<p>命题1（效率）：如果存在两个用户使得$\lim _{x_{i, n} \rightarrow 0} \partial u_i\left(x_i, \omega\right) / \partial x_{i, n}=\infty$ for all $n$，则阶段2的所有NE都对应了(11)的最优解。</p>
<p>主要的证明包括利用 (12) 和 (11) 的最优条件之间的相似性，证明存在一个近似值，可以得到 (11) 中问题的最优解。最后，如果有两个积极 “竞争 “的用户，他们的分配必须为正，即在 NE 上$x_i^<em>\left(\lambda^</em>\right)&gt;0$，我们可以证明 (12) 的最优性条件等同于 (11) 的最优性条件，这意味着所有 NE 都应解决 (11) 中的问题。 </p>
<h3 id="Equilibrium-Analysis-in-Stage-I"><a href="#Equilibrium-Analysis-in-Stage-I" class="headerlink" title="Equilibrium Analysis in Stage I"></a>Equilibrium Analysis in Stage I</h3><p>基于对命题1的观察，我们可以进一步分析阶段1中的均衡结果。我们首先通过比较谎报用户$i$的传感数据所带来的改进，来确定 T-SAB 机制的特殊“增益受限”属性：</p>
<p>引理2：当所有其他用户都说真话时，每个用户$i$谎报传感数据的收益提升是有上限的：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& J_i^{\beta_i^*}\left(\lambda^*\left(\tilde{\theta}_i, \theta_{-i}\right) \mid \theta\right)-J_i^{\beta_i^*}\left(\lambda^*(\theta) \mid \theta\right) \\
\leq & \sum_{j \neq i} \sum_{n \in \mathcal{N}} f\left(\tilde{x}_{j, n}, \lambda_{j, n}^*\right)-\max _{x_{-i} \in \mathcal{X}_{-i}} \sum_{j \neq i} \sum_{n \in \mathcal{N}} f\left(x_{j, n}, \lambda_{j, n}^*\right) \\
& -\sum_{j \neq i} \sum_{n \in \mathcal{N}} f\left(\tilde{x}_{j, n}, \tilde{\lambda}_{j, n}\right)+\max _{x_{-i} \in \mathcal{X}_{-i}} \sum_{j \neq i} \sum_{n \in \mathcal{N}} f\left(x_{j, n}, \tilde{\lambda}_{j, n}\right)+\epsilon
\end{aligned} \tag{13}</script><p>其中$\tilde{\lambda}=\lambda^<em>\left(\tilde{\theta}_i, \theta_{-i}\right), \tilde{x}=x^</em>(\tilde{\lambda})$, and $\lambda^<em>=\lambda^</em>(\theta)$.</p>
<p>根据定理 1 可以证明定理 2。定理 2 意味着，谎报的收益可以通过一个与用户效用函数无关的参数来确定上限。上述结果适用于任意规则代理函数。为了推导出更明确的性质，我们将重点放在正则代用函数族上：</p>
<script type="math/tex; mode=display">
f(x, \lambda)=\lambda \phi^{(\alpha)}(x) \tag{14}</script><p>其中$\phi^{(\alpha)}(x)$是[30,41]给出的$\alpha$-公平效用。</p>
<script type="math/tex; mode=display">
\phi^{(\alpha)}(x)= \begin{cases}(1-\alpha)^{-1} x^{1-\alpha}, & \forall \alpha>0 \text { and } \alpha \neq 1 \\ \log (x), & \text { if } \alpha=1\end{cases} \tag{15}</script><p>将M定义成所有用户的聚合收益的上限，即：</p>
<script type="math/tex; mode=display">
\sum_{i \in \mathcal{I}} u_i\left(x_i, \omega\right) \leq M, \forall x \in \mathcal{X}, \omega \in \Omega \tag{16}</script><p>$\mathcal{X}$的紧致性确保了M的存在性。给定(14)中指定的正则代理函数，我们可以细化（13）中的结果并推导出以下绑定结果：</p>
<p>命题2：利用 (14) 中的代用函数，并假设$\alpha \rightarrow 0$，则引理2中的界限可以被改写为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& J_i^{\beta_i^*}\left(\lambda^*\left(\tilde{\theta}_i, \theta_{-i}\right) \mid \theta\right)-J_i^{\beta_i^*}\left(\lambda^*(\theta) \mid \theta\right) \\
\leq & \left\|P_{\Omega}(\cdot \mid \theta)-P_{\Omega}\left(\cdot \mid \tilde{\theta}_i, \theta_{-i}\right)\right\| M+\epsilon
\end{aligned} \tag{17}</script><p>其中，$||\cdot||$表示$\mathcal l_1$范数，M定义在(16)中。</p>
<p>我们在附录7.2中给出了命题2的证明。命题2提供了一个当其他用户都说真话时用户$i$谎报所能带来的收益上界。直观上，如果用户通过谎报来操纵$P_\Omega(\cdot|\theta)$的能力受限，则操纵$\lambda^\ast(\tilde\theta_i,\theta_{-i})$同样困难。命题2的意义在于，它表明用户因谎报而获得的收益与用户的传感数据对后验概率分布$P_\Omega(\cdot|\theta)$的影响程度成正比。</p>
<p>我们指出，MCS 系统的主要优势在于它利用了人群中固有的不准确数据的多样性。因此，在用户数量相当多的情况下，每个用户的传感数据对$P_\Omega(\cdot|\theta)$的贡献很小，并且 (17) 中的界限接近于0。因此，T-SAB 机制可能会刺激用户如实报告$\theta_i$。</p>
<p>为了进一步表征用户真实性的诱导程度，我们引入以下定义[13]：</p>
<p>定义 4（信息大小）。用户$i$的信息量为：</p>
<script type="math/tex; mode=display">
v_i=\max _{\theta_i, \tilde{\theta}_i} \min \left\{\epsilon \geq 0 \mid \operatorname{Prob}\left\{\tilde{\theta}_{-i} \in I_{i, \epsilon}\left(\theta_i, \tilde{\theta}_i\right)\right\} \leq \epsilon\right\} \tag{18}</script><p>其中，</p>
<script type="math/tex; mode=display">
I_{i, \epsilon}\left(\theta_i, \tilde{\theta}_i\right)=\left\{\theta_{-i} \mid\left\|P_{\Omega}(\cdot \mid \theta)-P_{\Omega}\left(\cdot \mid \tilde{\theta}_i, \theta_{-i}\right)\right\| \geq \epsilon\right\} . \tag{19}</script><p>信息大小$v_i$表征了用户$i$通过谎报$\theta_i$操纵条件概率的$P_\Omega(\cdot|\theta_i,\theta_{-i})$的能力。较小的用户信息量表明T-SAB机制实现了可忽略不计的操纵能力。</p>
<p>为了衡量用户对（5）中奖励函数的响应有多敏感，我们进一步引入以下定义：</p>
<p>定义5（变化性）：用户$i$的变化性是：</p>
<script type="math/tex; mode=display">
Z_i=\min _{\theta_i, \tilde{\theta}_i \in \Theta_i, \theta_i \neq \tilde{\theta}_i} \| \frac{P_{\Theta_{-i}\left(\cdot \mid \theta_i\right)}}{\left\|P_{\Theta_{-i}\left(\cdot \mid \theta_i\right)}\right\|_2}-\frac{P_{\Theta_{-i}\left(\cdot \mid \tilde{\theta}_i\right)}}{\left\|P_{\Theta_{-i}\left(\cdot \mid \tilde{\theta}_i\right)}\right\|_2 \|_2^2}, \tag{20}</script><p>其中$||\cdot||_2$表示$\mathcal{l}_2$范数。</p>
<p>较大的$Z_i$意味着用户$i$对（5）中的奖励函数更敏感。基于命题2和定义4和5，我们得到以下主要结果：</p>
<p>定理 3（真实性）。选择(5)中的近似系数$\epsilon$以满足：</p>
<script type="math/tex; mode=display">
\epsilon=\frac{2 M \sqrt{|\Theta|} \max _{i \in I} v_i}{\min _{i \in I} Z_i} \tag{21}</script><p>给定(14)中的代理函数并令$\alpha\rightarrow 0$，则T-SAB机制满足以下两个真实性标准：</p>
<ol>
<li>事前真实性：存在满足(9)的PBE  $\tilde\theta^\ast$;</li>
<li>$\epsilon$事后真实性，定义为：<script type="math/tex; mode=display">
\operatorname{Prob}\left\{J_i^{\beta_i^*}\left(\lambda^*\left(\tilde{\theta}_i, \theta_{-i}\right) \mid \theta\right)>J_i^{\beta_i^*}\left(\lambda^*(\theta) \mid \theta\right)+\epsilon\right\} \leq \epsilon \tag{22}</script>我们在附录7.3中提供了定理3的证明。要理解事前真实性，选择满足（21）的近似系数，就可以确保（5）中诚实报告的收益大于错误报告的收益（特征见命题 2）。为了解释近似事后真实性，如果用户$i$的信息量很小，那么我们可以推导出：<script type="math/tex; mode=display">
\operatorname{Prob}\left\{\left\|P_{\Omega}\left(\cdot \mid \theta_i, \theta_{-i}\right)-P_{\Omega}\left(\cdot \mid \tilde{\theta}_i, \theta_{-i}\right)\right\| \approx 0\right\} \approx 1 \tag{23}</script>用户$i$可以认为近似说真话，因为<script type="math/tex; mode=display">
\operatorname{Prob}\left\{J_i^{\beta_i^*}\left(\lambda^*\left(\tilde{\theta}_i, \theta_{-i}\right) \mid \theta\right)-J_i^{\beta_i^*}\left(\lambda^*(\theta) \mid \theta\right) \leq 0\right\} \approx 1 \tag{24}</script>定理 3 有两方面的意义。首先，它证明了大型 MCS 系统中的用户真实性（由于 (21) 中的$\epsilon$较小），这将在第 5 节中进一步说明。其次，它还为进一步减少$\epsilon$提供了启示，即通过调整参数$|\Theta|$和$Z_i$来减少$\epsilon$。为此，平台可在第一阶段限制用户的报告选择。</li>
</ol>
<p>(21)中$\epsilon$的取值取决于参数M的知识。我们注意到，可以在不知道𝑀的情况下修改 T-SAB 机制以保持近似的事后真实性（但牺牲事前真实性）。此外，还可以根据经验数据估计M。</p>
<p>接下来，我们考虑由(4)和(5)中类似于 VCG 的结果函数所产生的其余两个性质(E3)-(E4)。特别是，由于(12)在 NE 中的最大值（由于定理 1）和(5)中的正奖励函数，我们可以证明以下性质：</p>
<p>命题3（个体理性）：T-SAB机制实现个体理性（E3），即</p>
<script type="math/tex; mode=display">
J_i^{\beta_i^*}\left(\lambda^*(\theta) \mid \theta\right) \geq 0, \forall i \in I \tag{25}</script><p>我们在附录7.4中给出了简要证明。命题3的意义在于，用户永远不会因为参与T-SAB机制而变得更糟，例1中的赢家诅咒在这里也不会发生。</p>
<p>此外，(5) 中的支付结构得出以下近似预算平衡结果：</p>
<p>推论2（$\epsilon I$-近似预算平衡）T-SAB机制实现了近似预算平衡（E4），即：</p>
<script type="math/tex; mode=display">
\sum_{i \in \mathcal{I}} h_i(\lambda, \tilde{\theta}) \geq-\epsilon I</script><p>其中$\epsilon$在(21)中给出。</p>
<p>我们在附录 7.5 中提供了推论 2 的证明。可能出现预算不足的原因是需要激励用户如实报告。然而，当用户的信息量较小时（因为$\epsilon$较小），这种预算不足可以忽略不计。此外，正如我们将在第 5.2 节中用数字说明的，近似系数$\epsilon$随I的增大而迅速减小，这意味着随着I的增大，预算赤字$\epsilon I$也会减小。</p>
<p>简而言之，T-SAB 机制可以实现所有的经济特性（E1）-（E4），只要用户的信息量很小，这在大型 MCS 系统中是合理的。</p>
<h2 id="CASE-STUDY-SPECTRUM-SENSING-AND-ALLOCATION-IN-COGNITIVE-RADIO"><a href="#CASE-STUDY-SPECTRUM-SENSING-AND-ALLOCATION-IN-COGNITIVE-RADIO" class="headerlink" title="CASE STUDY: SPECTRUM SENSING AND ALLOCATION IN COGNITIVE RADIO"></a>CASE STUDY: SPECTRUM SENSING AND ALLOCATION IN COGNITIVE RADIO</h2><p>我们研究了认知无线电网络中的协作频谱感知场景[45]，作为具有网络资源共享的 MCS 系统的玩具示例。然后，我们进行数值分析，以研究用户信息量较小的条件以及与独立基准相比的性能增益。</p>
<h3 id="System-Model"><a href="#System-Model" class="headerlink" title="System Model"></a>System Model</h3><h4 id="System-overview"><a href="#System-overview" class="headerlink" title="System overview"></a>System overview</h4><p>我们考虑由一个基站和一组（二级）用户$\mathcal{I}$组成的中心化二级网络，在我们的示例中，我们只考虑只有一个信道的小问题，以便清楚地说明主要思想，信道要么被占用，要么空闲，记作$\omega\in\left\{0,1\right\}=\Omega$，其中0表示占用，1表示空闲。每个用户$i$都应用能量检测来检测信道是否被占用，并接收二进制检测结果$\theta_{i}=\left\{0,1\right\}$，这是对$\omega$的估计。</p>
<h4 id="Probability-Model"><a href="#Probability-Model" class="headerlink" title="Probability Model"></a>Probability Model</h4><p>为了表征$P_\Omega(\omega|\theta)$和$P_{\Theta_i}(\theta_{-i}|\theta_i)$的条件概率分布，我们采用了文献[45]中表 2 所列的误报、检测、漏检和漏报概率。具体来说，$\xi_i$表示能量检测阈值，$\gamma_i$表示用户$i$传感数据的信噪比SNR，$u$是能量检测器的时间带宽乘积，$\Gamma(\alpha,x)$是不完全伽马函数，由$\Gamma(a, x)=\int_x^{\infty} t^{a-1} e^{-t} d t$给出， $\Gamma(\alpha)$是伽玛函数，$Q_u(a,b)$是广义 Marcum Q 函数 [45]。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$Prob(\theta_i\</th>
<th>\omega)$</th>
<th>$\omega=0$</th>
<th>$\omega=1$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\theta_i=0$</td>
<td>$\frac{1-\Gamma\left(u,\zeta/2\right)}{\Gamma\left(u\right)}$</td>
<td>$1-Q_u(\sqrt{2y_i},\sqrt{\zeta})$</td>
</tr>
<tr>
<td>$\theta_i=1$</td>
<td>$\frac{\Gamma\left(u,\zeta/2\right)}{\Gamma\left(u\right)}$</td>
<td>$Q_u(\sqrt{2y_i},\sqrt{\zeta})$</td>
</tr>
</tbody>
</table>
</div>
<p>令$p(\omega)$表示世界状态的概率分布，因此，以所有其他用户的传感数据$\theta$为条件的世界状态的概率是</p>
<script type="math/tex; mode=display">
\begin{aligned}P_{\Omega}(\omega|\boldsymbol{\theta})&=\frac{p(\omega)\prod_{\boldsymbol{i}\in\boldsymbol{I}}\mathrm{Prob}(\theta_{\boldsymbol{i}}|\omega)}{\sum_{\tilde{\omega}\in\{0,1\}}p(\tilde{\omega})\prod_{\boldsymbol{i}\in\boldsymbol{I}}\mathrm{Prob}(\theta_{\boldsymbol{i}}|\tilde{\omega})}\end{aligned} \tag{26}</script><p>其中 (26) 中的乘积项是由独立条件概率$Prob(\theta_i|\omega)$引起的。每个用户$i$对其他用户的传感数据的先验信念由下式给出：</p>
<script type="math/tex; mode=display">
\begin{aligned}P_{\Theta_{-i}}(\boldsymbol{\theta}_{-i}|\theta_{i})&=\frac{\sum_{\tilde{\omega}\in\{0,1\}}p(\tilde{\omega})\prod_{j\in I}\operatorname{Prob}(\theta_{j}|\tilde{\omega})}{\sum_{\tilde{\omega}\in\{0,1\}}p(\tilde{\omega})\text{Prob}(\theta_{i}|\tilde{\omega})}\end{aligned} \tag{27}</script><h4 id="Resource-Allocation"><a href="#Resource-Allocation" class="headerlink" title="Resource Allocation"></a>Resource Allocation</h4><p>为了避免用户传输之间的相互干扰，平台将频谱信道以分时方式分配给用户。令$x_i$表示用户$i$的时间份额。每个用户都有一个由$u_i(x_i|\omega)=\kappa_{i,\omega}\log(1+x_i)$给出的加权对数效用函数，其中当$\omega=0$时，参数$k_{i,\omega}$遵循区间$[0, 0.1]$上的 i.i.d 均匀分布，当$\omega=1$时，遵循区间$[0, 15]$的i.i.d均匀分布。</p>
<h3 id="Numerical-Results"><a href="#Numerical-Results" class="headerlink" title="Numerical Results"></a>Numerical Results</h3><h4 id="Simulation-Setup"><a href="#Simulation-Setup" class="headerlink" title="Simulation Setup"></a>Simulation Setup</h4><p>我们将占用概率设置为$p(0)=0.3$，空闲概率为$p(1)=0.7$，表2中的阈值$xi=16$，信道容量为$C=250$。</p>
<h4 id="Standalone-Benchmark-Mechanism"><a href="#Standalone-Benchmark-Mechanism" class="headerlink" title="Standalone Benchmark Mechanism"></a>Standalone Benchmark Mechanism</h4><p>为了进行性能比较，我们考虑了一种独立的基准机制，这种机制由于潜在的谎报而没有充分利用监控监听系统。具体来说，在不汇总所有用户传感数据的情况下，用户直接参与传统机制，并完全根据自己的感知数据$\theta_i$做出决策。</p>
<h4 id="Simulation-Results"><a href="#Simulation-Results" class="headerlink" title="Simulation Results"></a>Simulation Results</h4><p>在图 3 中，我们研究了不同用户数量I和信噪比下用户的信息量。我们发现，每个用户的信息量随着用户数量的增加呈指数级下降。直观地说，当用户数量增加时，每个用户改变后验概率分布$P_\Omega(\cdot|\cdot)$的能力就会减弱。此外，我们还观察到，当信噪比增加时，信息量也会减少。</p>
<p>其次，我们从图 4 中观察到定理 3 中近似系数$\epsilon$的类似趋势。也就是说，近似系数$\epsilon$会随I和信噪比的增大而减小，因为它在很大程度上取决于信息量的大小。这意味着，当有足够多的用户（例如，$I\geq 6$）且用户的传感数据准确（例如，信噪比= 5dB）时，用户几乎是真实的（根据定理 3），预算几乎是平衡的（根据推论 2）。</p>
<p>在图 5 中，我们绘制了在信噪比为 0 dB 时，与独立基准相比，T-SAB 机制实现的事后社会福利（即 (3) 中的目标值）。我们发现，性能增益从 14% 提高到 20%。这意味着，由于传感结果更加准确，更多用户可能会带来更显著的性能提升。</p>
<h2 id="CONCLUSIONS"><a href="#CONCLUSIONS" class="headerlink" title="CONCLUSIONS"></a>CONCLUSIONS</h2><p>资源发现 MCS 系统中相互依赖估值的特点会刺激移动用户误报他们的感知数据。在这项工作中，我们首次提出了 MCS 网络的相互依赖估值问题。考虑到自利用户的私人效用信息和相互依存的估值，我们提出了 T-SAB 机制。我们证明，当用户的信息量较小时，我们提出的 T-SAB 机制可以实现真实性和分配效率，这在大型 MCS 系统中是一个合理的条件。我们的案例研究验证了 T-SAB 机制。未来值得关注的方向包括：激励联合真实感官数据报告和参与 MCS 的机制设计，以及 MCS 系统中其他决策问题（如 Waze 的交通调度）的相互依存估值问题。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>trustworthiness</tag>
        <tag>crowdsourcing</tag>
        <tag>mechanism</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-INFOCOM 2024审稿</title>
    <url>/2023/08/15/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-INFOCOM%202024%E5%AE%A1%E7%A8%BF/</url>
    <content><![CDATA[<h1 id="1570927008——CORE：-通过区块链发布受交易承诺控制的私有数据"><a href="#1570927008——CORE：-通过区块链发布受交易承诺控制的私有数据" class="headerlink" title="1570927008——CORE： 通过区块链发布受交易承诺控制的私有数据"></a>1570927008——CORE： 通过区块链发布受交易承诺控制的私有数据</h1><ol>
<li>针对问题：区块链上交易失败后本该被撤回的私有数据却被接收方收到了</li>
<li>本文方法：设计了CORE协议（transaction commit-controlled release，交易提交控制释放）</li>
<li>常用的私有数据交易方法：<ol>
<li>公链：HTLC（哈希时间锁合约）</li>
<li>许可链：点对点的私有交易</li>
</ol>
</li>
<li>什么情况下会出现事务失败导致私有数据泄露：现有协议假设底层区块链系统是安全可靠的，但实际上交易很可能因为网络延迟和执行故障而失败<ol>
<li>公链中：提款的一方因为各种原因没提成，然后款退回了，但他已经输入了密钥，并被公开，使得另一方既收回了钱，也拿到了密钥</li>
<li>许可链：同样是因为各种原因，背书交易没上链，但私有数据已经发过去了</li>
</ol>
</li>
<li>本文：提出了事务提交控制释放（CORE）协议，确保交易提交后隐私数据才会被拿到<ol>
<li>通信模型：异步通信</li>
<li>安全模型：UC模型</li>
</ol>
</li>
<li>CORE的基本思路：私有数据的释放由事务提交事件控制<ol>
<li>采用一组n个区块链见证人来证明交易提交事件</li>
<li>采用双线性配对密码学来控制仅向预期接收者发布私有数据的时间，同时对所有见证人保密私有数据</li>
<li>利用阈值密码学来容忍t−1恶意证人</li>
</ol>
</li>
<li>CORE协议的六个算法：<ol>
<li>WitnessKeyGen：见证人用的门限加密，要t个签名才能解密</li>
<li>UserKeyGen：对应见证人加密的用t个签名去解密</li>
<li>ReferGen：持有私有数据的节点生成交易编号</li>
<li>Enc：持有私有数据的节点对私有数据进行加密</li>
<li>CmtConfirm：见证人看到交易提交后发出确认</li>
<li>Dec：收到私有数据的节点在t个见证人签名后进行解密</li>
</ol>
</li>
<li>见证人选择和激励：<br> CORE的几个属性允许区块链社区通过半诚实方构建见证服务，类似于现有的RPC服务[33]，以确保具有盈利动机的特殊类型的私有数据传输交易的数据安全。<ol>
<li>私人数据对所有证人都是保密的，并且 CORE 可以容忍一小部分恶意证人。</li>
<li>见证人的提交确认密钥可以通过见证人的公钥和已提交交易的参考进行公开验证，从而可以轻松审计见证人的行为。</li>
<li>见证人的作用仅限于签署已承诺交易的参考文件，其工作量很小。现有的 RPC 服务提供商（例如 Infura [33]）可以进一步集成见证服务来扩展业务并吸引更多用户。</li>
</ol>
</li>
<li>实验：在以太坊和fabric上做了实验，见证人节点是7个</li>
<li>存在问题：<ol>
<li>文中提到了对见证人节点的激励，认为其工作量很小，可以集成到RPC服务中，但是RPC服务目前也存在较大的中心化问题和风险，另一方面如果不设计激励机制，很容易导致见证人节点不确认，最终使得大量交易失败，因此一个合理的激励设计是不可或缺的；</li>
<li>创新性弱，只有增加见证人确认交易上链是新的。</li>
<li>实验中的7个见证人数量很容易受到攻击，如果出于安全性考虑增加见证人节点，是否会严重影响协议性能？</li>
</ol>
</li>
</ol>
<h1 id="1570935843——LightCross：智能合约的轻量级跨分片执行分片"><a href="#1570935843——LightCross：智能合约的轻量级跨分片执行分片" class="headerlink" title="1570935843——LightCross：智能合约的轻量级跨分片执行分片"></a>1570935843——LightCross：智能合约的轻量级跨分片执行分片</h1><ol>
<li>针对问题：<ol>
<li>跨分片交易导致性能降低</li>
<li>大多数解决方案只关注转账交易，不关注智能合约</li>
</ol>
</li>
<li>本文方法：LightCross<ol>
<li>将跨分片交易的执行卸载到配备 TEE 硬件的链下执行器中，该执行器可以适应任意复杂合约的执行</li>
<li>设计了一个轻量级的跨分片提交协议来提交跨分片交易，而无需分片之间的多轮分片到分片通信</li>
<li>通过根据历史交易动态改变合约分布，降低跨分片交易率</li>
</ol>
</li>
<li>实验：基于 FISCO-BCOS 项目实现了 LightCross 原型 </li>
<li>创新的方法：根据从历史交易中学到的知识，定期迁移智能合约，以收集经常同时调用到同一分片的合约。 LightCross将合约之间的关系建模为交易调用图，然后将合约迁移转化为图划分问题。分区后，LightCross采用协议在所有分片之间迁移与合约相关的代码和存储，以降低CSTx比率。</li>
<li>系统设计：<ol>
<li>用户：普通客户端，调用合约</li>
<li>S分片：部署了智能合约的分片，称为合约入口（？这句目前没理解）</li>
<li>执行器：配备TEE的节点，执行跨片交易</li>
<li>R分片：调度跨片交易并广播执行结果的分片</li>
</ol>
</li>
<li>区块链系统向用户隐藏分片信息，例如合约在哪一片等，用户向任意节点提交交易后，交易自动路由到入口分片，然后找到合约所在的S分片，如果合约没调用其他合约，则不涉及跨片，在分片内找个可信任节点执行即可；如果合约调用了其他合约，则属于跨片合约。</li>
<li>信任模型：<ol>
<li>不考虑会影响区块链本身安全性的攻击，每个分片用拜占庭容错协议，恶意节点不超过三分之一，不会分叉。</li>
<li>不考虑会影响TEE安全的问题。</li>
</ol>
</li>
<li>跨片交易执行过程：<ol>
<li>通过 TEE 支持将 CSTx 的执行卸载到链下执行器。然后，其他S-shards可以验证并接受执行结果，而无需重新执行每个CSTx。</li>
<li>不同的执行器可以并行处理不同的CSTx，从而增加系统的并行性。</li>
</ol>
</li>
<li>智能合约迁移：<ol>
<li>定期动态在所有S分片上重新分配智能合约来降低 CSTx 比率</li>
<li>同时调用的合约会聚集在同一个 S 分片中，从而降低 CSTx 比率</li>
</ol>
</li>
<li>跨片协议：<ol>
<li>原始交易创建：发送者账户创建原始交易，表示调用某个地址的合约，然后交易被路由到对应的分片入口。</li>
<li>跨片交易识别：交易如果调用了另一个分片上的合约就会被标记为跨片交易。</li>
<li>跨片交易执行：分片先找TEE执行，执行过程中调用其他分片的合约时，找对应入口发送请求，新分片也是找TEE执行，然后把结果返回给刚才的分片，完成调用。执行之后要生成证书，连同执行结果等一起发给R分片。总的来说就是不管合约代码在哪个分片上，实际执行的都是TEE，每次执行的时候TEE请求合约代码和交易数据等。</li>
<li>跨片交易调度：总的来说就是R分片定期接收消息并调度和验证，然后打包验证结果进行共识，再发给所有S分片（那么R分片很容易被攻击吧）</li>
<li>跨片交易承诺： S分片收到R分片打包的区块后，与R分片协同验证是否有违反串行的，然后把通过验证的交易打包插入下一个块提交</li>
<li>通信基元：通信机制应该安全可靠，以抵御敌对攻击。例如，当一个正确的执行者向S-shard请求状态数据时，通信机制应保证即使存在恶意节点，正确的执行者最终也能收到正确的状态数据。LightCross 利用区块链内置的 Merkle 树来验证从 S-shard 向执行者传输的状态数据，这是一种点对点的可验证发送（见 [31] 中的附录 D）。采用这种方法，执行者只需访问 S-shard 中的几个节点（大多数情况下为 &lt;3），就能获得所需的值。</li>
<li>协议优势：<ol>
<li>跨片交易只在单个节点执行器，无需拆分；</li>
<li>通过批处理来分摊一组 CSTx 的成本。</li>
</ol>
</li>
</ol>
</li>
<li>交易验证：R分片要验证状态更新并及时丢弃已处理的交易<ol>
<li>R分片的交易共识后，打包广播到所有S分片，每个S分片检查所有交易输入的数值是否和当前最新的一致，如果不一致则交易无效；</li>
<li>S分片把验证结果发给R分片，同时锁定交易涉及的写状态，此时如果有其他交易也需要改变状态，则在解锁之前不会被处理；</li>
<li>R分片收到所有分片的验证结果，然后合并得到每个交易的最终验证结果，并广播；</li>
<li>S分片收到R的确认以后，提取通过验证的交易并提交上链，然后释放状态锁。</li>
</ol>
</li>
<li>其他：除了验证单一的跨片交易，也还需要验证互相有联系或冲突的跨片交易，例如同一个状态，一个交易在读，一个交易在写，肯定不行。<ol>
<li>根据时间戳排序</li>
<li>运用其他已有的调度算法</li>
</ol>
</li>
<li>锁定的影响：锁定机制足够轻量，不会产生明显的延迟</li>
<li>R分片调度：只是命令和验证 CSTx 而不是执行它们，因此不会成为瓶颈</li>
<li>智能合约迁移：定期动态将频繁被同一个交易调用的合约们迁移到一个S分片上<ol>
<li>用交易图TCG模拟智能合约之间的关系，将智能合约迁移问题转化为具有时间平衡的离线图分割问题。</li>
<li>TCG的顶点表示合约，顶点权重表示触发合约的事务数；边表示两个合约同时被触发了，边权重表示同时触发的次数</li>
<li>根据历史交易构建此 TCG，有两个目标：<ol>
<li>平衡工作量：将G中的顶点近似划分为相等的不相交子集，直观来说就是不同分片上的合约数量差不多；</li>
<li>(2)低CSTx比率：最小化交叉边的权重之和，即顶点属于两个不同子集的边，直观上来说就是尽量让同一个交易触发的合约在同一个分片上。</li>
</ol>
</li>
<li>由此，合约迁移问题转化为子图分割问题，分割约束：<ol>
<li>每个子图权重尽可能接近总体均值，也就是说每个分片上的合约调用次数差不多</li>
<li>跨子图的边权重尽可能小</li>
</ol>
</li>
<li>这个多目标约束子图分割问题已经有人求解了，每次要迁移的时候，先确定合约的最优分区，然后观察现在的合约分布情况，最小化要移动的状态数据，从而完成迁移，这里认为分片不会太多，所以直接枚举找最小的移动方式。</li>
<li>降低合约迁移开销的措施：<ol>
<li>引入连续的epoch，只在每一轮开始的时候迁移，每一轮的时间要足够长，来分摊迁移开销</li>
<li>尽量减少合约迁移，避免迁移大尺寸合约</li>
<li>跨片合约数量达到一定阈值的时候才开始迁移</li>
</ol>
</li>
<li>合约迁移的过程：新的一轮开始时，R分片协调合约迁移<ol>
<li>准备：每一轮快结束时，R分片停止调度跨片交易，告诉所有S分片这件事，所有S分片处理好内部的跨片交易之后，给R分片发消息</li>
<li>构造TCG：每个S分片收集上一轮的交易，构建部分图，发给R分片，R分片收齐后合并成完整的TCG</li>
<li>图的划分：R分片用已有的方法把TCG划分成分片数量的分区，然后排列枚举确定需要迁移的合约，并创建迁移合约的交易以及广播交易</li>
<li>状态数据迁移：S分片收到广播以后开始迁移合约的状态数据</li>
<li>恢复服务：完成迁移后的S分片会给R分片发送确认消息，然后R分片会在已经确认了的S分片上调度跨片交易</li>
<li>这里并不是移动整个Merkle 子树，而是按照某个参考文献延迟状态数据同步，使得每个 S 分片能够在传输合约时处理交易。</li>
<li>LightCross 维护一个动态路由表来分布式记录这些信息，导航节点将交易路由到其入口 S 分片。这部分内容详见某个参考文献。</li>
</ol>
</li>
</ol>
</li>
<li>存在问题：<ol>
<li>迁移合约的部分认为分片最多20，但实际应用中分片可能不止这么少，比如以太坊就很多，迁移合约带来的时间开销需要再考虑；</li>
<li>定期迁移合约和定期改变节点分片哪种更合适？</li>
<li>合约迁移过程的开始和结束都依赖于R分片与S分片的通信，如果攻击者伪造并发送确认消息，很容易导致某个S分片的交易还没处理完，R分片就开始合并TCG，又或者很长时间某个S分片都无法处理跨片交易，针对这样的问题，在合约迁移中是否有时间限制？或者有其他方式来避免？</li>
<li>构建交易图并根据权重划分分区，然后修改分片的做法创新性较弱，本文也没提出新的图算法；把合约放到TEE执行的做法也不少见，本文总的来说就是TEE+TCG，关注跨片合约这一点是现有研究比较少的，从实验来看性能也有提升。</li>
</ol>
</li>
<li>补充：查资料的时候看到infocom2022有篇论文<strong>BrokerChain: A Cross-Shard Blockchain Protocol for Account/Balance based State Sharding</strong>也是根据历史数据做一个交易状态图并划分，然后动态调整。<h1 id="1570936952——Lipper：在时变对抗群体下利用分片区块链的安全性和活跃性"><a href="#1570936952——Lipper：在时变对抗群体下利用分片区块链的安全性和活跃性" class="headerlink" title="1570936952——Lipper：在时变对抗群体下利用分片区块链的安全性和活跃性"></a>1570936952——Lipper：在时变对抗群体下利用分片区块链的安全性和活跃性</h1></li>
<li>针对问题：现有协议采用悲观方法，总是试图承受固定上限数量的对抗节点。当运行时实际存在的对手较少时，这种方法无法利用最大化事务吞吐量的机会。</li>
<li>本文方法： Lipper，一种新颖的分片协议，可以在最大化交易吞吐量和防御对手的运行时数量之间实现权衡。更具体地说，只要对手的数量低于安全阈值，Lipper的共识推导始终保证网络的安全，而不牺牲交易吞吐量。Lipper 可以根据攻击网络活跃度的对手数量来优雅地调整交易吞吐量。当对手较多（或较少）时，Lipper 将花费更多（或更少）的努力来实现活跃性，从而降低（或增加）交易吞吐量。</li>
<li>大量的实验结果表明，与最先进的方法相比，Lipper 在存在随时间变化的对手群体的情况下实现了卓越的交易吞吐量和鲁棒性。</li>
<li>区块链的安全性有两个关键属性：活跃性和安全性。活跃度是指分片最终向所有参与节点传递新消息的能力。安全性涉及就输出消息的顺序达成共识。安全阈值（S）和活跃阈值（L）分别表示分片内为确保安全性和活跃性而允许的最大允许的敌对参与者比例。</li>
<li>分片在并行和安全之间有权衡</li>
<li>实际场景中，攻击者是动态变化的，有时多有时少，有时正常有时恶意，现有的实时调整分片的方法会增加开销</li>
<li>本文：根据时变的对抗群体调整其行为，同时最大限度地减少开销<ol>
<li>允许具有高 S 和低 L 的小分片来实现高并行性</li>
<li>两层投票机制，该机制使用额外的投票过程来恢复停滞的分片。由于额外投票的开销与停滞分片的数量成正比，因此系统的交易吞吐量会根据运行时的对抗性群体进行适度调整。</li>
</ol>
</li>
<li>实验：与Gearbox 和 Rapidchain比较，说明了本文方法的好处</li>
<li>Lipper：两层多阶段分片协议，动态调整活跃度和安全阈值，并在运行时适应随时间变化的对抗群体<ol>
<li>支持双向扩展，可根据随时间变化的对抗群体自动调整事务吞吐量。</li>
<li>它能有效避免调整分片大小或分片数量，</li>
<li>还能防止分片成员重叠。</li>
</ol>
</li>
<li>概述：两层结构，工作分片和委员会分片<ol>
<li>S &lt; 100% 且 L = 0% 的工作分片包含少量节点并管理一系列交易（钱包账户）。 </li>
<li>S = L &lt; 50% 的委员会分片管理多个工作分片。</li>
<li>同一层的分片不共享重叠的成员。</li>
<li>每个节点都被随机分配给一个工作分片和管理它的委员会分片。</li>
</ol>
</li>
<li>五阶段协议：每个分片至少经过一阶段，至多经过五阶段<ol>
<li>每阶段分片内超过安全阈值数量的节点达成共识，这个阈值与阶段有关，越往后越容易达到，例如第一阶段要87.5%的节点共识，第二阶段就只需要75%，而最多到第五阶段是37.5%，每阶段会引入一些新的节点（helper）。</li>
<li>这一段我理解起来有点混乱，前面说是5阶段（phase），后面又说如果第一阶段（也是phase）没共识，则进入第二阶段，并把安全阈值调到83.3%， 这和前面5阶段的公式不一样，但是按描述是一样的，此外这里出现的V=1也不明白是表示什么，</li>
<li>总体来说就是当分片内节点中的不同声音很少时，意味着大部分都是诚实节点，系统是安全的，于是飞快达成共识；当不同声音较多，没法达成共识的时候，就引入更多外部节点，扩大分片，同时适当降低安全阈值，来试图达成共识。由此实现分片大小、安全性设置随对抗群体规模动态变化。</li>
</ol>
</li>
<li>与其他分片方法不同，lipper并不会破坏旧的分片把它们合并成新的大分片，每阶段会引入的helper是一开始就固定的，并且helper只同步最新的确认状态和最新的区块，而分片本身会更新状态。在最坏的情况下，当L、S &lt; 50%时，可以在最后阶段做出决策，表明分片中的大多数节点是诚实的。</li>
<li>系统模型：网络有N个节点，其中Nc是委员会分片，Nw是工作分片，每个节点都在一个工作分片和管理该工作分片的委员会分片上。</li>
<li>攻击模型：<ol>
<li>容忍三分之一的恶意节点</li>
<li>对抗节点和诚实节点的集合在每个 epoch 期间保持固定，并且只能在 epoch 之间更改。</li>
</ol>
</li>
<li>Lipper协议：<ol>
<li>随机性生成：节点在哪个分片是随机的</li>
<li>节点分配：首先节点公开共享所有节点的预定义列表，然后每个节点根据列表可以计算自己和其他节点在工作分片和委员会分片上的id，从而确定所属分片和helper</li>
<li>区块链结构：<ol>
<li>每个工作/委员会分片都有各自的链，每个节点同时维护主链和所属分片的链</li>
<li>工作分片：采用State-block-State 结构，每个 WS Block 后面都会链接一个 State，State 不存储详细的交易信息，仅捕获当前 WS Block 执行后的账户余额。当验证一个WS块的正确性时，检查对应的先前状态的账户余额列表就足够了</li>
<li>委员会分片：委员会不记录分片交易数据，存储在特定时间段内其管辖下的所有 WS 达成共识的 WS 区块的哈希值。主要目标是确保 CS 内的所有节点都知道所有共识 WS 块，从而减轻跨分片交易中恶意攻击的可能性。</li>
</ol>
</li>
<li>共识阶段：<ol>
<li>符号定义：每阶段有num_i个节点需要参与投票，阶段时长T_i，安全阈值S_i，由此可以计算活跃阈值L&lt;1-S_i，这里的问题是为什么L是这么算的，以及L是不是应该改成L_i呢？</li>
<li>流程：通过引导将节点随机分配到工作分片和委员会分片后，Lipper 进入共识阶段。在此阶段，Lipper 并行执行每个委员会分片。在每个委员会分片内，工作分片也同时运行<ol>
<li>选leader：索引最低的节点成为leader，索引随机生成，因此leader也随机。如果leader生成的区块被共识拒绝，则在剩余的非对手节点中选索引最低的成为新leader。</li>
<li>工作分片：leader收集交易生成区块，并在工作分片内进行投票共识，值得注意的是，在第一阶段，当 (S1 × N um1) 个节点的阈值投出相同的票时，就会达成共识，其中 S1 = 100%，Num1 = Nw。这里和前面的安全阈值公式也不一样。第一阶段的共识协议会产生两种可能的结果：<ol>
<li>达成共识，开始下一轮</li>
<li>没达成共识，进入下一阶段，引入新节点作为helper参与投票，此前的投票也会累积加进来，同时从第二阶段开始如果区块被共识拒绝，则会换leader</li>
</ol>
</li>
<li>助手（helper）：助手不需要同步所有数据，只访问上一轮的状态。每当节点对WS块进行投票时，都需要将该投票发送给同一CS内的所有其他节点。这样，在任何给定时刻，节点都可以获取同一CS下所有WS的状态信息，包括是否达成共识以及每个WS当前处于哪个阶段。通过这些信息，节点可以确定它应该参与哪个阶段并充当 CS 内任何 WS 的帮助者。</li>
<li>委员会分片：leader统计CS内所有达成共识的WS分片的哈希并建立CS块，并广播到所有CS节点，然后投票共识，其安全阈值固定是50%。WS 和 CS 分片在尝试达成共识时都是独立运行的。他们既不互相依赖，也不互相等待。</li>
</ol>
</li>
</ol>
</li>
<li>跨分片交易：委员会分片允许直接集成传统分片区块链中常用的跨分片交易协议</li>
<li>参数确定：S_i的公式感觉不对劲，应该是i-1</li>
</ol>
</li>
<li>实验部分比较了吞吐量等指标，说明了lipper比gearchain和rapidchain在吞吐量和存储效率方面更好</li>
<li>存在问题：<ol>
<li>在跨片交易中，跨WS和跨CS是否有区别？</li>
<li>公式存在问题，一个是V=1，一个是计算S的公式</li>
<li>针对S和针对L的攻击是分开考虑吗？为什么可以根据1-S来计算L</li>
<li>这种先在小分片内进行100%共识，没成功再逐渐扩大的方式是有创新的，但是小分片带来的跨片交易延迟与开销也应该考虑进来</li>
</ol>
</li>
</ol>
<h1 id="1570906233——FISFU：联邦遗忘的公平意识激励计划"><a href="#1570906233——FISFU：联邦遗忘的公平意识激励计划" class="headerlink" title="1570906233——FISFU：联邦遗忘的公平意识激励计划"></a>1570906233——FISFU：联邦遗忘的公平意识激励计划</h1><ol>
<li>针对问题：联邦遗忘没有考虑对用户的激励</li>
<li>本文：联邦遗忘公平意识激励方案FISFU<ol>
<li>遗忘阶段加入惩罚机制</li>
<li>恢复阶段把一部分惩罚作为奖励分配</li>
</ol>
</li>
<li>进行了广泛的评估，以证明FISFU在恢复训练阶段惩罚遗忘客户端并降低服务器成本的能力，证实了我们的方案在联邦遗忘期间实现公平奖励分配的能力</li>
<li>现有联邦学习激励机制存在的问题：<ol>
<li>这些机制未能认识到客户端可能发起联合取消学习的可能性</li>
<li>他们忽视了在遗忘过程后进行恢复训练以提高模型准确性的必要性，导致这一阶段的训练缺乏激励</li>
</ol>
</li>
<li>设计激励机制面临的挑战：<ol>
<li>建立精准的惩罚机制：很难同时根据遗忘模型的准确性确定遗忘客户端的惩罚，并平衡失学客户端的隐私收益和模型价值的下降。</li>
<li>激励恢复训练：根据恢复后模型的准确率，很难确定分配多少惩罚作为奖励来鼓励客户端进行恢复训练，并确保该奖励在服务器的性能之间取得平衡支出和模型价值的增加。</li>
</ol>
</li>
<li>本文贡献：提出了FISFU<ol>
<li>第一阶段：某个客户端发起取消学习请求时，我们对该客户端实施惩罚机制。我们使用遗忘后模型的准确性来量化遗忘客户端的隐私收益和模型价值的下降。通过根据这些因素以及惩罚水平仔细构建效用函数，我们从理论上证实了最优惩罚率可以在隐私收益和模型价值的下降之间取得平衡。</li>
<li>第二阶段：根据恢复模型的准确率计算模型值的增加量，设计一个随模型值增加量、每个客户端的恢复训练成本、恢复训练奖励的效用函数，使得服务器能够确定收到的惩罚的最佳数量，以分配为恢复训练的奖励，从而实现服务器支出和模型价值增加之间的平衡。</li>
<li>总而言之贡献如下：<ol>
<li>第一个关注联邦遗忘的奖惩问题</li>
<li>设计并从理论上验证了最优惩罚机制，该机制平衡了隐私优势和模型价值的降低。</li>
<li>设计了独特的恢复训练激励机制，将收到的惩罚最优分配为奖励，以激励客户端参与恢复训练，有效维持服务器支出与模型价值增长之间的平衡。</li>
</ol>
</li>
</ol>
</li>
<li>基础内容：联邦学习和联邦遗忘的方法采用已有论文的内容，联邦激励设计也是已有论文的内容</li>
<li>系统模型：<ol>
<li>整体流程：最初所有客户端在本地训练一定精度的模型，服务器则给客户端对应的奖励，当某客户端要求撤回数据时，模型的准确性会受到影响，其他客户端需要再做恢复训练，服务器给的补偿决定了每个客户端恢复的准确性。系统图中的recover似乎打错成了rocover</li>
<li>惩罚函数：由没收和惩罚组成$\phi(\theta_k, \theta_u,\eta)=P_i+\eta[ln(\theta_k+1)-ln(\theta_u+1)]$<ol>
<li>没收之前训练给的奖励，记作P_i</li>
<li>额外罚款，是$\eta[ln(\theta_k+1)-ln(\theta_u+1)]$，这里$ln(\theta+1)$是参照联邦遗忘那个论文中的模型准确率价值，两个相减表示遗忘带来的准确率损失，而系数就是惩罚率。</li>
</ol>
</li>
<li>客户端在成功撤回的时候，会收到数据提供者给的奖励，具体来说是数据提供者奖励率$\delta$与模型准确率下降差异的乘积，这个奖励率因人而异。</li>
<li>在执行遗忘算法之前，将遗忘后的准确度确定为算法执行的阈值。获得的遗忘奖励是根据这个遗忘后的准确率来计算的：$R(\theta_k, \theta_u,\delta) = \delta(\theta_k − \theta_u)$，这里和上一条一个意思。</li>
<li>遗忘客户端的效用：遗忘奖励减去服务器的惩罚$R()-\phi()$</li>
<li>服务器效用：收到的惩罚减去模型准确度下降的损失$\phi()-\beta[ln(\theta_k+1)-ln(\theta_u+1)]$，其中$\beta$是模型的价值率</li>
<li>总体思想：该服务器效用函数通过控制未学习客户端的惩罚率来最大化服务器的效用，从而平衡模型退化的程度和收到的总惩罚。</li>
<li>客户端策略：遗忘后的准确率$\theta_u$；服务器策略：惩罚率。惩罚过程是算法1，这里算法1的标题打错字了，应该是punishment，打成了publishment。这个算法大致思路是首先对客户端的收益函数求导取0，找使客户端收益最大的$\theta_u$，再对服务端的收益函数求导取0，找使服务器收益最大的惩罚率$\eta$。定了两个目标参数之后，就是根据参考文献的方法逆向梯度来遗忘。</li>
<li>奖励机制：奖励那些没撤回数据的客户端<ol>
<li>计算每个客户端学习前后的准确率之差，所有客户端根据对最终模型准确率的贡献比例分配奖励</li>
<li>客户端i的效用由两部分组成，是服务器给的奖励减去客户端自己学习的消耗，这里公式有问题，下面介绍了的字母R没出现在公式中，反而是$\xi_i$没有给解释（在前面很远的地方有解释，但是R也一样在前面有解释）</li>
<li>对效用函数求导取0，可以得到使得客户端i效用最大化的训练后精度</li>
</ol>
</li>
<li>服务器策略：效用函数修改为“模型值的增量加上对未学习客户端施加的惩罚，减去用于激励剩余客户端的总奖励”，效用函数求导取0可以得到服务器拿出来激励客户端训练的最优总奖励。如果对发起遗忘客户端的惩罚小于这个最优总奖励，那服务器就得赔钱进去来激励客户端训练，反之就是挣钱了</li>
</ol>
</li>
<li>实验评估：<ol>
<li>数据集：MNIST的60000张图</li>
<li>客户端：10个独立同分布，每个接收6000张图</li>
<li>测试集：1000张图</li>
<li>模型：CNN</li>
<li>参数设置：价值率、准确率、奖励以及CNN训练涉及的参数等都进行了设置</li>
<li>评估过程：<ol>
<li>数值验证算法选择的策略的有效性</li>
<li>进行了模拟，并将准确性与无激励的不学习算法进行了比较</li>
<li>分析了整个过程中各方收益变化曲线和原因，还算合理</li>
<li>设置了对客户端的不同奖励来观察策略变化，不过没分析原因，最好能加上</li>
<li>总的来说实验部分就是分析各种参数变化对前文算法中的各方策略的影响</li>
<li>也对比了不进行激励的情况，显然不激励的时候恢复训练会不太行，不过我觉着别的算法也会激励，毕竟撤回以后的恢复可以看作是新的训练过程了</li>
<li>遗忘后的准确率越低，服务器给的惩罚越大（这不是显然吗，前面的函数就这么设计的呀</li>
<li>和其他恢复训练的激励算法的对比：<ol>
<li>IMEF：遗忘后服务器出钱让客户端恢复</li>
<li>IMOF：服务器激励客户端来弥补隐私成本，客户端的策略是目标准确率和迭代轮数</li>
<li>LBIM：客户端的策略是确定用来训练的数据量</li>
</ol>
</li>
</ol>
</li>
<li>这里的问题是 ，胡萝卜加大棒这个概括在实验部分才第一次出现，前面的摘要、引言和理论描述都没出现，在写作上不太妙</li>
</ol>
</li>
<li>存在问题：<ol>
<li>已经有一部分针对联邦遗忘的激励机制，intro中说“现有联邦学习激励机制存在的问题”是不准确的，同时related work中也建议补充完善这部分内容</li>
<li>贡献部分说是第一个做联邦遗忘激励的，这也不准确，建议充分调研</li>
<li>实验部分图2应该补充服务器效用随遗忘后全局模型的准确性的变化，以及遗忘客户端效用随惩罚率的变化</li>
<li>如果惩罚比奖励小，是什么使得服务器贴钱也要进行恢复呢？如果服务器有准确率提升带来的额外收益，那应该也在计算中体现出来</li>
<li>实验中提到了数据提供者给的撤回奖励越高，惩罚率和服务器效用也会有所变化，但是没有解释原因</li>
<li>有没有考虑过收益函数为负的情况？论文中没有这方面的讨论，但是如果收益函数为负，客户端还会撤回吗？</li>
<li>前面提到的一系列写错了的词、少了的字母解释等</li>
</ol>
</li>
</ol>
<h1 id="1570937888——基于区块链的纵向联邦学习支持多方参与"><a href="#1570937888——基于区块链的纵向联邦学习支持多方参与" class="headerlink" title="1570937888——基于区块链的纵向联邦学习支持多方参与"></a>1570937888——基于区块链的纵向联邦学习支持多方参与</h1><ol>
<li>针对问题：纵向联邦学习VFL普遍采用PSI协议，但是现有方案：<ol>
<li>仅支持两个参与者之间的加密ID对齐，并且需要以全连接的方式为多个参与者执行【这一点应该不算问题，查了一下做多方PSI的有很多，各有各的方法】</li>
<li>此外，VFL中使用集中式参数服务器来分发加密密钥并更新加密的训练参数，成为单点攻击的目标</li>
</ol>
</li>
<li>本文：基于区块链的纵向联邦学习（BVFL）<ol>
<li>一种基于区块链的多方 PSI 协议，具有快速的两阶段加密 ID 对齐策略</li>
<li>设计了一种基于PoW的随机密钥分配方法</li>
<li>提出了一种基于随机掩码和训练梯度上同态加密聚合的真实的基于区块链的模型训练方案</li>
</ol>
</li>
<li>实验表明：<ol>
<li>BVFL 中的 PSI 协议的执行速度是现有 PSI 协议的两倍以上</li>
<li>BVFL 中基于块的模型训练在准确性上接近集中式训练</li>
</ol>
</li>
<li>纵向联邦学习VFL：多个数据提供者持有相同样本的不同特征</li>
<li>现有相关研究集中在隐私保护和适用性方面，存在前述的两个问题</li>
<li>本文贡献：<ol>
<li>基于区块链的VFL方案</li>
<li>快速多方PSI协议</li>
<li>基于区块链的安全密钥分发和模型训练</li>
<li>实验表明结果好（感觉贡献里单独写一条实验不太合适吧）</li>
</ol>
</li>
<li>系统结构：<ol>
<li>联邦学习层：训练模型，不同参与者之间通过PSI协议对齐样本空间ID</li>
<li>区块链层：<ol>
<li>矿工节点：验证交易托管账本，假设诚实可信</li>
<li>排序节点：对交易排序并生成区块</li>
</ol>
</li>
<li>应用层：参与联邦学习的边缘节点设施，有API接口</li>
<li>联邦学习层到区块链层的数据加密，区块链的作用主要是取代传统VFL的第三方，为参与者生成密钥</li>
</ol>
</li>
<li>关键步骤：<ol>
<li>基于区块链的PSI：介绍了样本对齐的概念，说明本文提出了基于区块链的支持多参与者的PSI</li>
<li>基于区块链的模型训练：传统方法是中心化协作者用同态加密传输模型参数，易受攻击，本文提出了基于区块链的训练，去中心化，具体案例方面实现了安全逻辑回归的训练</li>
</ol>
</li>
<li>PSI协议：<ol>
<li>N+1个参与者，其ID集合记作P，包含p_label和p_i，前者表示有label的参与者。</li>
<li>参与者拥有的数据集的样本空间记作D，包含d_label和d_i</li>
<li>矿工集合是M，一共有N_M个，每个m_j持有公钥k_j^m，用作通信密钥和信息认证码</li>
<li>两方PSI协议：这段主要是介绍PSI的作用</li>
<li>本文PSI的设计目标：<ol>
<li>支持多参与者</li>
<li>基于密码学和区块链，实现快速、安全的ID交换和比对验证</li>
</ol>
</li>
<li>PSI流程：<ol>
<li>基于可交换加密算法实现</li>
<li>包括以下步骤：<ol>
<li>连接建立：参与者通过矿工的公共地址随机与多个矿工简历连接</li>
<li>私有 ID 集上传：矿工m_j和参与者p_n连接，则p_n用公钥k_j^m对自己的ID集的哈希值进行加密，然后发给m_j</li>
<li>第一 ID 对齐：m_j连接的参与者集合是P_j，m_j会收到都是用k_j^m加密的不同参与者的ID集哈希。然后矿工执行第一次ID对齐，把自己收到的这些都对齐了，具体操作过程如下：<ol>
<li>首先，矿工 mj 初始化轮数 num = 0 和第一 ID 对齐集 Sj = ∅</li>
<li>当num = 1时，mj直接合并ExEnc(H(di1d), kmj )和Sj（第4行到第6行）。</li>
<li>然后，矿工 mj 在他/她收到的所有私有样本 ID 中挑选出相同的加密 ExEncvalues 来形成 Sj（第 8 行到第 10 行）。</li>
</ol>
</li>
<li>第二 ID 对齐：所有矿工用自己的公钥和对齐后的ID生成消息认证码，并打包发给排序节点。排序节点之间相互共享交易，并验证真实性，然后执行第二次对齐，过程如下：<ol>
<li>首先，排序节点初始化一些参数（私有交集集 U = ∅，已验证参与者集 P = 0，回合数 num = 1）（第 1 行至第 4 行）。</li>
<li>在每一轮中，排序节点都需要验证已验证的参与者集 P 是否等于总参与者集 P，如果是，则该算法终止。同样，如果私有交集 U = ∅，排序节点直接将 S1 插入 U 中（第 8 行至第 11 行）。</li>
<li>接下来，图 3 举例说明了下一个过程。如图 3（a）所示，每个 u∈U 中的元素之间存在一种特殊关系。例如，在图 3 (a)中，序号为 “1 “的所有元素表示它们拥有相同的明文（样本 ID=3）。我们使用这些序列号来建立上述特殊关系。</li>
<li>如图 3(b) 所示，排序节点通过可交换加密更新 u1 和 $u_{num}(u1:[4, k_1^m], [5, k_1^m]; u_{num}:[4, k_{num}^m], [5, k_{num}^m])$的交集（第 13 行到第 18 行）。计算交集后，排序节点选择当前的序列号，并将其保留在新一轮中（第 19 行）。排序节点删除每个 u 中没有当前序列号的元素（第 20 行）。在图 3(b) 的步骤 2 中，将通过插入 u_num 来更新私有交集 U，并且将重新排列序列号（第 21 行）。</li>
</ol>
</li>
<li>区块链更新：<ol>
<li>排序节点生成新区块并广播</li>
<li>矿工验证区块并进行PoW，然后广播</li>
<li>所有矿工接收并验证区块后，和自己连接了的参与者共享第二次对齐的结果</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>基于区块链的模型训练：<ol>
<li>问题分析：联邦学习使用对齐后的样本进行<ol>
<li>传统安全逻辑回归：介绍了一下公式模型</li>
<li>设计目标：基于区块链的安全逻辑回归多方模型训练框架</li>
</ol>
</li>
<li>训练流程：<ol>
<li>准备：PoW胜利的矿工广播区块</li>
<li>训练与更新：<ol>
<li>分发密钥：矿工给自己连接的参与者发公钥</li>
<li>训练模型：和传统的联邦学习一样</li>
<li>同态加密：参与者使用第一阶段的公钥对模型训练的中间输出加密</li>
<li>上传隐私梯度：生成随机掩码与前一步的加密梯度相加并发给矿工</li>
<li>返回梯度：矿工解密并返回给参与者</li>
<li>上传测试结果：参与者用矿工返回的结果更新模型，并将测试集结果发给矿工，矿工将测试结果打包成交易发送给排序节点</li>
<li>生成区块并准备：排序节点把有效交易放到新区块中，矿工PoW竞争，获胜者为下一轮选择第一步中的密钥</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>安全性分析<ol>
<li>PSI 的正确性</li>
<li>BVFL 的安全分析</li>
<li>这部分没细看，大致意思就是密码学保证是安全的，感觉安全性问题得结合实验看了</li>
</ol>
</li>
<li>实验：<ol>
<li>实验中出现的矿工数量很少，这会带来安全性问题</li>
<li>实验中的参与者数量同样少，实验中体现的性能可能并不现实</li>
<li>好像没和其他联邦学习做对比实验</li>
<li>很多联邦学习会关注通信轮数的指标，而本文引入了区块链技术，其效率也很依赖于通信轮数，建议实验中增加该指标，或者说明为什么没用这个指标</li>
</ol>
</li>
<li>存在问题<ol>
<li>写作方面前面有很多比较冗长且含义重复的介绍，一些已经介绍过的理论不必重复</li>
<li>现阶段已经有很多多方PSI，这与本文intro不符，建议进一步调研文献</li>
<li>对矿工和排序节点的选择依据和激励方式不明确</li>
<li>实验部分的4个问题</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
        <tag>审稿意见</tag>
        <tag>mechanism design</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Evolution of cooperation in stochastic games</title>
    <url>/2023/07/20/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Evolution%20of%20cooperation%20in%20stochastic%20games/</url>
    <content><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><ol>
<li>阅读本文的原因：了解随机博弈中的合作</li>
<li>本文研究目的：激励相容不满足时，会出现社会困境，本文用随机博弈和演化博弈分析当公共资源可变时个体的决策变化</li>
<li>本文与我研究的相关性：是博弈论</li>
<li>本文的潜在假设：公共资源可变，合作增加公共资源，而背叛则减少公共资源。</li>
<li>本文研究方法：随机博弈和演化博弈</li>
<li>本文研究结论：<ol>
<li>公共资源对以往互动的依赖可以大大增强合作倾向。</li>
<li>互惠和回报反馈之间的相互作用至关重要：无论是在恒定环境中的重复交互还是在变化的环境中的单次交互都不会产生类似的合作率。</li>
<li>剥削与环境之间的反馈（无论是自然发生的还是设计的）有助于克服社会困境。</li>
</ol>
</li>
<li>是否进一步阅读：略读一下</li>
</ol>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><ol>
<li>公地悲剧：公地作为一项资源或财产有许多拥有者，他们中的每一个都有使用权，但没有权利阻止其他人使用，而每一个人都倾向于过度使用，从而造成资源的枯竭。</li>
<li>已有分析：公共物品博弈<code>public goods game</code>、集体风险困境<code>collective-risk dilemma</code></li>
<li>存在问题：假设公共利益在时间上保持不变，与之前互动的结果无关</li>
<li>本文：人类影响公共资源的价值并受到公共资源价值的影响，并且他们能够预测并适应这种内生变化</li>
</ol>
<h2 id="随机博弈"><a href="#随机博弈" class="headerlink" title="随机博弈"></a>随机博弈</h2><p>一组玩家可以处于多种状态之一，不同的状态反映了当前的物理或社会环境如何影响玩家的可行行动及其回报。如下图a所示：在公共物品博弈中，如果一些玩家叛变，那么环境可能会恶化，从而降低公共物品的价值。如果所有人都合作，那么环境就会恢复，公共物品的原始价值也可能恢复。环境的不同状态对应着可以进行的不同博弈。</p>
<p>在b中，如果玩家的行动和当前的博弈唯一地决定了下一轮的博弈，那么这个随机博弈就是确定的。如果下一轮的博弈只取决于博弈者的行动，而不取决于当前的博弈（状态），那么这个博弈就是与状态无关的。因此，根据过渡是确定性的还是概率性的（其中<code>p</code> 和<code>1-p</code> 表示进行相应过渡的概率），以及它们是与状态无关还是与状态相关，我们将随机博弈分为四种不同类型。我们注意到，即使只涉及确定性过渡的博弈也被称为 “随机 “博弈，因为它代表了该框架的一种特殊情况。</p>
<p>在某些情况下，博弈者的策略和环境的共同演化会导致合作者和叛逃者之间的振荡。但如果合作者在任何环境中都处于劣势，环境反馈就无法有效阻止合作者灭绝。一次性模型假定博弈者在进行策略选择时只考虑当前的收益。而在随机博弈中，博弈者会从长远角度考虑问题。为了找到最佳策略，他们需要考虑自己的行动会如何影响对手的反应以及未来的环境状况。正如我们所展示的，互惠和回报反馈之间的相互作用对于合作至关重要。</p>
<p><img src="https://github.com/likun1208/image/blob/master/ECSG-1.png?raw=true" alt="随机博弈示意图"></p>
<h2 id="本文博弈模型"><a href="#本文博弈模型" class="headerlink" title="本文博弈模型"></a>本文博弈模型</h2><p>传统上，随机博弈的研究考虑可以采用任意复杂策略的理性玩家，但不关注玩家如何调整策略的动态。我们引入了随机博弈的进化视角。玩家不需要理性行动，而是尝试可用的策略并根据成功情况模仿其他策略。</p>
<p>我们首先研究具有两种状态的随机博弈，每个个体使用纯粹的“记忆”策略，即玩家的行动仅取决于当前状态和上一轮的结果。该博弈中，每一轮开始时公共资源会在参与者之间重新分配。合适的参数会使得合作所对应的博弈比背叛所对应的博弈更好，模拟表明，这种反馈可以显着促进合作。对于合理的参数，随机博弈群体很快就会适应充分合作。</p>
<p><img src="https://github.com/likun1208/image/blob/master/ECSG-2.png?raw=true" alt="随机博弈记忆策略示意图"></p>
<p>当参数满足一定条件时，该博弈会稳定出现合作，这意味着合作的稳定性取决于参与者决策下状态如何变化。为了探究更具体的关系，本文进行了更多参数的模拟。同时也发现增加概率性转变更有助于促进合作。</p>
<p>接下来我们探讨博弈收益和策略选择之间的理想反馈。我们考虑一个有四个玩家和五个状态的随机博弈。一小部分参与者的背叛会对合作收益产生直接、渐进或延迟的负面影响，或者没有影响。当负面影响是立即产生时，合作率最高，直观的解释是：如果游戏者在最有价值的游戏中合作的积极性最高，则合作率最高。而即便是延迟的负面影响，也比完全没影响能带来更高的合作率。当五个状态下合作的收益都很高时，合作率最低。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们引入了一个概念，即在不同的回合中，博弈的回报会发生变化。我们探讨了合作会导致下一轮游戏更有价值，而叛逃会导致下一轮游戏价值更低的情况。我们发现这种情况会明显促进合作。在由此产生的随机博弈中，即使合作在所有个体重复博弈中都不成功，合作也能占上风。我们的观察结果表明，自然发生或设计的反馈可以促进合作。如果叛逃导致环境（迅速）恶化，就可以避免公地悲剧。同样，如果当前的合作有希望获得更高的收益，那么合作也会得到促进。</p>
<p>论文中的数据应该是matlab仿真得到的。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录 - Social Decision-Making: Insights from Game Theory and Neuroscience</title>
    <url>/2023/07/20/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Social%20Decision%20Making%20Insights%20from%20Game%20Theory%20and%20Neuroscience/</url>
    <content><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><ol>
<li>阅读本文的原因：了解一下神经科学对博弈论的看法</li>
<li>本文研究目的：探讨神经系统在博弈场景中如何影响决策</li>
<li>本文与我研究的相关性：关系不大，都有博弈论</li>
<li>本文的潜在假设：无</li>
<li>本文研究方法：大致就是做博弈决策的同时也分析玩家神经数据的变化</li>
<li>本文研究结论：人并不是完全理性的，社会决策中往往会受各因素影响</li>
<li>是否进一步阅读：否</li>
</ol>
<p>过往的博弈论研究普遍假设玩家是纯粹理性的、自私自利的，但实际上生活中的人们在决策时并没有这样自私和策略性，例如讨价还价博弈、信任博弈、囚徒困境等，实际中的实验与理论上的分析都不太一致。一些现有研究会在玩家进行博弈时观测脑细胞、神经系统等变化，并发现多巴胺、纹状体等在决策时确实有影响。同时，情绪对社会决策也有影响，而传统模型普遍忽略了。“这些情绪反应被认为是一种避免不平等的机制，并且可能正是为了促进互惠、使声誉变得重要以及鼓励惩罚那些试图利用他人的人而发展起来的。”</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>Game theory</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-The universal visitation law of human mobility</title>
    <url>/2023/07/19/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-The%20universal%20visitation%20law%20of%20human%20mobility/</url>
    <content><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><ol>
<li>阅读本文的原因：之前毕业论文提到了这个人群移动性的问题，因此现在详细看一下</li>
<li>本文研究目的：探索人类移动性的空间和时间特征,建立一个可以同时描述人类移动的距离和频率分布的框架。</li>
<li>本文与我研究的相关性：之前的研究中用到了，考虑是否能迁移到区块链的场景中。</li>
<li>本文的潜在假设：个体对特定地点的吸引力主要取决于对该地点特征的共同兴趣,因此不同起点地对一个地点的吸引力应该是相近的。</li>
<li>本文研究方法：利用全球不同地区的大规模手机定位数据集,统计每个地点的访问者所处位置的距离分布和访问频率分布。</li>
<li>本文研究结论：<ol>
<li>访问者数量与其行程距离和访问频率的乘积的平方呈反比,这个规律在不同地区高度一致。不同吸引力地点的有效旅行距离是一致的。</li>
<li>发现了一个简单但强大的关于人类移动的访问定律,它只依赖距离和频率的乘积,而与具体的距离或频率无关。这个定律支持了中心地理论等地理假说,并可用于预测城市间的流动。</li>
</ol>
</li>
<li>是否进一步阅读：是</li>
</ol>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ol>
<li>此前的模型（重力定律、辐射模型等）专注于流动性的纯粹空间依赖性，并且没有捕获重复访问同一地点的不同频率。</li>
<li>本文：基于来自全球不同城市的大规模流动数据来捕获人口流动的时间和空间范围</li>
<li>结论：<ol>
<li>任何地点的游客数量都会随着访问频率与旅行距离乘积的平方反比而减少</li>
<li>流向不同位置的时空流会产生突出的空间集群，其面积分布遵循齐普夫定律</li>
<li>建立了一个基于探索和优先回报的个体流动模型，为发现的尺度规律和新兴的空间结构提供机械解释</li>
</ol>
</li>
</ol>
<h2 id="Distance–frequency-scaling-of-spectral-population-flows"><a href="#Distance–frequency-scaling-of-spectral-population-flows" class="headerlink" title="Distance–frequency scaling of spectral population flows"></a>Distance–frequency scaling of spectral population flows</h2><p>这部分分析人口流动性的空间和时间元素，把整个区域划分成小格子，将夜间停留的地方定义为家<code>home</code>，接下来对访问过每个小格子的用户进行分组，分组依据是小格子到用户家的距离<code>r</code>以及用户的访问频率<code>f</code>，最后对每个区域的访客数量根据该区域的面积进行了标准化处理，所得的结果被称为“频谱流”。本文证明了频谱流并不分别依赖于<code>r</code>和<code>f</code>，但是与<code>rf</code>相关。</p>
<h2 id="Spatial-distribution-of-the-attractiveness"><a href="#Spatial-distribution-of-the-attractiveness" class="headerlink" title="Spatial distribution of the attractiveness"></a>Spatial distribution of the attractiveness</h2><p>这部分的结论是符合Zipf定律。具体内容没看懂。</p>
<h2 id="Microscopic-model-of-spectral-population-flows"><a href="#Microscopic-model-of-spectral-population-flows" class="headerlink" title="Microscopic model of spectral population flows"></a>Microscopic model of spectral population flows</h2><p>这部分是要建立人口流动模型。</p>
<p>从前文可以得出以下两条规律：</p>
<ol>
<li>流向地点的时空人口流动遵循高度可重复的标度律</li>
<li>尽管这些流动的规模在不同地点之间差异很大，但它们表现出系统的空间聚集</li>
</ol>
<p>首先从EPR模型开始。在每个时间步，个体（智能体）以一定的概率选择探索一个新的、以前未访问过的位置，或者以互补的概率返回到以前访问过的位置之一（优先选择那些智能体访问频率更高的位置）。EPR模型在访问各位置的距离-频率缩放上表现与实际相符，但是由于智能体彼此独立地选择位置，EPR 模型无法重现位置吸引力及其系统空间聚类的异质性。事实上，个体的轨迹并不是独立的，而是通过共同的吸引力点在空间上耦合的：人们倾向于去其他人经常光顾的热门地点（例如购物区）。</p>
<p>针对该问题，本文将智能体的运动耦合到模型中，以便在探索新位置时，它们会优先被吸引到频繁出现的区域，该模型被称为优先勘探和优先回报（PEPR）模型，模拟表示一切都与实际相符。</p>
<h2 id="Prediction-of-origin–destination-flows"><a href="#Prediction-of-origin–destination-flows" class="headerlink" title="Prediction of origin–destination flows"></a>Prediction of origin–destination flows</h2><p>这部分内容是讲：可以根据人口密度来估计距离-频率缩放尺度，由此直接计算来自任何出发地的出行次数或唯一访客数量。</p>
<h2 id="Discuss"><a href="#Discuss" class="headerlink" title="Discuss"></a>Discuss</h2><p>核心结论：任何地点的游客数量都与旅行距离和访问频率的平方成反比。</p>
<p>该研究证实了中心地理论CPT的一些关键思想，例如，我们的结果支持位置嵌套层次结构的存在，其中具有专门功能的高阶中心（例如购物中心和博物馆），它们有着较低的访问频率，也具有非专门功能的低阶中心（例如杂货店和餐馆），它们有着更高的访问频率。因此，更专业的功能不仅意味着较低的访问频率，而且还意味着更大的服务半径（即人们走得更远）。我们的数据再次支持了这一点，表明每次访问的平均旅行距离与访问频率成反比。</p>
<p>本文还计算了空间经济中使用的费马-托里切利-韦伯度量。该指标确定每个吸引位置在将该位置移动到另一个地理位置时所有访问者行进的有效距离的潜在减少量。最终发现：对于大多数地点来说，不可能明显减少游客的有效出行距离，这表明目前地点的空间配置在交通效率方面已接近最佳。虽然博弈论表明，人类集体行为往往是非理性的，并且与社会期望的结果相去甚远，但这一结果表明，当涉及出行努力时，人类能够实现最佳的群体层面行为。</p>
<h2 id="后续可参考"><a href="#后续可参考" class="headerlink" title="后续可参考"></a>后续可参考</h2><ol>
<li><a href="https://arxiv.org/abs/1209.2817" target="_blank" rel="noopener">Preferential attachment in the interaction between dynamically generated interdependent networks</a></li>
<li><a href="https://arxiv.org/abs/1801.03962" target="_blank" rel="noopener">Understanding the interplay between social and spatial networks in human mobility</a></li>
<li><a href="https://arxiv.org/pdf/1011.0673.pdf" target="_blank" rel="noopener">Modeling the structure and dynamics of discussion cascades</a></li>
<li><a href="https://www.sciencedirect.com/science/article/pii/S0370157314002105" target="_blank" rel="noopener">The architecture and dynamics of multilayer networks</a></li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>crowdsourcing</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Causal Intervention for Leveraging Popularity Bias in Recommendation</title>
    <url>/2023/03/27/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Causal%20Intervention%20for%20Leveraging%20Popularity%20Bias%20in%20Recommendation/</url>
    <content><![CDATA[<h1 id="Causal-Intervention-for-Leveraging-Popularity-Bias-in-Recommendation"><a href="#Causal-Intervention-for-Leveraging-Popularity-Bias-in-Recommendation" class="headerlink" title="Causal Intervention for Leveraging Popularity Bias in Recommendation"></a>Causal Intervention for Leveraging Popularity Bias in Recommendation</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>推荐系统通常面临着人气偏差的问题：从数据的角度来看，项目在交互频率上表现出不均匀（通常是长尾）的分布；从方法的角度来看，协同过滤方法容易通过过度推荐热门项目来放大偏差。毫无疑问，在推荐系统中考虑人气偏差是非常关键的，现有的工作主要是通过基于倾向的无偏向学习或因果embedding来消除偏差效应。然而，我们认为，数据中并非所有的偏见都是坏的，也就是说，有些项目因为其更好的内在质量而表现出更高的人气。盲目追求无偏见的学习可能会删除数据中的有益模式，降低推荐的准确性和用户满意度。</p>
<p>这项工作研究了推荐中的一个未被探索的问题——如何利用流行度偏差来提高推荐的准确性。关键在于两个方面：如何在训练过程中消除人气偏差的不良影响，以及如何在生成顶级𝐾推荐的推理阶段注入所需的人气偏差。这就对推荐生成过程的因果机制提出了质疑。沿着这个思路，我们发现物品流行度在暴露的物品和观察到的交互作用之间起到了混淆者的作用，造成了偏差放大的坏影响。为了实现我们的目标，我们提出了一种新的训练和推理范式，命名为 “人气-偏向解惑和调整”（PDA）。它在模型训练中去除混杂的流行偏向，并通过因果干预调整具有理想流行偏向的推荐分数。我们在潜伏因子模型上展示了新的范式，并在葵、豆瓣和腾讯的三个真实世界数据集上进行了广泛的实验。实证研究验证了去中心化的训练有助于发现用户的真实兴趣，而带有流行偏向的推理调整可以进一步提高推荐精度。我们在<a href="https://github.com/zyang1580/PDA" target="_blank" rel="noopener">Github</a> 上发布了我们的代码。</p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>推荐系统面临人气偏差问题，现有的关于流行偏向感知推荐的工作主要是进行无偏向学习或排名调整，可以分为：</p>
<ol>
<li>逆向倾向评分（IPS），通过对模型训练中的交互实例进行重新加权，将数据分布调整为均匀[17, 38]。虽然IPS方法有良好的理论基础，但由于估计倾向性的困难和模型的高方差，它们在实践中几乎没有效果。</li>
<li>因果embedding，它使用无偏的统一数据来指导模型学习无偏的embedding[8, 27]，迫使模型放弃商品流行度。然而，获得这样的统一数据需要将商品随机地推荐给用户，这有可能会伤害用户体验。因此，数据通常是小规模的，使得学习的稳定性降低。</li>
<li>排名调整，对推荐列表进行事后的重新排名[3, 50]或对训练进行模型正则化[2, 50]。这两类方法都是启发式设计，有意提高不太流行的商品的分数，然而这些方法的有效性缺乏理论基础。</li>
</ol>
<p>我们认为，推荐系统不应该消除人气偏差的影响，而应该利用人气偏差。我们的考虑是，并不是所有数据中的人气偏差都意味着坏的影响。例如，有些商品表现出更高的流行度，是因为它们有更好的内在质量或代表了当前的趋势，值得更多的推荐。盲目地消除流行偏见的影响，会失去数据中隐含的一些重要信号，不适当地压制高质量或流行的项目。此外，一些平台有必要在系统中引入期望的偏见，例如，推广那些有可能在未来成为流行的物品。这项工作旨在填补有效利用人气偏差来提高推荐准确性的研究空白。</p>
<p><img src="https://github.com/likun1208/image/blob/master/ci-1.png?raw=true" alt="图1"></p>
<p>为了理解商品流行度如何影响推荐过程，我们先借助因果图[35]的语言进行定性分析。图1(a)表明，传统的方法主要是进行用户-商品匹配来预测亲和力得分：$U$（用户节点）和$I$（物品节点）是原因，而$C$是结果节点，表示交互率。一个例子是隐语义模型[18, 32]，它将预测形成为用户embedding和项目embedding之间的内积。由于一个模型如何形成预测意味着它假设标记的数据是如何产生的，这个因果图也可以解释观察到的交互数据的假设产生过程。商品流行度虽然对数据生成过程有很大影响，但这种粗粒度的建模方法没有明确考虑。</p>
<p>我们接下来考虑商品的流行度是如何影响这个过程的，从而丰富了 图1(b)中的因果图。节点Z表示商品流行度，有两条边指向$C$和$I$。首先，从Z到C的边表示商品流行度对交互率的直接影响，因为很多用户有从众心理，因此倾向于跟随大多数人消费流行的物品[28, 48]。其次，从Z到I的边意味着商品的流行度会影响商品是否被更多推荐，因为推荐系统通常会继承数据中的偏差，更频繁地推荐流行的商品。值得注意的是，我们发现$Z$是导致$I$和$C$的共同原因，在被推荐的项目和观察到的交互率之间充当混淆因素[35]。这意味着，流行度$Z$通过两条因果路径影响观察到的流行数据：1）$Z\rightarrow C$和2）$Z\rightarrow I \rightarrow C$，其中第二条路径包含偏见放大的负面影响，因为它增加了热门商品的交互率，尽管它们可能不太符合用户兴趣。</p>
<p>为了移除这样的负面影响，我们需要干预推荐商品I，使他们对自己的人气Z免疫。在实验上，这意味着我们需要改变曝光策略，使其不受项目流行度的影响，然后重新收集数据，然而这对学术界的研究人员来说成本很高，不可能实现。由于因果科学的进步，我们可以用do-calculus[35]实现同样的结果，而无需进行干预性实验。简而言之，在训练阶段，与通过那些将用户的兴趣与流行的偏见混为一谈的现有推荐模型估计得到的相关性$P(C|U,I)$不同，我们截断路径$P(C|U,I)$来估计用户-商品的匹配$P(C|do(U,I))$。通过这样的非混淆的培训，$P(C|do(U,I))$比$P(C|U,I)$能更准确地估计用户对商品的兴趣匹配，消除了由于Z的混淆因素而在I和C之间的虚假相关性。在推断阶段，我们推断排名分数$P(C|do(U,I),do(Z))$，用我们期望的偏见来干预项目的流行度𝑍（例如，在测试阶段中的预测流行度）。</p>
<p>本文主要贡献如下：</p>
<ol>
<li>我们用因果图分析了人气偏差是如何影响推荐系统的，因果图是一个强大的工具，但在社区中很少使用；我们发现，人气偏差的不良影响源于项目人气的混杂效应。</li>
<li>我们提出了 “人气偏差解构和调整”（PDA），这是一个新颖的框架，用do-calculus进行解构训练，并在推荐推理中对人气偏差进行因果干预。</li>
<li>我们在三个真实的数据集上进行了广泛的实验，验证了我们因果分析和方法的有效性。</li>
</ol>
<h2 id="Primary-Knowledge"><a href="#Primary-Knowledge" class="headerlink" title="Primary Knowledge"></a>Primary Knowledge</h2><p>我们用大写字母表示随机变量，小写字母表示具体的值，手写体字母表示相应随机变量的样本空间，以及$P(\cdot)$表示随机变量的概率分布。</p>
<p>$\mathcal{D}$：历史数据，通过$T$阶段依次收集得到，即$\mathcal{D}=\lbrace \mathcal{D}_1\cup … \cup \mathcal{D}_T \rbrace$</p>
<p>$\mathcal{U}=\lbrace u_1,…,u_{|\mathcal{U}|} \rbrace$：所有用户</p>
<p>$\mathcal{I}=\lbrace i_1,…,i_{|\mathcal{I}|} \rbrace$：所有商品</p>
<p>通过对历史数据的学习，推荐系统有望抓住用户的偏好，为下一阶段𝑇+1提供良好的服务。也就是说，它的目标是在$\mathcal{D}_{T+1}$上获得高的推荐精度。本文中我们关注对商品流行度这一因素，将商品$i$在阶段$t$时的局部流行度定义为：$m_i^t=D_i^t / \sum_{j \in I} D_j^t$，其中$D_i^t$表示商品$i$在$\mathcal{D}_{t}$中观察到的交互次数。我们同样可以根据商品在$\mathcal{D}$中的交互频率来定义商品的全局流行度$m_i$，但我们认为局部流行度对系统的曝光机制和用户决策的影响更大，因为系统通常会定期重新训练，最新的数据影响最大。</p>
<p>流行度漂移。直观地说，商品流行度是动态的，并随时间变化，这意味着流行度偏差的影响也可能是动态的。为了量化人气漂移，我们定义了一个名为人气漂移（Drift of Popularity, DP）的指标来衡量两个阶段之间的漂移。首先，我们将每个阶段$𝑡$表示为商品的概率分布：$[m_1^t,…,m^t_{|\mathcal{T}|}]$，其中每个条目表示一个商品在该阶段的频率。然后，我们使用Jensen-Shannon散度(JSD）[15]来衡量两个阶段之间的相似性：$DP(t,s)=JSD\left(\left[m_1^t, \ldots, m_{|I|}^t\right],\left[m_1^s, \ldots, m_{|I|}^s\right]\right)$，其中，$t$和$s$是两个阶段。与JSD类似，DP的范围是$[0, 𝑙𝑜𝑔(2)]$，数值越大，说明流行度越大。</p>
<p>补充说明：JS散度度量了两个概率分布的相似度，是KL散度的变体，JS散度解决了KL散度非对称的问题。一般地，JS散度是对称的，其取值是0到1之间，具体参考<a href="https://blog.csdn.net/hy592070616/article/details/122387046" target="_blank" rel="noopener">这个链接</a>。</p>
<p><img src="https://github.com/likun1208/image/blob/master/ci-2.png?raw=true" alt="图2"></p>
<p>图2(a)显示了三个真实世界数据集上连续两个阶段的DP值，即$DP(t, t +1)$，其中$t$从1到9迭代（详见4.1.1节）。我们可以看到，三个数据集都明显存在流行度漂移，不同的数据集表现出不同的流行度漂移程度。图2(b)显示了第一阶段和现阶段的DP值，即$DP(1,t )$，它衡量了累积的人气漂移。我们可以看到一个明显的上升趋势，表明时间间隔越长，数据表现出的人气漂移越大。这些结果显示，人气偏差及其影响也会随着时间的推移而变化。未来阶段的人气偏差与过去阶段的人气偏差不同。如果我们把模型泛化的目标设定为在下一阶段的数据$\mathcal{D}_{T+1}$上追求高准确度，那么一个可行的方法就是预测流行趋势并将其注入到推荐中。</p>
<h2 id="METHODOLOGY"><a href="#METHODOLOGY" class="headerlink" title="METHODOLOGY"></a>METHODOLOGY</h2><h3 id="Causal-View-of-Recommendation"><a href="#Causal-View-of-Recommendation" class="headerlink" title="Causal View of Recommendation"></a>Causal View of Recommendation</h3><h3 id="Deconfounded-Training"><a href="#Deconfounded-Training" class="headerlink" title="Deconfounded Training"></a>Deconfounded Training</h3><h3 id="Adjusting-Popularity-Bias-in-Inference"><a href="#Adjusting-Popularity-Bias-in-Inference" class="headerlink" title="Adjusting Popularity Bias in Inference"></a>Adjusting Popularity Bias in Inference</h3><h3 id="Comparison-with-Correlation-P-C-U-I"><a href="#Comparison-with-Correlation-P-C-U-I" class="headerlink" title="Comparison with Correlation $P(C|U,I)$"></a>Comparison with Correlation $P(C|U,I)$</h3><h2 id="EXPERIMENTS"><a href="#EXPERIMENTS" class="headerlink" title="EXPERIMENTS"></a>EXPERIMENTS</h2><h3 id="Experimental-Settings"><a href="#Experimental-Settings" class="headerlink" title="Experimental Settings"></a>Experimental Settings</h3><h3 id="Deconfounding-Performance-RQ1"><a href="#Deconfounding-Performance-RQ1" class="headerlink" title="Deconfounding Performance (RQ1)"></a>Deconfounding Performance (RQ1)</h3><h3 id="Performance-of-Adjusting-Popularity-RQ2"><a href="#Performance-of-Adjusting-Popularity-RQ2" class="headerlink" title="Performance of Adjusting Popularity (RQ2)"></a>Performance of Adjusting Popularity (RQ2)</h3><h2 id="RELATED-WORKS"><a href="#RELATED-WORKS" class="headerlink" title="RELATED WORKS"></a>RELATED WORKS</h2><h2 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>因果推断</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-因果框架对比</title>
    <url>/2023/02/01/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-%E5%9B%A0%E6%9E%9C%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h1 id="因果框架对比分析"><a href="#因果框架对比分析" class="headerlink" title="因果框架对比分析"></a>因果框架对比分析</h1><h2 id="Rubin因果框架——潜在结果模型"><a href="#Rubin因果框架——潜在结果模型" class="headerlink" title="Rubin因果框架——潜在结果模型"></a>Rubin因果框架——潜在结果模型</h2><ol>
<li>针对的场景是：统计学中的因果关系分析</li>
<li>三大假设：<ol>
<li>潜在结果：针对每个单元的每种干预都有一种潜在结果，且实际情况下只能观察到一种潜在结果</li>
<li>稳定性假设：不同个体的潜在结果之间不会有交互影响，干预水平对所有个体都是相同的</li>
<li>分配机制：是决定哪些个体得到处理，从而哪些潜在结果可以被观察到的过程。正式地来说，分配机制是协变量、潜在结果和分配向量的函数，表示在特定协变量和潜在结果下，某一分配向量实现的概率。</li>
</ol>
</li>
<li>基本问题：所有潜在结果不可能同时被观测到，由此导致因果推断中的数据缺失问题</li>
<li>解决方法：Rubin(1974)认为这一问题实质上就是一个缺失数据的问题。因此要进行因果分析，就需要把缺失的潜在结果填补上。一些个体的背景特征（协变量）往往能够帮助我们进行缺失潜在结果的预测。</li>
<li>总的来说是基于协变量进行反事实推断，从而估计因果关系。</li>
</ol>
<h2 id="Pearl因果框架——结构因果模型"><a href="#Pearl因果框架——结构因果模型" class="headerlink" title="Pearl因果框架——结构因果模型"></a>Pearl因果框架——结构因果模型</h2><ol>
<li>研究的问题是如何从已有的数据中学习表征因果关系的贝叶斯网络</li>
<li>用数学语言描述就是判断变量是否条件独立</li>
</ol>
<h2 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h2><p>目的都是为了计算存在混淆变量时，干预变量时对结果的影响，都需要对因果关系作假设，以及控制带来偏差的变量</p>
<p><strong>不同点在于：</strong> </p>
<ol>
<li>Rubin框架估计的因果效应主要是干预前后的期望差值</li>
<li>而Pearl框架下，我们估计的是干预前后的分布差异</li>
<li>Rubin框架解决的问题是因果效应的估计和统计推断</li>
<li>Pearl框架更偏向于因果关系的识别</li>
</ol>
<h2 id="Rubin-的观点"><a href="#Rubin-的观点" class="headerlink" title="Rubin 的观点"></a>Rubin 的观点</h2><p>我曾经在哈佛大学帮助组织过一次会议，我们邀请了Don Rubin和Tyler Vanderweele（DAGs的支持者）就因果推断的图形方法的优点进行了演讲。我们有来自文理研究生院统计系的学生（一般是站在Rubin一边）和来自公共卫生学院流行病学和生物统计系的学生（由于Jamie Robins的影响，公共卫生学院的统计系有大量的图形化研究）。这次会议的部分目的是帮助我们了解对方的想法，并澄清我们真正的分歧所在。</p>
<p>由于我是一名流行病学家，而不是统计学家，鲁宾的一些论点可能超出了我的想象。然而，我的主要收获是，Rubin非常相信 “没有操纵就没有因果关系 “的论断，也就是说，把不可操纵的变量说成是什么原因是没有意义的。我的理解是，他不喜欢DAGs，因为这些图隐含地将混杂物标记为暴露和结果的 “原因”，违反了这一哲学。</p>
<p>以下是对这两种因果推断方法之间差异的主要简化。</p>
<p>Pearl和Rubin都提供了框架，用于陈述关于数据如何产生的假设，并使用这些假设来证明一个观察量将等于因果效应。这些框架都是有效的，因为如果假设（非封闭性）是真的，那么结论（因果效应的识别）也就随之而来。</p>
<p>在Pearl的框架中，调查者从一个假设出发，即数据是由一个特定的有向无环图产生的，然后证明如果他能够通过对某些协变量进行调节来阻止暴露和结果之间的所有后门路径，那么控制这些变量就足以消除混杂。</p>
<p>在Rubin的框架中，调查者从假设治疗是由 “治疗分配机制 “分配的开始，然后证明，如果以某些协变量为条件，这个机制不取决于反事实结果，那么控制这些协变量就足以消除混杂。</p>
<p>Pearl声称这些方法是等同的。从Pearl对混杂的定义到Rubin的定义，其逻辑含义似乎没有争议。我不确定你到底要做什么背景假设（如果有的话）才能使反面的说法成立，但我认为这些假设并不具有限制性。</p>
<p>这两种方法在逻辑上都是有效的。然而，有无限多的可能的假设，你可以作为你的推理链的起点来证明识别。因此，真正的问题是，任何一个框架是否允许你从一个基础开始推理，以利于清楚地交流关于鉴定所需的假设对某项研究来说是否真实。</p>
<p>这就是我认为Pearl的优势所在。他的DAGs确实经过了优化，允许科学家准确地澄清他们认为数据是如何产生的，并以透明的形式呈现这些假设，以便其他科学家可以对其进行评估、讨论和批评。我认为，如果只使用反事实变量和治疗分配机制的语言来进行这样的对话，将是非常具有挑战性的。</p>
<p>我认为，Pearl的框架更适合作为我们进行关于控制哪些变量的讨论的语言的目的。我相信图形语言的使用者将能更好地传达一些微妙的观点，这些观点将影响分析方法的选择和估计的可信度。由于这是观察性研究中不确定性的主要来源，我相信DAGs最终会在思想市场上胜出。</p>
<h2 id="一些英文资料的总结"><a href="#一些英文资料的总结" class="headerlink" title="一些英文资料的总结"></a>一些英文资料的总结</h2><p>鲁宾模型的重点是潜在的结果，以及单位在不同的条件下（最常见的是有和没有二元处理）如何有潜在的结果。例如，Y(1)是治疗1下的潜在结果数组，Y(0)是治疗0下的潜在结果数组。这在考虑实验以及随机化如何实现一个单位的一个潜在结果时特别有用，该结果可以与其他单位结合起来，用于计算平均治疗效果（因为我们不能估计个人层面的因果效应）。为了解决因果推断的基本问题（我们只能在一个世界中观察一个单位），我们需要一台时间机器，在没有这种科幻工具的情况下，我们只能依靠分配机制对因果推断的重要性（来估计ATE、LATE、PATE、ATT、ATC和ITT等效应）。这个模型的关键优势之一是了解潜在的结果是如何变成一个实现的结果以及我们所依赖的假设。例如，稳定的单位处理价值假设（SUTVA）意味着一个单位的潜在结果不受另一个单位处理的影响。这就强调了尽量减少单位之间干扰的重要性。对Rubin模型最好的全面介绍是Imbens和Rubin（2015）。</p>
<p>Pearl模型通过有向图（DAG）提供了因果识别，也就是说，沿着一条路径对一个变量进行调节是如何阻断路径的，以及为了进行因果推断，需要对具体的效果进行限制。在使用这种因果关系模型时，你通常要处理多条路径，而不是只有两组、一个结果和一个处理的简单设置。DAGs也可以理解为非参数结构方程模型，在处理条件概率和贝叶斯网络/图形模型时特别有用。</p>
<p>Pearl模型的主要优点之一是，它迫使你更仔细地思考你的因果模型，包括不控制的内容。由于这个原因，该模型比鲁宾模型更适合于复杂环境下的因果推断。</p>
<p>然而，也有一些值得注意的限制。模型中隐含着交互作用和效应的异质性，要表达这样的想法可能很困难（而在Rubin模型中考虑条件平均治疗效应则比较容易）。虽然DAG对理解复杂的因果模型很有帮助，但当我们要考虑在实践中估计因果效应所需的参数化假设时，它的帮助往往就不大。</p>
<p>令人惊讶的是，对珍珠模式最好的介绍不是珍珠本人的作品（尽管我确实喜欢《为什么之书》）。作为一名政治科学家（或更普遍的社会科学家），我发现摩根和温希普（2014）、埃尔韦特（2013）、埃尔韦特和温希普（2014）、达布兰德（2020）和鲁尔（2018）等介绍更容易理解。</p>
<p>在政治学中，研究人员大多依赖鲁宾和坎贝尔的工作，而较少依赖珍珠的工作。然而，最近我们看到了一些依靠DAGs所提供的洞察力的好工作。很好的例子包括关于美国有种族偏见的警务工作（见Knox等人，2020）和关于估计受控直接效应的工作（Acharya等人，2016）。</p>
<p>Imbens（2020）对DAGs与Rubin模型的关系进行了很好的批判性讨论（赞成潜在的结果而不是DAGs作为社会科学内因果关系的首选模型）。Matthay和Glymour（2020）展示了对内部、外部、构造和统计结论有效性的威胁如何以DAG的形式呈现。Lundberg等人（2021年）展示了潜在结果和DAGs如何被用来概述连接理论估计和经验估计的识别假设。这是一项了不起的工作，每个对连接统计证据和理论的强因果推理感兴趣的人都应该读一读。</p>
<p>我的看法是，这三种模型可以很好地结合在一起，但在思考理论、研究设计和数据时不一定同时进行。具体来说，我更喜欢Pearl → Rubin → Campbell。首先，用Pearl来概述因果模型（特别关注不包括什么）。第二，用Rubin来关注感兴趣的因果估计，考虑不同的估计器和假设（SITA/SUTVA）。第三，用坎贝尔来讨论对真实性的威胁，测量误差等。</p>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ol>
<li><a href="https://wiki.swarma.org/index.php/%E9%B2%81%E5%AE%BE%E5%9B%A0%E6%9E%9C%E6%A1%86%E6%9E%B6" target="_blank" rel="noopener">wiki</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20897233" target="_blank" rel="noopener">Imbens &amp; Rubin：因果分析的基本框架以及经典随机试验</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/494643196" target="_blank" rel="noopener">因果推断(三): 潜在结果模型</a></li>
<li><a href="https://www.zhihu.com/question/473104840" target="_blank" rel="noopener">到底 Judea Pearl 提出的 因果推理 和 贝叶斯网络 是什么，求深入浅出讲解？ - 知乎</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1913836" target="_blank" rel="noopener">因果推断笔记—— 相关理论：Rubin Potential、Pearl、倾向性得分、与机器学习异同（二）</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1913886" target="_blank" rel="noopener">因果推断笔记——自整理因果推断理论解读（七）</a></li>
<li><a href="https://www.zhihu.com/question/266812683" target="_blank" rel="noopener">因果推断（causal inference）是回归（regression）问题的一种特例吗？</a></li>
<li><a href="https://qr.ae/prkWfQ" target="_blank" rel="noopener">Quora上的问答</a></li>
<li><a href="https://erikgahner.dk/2021/causality-models-campbell-rubin-and-pearl/" target="_blank" rel="noopener">Causality models: Campbell, Rubin and Pearl</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33860572" target="_blank" rel="noopener">【综述长文】因果关系是什么？结构因果模型入门</a></li>
</ol>
<p>此外：</p>
<ol>
<li><a href="https://campus.swarma.org/course/2460" target="_blank" rel="noopener">因果科学与Causal AI读书会第二季</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/474409503" target="_blank" rel="noopener">统一Pearl与Rubin的因果图模型：Single-World Intervention Graphs</a></li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>因果推断</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-教育学中的因果推断</title>
    <url>/2023/01/30/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-%E6%95%99%E8%82%B2%E5%AD%A6%E4%B8%AD%E7%9A%84%E5%9B%A0%E6%9E%9C%E6%8E%A8%E6%96%AD/</url>
    <content><![CDATA[<h1 id="教育学中的因果推断"><a href="#教育学中的因果推断" class="headerlink" title="教育学中的因果推断"></a>教育学中的因果推断</h1><h2 id="理论综述性质"><a href="#理论综述性质" class="headerlink" title="理论综述性质"></a>理论综述性质</h2><p>[1]郭娇,吴寒天.大数据时代的因果推断——教育政策评估的新路径[J].重庆高教研究,2022,10(04):39-48.DOI:10.15998/j.cnki.issn1673-8012.2022.04.005.</p>
<ol>
<li>大数据时代的因果推断范式具有<strong>数据密集性</strong>和<strong>场境依赖性</strong>两个本质特征，反映为图中的两大支柱( 即基于数据的因果推断与嵌入真实的教育场境) 。</li>
<li>教育政策评估的路径创新体现在<strong>数据</strong>、<strong>技术</strong>以及<strong>应用</strong> 3 个层面。<ol>
<li>在数据层面不仅打通了宏观社会经济结构、中观院校机构以及微观师生个体数据，而且通过增设的大数据中心及其数据采集、清洗、挖掘、可视化等功能助力决策咨询、专家分析、管理实施以及公众问责;</li>
<li>在技术层面则在成熟的量化( 如调查问卷) 与质性研究工具( 包括访谈、案例、课堂观察等) 基础上加入了随机控制实验、准实验( 如工具变量) 、机器学习( 包括决策树、随机森林等) 、自适应实验或政策学习等最新技术手段; </li>
<li>就应用层面而言，除动态监测、过程挖掘等功能创新之外，还可对教育政策评估的原有重要功能( 如高等教育阶段的学情调查、学科评价等) 进行升级或拓展。<br><img src="https://github.com/likun1208/image/blob/master/EDUCI-1.jpg?raw=true" alt="教育路径示意图"></li>
</ol>
</li>
</ol>
<p>目前，广义社会科学领域中基于机器学习的因果推断尚以经济学研究为主，近两年零星出现了若干教育领域的应用研究( 例如智利全国与美国纽黑文全区的中小学智能择校大数据平台[26]、美国 976 节小学英语课的视频逐字转录的海量文字记录的研究[27] ，以及以美国 7 个学区 84 所小学为实施单位的学生行为随机干预等[28] ) ，但尚未出现高等教育学领域<br>与政策研究相关的经典文献。</p>
<p>[2]黄斌,李波.因果推断、科学证据与教育研究——兼论2021年诺贝尔经济学奖得主的教育研究[J].华东师范大学学报(教育科学版),2022,40(04):1-15.DOI:10.16382/j.cnki.1000-5560.2022.04.001.</p>
<ol>
<li>诺贝尔经济学奖得主在教育领域的重要研究发现<ol>
<li>教育收益率的因果推断</li>
<li>班级规模与学业表现的因果推断</li>
<li>学校投入与学生学业成绩的因果推断</li>
</ol>
</li>
<li>目前我国教育因果研究存在的问题<ol>
<li>重量化技术、轻研究设计</li>
<li>重参数估计、轻证伪检验</li>
<li>重效应识别、轻机制分析</li>
</ol>
</li>
<li>推动我国教育因果研究发展的两点建议<ol>
<li>围绕学生因果思维培养，改革教育量化方法课程体系</li>
<li>立足我国教育政策实际，提升教育因果研究创新能力</li>
</ol>
</li>
</ol>
<p>[3] 黄斌;方超;汪栋;;<a href="https://www.cnki.com.cn/Article/CJFDTOTAL-YWHL201706030.htm" target="_blank" rel="noopener">教育研究中的因果关系推断——相关方法原理与实例应用</a>[J];教育文化论坛;2017年06期</p>
<ol>
<li><p>断点回归</p>
<p> 断点回归方法最早由 Thistlethwaite ＆ Campbell( 1960) 在一本教育心理学专业期刊上提出，之后沉寂多年，直到 1980 年后才逐渐发展成熟并得到大量应用。与随机实验相似，断点回归也是试图利用一种随机安排形成两组无显著差异的个体进行对照比较。不同在于，断点回归的随机安排并不是人为事先就设计好的，而是研究者事后利用在数据形成过程中自然发生的事件构造出来的。这些“自然事件”应是一些外生事件并对结果变量具有冲击作用，例如自然灾害、爆发战争、实行已久的政策戛然而止、政策对象的随机指派，等等。在外来的冲击作用下，观测对象的某一特征变量会在取值上出现一个断点，观测对象被随机分配至断点两边，一方为接受处理的处理组，另一方为未接受处理的控制组。如果处理手段对于观测对象的行为结果具有因果效应，那么，在该断点上观测对象的结果变量取值必定会有一个明显的跳跃变化，而断点回归的核心任务就是侦测这一跳跃变化是否真的存在。</p>
</li>
<li><p>工具变量法 </p>
<p> 与断点回归相同，工具变量法对残值异质性也是采用整体解决的方案，但在研究设计上，工具变量法则另辟蹊径。如前所述，之所以会出现因果关系估计偏差，是因为异质性残值与处理变量出现了相关，导致处理变量的内生化。在此基础上，研究者进一步思考，如果我们能够通过一定方法将处理变量的变异进行分解，将处理变量变异中与残值相关的那部分变异( 即内生变异部分) 剔除，仅保留与残值不相关的那部分变异( 即外生变异部分) ，并只用这部分外生变异对结果变量进行回归的话，其估计必定是无偏的。</p>
</li>
<li><p>倾向得分法结合倍差法</p>
<p> 在实际数据分析中，受制于观测数据的事后性，有效的断点与工具变量往往难以找寻，这严重掣肘着因果关系推断方法的推广应用。近年来，倾向得分法结合倍差法的研究设计逐渐盛行，该方法的基本思路是对异质性残值的不同构成分别运用不同的方法予以解决: 运用倾向得分匹配法解决可观测异质性，运用倍差法解决不随时间变化的不可观测异质性，对于随时间变化的不可观测异质性则采用一些补救手段尽可能地予以消除。</p>
</li>
</ol>
<h2 id="教育对其他因素的影响分析"><a href="#教育对其他因素的影响分析" class="headerlink" title="教育对其他因素的影响分析"></a>教育对其他因素的影响分析</h2><p>[1]李适源,刘爱玉.“忧郁的孩子们”：课外补习会带来负向情绪吗？  基于中国教育追踪调查（CEPS）两期数据的因果推断[J].社会,2022,42(02):60-93.DOI:10.15992/j.cnki.31-1123/c.2022.02.002.</p>
<p>[2]韩佳峻. 教育如何影响个人生育意愿？[D].华东师范大学,2022.DOI:10.27149/d.cnki.ghdsu.2022.002101.</p>
<p>[3]张心悦.高等教育规模对全要素生产率的因果效应分析——以高等教育扩招为工具变量[J].天津市教科院学报,2022,34(05):42-52.</p>
<h2 id="其他可能相关"><a href="#其他可能相关" class="headerlink" title="其他可能相关"></a>其他可能相关</h2><p>[1]赵国庆,李欣媛,路通,彭青青.从认知地图到认知图谱：相似概念的跨学科审视[J].现代远程教育研究,2021,33(05):14-25.</p>
<p>这篇和因果推断没有关系，但是借鉴了心理学的认知地图和计算机的知识图谱，并试图相互融合，也许以后可以参考。</p>
<h2 id="英文材料"><a href="#英文材料" class="headerlink" title="英文材料"></a>英文材料</h2><ol>
<li><p>Methods matter: Improving causal inference in educational and social science research.</p>
<p>世界各地的教育政策制定者不断作出决定，如何利用稀缺的资源来改善儿童的教育。不幸的是，他们的决定很少有关于这些举措在其他环境中的后果的证据。在做出决定的同时，通常也没有制定良好的计划来评估其因果影响。因此，关于在不同情况下什么是有效的知识积累得非常缓慢。在过去的几十年里，研究方法、行政记录保存和统计软件的进步极大地提高了研究人员对教育干预措施的因果影响进行令人信服的评估的潜力，而且设计良好的研究数量也在增加。本书以清晰、简明的散文写成。改善教育和社会科学研究中的因果推断，为评估教育政策的人提供了必要的指导。在严谨的同时，本书提供了易于理解的启发式解释。作者通过描述分析方法在研究教育干预措施因果影响的高质量研究中的使用，以及讨论围绕每项研究的争议，激发了人们对分析方法的兴趣。Murnane和Willett在因果推断方面提供了强有力的方法论见解，同时还研究了在美国和国外实施的各种教育政策的后果。本书是对教育研究文献的独特贡献，对教育和公共政策领域的学生和研究人员，以及对社会科学感兴趣的人来说是非常宝贵的。</p>
</li>
<li><p>Causal inference in educational effectiveness research: A comparison of three methods to investigate effects of homework on student achievement.</p>
<p> 在教育效果研究中，经常被证明很难对因果关系做出可信的推断。文章首先确定了从观察性数据中进行有效因果推断的主要威胁类别，并讨论了防止这些威胁的设计和分析方法。通过使用来自22个国家的数据，这些国家参加了2003年国际数学和科学趋势研究（TIMSS）和2008年TIMSS的8年级学生样本，然后运用3种不同的方法来研究花在家庭作业上的时间对数学成绩的影响。(a) 2级回归，用于分离学生层面的关系和班级层面的关系；(b) 工具变量回归，使用教师报告的家庭作业时间来衡量学生报告的家庭作业时间；以及(c) 差别分析，调查2003年和2007年之间国家层面的变化。所有3种方法都表明，家庭作业时间对学生成绩有积极影响。</p>
</li>
<li><p>Embedding Experiments: Staking Causal Inference in Authentic Educational Contexts</p>
<p> 为了确定教师和教育系统可以改善学习的方式，研究人员需要进行因果推断。对现有数据集的分析在检测因果模式方面发挥了重要作用，但进行实验也在这项研究中发挥了不可或缺的作用。在这篇文章中，我们主张将实验嵌入到真实的教育环境中，使研究者能够测试诸如学习活动、新技术或建议策略等干预措施是否在真实的学生行为和教育结果中引起可靠的改善。嵌入实验，即在真实的学习环境中系统地操纵理论上的相关变量，对做出因果推论有很大的好处，特别是当与当代电子学习环境的丰富数据资源结合起来时。为了实现这一目标，我们提供了一份嵌入式实验的实地指南，回顾了实验设计的选择，解决了伦理问题，讨论了教师参与的重要性，并回顾了如何在各种背景下以各种规模部署干预措施。因果推断是一个旨在改善学生学习的领域的重要组成部分；在学习分析中，将实验与现有数据的分析结合起来，是检验因果主张的最有说服力的方法。</p>
</li>
<li><p>Causal inference in AI education: A primer</p>
<p>  因果推理的研究最近在机器学习和人工智能（AI）领域出现了势头，特别是在转移学习、强化学习、自动诊断和可解释性（等等）领域。然而，尽管它在解决现代人工智能的许多边界方面的应用越来越多，但大多数人工智能课程中仍然没有因果关系的主题。这项工作试图通过提供融入人工智能传统主题的、可在课堂上使用的介绍来弥合这一差距，建议将直观的图形工具应用于概率和因果推理的新课程和传统课程，并为教员提供途径，让他们认识到攀登 “因果层次 “以解决关联性、干预性和反事实推理层面的问题的好处。最后，本研究分享了教员的轶事经验、成功，以及在多个教育层次上整合这些课程的挑战。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>因果推断</tag>
        <tag>教育学</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-A Survey of Deep Causal</title>
    <url>/2023/01/27/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-A%20Survey%20of%20Deep%20Causal%20Model/</url>
    <content><![CDATA[<h1 id="A-Survey-of-Deep-Causal-Model"><a href="#A-Survey-of-Deep-Causal-Model" class="headerlink" title="A Survey of Deep Causal Model"></a>A Survey of Deep Causal Model</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><ol>
<li>因果推断应用场景<ol>
<li>估计广告中观察数据的因果效应[3, 4, 5, 6, 7, 8, 9]  </li>
<li>开发与因果干预效果估计高度相关的推荐系统[10, 11, 12, 13, 14, 15, 16]  </li>
<li>学习医学中患者的最佳干预规则[17, 18, 19]  </li>
<li>强化学习中的ITE估计[20,9, 21, 22, 23, 24, 25, 26, 27]  </li>
<li>自然语言处理中的因果推理任务[28, 29, 30, 31, 32, 33]  </li>
<li>新兴的计算机视觉和语言交互任务[34, 35, 36, 37, 38]  </li>
<li>教育[39]  </li>
<li>政策决定[40, 41, 42, 43, 44]  </li>
</ol>
</li>
<li>深度学习与因果模型的结合  <ol>
<li>深度学习模型的计算效率更高，精度更高，在各个领域都拥有良好的表现  </li>
<li>许多深度学习模型是黑盒子，可解释性差，因为它们对输入和输出的相关性比因果关系更感兴趣[49, 50, 51]  </li>
<li>深度学习模型已被广泛用于挖掘数据的因果关系，而不是相关关系[40, 42]  </li>
<li>深度因果模型已经成为一种基于无偏估计的干预效果的核心方法[19, 43, 44, 52]，因果推断领域的许多工作都利用深度因果模型来选择合理的干预方案[53, 54, 55, 56]  </li>
</ol>
</li>
<li>现状<ol>
<li>长期以来，主流研究的一个特点是使用潜在结果框架作为解决观察性数据的因果推断问题的手段[63]。潜在结果框架也被称为Rubin因果模型[64]  </li>
<li>考虑代表分布平衡的方法[40, 42, 43]，协变量混淆学习方法的影响[52, 65, 66, 67]，基于生成对抗网络的方法[44, 68, 69, 70]，其他相关内容[56, 33, 71]等等 </li>
<li>由于深度学习方法有利于因果推断，因果推断也促进了深度学习方法的发展。除了提高因果效应估计的准确性外，对深度网络的研究还为开发深度学习算法提供了合理的依据[72, 73, 74]  </li>
</ol>
</li>
<li>相关调研工作的主要主题：<ol>
<li>因果推断的起始与发展[75]  </li>
<li>反事实因果推理的机器学习可解释性[76]  </li>
<li>图形化因果推理与机器学习的联系[77]  </li>
<li>通过因果表征学习探索数据中的因果变量[78]  </li>
<li>医疗保健的因果机器学习[79]  </li>
<li>大数据情况下的因果学习和机器学习的关系[1]  </li>
<li>潜在结果框架中观察数据的因果效应估计[2]  </li>
<li>深度学习和变量范式视角在因果发现中的应用[80]  </li>
<li>通过因果推理提取因果关系来优化推荐系统[81]  </li>
<li>深度学习对解决传统因果学习问题的意义[83]</li>
<li>深度模型中的因果效应估计与有偏差的样本观测和当前工业应用中的挑战[本文]</li>
</ol>
</li>
</ol>
<h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>主要来自[64, 2]</p>
<p>定义1：干预效果估计（因果效应估计）：估计接受干预的特定样本的结果变化。干预效果估计和提升模型有相同的目标，不同的是：提升模型是对随机实验数据的，干预效果估计通常需要坚持必要的假设，适用于实验和观察数据。</p>
<p>定义2：干预（treatment）。干预描述了应用于样本的方案或行动。作为一个医学术语，一个药物方案就是一种干预。对于二元干预，$T=1$是实验组，$T=0$是对照组。多个干预方案可以用$T(T\in\lbrace0,1,2,…,T_N\rbrace)$来表示，其中$N+1$表示方案总数量。</p>
<p>定义3：观察结果。观察性结果，也被称为事实性结果，是衡量样本的结果如何应用于干预的措施。在某一干预方案的情况下，观察结果记作$Y^F$，其中$Y^F=Y(T=T_i)$。</p>
<p>定义4：反事实的结果。反事实的结果是与事实的结果不同的结果。在二元干预的情况下，反事实结果记作$Y^{CF}=Y(T=1-T_i)$。在多干预的情况下，$Y^{CF}(T=T_i^{‘})$表示干预$T_i^{‘}$的反事实结果。</p>
<p>定义5：剂量。剂量是指在某一特定干预期间连续服用的数量。一般来说，有许多医学干预涉及到连续的剂量参数，如血管压缩机。一组连续的剂量方案记作$D_T$。针对特定干预的事实剂量记作$D^F=D(T=T_i)$。反事实剂量记作$D^{CF}(T=T_i^{‘})$。</p>
<p>定义6：剂量-反应曲线。剂量-反应曲线表示在接受不同剂量的干预后，样品的反应效果随时间推移而变化。对剂量反应曲线进行更好的拟合可以使模型在连续剂量处理中更加稳健和富有表现力。剂量-反应曲线上的实际结果和反事实结果可以表示为集合$Y^F(D^F,T_i)$和$Y^{CF}(D^{CF},T_i^{‘})$。</p>
<p>定义7：协变量。协变量是不受干预选择影响的变量。一般来说，医疗环境中的协变量是指患者的人口统计学、病史、实验数据等，通常用X表示。协变量可以分为混杂变量和非混杂变量，具体分为三类[65]：工具因素$I$，只影响干预$T$；混杂因素$C$，对干预$T$和结果$Y$都有影响；调整因素$A$，只决定结果$Y$。</p>
<h3 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h3><p>主要来自[2,77]</p>
<p>假设1：稳定的样品处理值（SSTV）。一个样本对干预的反应与其他样本的分布无关。基于这一假设，样本之间不存在相互影响，每个干预方案只有一个版本。SSTV可以表示为$P(Y_i|T_i,T_i^{‘},X_i)=P(Y_i|T_i,X_i)$。</p>
<p>假设2：可忽略性。给定协变量$X$，干预分布$T$与潜在结果无关。基于该假设，不应该有未观察到的混杂因子。换言之，$T\bot Y(T=T_i),Y(T=T_i^{‘})|X$需要成立。</p>
<p>假设3：重叠。当给定观察变量时，每个样本都有非零的概率接受任一干预状态。为了估计反事实的干预效果，必须假设每个样本都能实施任何干预方案，否则重叠假设将不成立。即，$0&lt;P(T=T_i|X=x)&lt;1$且$0&lt;P(T=T_i^{‘}|X=x)&lt;1$。</p>
<h2 id="Treatments-and-Metrics"><a href="#Treatments-and-Metrics" class="headerlink" title="Treatments and Metrics"></a>Treatments and Metrics</h2><p>本节对不同经典应用场景所采用的不同性能指标进行了分析和描述。除了[2]中的基本指标外，我们将评估从二元扩展到多剂量和连续剂量情况。</p>
<h3 id="二元干预"><a href="#二元干预" class="headerlink" title="二元干预"></a>二元干预</h3><ol>
<li>平均干预影响Average Treatment Effect(ATE)[85,86]    <script type="math/tex">\mathrm{ATE}=\mathbb{E}[Y(T=1)-Y(T=0)]</script></li>
<li>条件平均干预影响Conditional Average Treatment Effect (CATE)[2]<script type="math/tex; mode=display">
\mathrm{CATE}=\mathbb{E}[Y(T=1) \mid X=n]-\mathbb{E}[Y(T=0) \mid X=n]</script></li>
<li>个体干预效果Individual Treatment Effect (ITE)[2]<script type="math/tex; mode=display">
\mathrm{ITE}_n=Y_n(T=1)-Y_n(T=0)</script></li>
<li>异质性估计的精确度Precision in Estimation of Heterogeneous(PEHE)[44,52]<script type="math/tex; mode=display">
\mathrm{PEHE}=\sqrt{\frac{1}{N} \sum_{n=1}^N\left(Y_1^F(n)-Y_0^F(n)-\left(Y_1^{C F}(n)-Y_0^{C F}(n)\right)\right)^2}</script></li>
<li>针对实验组的平均干预影响 Average Treatment effect on the Treated group (ATT)[2, 87]<script type="math/tex; mode=display">
\text { ATT }=\mathbb{E}[Y(T=1) \mid T=1]-\mathbb{E}[Y(T=0) \mid T=1]</script></li>
<li>政策风险 Policy Risk（$R_{pol}(\pi)$） [42]<script type="math/tex; mode=display">
R_{\mathrm{pol}}(\pi)=\frac{1}{N} \sum_{n=1}^N\left[1-\left(\sum_{i=1}^K\left[\frac{1}{\left|\Pi_i \cap T_i \cap E\right|} \sum_{X(n) \in \Pi_i \cap T_i \cap E} Y_i^F(n) \times \frac{\left|\Pi_i \cap E\right|}{|E|}\right]\right)\right]</script></li>
</ol>
<h3 id="多元干预"><a href="#多元干预" class="headerlink" title="多元干预"></a>多元干预</h3><ol>
<li>根均方误差Root Mean Square Error (RMSE) [88, 41]<script type="math/tex; mode=display">
R M S E=\sqrt{\frac{1}{N} \sum_{n=1}^N \frac{1}{|T|} \sum_{j \in T}\left(Y^F(n, j)-Y^{C F}(n, j)\right)^2}</script></li>
<li>平均PEHE[88, 89, 90]——用于估计多因素干预对新冠的影响<script type="math/tex; mode=display">
\text { AveragePEHE }_j=\frac{1}{|T|} \sqrt{\frac{1}{N} \sum_{n=1}^N\left(\left(Y^F(n, j)-Y^F(n, 0)\right)-\left(Y^{C F}(n, j)-Y^{C F}(n, 0)\right)\right)^2}, j \in\left(T-T_0\right)</script></li>
</ol>
<h3 id="连续剂量干预"><a href="#连续剂量干预" class="headerlink" title="连续剂量干预"></a>连续剂量干预</h3><ol>
<li>平均积分平方误差Mean Integral Squared Error(MISE) [55]<script type="math/tex; mode=display">
\text { MISE }=\sqrt{\frac{1}{K} \frac{1}{N} \sum_{T_n \in \mathcal{T}} \sum_{n=1}^N \int_{\mathcal{D}_{T_n}}\left(Y_n\left(T_n, u\right)-\hat{Y}_n\left(T_n, u\right)\right)^2 \mathrm{~d} u}</script></li>
<li>平均剂量政策误差Mean Dose Policy Error (DPE)[55]，可以结合序列最小二乘法估计Sequential Least Squares Estimation[91]来决定最优剂量。<script type="math/tex; mode=display">
\mathrm{DPE}=\sqrt{\frac{1}{K} \frac{1}{N} \sum_{T_n \in \mathcal{T}} \sum_{n=1}^N\left(Y_n\left(T_n, D_{T_n}^*\right)-Y_n\left(T_n, \hat{D}_{T_n}^*\right)\right)^2}</script></li>
<li>政策误差(PE)[55, 92]<script type="math/tex; mode=display">
\mathrm{PE}=\sqrt{\frac{1}{N} \sum_{n=1}^N\left(Y_n\left(T_n^*, D_{T_n}^*\right)-Y_n\left(\hat{T}_n^*, \hat{D}_{T_n}^*\right)\right)^2}</script></li>
</ol>
<h3 id="时间序列干预"><a href="#时间序列干预" class="headerlink" title="时间序列干预"></a>时间序列干预</h3><p>时间序列与连续剂量的不同在于，时间序列用到了与时间相关的历史数据。<br>个体干预影响[93]</p>
<script type="math/tex; mode=display">
E_t^{(i)}=\mathbb{E}\left[y_{1, t}^{(i)} \mid x_t^{(i)}, a_t^{(i)}, D^{(i)}\right]-\mathbb{E}\left[y_{0, t}^{(i)} \mid x_t^{(i)}, a_t^{(i)}, D^{(i)}\right], t \in[T+1, T+\tau]</script><p>与二元处理和多元处理类似，根据ITE的处理类型，PEHE或平均PEHE可以作为评价指标。而RMSE或MAE可用于ATE和CATE。MIMIC III[94]数据集常用于时间序列干预问题，它是一个来自ICU病人的电子健康记录数据库。</p>
<p>此外，许多研究人员将模拟数据集灵活地应用于不同的场景。为了提供更多的消融实验，证明模型的稳健性。相关数据集的详细描述可以在第7节找到。</p>
<h2 id="深度因果模型的发展"><a href="#深度因果模型的发展" class="headerlink" title="深度因果模型的发展"></a>深度因果模型的发展</h2><h3 id="发展时间线"><a href="#发展时间线" class="headerlink" title="发展时间线"></a>发展时间线</h3><p><img src="https://github.com/likun1208/image/blob/master/DCM-1.png?raw=true" alt="时间线示意图"></p>
<h3 id="模型分类"><a href="#模型分类" class="headerlink" title="模型分类"></a>模型分类</h3><p><img src="https://github.com/likun1208/image/blob/master/DCM-2.png?raw=true" alt="模型分类示意图"></p>
<ol>
<li>学习平衡表征：这种类型的方法长期以来一直是一种流行的研究。其核心思想是利用编码器将协变量$X$映射到表示空间$\Phi$，结合处理$T$，采用网络$h$来预测输出结果$Y$，并使事实和反事实结果之间的分布距离$disc_H$最小。</li>
<li>混淆学习的协变量：这类方法的目的是在理论上对协变量关系进行分解。它的主要应用方案是对协变量进行无偏估计，并利用解耦、重权、编解码器重建等方法去除混杂因素。</li>
<li>基于GAN的反事实模拟：随着近年来GANs在数据综合方面的巨大成功，它也被广泛采用来解决因果效应估计问题。在使用GAN网络进行反事实模拟时，通常涉及两种方案，即生成反事实的输出结果或平衡表示空间分布。</li>
<li>时间序列因果估计：时间性因果估计已被广泛关注。使用RNN跟踪上下文协变量信息并处理时变混杂偏差是许多模型长期采用的解决方案。</li>
<li>多干预和连续剂量模型：多重处理和连续剂量处理的问题是近期深度因果学习的研究热点之一。一般来说，这类问题可以采用匹配、变异自动编码器、分层判别器和多头关注机制等方案进一步简化和结构化。</li>
</ol>
<h2 id="典型深度因果模型"><a href="#典型深度因果模型" class="headerlink" title="典型深度因果模型"></a>典型深度因果模型</h2><p><img src="https://github.com/likun1208/image/blob/master/DCM-3.png?raw=true" alt="模型总结表"></p>
<h3 id="学习平衡表征"><a href="#学习平衡表征" class="headerlink" title="学习平衡表征"></a>学习平衡表征</h3><p>大多数统计学习理论认为，测试数据和训练数据具有独立且相同的分布，但在现实中，测试数据和训练数据的分布往往是相关的，但不完全相同。解决这个问题需要深度学习模型，在因果效应估计领域学习因果关系而不是相关关系。观察性数据没有标准的干预分配策略，这与RCTs不同。正如我们所知，由于已知和未知协变量引起的选择偏差，事实和反事实分布往往是不同的。因此，因果效应估计需要转化为一个领域适应问题，通过从事实数据中学习来预测反事实的结果。</p>
<h4 id="BNN及其衍生"><a href="#BNN及其衍生" class="headerlink" title="BNN及其衍生"></a>BNN及其衍生</h4><ol>
<li>BNN[40]是一个用于反事实推理的算法框架，如图所示，它将因果效应估计问题转化为一个表示分布平衡问题。在将协变量映射到表征空间后，编码器利用一个两层全连接神经网络，平衡表征空间的分布距离，然后利用另一个两层全连接网络得出反事实结果。使用的回归函数如下：<script type="math/tex; mode=display">
B_{\mathcal{H}, \alpha, \gamma}(\Phi, h)=\frac{1}{n} \sum_{i=1}^n\left|h\left(\Phi\left(x_i\right), t_i\right)-y_i^F\right|+\alpha \operatorname{disc}_{\mathcal{H}}\left(\hat{P}_{\Phi}^F, \hat{P}_{\Phi}^{C F}\right)+\frac{\gamma}{n} \sum_{i=1}^n\left|h\left(\Phi\left(x_i\right), 1-t_i\right)-y_{j(i)}^F\right|</script><img src="https://github.com/likun1208/image/blob/master/DCM-BNN.jpg?raw=true" alt="BNN示意图"></li>
<li>作为测量实验组和对照组空间分布距离的创新方法，文献[42]提出了基于BNN[40]的CFRNet网络结构，采用MMD和WASS进行空间分布距离表示。在网络训练时，根据距离的明确边界计算不平衡惩罚，并分别计算实验组和对照组的损失。除了在结果预测层之间增加多个神经网络层外，DCN-PD[95]还将多任务深度神经网络与倾向分数剔除相结合[118]。</li>
<li>在CFRNet[42]模型的基础上，RCFR[96]和CFR-ISW[97]都采用了Propensity score对代表性空间特征区域和采样目标函数进行重新加权；Atan等人提出了一个无偏的自动编码器网络Deep-Treat[19]框架，应用前馈神经网络学习最优干预策略。虽然它减少了表征重建的损失以及空间的信息损失，但也缩小了选择偏差。</li>
</ol>
<h4 id="SITE及其衍生"><a href="#SITE及其衍生" class="headerlink" title="SITE及其衍生"></a>SITE及其衍生</h4><ol>
<li>为了保持代表实验组和对照组的数据的局部相似性和平衡，提高个体干预效果，Yao等人提出了SITE[43]方法，该方法将位置依赖的深度度量PDDM与中点距离最小化MPDM结合到表示空间中，并使用二元结果网络预测潜在结果。在这种情况下，使用了以下损失函数：<script type="math/tex; mode=display">
\mathcal{L}=\mathcal{L}_{\mathrm{FL}}+\beta \mathcal{L}_{\text {PDDM }}+\gamma \mathcal{L}_{\mathrm{MPDM}}+\lambda\|W\|_2</script></li>
<li>根据SITE[43]，ACE[53]提出了一种平衡和自适应的相似性正则化结构来提取空间细粒度的相似性信息。</li>
<li>在[54]中提出了DKLITE，通过应用深度核回归和后验正则化来学习空间域重叠信息</li>
<li>BWCFR[105]对域重叠区域的空间特征分布进行了重新加权</li>
</ol>
<h4 id="其他深度网络模型"><a href="#其他深度网络模型" class="headerlink" title="其他深度网络模型"></a>其他深度网络模型</h4><ol>
<li>通过将GAN与互信息估计器正则化结构相结合，ABCEI[104]试图平衡表征空间中实验组和对照组的协变量分布</li>
<li>在[109]中，CETransformer被提出应用注意力机制来关注协变量之间的关系，然后学习平衡表征分布；</li>
<li>TransTEE[73]将平衡表征分布方法扩展到连续、结构化和剂量相关的干预，它使因果效应估计成为更加开放的问题。</li>
<li>CURE[116]为纵向（或结构化）病人数据设计了新的序列编码，并将结构和时间合并到病人嵌入中</li>
<li>DESCN[114]在整个样本空间中联合学习处理和反应函数，以避免处理偏差，并使用中间的伪处理效果预测网络来缓解样本的不平衡</li>
<li>在[72]中，SCI归纳了子空间的概念，如图4所示，将协变量同时整合到一个共同的子空间、一个干预子空间和一个控制子空间，从而得到一个共同的表示和两个具体的表示。之后，共同表征与实验组和对照组的具体表征相连，从重建和预测网络中得到两个潜在的结果。<br> <img src="https://github.com/likun1208/image/blob/master/DCM-SCI.jpg?raw=true" alt="SCI示意图"></li>
<li>基于SCI，NETDECONF[119]使用网络结构信息来推断观察数据中的隐藏混杂。</li>
<li>OrganITE[120]提出了一个个性化的干预效果模型，根据稀缺性分配干预，并估计潜在的结果。</li>
</ol>
<h3 id="混淆学习的协变量"><a href="#混淆学习的协变量" class="headerlink" title="混淆学习的协变量"></a>混淆学习的协变量</h3><p>因果效应估计的主要问题是在给定一个协变量、一个干预方法和一个预测结果的情况下估计干预效果。通过识别和校正混杂因素，有可能从观察性数据中更准确地估计因果效应。然而，在实际案例中，存在着潜在的噪音和不确定性的混杂因素，以及一些非混杂因素。因此，挖掘潜在的混杂因素并对相关协变量进行解耦，是从观察数据中学习反事实的无偏表述的重要方法。</p>
<h4 id="CEVAE"><a href="#CEVAE" class="headerlink" title="CEVAE"></a>CEVAE</h4><ol>
<li>CEVAE[52]模型结构最早由Louizos等人提出，在存在噪声和不确定混杂因素的情况下，用VAE捕捉隐藏的混杂因素，并进行处理和预测。在TARNet[42]因果关系图结构的基础上，对推理网络中的y和t，以及模型网络中的z和t分别进行Do-calculus[121]推导，以拟合潜在混杂变量与干预效果之间的相互作用。总的来说，因果变异自动编码器中涉及以下预测函数：<script type="math/tex; mode=display">
\mathcal{F}_{\mathrm{CEVAE}}=\mathcal{L}+\sum_{i=1}^N\left(\log q\left(t_i=t_i^* \mid \mathbf{x}_i^*\right)+\log q\left(y_i=y_i^* \mid \mathbf{x}_i^*, t_i^*\right)\right)</script></li>
<li>在CEVAE[52]的基础上，Sun等人提出了LaCIM[106]潜在因果模型，以避免虚假关联，提高模型的泛化能力</li>
<li>CEGAN[68]利用GAN网络无偏地识别潜在的混杂因素</li>
</ol>
<h4 id="Dragonnet"><a href="#Dragonnet" class="headerlink" title="Dragonnet"></a>Dragonnet</h4><ol>
<li>由Shi等人提出，首创的Dragonnet[66]将正则化目标函数禁入非参数估计理论，将倾向得分预测网络禁入CFRNet[42]，从而确保协变量中与干预相关的信息得到调整。可以看出，图5显示了倾向得分自适应神经网络的网络结构。<br><img src="https://github.com/likun1208/image/blob/master/DCM-Dragonnet.jpg?raw=true" alt="Dragonnet示意图"></li>
<li>根据Dragonnet[66]，VSR[107]提出了一个去除关联处理和混杂因素的复权模型。它还使用了一个深度神经网络来聚合整个变异分布中潜变量的密度比，以计算样本权重分布</li>
<li>作为估计过程的一部分，DONUT[110]对总损失中的非混杂因素增加了一个正交约束；此外，还提出了一个名为FlexTENet[111]的端到端正则化和重新参数化方法，利用多任务框架学习新架构，通过它自适应地获得因果结构间的共享函数。</li>
<li>在DIRECT-ND[122]中，通过混合学习解决了纠缠表示，并从一个新的角度研究了多变量因果效应估计问题。此外，模型中加入了VAE和GAN网络，实现了混合表示空间的学习。</li>
</ol>
<h4 id="DeR-CFR"><a href="#DeR-CFR" class="headerlink" title="DeR-CFR"></a>DeR-CFR</h4><ol>
<li>为了平衡选择偏差，Zhang等人[98]提出了RSB算法，通过PCC正则化和工具变量使用自动编码器网络，同时加入混杂变量和调节器进行预测。作为CFRNet[42]的延伸，DR-CFR[99]和DeR-CFR[65]都被提出，其主要结构如图6所示，以消除协变量的关联性。<br><img src="https://github.com/likun1208/image/blob/master/DCM-DeR-CFR.jpg?raw=true" alt="DeR-CFR示意图"></li>
<li>基于DeR-CFR，CATE的预测性能已经用CF-CV[123]进行了评估，它从潜在的候选人中选择最佳模型或超参数。</li>
<li>在[124]中，元学习方法与深度网络、理论推理和最佳反事实信息结合在一起。</li>
</ol>
<h3 id="基于GAN的反事实模拟"><a href="#基于GAN的反事实模拟" class="headerlink" title="基于GAN的反事实模拟"></a>基于GAN的反事实模拟</h3><p>在深度生成模型中，生成式对抗网络可以捕捉到反事实分布的不确定性。生成器产生反事实结果或控制组和实验组之间的一致性分布，而判别器则适合对干预效果的无偏估计。除了使用事实数据外，GAN网络在进行因果效应估计时也会考虑反事实结果的准确性。有鉴于此，生成式对抗模型越来越多地被用于因果效应估计。</p>
<ol>
<li>Yoon等人建议的第一个方法是由GANITE[44]网络根据事实数据生成反事实结果，并将其传递给ITE生成器。图7显示了GANITE的详细框图。<br><img src="https://github.com/likun1208/image/blob/master/DCM-GANITE.jpg?raw=true" alt="GANITE示意图"></li>
<li>CEGAN[68]首次应用GAN网络，通过利用GAN网络的判别损失，并在编码器之后对Decoder的构造损失或权重进行加权，来平衡空间处理组和对照组之间的分布。为了解决生成器-鉴别器的最小-最大问题，使用了以下奖励函数:<script type="math/tex; mode=display">
\min _{\left(\theta_E, \theta_I, \theta_P\right)} \max _{\theta_D} \mathbb{E}_{q_E(\mathbf{z}, \mathbf{x}, t, \mathbf{y})}[\log (D(\hat{\mathbf{z}}, \mathbf{x}, t, \mathbf{y}))]+\mathbb{E}_{q P(\mathbf{z}, \mathbf{x}, t, \mathbf{y})}[\log (1-D(\mathbf{z}, \mathbf{x}, t, \hat{\mathbf{y}}))]</script></li>
<li>作为生成式对抗框架的一部分，GAD[100]将GAN网络应用于连续干预问题，以学习样本平衡的权重矩阵，从而消除干预方案与协变量之间的关联</li>
<li>为了解决多重干预以及连续剂量干预问题，DRGAN[101]提出了一个由耦合事实发生器、判别器和推理块组成的模型架构</li>
<li>作为更好地应对连续干预问题的手段，SCIGAN[69]在DRGAN基础上增加了一个分层的判别器</li>
<li>CTAM[33]也将生成式对抗思想应用于文本序列信息的干预效果估计。它在学习表征时过滤掉了与近似工具变量相关的信息，并在学习的表征之间进行匹配</li>
<li>为了消除干预与患者病史之间的关联，CRN[102]利用反事实的递归神经网络来反映时变的干预效果</li>
<li>在ABCEI[104]中，用GAN网络很好地平衡了对照组和实验组之间的协变量分布，并加入了互信息估计器的正则化函数以减少偏差</li>
<li>为了学习平衡的协变量表征，CETransformer[109]将注意力机制与WGAN相结合</li>
<li>在TransTEE[73]中，Transformer被用于协变量表征，其中干预效果由倾向得分网络估计，选择偏差可由GAN网络克服。特别是，该模型也可用于离散、连续、结构化或剂量相关的干预。</li>
</ol>
<p>总的来说，利用GAN网络将单个治疗效果估计的方式扩展到多个干预措施和连续剂量干预措施并不难，而且对代表分布的平衡和潜在结果的产生有奇妙的效果。但是，由于缺乏完整的理论支持体系，利用GAN网络解决因果效应估计的问题需要在未来进行更多无懈可击的理论推导。</p>
<h3 id="时间序列因果估计"><a href="#时间序列因果估计" class="headerlink" title="时间序列因果估计"></a>时间序列因果估计</h3><p>在干预效果估计中，大多数模型都集中在数字变量上，处理文本信息和时间序列信息仍有难度[125]。文本信息估计的变量解耦可以减少估计偏差，因为文本信息中存在许多与因果效应估计无关的协变量。在处理时间序列信息时，RNNs通常被结合起来，根据历史信息创建反事实的递归网络。</p>
<ol>
<li><p>R-MSN[71]模型是由Lim等人首次提出的，目的是解决时间序列下连续治疗剂量和多治疗所产生的问题。图8说明了该模型的框架结构，它使用一个递归边缘网络来消除随时间变化的混杂因素，一个标准的RNN结构来编码和解码。<br><img src="https://github.com/likun1208/image/blob/master/DCM-R-MSN.jpg?raw=true" alt="R-MSN示意图"><br>为了预测因果效应，R-MSN使用了标准的LSTM结构，根据相应的时间间隔划分了多治疗和连续干预问题。</p>
</li>
<li><p>作为一个反事实的递归网络，CRN[102]在R-MSN[71]的基础上构建了每个时间步长的治疗变量表示，消除了患者在治疗分配和治疗分配之间的病史关联，平衡了时变混杂偏差</p>
</li>
<li>通过与当前干预分配和历史信息相结合，利用DSW[93]中的递归加权神经网络推断出隐藏的混杂因素，然后利用时变的反概率进行重新加权</li>
<li>除了建立一个多任务输出的RNN因子模型外，TSD[103]还在一段时间内分配多个治疗，然后用多原因的隐性混杂因素估计治疗效果，通过这种方法可以推断出不受治疗影响的潜变量。此外，它用潜变量替代了未观察到的混杂因素，并推断出没有治疗的逻辑回归结果</li>
<li>在SyncTwin[113]中，根据预测结果的时间结构进行治疗估计，并构建合成双胞胎样本，获得反事实预测结果</li>
<li>Yao等人提出了一种考虑到文本序列信息的匹配治疗-对抗学习CTAM[33]方法。如图9所示，在学习表征时，它过滤掉近似的工具变量，然后在学习的表征之间进行匹配，以估计治疗效果<br><img src="https://github.com/likun1208/image/blob/master/DCM-CTAM.jpg?raw=true" alt="R-CTAM示意图"><br>具体来说，CTAM[33]有三个主要部分：文本处理、表征学习和条件处理判别。在第一步中，文本处理部分将原始文本转化为向量表征 S，将S与非文本协变量X连接起来，然后构建一个统一的特征向量，将输入转化为潜在的表征Z。作为下一步，Z和Y都被输入到条件治疗判别器中，在训练过程中，在表征学习网络和条件治疗判别器之间计算最大最小算术单元。为了过滤掉与工具变量有关的信息，表征学习网络防止判别器分配相关的治疗。作为最后一步，它在表征空间Z中实现了匹配。</li>
</ol>
<p>为了利用全局特征表征和个体特征表征之间的相互信息来预测治疗分配，IDRL[126]提出了学习Infomax和与领域无关的表征。为了最大限度地捕捉治疗组和对照组之间的共同预测信息，过滤掉了工具变量和不相关变量的影响。</p>
<p>SCRNet[127]试图通过划分协变量来估计不同类型变量的ITE。</p>
<p>CT[115]采用transformer和lstm来捕捉时变混杂因素之间复杂的长期依赖关系，并提出了一个新的反事实域混淆损失来解决混淆偏倚问题。</p>
<p>文本时间序列的因果效应估计往往与多处理和连续剂量处理的相关问题相结合。尽管这个方向的应用很广泛，但研究人员需要根据实际情况制定一个测量干预效果的标准，而且很难评估业内使用的各种工作标准的合理性和可靠性。</p>
<h3 id="多干预和连续剂量模型"><a href="#多干预和连续剂量模型" class="headerlink" title="多干预和连续剂量模型"></a>多干预和连续剂量模型</h3><p>单一治疗的偶然性估计主要是解决二元治疗问题，而将其扩展到多重治疗则计算成本很高。然而，多重治疗和连续剂量治疗模型有很多应用，如癌症治疗的放疗、化疗和手术，以及多年来血管抑制剂的长期使用。因此，在这些不同的治疗环境中估计持续干预的效果，以做出奇妙的长期过程决策是有益的。</p>
<ol>
<li>Schwab等人首次用PM[41]算法将个体治疗估计扩展到多离散治疗问题。在PM中，反事实推理是通过匹配最近的邻居样本来小批量利用的，这使得它很容易实现，并与各种架构兼容，而且不需要增加计算复杂性或其他超参数来处理任意数量的病人。</li>
<li>为了捕捉高阶效应，TECE-VAE[88]通过使用任务嵌入对治疗之间的依赖性进行建模，将问题扩展到多治疗情况的任意子集。</li>
<li>在解决涉及多治疗和连续剂量治疗的问题时，GAN网络经常被结合起来。GAD[100]提出的两步生成对抗性去混杂算法可用于连续治疗问题，去除协变量和治疗变量之间的关联。具体来说，它与以下三个步骤。A）产生一个协变量之间没有关联的无偏分布；B）学习样本权重，将观察到的数据转移到无偏分布上；C）用生成对抗网络对数据进行去模糊化。</li>
<li>作为一种改进的GAN模型，DRGAN[101]采用了生成器、判别器和预测网络的形式，通过考虑多治疗和连续剂量治疗方案，为每个样本生成完整的剂量-反应曲线；通过在DRGAN基础上使用分层判别器，提出了SCIGAN[69]，以提高模型处理连续干预问题的能力。</li>
<li>同时，在DRNet[55]中提出了一套开放的模型基准参数，包括MISE、DPE、PE和模型选择标准，可以在连续剂量参数下生成无限数量的治疗的剂量-反应曲线。</li>
<li>在利用变系数神经网络的VCNet[56]中，为连续激活函数自动计算了连续ADRF[128, 129, 130]估计器，这有利于防止处理信息的丢失。此外，现有的目标正则化方法也被扩展，以获得一个双稳健的ADRF曲线估计器。</li>
<li>作为DRNet[55]的一部分，连续的治疗被分成若干块，分别训练成隐藏层，然后相互嵌套，构建单个剂量-反应曲线的片断拟合；VCNet[56]通过更加关注治疗的连续性，将单个预测头优化为随治疗变化的协变量的映射函数，从而建立了加权治疗的连续预测头。DRNet 和 VCNet 模型的结构比较见图 10。<br> <img src="https://github.com/likun1208/image/blob/master/DCM-VCNet.jpg?raw=true" alt="VCNet示意图"></li>
<li>TransTEE[73]将SCIGAN[69]的分层判别器与VCNet[56]的可变系数结构相结合，并归纳出Transformer多头关注机制通用框架，将因果效应估计问题扩展到离散、连续、结构化和剂量相关的治疗。</li>
<li>作为对多治疗组合问题的首次研究，NCoRE[108]利用跨治疗的相互作用来推断多治疗组合的因果生成过程，其中在治疗环境中学习的反事实表征被结合起来。</li>
<li>为了估计多因扰动的治疗效果，Prichard等人首次提出了SCP[112]的观点。为了克服混杂偏差，分两步走，首先应用单因CATE估计器来增强观察数据，并估计潜在的结果。并估计潜在的结果；下一步，增强的数据集被调整为协变量，以获得多因素的 无偏估计。除了说明单因素和多因素问题之间的关系外。SCP显示了单因素干预和多因素干预的条件预期的等同性。这可以通过以下公式来验证<script type="math/tex; mode=display">
\mathbb{E}_\alpha\left(Y\left(a_k, \mathbf{a}_{-k}\right) \mid \mathbf{X}\right)=\mathbb{E}_k\left(Y\left(a_k\right) \mid \mathbf{X}, \mathbf{A}_{-k}\left(a_k\right)=\mathbf{a}_{-k}\right)</script></li>
<li>与SCP不同的是，OOSR[131]提出了一种预测模型，它采用了一种重新加权的方式 强调了以结果为导向的治疗。</li>
</ol>
<p>最近，越来越多的研究人员对多治疗和连续剂量治疗的问题产生了兴趣，也做出了重大贡献。尽管如此，这一领域仍有许多模型需要开发。特别是，如何制定一个统一的因果效应测量标准，仍然是一个迫切需要解决的问题。</p>
<h2 id="工业界应用现状"><a href="#工业界应用现状" class="headerlink" title="工业界应用现状"></a>工业界应用现状</h2><h3 id="市场营销应用"><a href="#市场营销应用" class="headerlink" title="市场营销应用"></a>市场营销应用</h3><ol>
<li>激励分配：为了使投资回报最大化，在预算限制下决定如何分配针对用户的激励措施是至关重要的。<ol>
<li>PCAN[132]利用少量的无偏数据集来训练一个无偏模型，并建立一个有偏网络，通过有偏数据和无偏数据表示的分布差异来生成一个接近无偏网络的表示。离线和在线实验结果表明，所开发的方法可以缓解价格偏见的问题，并导致所产生的分配政策在现实世界的营销活动中的性能显著提高。</li>
<li>DESCN[114]被开发出来，以综合的方式捕捉干预倾向、真实反应和伪干预效果之间的关系，该方法被应用于阿里巴巴集团旗下东南亚领先的电子商务平台Lazada的优惠券分配业务。相关结果表明，这种方法在ITE估计的准确性和提升排名性能方面都有优势。</li>
<li>对于多处理场景，亚马逊提出了MEMENTO[133]。它的基础是获得各种干预类型的混杂因素的匹配表示，通过最小化事实和反事实损失之和的上限来实现。</li>
</ol>
</li>
<li>市场营销的其他任务。例如，AntGroup提出了一个用户保留模型UR-IPW[134]，以说明印象-重访效应，即用户即使不与推荐系统明确互动，也可以重访APP。该模型充分利用了观察到的数据中的显性和隐性互动，并通过使用反倾向加权来估计重访率，考虑到用户的自我选择造成的选择偏差。</li>
<li>实际应用：在双边商业关系中，有效的营销策略也应该激励商户和客户。例如，为了鼓励移动支付活动，商家在顾客扫描二维码并使用支付宝付款后，可以与顾客分享奖励。然而，对双方进行独立的优化可能是不理想的。因此，[135]和[136]考虑到了相互影响，并使用图神经网络，通过对潜在的两边影响进行建模，共同代表商家和顾客。大量的实验结果证明了所提方法的有效性。</li>
</ol>
<h3 id="电子商务应用"><a href="#电子商务应用" class="headerlink" title="电子商务应用"></a>电子商务应用</h3><ol>
<li>推荐系统：传统的推荐系统基于数据观察中的学习相关性来提取用户的偏好，导致了包括选择偏差、接触偏差、位置偏差、顺从偏差等在内的偏差。为了解决这个问题，亚马逊、Netflix、Criteo、阿里巴巴、AntGroup、JD、Kuaishou等都开始利用因果效应估计来提取因果关系。<ol>
<li>数据集和最近关于推荐去偏的工作可以参考[137]和[138]</li>
<li>在[81]中，华为提出了去偏移的信息瓶颈，适用于各种类型的偏移。该架构约束模型在训练阶段学习具有独立的有偏和无偏成分的有偏嵌入向量，并在测试阶段只使用无偏成分，以提供更准确的推荐。</li>
<li>如[139]所述，Wei等人从因果关系的角度探讨了人气偏差问题，该方法进行多任务学习以实现每个原因的贡献，在测试期间，执行反事实推理来消除项目流行度的影响。</li>
<li>ESCM[140]利用用户行为的顺序模式来解决数据稀少的问题，并采用反事实风险最小化器作为正则器来同时解决CVR估计的固有估计偏差和CTCVR估计的潜在独立优先权这两个问题。</li>
<li>在[15]中，Criteo提出了一个多任务目标，将有偏见的数据矩阵和统一数据的矩阵联合进行因子化。</li>
<li>在[141]中，提出了一个能够实现统一数据建模的通用知识蒸馏框架，它由四个模块组成，包括基于标签的蒸馏、基于特征的蒸馏、基于样本的蒸馏和基于模型结构的蒸馏。</li>
<li>在[142]中，AutoDebias通过解决一小部分统一数据的双级优化问题来优化去重参数。</li>
</ol>
</li>
<li>实际应用：在[140]中，阿里巴巴提出了CausalMTA，它通过重新加权和学习无偏见的转换预测模型，从静态和动态的角度系统地消除了混杂的偏差。它的有效性由一个真实的广告印象数据来证明，其中包括30天的手机上的店铺广告印象数据。</li>
</ol>
<h3 id="金融应用"><a href="#金融应用" class="headerlink" title="金融应用"></a>金融应用</h3><p>计量经济学，估计政策影响方面的因果关系</p>
<ol>
<li>Hennessy等人[143]分析了在金融和经济学中常见的各类环境中替代性因果效应措施的意义和使用情况，这些环境中个体代理人拥有私人信息，结果变量由经济中其他代理人的信念所调解。他们建议使用两种不同的因果效应定义，包括部分因果效应和全部因果效应。</li>
<li>Tiffin[144]主要关注因果林算法，并以金融危机的成本为例进行说明，该文已努力说明此类技术如何能产生可信的结果，即估计出危机的平均影响。</li>
<li>Athey和Wager[145]引入了计量经济学中半参数效率理论的见解，提出了一个新的最优政策估计器，并分析了这个估计器的特性。政策可以根据其 “风险 “进行比较，”风险 “被定义为使用（未知）最优政策和估计政策的预期结果之间的差距。</li>
<li>Arpino等人[146]提出了一个明确的模型，该模型被应用于评估在托斯卡纳对小型手工业公司实施的政策，以解决由于细胞之间的干扰而违反稳定的细胞处理值假设的问题。结果显示，当被处理的企业受到高水平的干扰时，政策带来的好处会减少。</li>
<li>实际应用：在金融科技领域，蚂蚁金服集团的MYbank采用了因果反事实推理去偏方法[147, 107, 112, 108, 148, 149]，解决了贷款营销AB实验的偏颇问题。为了有效衡量干预效果，我们采用因果反事实推理的方法，在观察数据的基础上，从全部实验人群中构建一个同质性的控制组，从而进行横向比较。</li>
</ol>
<h3 id="医药应用"><a href="#医药应用" class="headerlink" title="医药应用"></a>医药应用</h3><ol>
<li>多病因干预问题<ol>
<li>有人提出了单病因扰动[112]，它首先用单病因干预下估计的潜在结果来增强观察数据集，然后对增强后的数据集进行协变量调整，得到估计值。</li>
<li>GraphITE[150]被提出，它使用图神经网络获得图结构干预的表征，并通过使用HSIC正则化增加目标和干预表征的独立性来缓解观察偏差。</li>
</ol>
</li>
<li>估计随时间变化的干预效果<ol>
<li>SCIGAN[69]，能够同时估计几种不同连续干预的反事实结果。</li>
<li>TE-CDE[151]，它允许在任何时间点对潜在的结果进行评估。逆向训练被用来调整随时间变化的混杂因素，这在纵向环境中是至关重要的。</li>
</ol>
</li>
<li>实际应用：van der Schaar实验室确定并瞄准了广泛的潜在临床应用，包括COVID-19、器官移植等。为了决定每个场景的 “一个最佳模型”，[152]中引入了一个首创的验证程序，用于估计使用影响函数的因果效应估计方法的性能，该程序利用类似泰勒的扩展方式，以其在已知因果效应的 “综合”、近似数据集上的影响函数来近似一个方法在特定数据集上的损失函数。</li>
</ol>
<h3 id="经济应用"><a href="#经济应用" class="headerlink" title="经济应用"></a>经济应用</h3><ol>
<li>无法得到无偏数据的问题：因果效应需要从具有不完美合规性的替代实验中学习，并且因果知识必须在结构异质的人群中进行推断。为了解决所有这些挑战，需要一个强大的因果效应估计框架，这些挑战基本上在不同程度上困扰着任何数据分析[153]。它嵌套了深度学习的预测能力，以获得高维协变量下一致的因果估计[154, 155, 156]</li>
<li>“可信度革命”<ol>
<li>在[157]中，Angrist和Steve Pischke创造了 “可信度革命 “这个术语。他们认为，经济学转向应用于特定因果问题的透明实证策略。</li>
<li>问题驱动的方法论议程主要是基于Rosenbaum和Rubin的倾向性得分定理[158]。这个定理改变了应用计量经济学，使我们的注意力集中在确定干预分配的过程而不是结果的模型上。</li>
<li>Dehejia和Wahba[85]是第一个证明这种方法的价值的人。</li>
<li>Belloni等人[159]利用深度学习对分数进行建模，同时对结果进行建模。这项工作可以看作是Robins的双重稳健性概念在更广泛的经验策略上的延伸。</li>
<li>Angrist[160]引入了一个新颖的框架，即用于因果效应估计的局部平均干预效应框架，以帮助经济学中的实证策略应该是透明和可信的。</li>
</ol>
</li>
<li>Hal R. Varian[161]认为，深度学习中使用的强大技术可能有助于开发更好的反事实估计，有可能改善因果效应估计。</li>
<li>对于广义邻居匹配来估计个人和平均干预效果，Vikas[162]提出在计量经济学中使用深度学习技术，特别是用于因果效应估计和估计个人以及平均干预效果。</li>
</ol>
<h3 id="教育应用"><a href="#教育应用" class="headerlink" title="教育应用"></a>教育应用</h3><p>关于教育干预措施对学生成绩影响的新研究[163]——人们越来越认识到在教育领域制定循证政策的必要性。教育政策制定者和实践者都想知道哪些政策和实践能最好地实现他们的目标。然而，提供适合指导政策的经验证据并不是一件容易的事，因为它指的是因果效应的估计，需要特殊的研究方法，而这些方法由于其技术的复杂性，并不总是容易沟通。</p>
<ol>
<li>从贝叶斯的角度来看，David[164, 165]介绍了对大规模教育评估中因果推断问题的回顾和总结，这需要阐明因果效应估计的框架，然后采用与框架密切匹配的统计方法，并能得出感兴趣的因果估计。</li>
<li>Zhao等人[39]提出智能导师系统中的残差反事实网络可以决定哪种提示更适合于特定的学生。</li>
</ol>
<p>然而，干预的有效性必然是多方面的，复杂的效果在不同的学生之间是不同的，是实施方案的函数[166]，而且有可能是时间和地点的函数。</p>
<ol>
<li>Sales等人[167]探讨了一种不同的干预效果异质性差异，即不同结果的有效性。具体来说，不同的后测项目测量不同的技能。</li>
<li>Carvalho [168] 使用不同的工具包GeNIe3，利用学习管理系统的数据对学生的在线行为模式进行了因果效应估计。</li>
<li>Chen等人[169]开发了一个因果发现框架，利用TETRAD[170]。</li>
</ol>
<h2 id="实验指南"><a href="#实验指南" class="headerlink" title="实验指南"></a>实验指南</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><ol>
<li>IHDP.婴儿健康与发展[86]数据集产生于一项针对低出生体重早产儿的随机对照试验。儿童及其母亲的各种特征作为治疗前的协变量被测量，如出生体重、头围、新生儿健康指数、产前护理、母亲的年龄、教育、药物和酒精。向治疗组的婴儿提供强化的高质量儿童护理，如专家家访[171]。结果是婴儿在认知测试中的得分。此外，需要去除治疗组的噪音子集，以建立无偏的选择模型。<strong>【医学相关】</strong></li>
<li>工作。乔布斯在LaLonde（1986）[87]中研究的就业数据集是由基于国家支持的工作计划的随机数据和观察性研究的非随机数据组成的。治疗前的协变量包括1974年和1975年的年龄、教育、种族和收入等八个变量。治疗组参加了职业培训，而对照组则没有。结果是就业状况。<strong>【社科相关】</strong></li>
<li>双胞胎。双胞胎数据集来自于1989-1991年美国的双胞胎出生数据[172]。对每对双胞胎进行了与怀孕、双胞胎出生和父母有关的40个协变量的评估，包括刚出生前的孕周、怀孕期间的护理质量、怀孕风险因素（贫血、酒精、吸烟等）、护理、居住等。其结果是一年的死亡率。有一个双胞胎数据集，其中有来自实验组（双胞胎中较重的）和控制组（双胞胎中较轻的）的结果。选择偏差通常是通过根据用户定义的标准分配不同的治疗来模拟的。<strong>【医学相关】</strong></li>
<li>新闻。新闻数据集由《纽约时报》语料库中5000篇随机抽样的新闻文章组成。新闻数据集包含媒体消费者对新闻项目的看法的数据。样本是由字数组成的新闻项目，结果是读者的意见，处理方法是可用于查看新闻项目的各种设备，如智能手机、平板电脑、电脑和电视。<strong>【社科相关】</strong></li>
<li>ACIC。自2016年以来，每年的大西洋因果推断会议都会举行因果效应估计数据分析挑战赛，该挑战赛针对各种因果效应估计问题提出不同的数据集。下面我们详细介绍ACIC2016和ACIC2018这两个典型的数据集。关于ACIC的最新会议数据集的摘要可以在[173]中找到。ACIC2016由77个数据集组成，具有不同程度的非线性、稀疏性、治疗分配和结果之间的相关性，以及干预效果之间的重叠性。协变量来自IHDP[86]数据集的真实数据，其中包括58个变量和4802个样本[174]。模拟模型产生了干预、事实和反事实的结果，而选择偏差是通过去除非白人母亲的干预儿童而产生的。ACIC 2018是一个常用的因果效应估计的基准数据集[175]。它是一个关于婴儿出生和死亡的半合成数据集[176]，包含63个数据集，每个数据集从不同的分布中随机抽取，然后通过模拟过程生成。<strong>【医学相关】</strong></li>
<li>TCGA。作为世界上最大和最全面的基因组数据库，癌症基因组图谱（TCGA）[92]包含了数十亿的基因组。TCGA[92]数据集共包括9658个个体，治疗方案为药物治疗、化疗和手术，结果为治疗后患癌的风险。<strong>【医学相关】</strong></li>
<li>肿瘤生长的PK-PD模型。药代动力学-药效学模型（PK-PD）[177]可用于探索剂量-反应关系，并提出最佳治疗方案。其主要功能包括化疗和放疗效果的结合、治疗后的细胞再生、病人的死亡或恢复，以及在诊断阶段基于癌症的肿瘤大小的不同目光分布，这使得这个模型成为治疗非小细胞肺癌病人的一个很好的模型。PKPD模型使临床医生能够探索关于剂量-反应关系的假设，并提出最佳治疗方案[178, 179]。在PK-PD最经典的例子中，通过观察对治疗、化疗和放疗的预期反应，可以预测具有时间依赖性的肿瘤生长[177]。<strong>【医学相关】</strong></li>
<li>MIMIC III。重症监护医疗信息市场(MIMIC III)[94]是一个来自ICU病人的电子健康记录数据库。基准数据集由7413个样本组成，在过滤了缺失值后有25个协变量。就治疗方案而言，抗生素、血管抑制剂和机械呼吸机是ICU中治疗败血症患者最常见的方案。一些实验室以病人的生命体征随着时间的推移作为衡量标准，评估抗生素、血管压缩机和机械呼吸机对以下协变量的影响，包括白细胞、血压和氧饱和度。关于临床数据的全面而详细的描述可以在[180]中找到。<strong>【医学相关】</strong></li>
<li>NICO。在使用带有上下文的图像数据集NICO进行物体分类时，样本选择存在偏差[106]。NICO中 “动物 “数据集中的猫或狗分类被视为非i.i.d的基准分布。参数包括采样时间、是否采样、上下文、猫和狗的语义形状，以及 “草 “和 “雪 “环境。<strong>【图像处理相关】</strong></li>
<li>ADNI. Alzheimer’s Disease Neuroimaging Initiative(ADNI)[181] 数据集有三个潜在的表示输出Alzheimer’s Disease, Mild Cognitive Impairment 和Normal Control。协变量是年龄和TAU[182]，它们决定了磁共振成像是否应作为治疗的输入。<strong>【医学相关】</strong></li>
<li>COVID-19。在大流行的第一个高峰期，数据集COVID-19[90, 89] 英格兰住院监测系统（CHESS）收集了3090名ICU病人的个人层面的风险因素、治疗和结果。有许多协变量，包括年龄和多种发病率等因素，以及治疗参数，如通风和抗病毒药物。结果是在重症监护室的停留时间[183]。<strong>【医学相关】</strong></li>
<li>CPRD。临床实践研究数据链(CPRD)包含来自英国国家医疗服务系统(NHS)全科诊所的记录，覆盖全国约6.9％的人口[184]。全国死亡率记录和医院事件统计表明，CPRD与二级护理住院有关。低密度脂蛋白是在CPRD开始后测量的，而治疗是指第一次开处方的日期。作为时间协变量，以下风险因素是在治疗开始前测量的：高密度脂蛋白胆固醇、血压、脉搏、肌酐、甘油三酯和吸烟状况。HPS登记的参与者是从125,784名符合资格标准的人中选出的。共有17371个治疗组和24557个对照组被分为三个同等大小的子集，用于训练、验证和测试。<strong>【医学相关】</strong></li>
<li>BlogCatalog。BlogCatalog是一个用户发布博客的在线社区。在数据集中，每个实例都是一个博主[185]。每条边代表两个博主之间的社会关系。博客描述中包含的关键词以词包的形式表示。博客读者意见作为输入，博客创建的内容在移动端或桌面端得到更多的评论作为干预，个人干预效果估计的参数来自读者在移动端（比桌面端）的评论内容。如果人们在移动设备上的阅读量比在桌面设备上的阅读量大，那么博主就属于实验组，反之亦然。<strong>【社科相关】</strong></li>
<li>Flickr。Flickr是一个在线社交网站，用户可以分享照片和视频[186]。该数据集由代表用户的实例和代表他们之间社会关系的边组成。感兴趣的标签由每个用户的特征来表示。一般来说，设置和假设与BlogCatalog数据集相同。<strong>【社科相关】</strong></li>
</ol>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ol>
<li>主要用PyTorch和TensorFlow</li>
<li>模型之间也可以再结合</li>
</ol>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>是与前面数据集相对应的实验说明。</p>
<h2 id="总结与未来展望"><a href="#总结与未来展望" class="headerlink" title="总结与未来展望"></a>总结与未来展望</h2><p>由于因果效应估计和深度学习的发展，深度因果模型作为一个研究课题变得越来越受欢迎。通过将深度网络模型应用于因果效应估计，有可能提高因果效应估计的准确性和无偏性。此外，深度网络可以通过因果效应估计中的深刻理论进行优化和改进。本调查介绍了深度因果模型的发展和各种方法的演变。首先，介绍了与因果效应估计领域相关的基本知识。然后，我们介绍了经典的处理方法和度量。此外，我们从时间发展上对深度因果模型进行了全面分析。接下来，我们将深度因果模型的方法分为五组，并进行了概述和分析。此外，我们对因果效应估计在工业中的应用做了全面的总结。最后，我们总结了相关的基准数据集、开放源代码和性能结果作为实验指南。</p>
<p>自2016年以来，因果效应估计首次在二元处理情况下与深度学习模型相结合，用于估计反事实的结果。到目前为止，深度因果模型已经被用于时间序列、多变量治疗和连续剂量治疗情况。这与深度学习领域的研究人员提出AE、GAN、RNN、Transformer等深度网络模型，统计领域的研究人员对IHDP、Twins、Jobs、News、TCGA等数据集的生成和模拟，以及业界研究人员在潜在结果框架理论指导下对ATE、PEHE、MISE、DPE的探索是分不开的。我们相信，在因果学习社区每个人的共同努力下，深度因果模型将蓬勃发展，造福社会和人类。</p>
<p>对于市场营销应用来说，除了激励性的功效评价分数，深度学习的可解释性也是必要的，以了解我们为什么预测输出，并将其作为商业创新的基础。此外，营销决策可能涉及道德和法律问题，如贷款申请。因此，使用因果效应估计作为公平性的保证是有意义的。</p>
<p>对于电子商务的应用，推荐系统中现有的debias方法通常只被设计用来解决一个或两个特定的偏见。现在迫切需要一个通用的debias框架来处理所有种类的偏见。此外，如何公平公正地评价一个推荐系统也是一个重要问题。现有的方法要么需要准确的倾向性分数，要么依赖无偏见的数据。因此，迫切需要深度因果模型来提供理论上的保证。</p>
<p>对于金融和经济应用来说，最好能整合微观和宏观层面的数据来研究稳定的因果效应。此外，不确定性量化也有利于决策过程，这可以通过深度学习的贝叶斯近似和集合学习技术来实现。</p>
<p>对于医学和教育应用，深度因果模型可以在多个领域采用，包括处理高维数据，用真实世界的数据丰富随机试验，评估溢出的因果效应，以及从对特定人群的研究转移到其他感兴趣的人群。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>因果推断</tag>
      </tags>
  </entry>
  <entry>
    <title>2023年2月1日-6月30日预算</title>
    <url>/2023/01/16/2023%E5%B9%B42%E6%9C%881%E6%97%A5-6%E6%9C%8830%E6%97%A5%E9%A2%84%E7%AE%97/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="28c7856973e37d21e20474c91d9d7bf1f55387e3d5814f7909c866f7573a8987">37677482e0ad0b0303755495d26d33f48e2d9353d6ac72383d428715a3456aeb913959d857e792b1c0d373d3646f0d6e5d82a6a887ba06e9cd4818983ddbf3eb9fcda287086fd29d43ad8fd255cc8e551ce1e62e3c207e56e31898cd72ce544cb72d7a5eea87a13e271a508e631db1025d913243f136b1d27bfe92b9e176f6014930fe7996183b80c4badd196f6aa037c4872e63c9186c8f2d449a7914a04e47e1ffccb82d0df644b30ac9c74a7f4b0a5c6a1280a537fc8f6cb2e39f70ca3fe6b32b586d3b2594862b413b3e58825ed436c6e804eed2f7c6c592d1d62dbbe61c135917940340c5b561b560f280eae3f186e9116bbc30675f9bf18cbd594e1758c32a312e835a814463da04c6e48be36ca944811403378ed258374227cef19bd827d6bebce2f4fdacdf274e7cbff2d6e9f8303710d34db51507bc0305442e8b44871c0954d5acb943de8293b504b27ae5b011ec290ef42ab0f8710e2d5c0ab2dabe8ea7961e23393877f879692a833aa3d84b206bcd9fc64d0895f21e5fd12b5091ec06eb208f09058d53eaea0ff40eea7ab41c49ee7f50072a959bdf4aed874654c7800d2dc34df7565c99ec091af9f3256f41458963de672d3406a7f61c0b6b3e533ae666225186b80f3fdadc7850d519bd14ce569aa28d6291afc7bdeedfb77890cc276151de3afe5a6b82dbdee5c2818ad81331ea6cc754d26e21d88e172ed326972f1551be32780ff97a380fff827b829d2b91e934675692567263d42df31331f092088eff995aacffb8caba8daed31c9cc3b31e48f1a6c16e337051e8edfbc072bd4512cae7cfad995abf80b2987969ee04a726f23a968eeeb84890170ec5ebaddb30f8186a2dd00b31bcf00cd873bd6db090e5f0c06f5bb3ec68d9bb883f38b154a32862db97df411cb9fd7fcfbbea0ff8edfacbcaa7e8a3a3b6e73e283d1842a2579773489ee1c11d2fc1112fedc10cf4c199e6c3f0d70a052717009be68a99e952a4f7d8722fc2507ce998743ee5202b84754d287ba8a8dfffdb24a855e438a35ba46e17bfc6bb1ab65ec60cfe14f7ce3b5131c9b29f31125521cadeb71a3c82cc67d9ef562191775a55a16cb5092d184950eca7704efeeab13585b6a258fc93de80153ff9d6a274d1d608fdd3dbbd816509d52832a8a96352b34ff5feaee6dfec74462f1b08992938efc50f7c605232724ada735b0c901e9c11d05fb4665705ca7cd1d0b274cbf79c74d3178a14ec3131f9464299b2c49fb5663c8a7014fabc83da4c3511751be2f7d56d2f64a148ebcfe8e55666cedc10bc665d7cfb8d1fa7eb7b68bb84915e0c3788bd077a69eabfffb6632bf509689adea8d989cc6fb8f4eba3530cae0050b99cce81cc478eeab38a7d7f137cb577acd564ff753537a47c54239c833067b375e522023d66b5b620e74e4bee1f6ed19c21ad6b0d553af1c59251bc7b91b7db4524e4c0c5e5d136f34cc9688708a5cce7d82cd54a843874ea1cfa196ecfd938daa919e9c023f95d013ce3cf75756cf35a5c58809bad52469f2717b2fb0827b7f2407902511b6e68bbbbb51f73a8573b6f5a834d54b36950d58a21dbcfd3408a82fe7a2c806ee2ee9f0e2af589c87a1ade26769340b1dafd6d53110f548bbc405a37beda573f3dfe94a398efd8868604b232be1304d0954bae4a4dfb671f2f5be1118989c1be403482d9a65cce1fadbfa7a335b442c58177d907a508cd3d94040fe5168539ab96a247b9176d08e2103a96f53a2f4b2541ef737e30977e03259def24a8d555657d38d7e337fd59130c740487a42fa357d4faa8528e92b7b8575ccfa6e2cc9f7cb1d605e6eda50ba0e62c6318cb69d9f30fb2f0a25470a3e1aae77a9b901dc8cf8a8db7e85cbd734711b02170cf2a5ccf121da6251320d57cca4aeabb44fdbcd0b1897c5b474e97bec6ac7b7fba90819f1fc2ccc532ccc876098374faad62b05e57849b4d2db93e23f3a383bca0aed06ce4e994cf9e1dc5cac8c606d2cbb096c9783d8aa9375536288746a025c8d9c54aa269fa343cb8e650fb99fd35430ee86fb5a04def2ae1a83e9a795df8ce99a91d9b6f6465854a433c8d644c26217f8dc141792e07c327212168070e3234e542ebfea6fd5ade28197e79324f554f9d184ba67eada483ff178469b7b88f9865ee7a52504c5bc5b38491a78e1b164c179ab4e0de7fe36869fc62aa5c09b9fae27a1777caec347a784019d0a3c7ab12e4c0652c72aadd2b68209de058e11757f47767d7476e408109a9ef80707eff1b1568cafc95a7d18d3cb51769960fdebb12a85ee6d507a688d1eb2f6443bdd4f5e53cd76a55496a3188b7f0f42f71bf182dbf9476bc3a39d65690bf785d87232f936275ee8da3bc276ed07df173135dde52124d813f5df100c9b2db20c4ca365d12ecb0eed086c9a49658d9e9c0db5b6439619ddc57d1d557daa8e9c1103cd3dc549238ed946b560e01adf0a4c2fd9d4513d911cbffdebe8c672614e12601707591793161011022c03cdf79ed851c06a2799c84952da3e7e7732c3e96496ad810dd3ec9dfd22e43c9ad63db58b059694aeb62c35702848fa57cb0662d14db7f9e8cc08543ea335a427ffbba17feefe00c436f1318a7519f470daae85af4333a62eeddf3322a2b57cf30abe3971024963509d9a78110c10b9b48bd41ddb48d86a4f2b9b540e2c22dc62b9f719ce6605c08f957a71273cd329111b311f9328e7ba80349940cce9d75ab480b6ec77377b5912f870d8a91d65da5fa7278d662ee5b14a05894ea4bca1880f8ed50a9b5f9b9a672f7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>预算决算</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-A Robust Bayesian Truth Serum for Small Populations</title>
    <url>/2023/01/02/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-A%20Robust%20Bayesian%20Truth%20Serum%20for%20Small%20Populations/</url>
    <content><![CDATA[<h1 id="A-Robust-Bayesian-Truth-Serum-for-Small-Populations"><a href="#A-Robust-Bayesian-Truth-Serum-for-Small-Populations" class="headerlink" title="A Robust Bayesian Truth Serum for Small Populations"></a>A Robust Bayesian Truth Serum for Small Populations</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>对等预测机制允许在真实的世界状态方面真实地引出私人信号（例如，经验或意见），而这个基础真相是不可观察的。最初的对等预测方法对于任意数量大于2的实体而言都是激励相容的，但依赖于所有实体共享的公共先验和机制。而贝叶斯吐真剂BTS则放宽了这个假设。BTS仍然假设代理共享同一个公共先验，但机制不需要知道该先验。然而，BTS仅在实体数量足够大的时候才激励相容，且需要的确切实体数量并不确定，而是取决于私有先验。本文提出了针对二值信息的稳定BTS，它对于任意实体数量大于3的场景都激励相容，利用二次函数评分规则的一个特性。RBTS是第一个针对$n \geq 3$的场景提供了严格激励相容而无需知道公共先验的对等预测机制。此外，与原始的BTS不同，我们的机制在数字上是稳健的，而且事后是个体理性的（<em>ex post</em> individually rational）。</p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>先略</p>
<h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><p>先略</p>
<h2 id="The-Setting"><a href="#The-Setting" class="headerlink" title="The Setting"></a>The Setting</h2><p>存在数量大于等于3的理性且风险中立的代理，其目标是最大化自己的期望收益。他们都共享同一个概率统计信念系统，该系统由两部分组成：状态和信号。状态$T$是一个随机遍历，取值$\lbrace 1,…,m\rbrace,m\geq 2$，代表了世界的真实状态。每一个实体$i$观察一个信号，记作随机变量$S_i$，是取值在$\lbrace 0,1 \rbrace$的二值变量，有时也记作$\lbrace l,h \rbrace$分别表示低和高。信号可以看作是代表了实体的经验或者意见。一个普通的信号用随机变量$S$表示。所有实体都有公共先验，由$Pr(T=t)$和$Pr(S=h|T=t)$组成，指给定任意可能状态$t$会观察到高级信号的条件概率。我们要求先验是可接受的：</p>
<p><strong>定义</strong>1：如果公共先验满足以下属性，那么它就是可接受的：</p>
<ol>
<li>有两个或更多的状态，即$m\geq 2$。</li>
<li>每一个状态都有正概率出现，即对于所有$t\in\lbrace 1,…,m \rbrace$来说，$Pr(T=t)&gt;0$。</li>
<li>状态之间是不同的，对于任意$t\neq t’$，都有$Pr(S=h|T=t)\neq Pr(S=h|T=t’)$。所有状态都按惯例排序，即$Pr(S=h|T=1)&lt;…&lt;Pr(S=h|T=m)$。我们把这称为同种异构的特性。</li>
<li>以状态为条件的信号信念是完全混合的，对于所有$t$，$0&lt;Pr(S=h|T=t)&lt;1$。</li>
</ol>
<p>可接受性是一个弱要求。尤其要注意的是，任何先验都可以转化为可接受的先验，因为(1)对于具有正概率的状态，所有以状态为条件的信号信念是完全混合的；(2)对于至少两个具有正概率的状态，以状态为条件的信号信念是不同的。任何两个具有相同信号信念概率的状态都可以合并成一个新的状态，而概率为零的状态可以被放弃。该机制不需要任何关于可接受性以外的先验知识。</p>
<p>给定实体$i$的信号$s_i$，它可以更新自己关于另一个实体$j$会收到高级信号的概率的后验信念$P(S_j=h|S_i=s_i)$。因为公共先验，我们可以用$p_h=Pr(S_j=h|S_i=h)$和$p_l=Pr(S_j=h|S_i=l)$来分别表示一个普通实体在自己持有高和低信号的条件下对其他实体会持有高级信号的后验信念。我们将之称为一阶信号后验，且：</p>
<script type="math/tex; mode=display">
p_{\{h\}}=\sum_{t=1}^m \operatorname{Pr}\left(S_j=h \mid T=t\right) \operatorname{Pr}\left(T=t \mid S_i=s_i\right)</script><p>【个人理解】这个式子是指一个普通实体自己持有高信号的情况下，认为其他实体也持有高信号的概率。具体计算起来，就是自己持有信号$s_i$的情况下状态是$T=t$的条件概率，乘以状态是$T=t$的情况下，实体$j$持有高信号的概率，然后对所有可能的$t$求和，得到的总概率就是$p_h$。我其实觉得末尾的$S_i=s_i$应该是$S_i=h$，这样才能说得通。</p>
<p>其中关于状态的后验可以用通常的方式从贝叶斯规则中确定，等于</p>
<script type="math/tex; mode=display">
\operatorname{Pr}\left(T=t \mid S_i=s_i\right)=\frac{\operatorname{Pr}\left(S_i=s_i \mid T=t\right) \operatorname{Pr}(T=t)}{\operatorname{Pr}\left(S_i=s_i\right)}</script><p>而分母则是：</p>
<script type="math/tex; mode=display">
\operatorname{Pr}\left(S_i=s_i\right)=\sum_{t=1}^m \operatorname{Pr}\left(S_i=s_i \mid T=t\right) \operatorname{Pr}(T=t)</script><p>这些信号后验可以在实体知道两个信号的情况下进行类似的计算。我们扩展了这个符号，因此$p_{\lbrace h,l \rbrace}$表示在知道一个高信号和一个低信号之后的二阶后验。例如，对于实体$i$，我们可知对于任意不同的$j,k\neq i$，都有$p_{\lbrace h,l \rbrace}=\operatorname{Pr}\left(S_k=h \mid S_i=h, S_j=l\right)$。在这种情况下，实体$i$首先更新关于状态$T$的后验，即$Pr(T=t|S_i=s_i)$，这成为信念，以便进行第二轮的贝叶斯更新。</p>
<h2 id="The-Bayesian-Truth-Serum"><a href="#The-Bayesian-Truth-Serum" class="headerlink" title="The Bayesian Truth Serum"></a>The Bayesian Truth Serum</h2><p>在这一节中，我们解释了Prelc（2004）的原始贝叶斯真理血清（BTS）。虽然我们介绍的是这个机制的二进制版本，但BTS是针对任意数量的信号而定义的。</p>
<p>在BTS中，每一个实体$i$都需要提供两个报告：</p>
<ol>
<li>信息报告：$x_i\in\lbrace 0,1 \rbrace$表示实体$i$报告的信号</li>
<li>预测报告：$y_i\in[0,1]$表示实体$i$对人群中高信号出现的频率的预测</li>
</ol>
<p>BTS中实体$i$的分数包括以下3步：</p>
<ol>
<li>对于任意实体$j\neq i$，计算除了$i$和$j$以外，所有实体报告信号的算术平均：<script type="math/tex; mode=display">
\bar{x}_{-i j}=\frac{1}{n}\left(\left(\sum_{k \neq i, j} x_k\right)+1\right)</script></li>
<li>对于任意实体$j\neq i$，计算除了$i$和$j$以外，所有实体对高低两种信号频率的预测的几何平均：<script type="math/tex; mode=display">
\bar{y}_{-i j}=\left(\prod_{k \neq i, j} y_k\right)^{\frac{1}{n-2}}, \quad \bar{y}_{-i j}^{\prime}=\left(\prod_{k \neq i, j}\left(1-y_k\right)\right)^{\frac{1}{n-2}}</script></li>
<li>计算实体$i$的BTS评分：<script type="math/tex; mode=display">
\begin{aligned}
& u_i=\underbrace{\sum_{j \neq i}\left(x_i \ln \left(\frac{\bar{x}_{-i j}}{\bar{y}_{-i j}}\right)+\left(1-x_i\right) \ln \left(\frac{1-\bar{x}_{-i j}}{\bar{y}_{-i j}^{\prime}}\right)\right)}_{\text {information score }} \\
& +\underbrace{\sum_{j \neq i}\left(\bar{x}_{-i j} \ln \left(\frac{y_i}{\bar{x}_{-i j}}\right)+\left(1-\bar{x}_{-i j}\right) \ln \left(\frac{1-y_i}{1-\bar{x}_{-i j}}\right)\right)}_{\text {prediction score }}
\end{aligned}</script>这里注释提到，BTS有两种，一种是无限数量的实体，一种是有限数量的实体，这篇论文关注的是后者。此外BTS使用了拉普拉斯平滑来避免出现为0的概率。</li>
</ol>
<p>此外，这里和我之前理解的不那么一样，具体来说，之前我以为是直接计算所有人的算术平均和几何平均，但是从这个论文来看，它是分别计算了去掉每一个实体以后的平均值并求和。在人很多的时候，去掉一个人对均值也没影响，而人很少的时候，这个均值就会有波动了，进而导致激励相容不一定成立。</p>
<p>这对$n \rightarrow \infty$来说很简单，因为公式中对$j\neq i$的求和可以用只用一个随机选择的$j\neq i$计算的信息分和预测分来代替。</p>
<p>如果所有代理人（1）报告他们的真实信号和（2）预测人口中高信号的频率是他们的信号后验，则BTS机制是严格的贝叶斯-纳什激励相容。</p>
<p><strong>定理</strong>1：当$n\rightarrow \infty$且所有先验可接受时，BTS是严格贝叶斯纳什激励相容的。</p>
<p>Prelec评论说，这个结果对于适当大的、有限的$n$也是成立的，实际的门槛取决于共同的先验。然而，BTS不需要为小群体的实体调整激励。此外，对于小群体来说，它不需要满足临时个体理性（interim IR），也就是说，实体的期望收益可以是负的。</p>
<p><strong>定理</strong>2：当$n=3$时，BTS并不满足贝叶斯纳什激励相容或个体理性。</p>
<p>BTS的这种局限性可以从Prelec对BTS的处理中得到理解。一般来说，BTS兼容Bayes-Nash激励所需的代理数量取决于先验，而且很难确定。尽管如此，不同地方对BTS的讨论仍然没有注意到这个重要的注意事项，例如（Jurca和Faltings 2008；Chen和Pennock 2010）。出于这个原因，我们提供一个具体的例子。这个例子不是唯一的，也不依赖于$n=3$。</p>
<p><strong>例</strong>1：（BTS且$n=3$）考虑三个代理人共享以下先验，$m=2$（两个状态）：$Pr(T=2)=0.7, Pr(S=h|T=2)=0.8, Pr(S=h|T=1)=0.1$。基于此，后验信号信念分别是$p_{\{h\}}=\operatorname{Pr}\left(S_j=h \mid S_i=h\right)=0.764$和$p_{\{l\}}=\operatorname{Pr}\left(S_j=h \mid S_i=l\right)=0.339$。</p>
<p>【个人理解】$P(T=2)=0.7,P(T=1)=0.3,P(S=h|T=2)=0.8,P(S=h|T=1)=0.1$</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(S_i=h)&=\sum_{t=1}^m P\left(S_i=h \mid T=t\right) P(T=t)\\
&=P(S_i=h|T=1)P(T=1)+P(S_i=h|T=2)P(T=2)\\
&=0.1*0.3+0.8*0.7\\
&=0.59
\end{aligned}</script><script type="math/tex; mode=display">
P(T=1|S_i=h)=\frac{P(S_i=h|T=1)P(T=1)}{P(S_i=h)}=\frac{0.1*0.3}{0.59}=0.0508</script><script type="math/tex; mode=display">
P(T=2|S_i=h)=\frac{P(S_i=h|T=2)P(T=2)}{P(S_i=h)}=\frac{0.8*0.7}{0.59}=0.9491</script><script type="math/tex; mode=display">
\begin{aligned}
P(S_j=h|S_i=h)&=\sum_{t=1}^m \operatorname{Pr}\left(S_j=h \mid T=t\right) \operatorname{Pr}\left(T=t \mid S_i=h\right) \\
&=P(S_j=h|T=1)P(T=1|S_i=h)+P(S_j=h|T=2)P(T=2|S_i=h)\\
&=0.1*0.0508+0.8*0.9491=0.764
\end{aligned}</script><p>由此$p_{\{h\}}=\operatorname{Pr}\left(S_j=h \mid S_i=h\right)=0.764$，$p_{\{l\}}=\operatorname{Pr}\left(S_j=h \mid S_i=l\right)=0.339$也是类似的算法。</p>
<p>根据上面这个计算，可以认为，一个自己持有高信号的实体，认为其他人也持有高信号的概率是0.764；而一个自己持有低信号的实体，认为其他人持有高信号的概率是0.339。</p>
<p>考虑实体$i=1$，假设实体2和3都说真话。假设$S_1=h$，即实体1真实的报告是$x_1=1,y_1=0.764$。则当实体1说真话时，对应着实体$j=2$的评分公式计算的期望分数应该是：</p>
<script type="math/tex; mode=display">
E\left[\ln \left(\frac{\bar{X}_{-12}}{\bar{Y}_{-12}}\right)+\bar{X}_{-12} \ln \left(\frac{0.764}{\bar{X}_{-12}}\right)+\left(1-\bar{X}_{-12}\right) \ln \left(\frac{1-0.764}{1-\bar{X}_{-12}}\right)\right]</script><p>该期望值是相对随机变量$\bar{X}_{-12}$和$\bar{Y}_{-12}$而言的。当概率$p_{\{h\}}=0.764$时，实体1会认为$\bar{x}_{-12}=(1+1)/3=2/3$且$\bar{y}_{-12}=0.764$，同时概率$1-p_{\{h\}}=0.236$，可得$\bar{x}_{-12}=(0+1)/3=1/3$且$\bar{y}_{-12}=p_{\{l\}}=0.339$。给定上述内容，我们可以得到期望信息分是$0.764ln(\frac{2/3}{0.764})+0.236ln(\frac{1/3}{0.339})=-0.108$，而期望预测分是$0.764((2/3)ln(\frac{0.764}{2/3})+(1/3)ln(\frac{0.236}{1/3}))+0.236((1/3)ln(\frac{0.764}{1/3})+(2/3)ln(\frac{0.236}{2/3})=-0.117$，由此可得期望分是-0.225。而当公式中的$j=3$时，用同样的方法计算得到的实体1说真话对应的分数是-0.450，因此BTS不满足个体理性。</p>
<p>如果实体1谎报，且$x_1=0$，而仍然报告$y_1=0.764$，则期望信息分（$j=2$）会是$E[ln(\frac{1-\bar{X}_{-13}}{\bar{Y}’_{-13}})]=0.764ln(\frac{1/3}{0.236})+0.236ln(\frac{2/3}{0.661})=0.266$，预测分是0.149，类似的，考虑$j=3$可得总期望分是0.298，也就是说实体1谎报更好。</p>
<p><strong>例</strong>2：（BTS且$n\rightarrow \infty$）考虑相同的先验但是数量更多的实体。在极限的情况下，关注实体1的信念，随机变量$\bar{X}_{-ij},\bar{Y}_{-ij},\bar{Y}’_{-ij}$以1的概率各自取值：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\bar{X}_{-1 j} & =\lim _{n \rightarrow \infty} \frac{1}{n}\left((n-2) p_{\{h\}}+1\right)=p_{\{h\}} \\
\bar{Y}_{-1 j} & =\lim _{n \rightarrow \infty}\left(\left(p_{\{h\}}^{(n-2) p_{\{h\}}}\right)\left(p_{\{l\}}^{(n-2)\left(1-p_{\{h\}}\right)}\right)\right)^{1 /(n-2)} \\
& =\left(p_{\{h\}}^{p_{\{h\}}}\right)\left(p_{\{l\}}^{1-p_{\{h\}}}\right)=0.631, \\
\bar{Y}_{-1 j}^{\prime} & =\left(1-p_{\{h\}}\right)^{p_{\{h\}}}\left(1-p_{\{l\}}\right)^{1-p_{\{h\}}}=0.301 .
\end{aligned}</script><p>如果实体1如实报告（$x_1=1,y_1=0.764$），则它的期望信息分是$ln(\frac{0.764}{0.631})=0.191$，期望预测分是$0.764ln(0.764/0.764)+(1-0.764)ln(\frac{1-0.764}{1-0.764})=0$，即总分0.191。谎报$x_1=0$则会得到期望信息分为-0.243。在这个例子中，$n$足够大，取极限时BTS是贝叶斯纳什激励相容的。</p>
<p>在证明了BTS中取值较小的$n$的激励调整和临时IR的失败后，我们还对其数字上的稳健性做了如下观察：</p>
<p><strong>定理</strong>3：对后验报告$y_i\in\lbrace0,1 \rbrace$而言BTS的分数是无界负数。</p>
<h2 id="Robust-Bayesian-Truth-Serum"><a href="#Robust-Bayesian-Truth-Serum" class="headerlink" title="Robust Bayesian Truth Serum"></a>Robust Bayesian Truth Serum</h2><p>在本节中，我们介绍了稳健贝叶斯真理血清（RBTS）。RBTS对于每一个$n\geq 3$来说都是激励相容的，事后个体理性的（意味着对于任何结果，没有实体的收益是负的），并且在数字上是稳健的。我们首先介绍正确计分规则（不太确定这里的proper怎么翻译）。</p>
<p><strong>正确计分规则</strong>是可以用于激励理性的实体如实宣称自己关于对未来事件的可能性的私人信念的函数。</p>
<p><strong>定义</strong>2：（二值计分规则）给定可能的结果$\Omega=\{0,1\}$和关于结果$\omega=1$的概率的报告$y\in[0,1]$，一个二值计分规则$R(y,\omega)$根据报告$y$和发生的结果$\omega$分配一个分数。</p>
<p>首先，实体需要回答自己的信念报告$y\in[0,1]$。其次，事件$\omega\in\{0,1\}$发生了（由机制来观察）。最后，实体收到报酬$R(y,\omega)$。</p>
<p><strong>定义</strong>3：（严格正确计分规则）如果一个二值计分规则能使得一个实体在如实报告自己信念$p\in[0,1]$时最大化自己的期望得分，则该规则是正确的。且如果一个实体仅在如实报告时才能最大化期望得分，则该规则是严格正确的。</p>
<p>一个严格正确计分规则的例子是二值二次函数计分规则$R_q$，经过归一化处理，给出的分数在0和1之间：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& R_q(y, \omega=1)=2 y-y^2 \\
& R_q(y, \omega=0)=1-y^2 .
\end{aligned}</script><p><strong>定理</strong>4：（例，Selten，1998）二值二次计分规则$R_q$是严格正确的。</p>
<p>请注意，如果人们对正确计分规则进行正负变换，该规则仍然是正确的。关于一般的适当得分规则的更详细讨论，我们参考Gneiting和Raftery（2007）的文章。</p>
<h3 id="The-RBTS-Mechanism"><a href="#The-RBTS-Mechanism" class="headerlink" title="The RBTS Mechanism"></a>The RBTS Mechanism</h3><p>首先，每一个实体$i$都需要提供两个报告：</p>
<ol>
<li>信息报告</li>
<li>预测报告</li>
</ol>
<p>在第二步，针对每个实体$i$，选择一个参考实体$j=i+1$（模数$n$，这里没看懂）和一个对等实体$k=i+2$（模数$n$）并计算</p>
<script type="math/tex; mode=display">
y_i^{\prime}=\left\{\begin{array}{lll}
y_j+\delta, & \text { if } & x_i=1 \\
y_j-\delta, & \text { if } & x_i=0
\end{array}\right.</script><p>其中$\delta=min(y_j,1-y_j)$。实体$i$的RBTS分数为：</p>
<script type="math/tex; mode=display">
u_i=\underbrace{R_q\left(y_i^{\prime}, x_k\right)}_{\text {information score }}+\underbrace{R_q\left(y_i, x_k\right)}_{\text {prediction score }}</script><p><strong>例</strong>3：（RBTS且$n=3$）我们使用和例1中一样的设定来解释RBTS，即$p_{\{h\}}=0.764,p_{\{l\}}=0.339$。此外，我们可以注意到$p_{\{h,h\}}=0.795$且$p_{\{l,h\}}=0.664$。考虑实体1的视角，令实体2和3扮演参考$j$和对等$k$的角色。假设实体2和3都说真话。首先解释$S_1=h,S_2=l,S_3=l$时的计算。如果实体1说真话，因为$y_2=0.339$且$\delta=0.339$，可得$y’=y_2+\delta=0.339+0.339=0.678$。因为$x_3=1$，实体1的信息分是$2y_1’-y_1’^2=2(0.678)-0.678^2=0.896$。因为$y_1=0.764$且$x_3=1$，预测分是$2(0.764)-0.764^2=0.944$。总分是1.84.</p>
<p>为了确定当$S_1=h$时实体1说真话是最优解，我们需要考虑期望得分，进而考虑实体2和3的信号的分布。针对预测报告，因为$R_q(y_1,x_3)$是严格正确的，所以一定是真实的。实体1的期望预测分是$0.764(2(0.764)-0.764^2)+0.236(2(0.236)-0.236^2)=0.820$。针对期望信息分，首先考虑如实报告$x_1=1$。在这种情况下，$y_1’$是由实体2的实际预测报告向上取整的，实体1的期望信息分是：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \operatorname{Pr}\left(S_2=h \mid S_1=h\right) \\
& \quad\left[\quad \operatorname{Pr}\left(S_3=h \mid S_1=h, S_2=h\right) R_q(0.764+0.236,1)\right. \\
& \left.\quad+\operatorname{Pr}\left(S_3=l \mid S_1=h, S_2=h\right) R_q(0.764+0.236,0)\right] \\
& +\operatorname{Pr}\left(S_2=l \mid S_1=h\right) \\
& {\left[\quad \operatorname{Pr}\left(S_3=h \mid S_1=h, S_2=l\right) R_q(0.339+0.339,1)\right.} \\
& \left.\quad+\operatorname{Pr}\left(S_3=l \mid S_1=h, S_2=l\right) R_q(0.339+0.339,0)\right] \\
& =\quad p_{\{h\}}\left[p_{\{h, h\}}\left(2(1)-1^2\right)+\left(1-p_{\{h, h\}}\right)\left(1-1^2\right)\right] \\
& \quad+\left(1-p_{\{h\}}\right)\left[p_{\{h, l\}}\left(2(0.678)-0.678^2\right)\right. \\
& \left.+\left(1-p_{\{h, l\}}\right)\left(1-0.678^2\right)\right]=0.79 .
\end{aligned}</script><p>针对报告$x_1=0$，期望信息分是：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& p_{\{h\}}\left[\quad p_{\{h, h\}} R_q(0.764-0.236,1)\right. \\
& \left.+\left(1-p_{\{h, h\}}\right) R_q(0.764-0.236,0)\right] \\
& +\left(1-p_{\{h\}}\right)\left[\quad p_{\{h, l\}} R_q(0.339-0.339,1)\right. \\
& \left.+\left(1-p_{\{h, l\}}\right) R_q(0.339-0.339,0)\right]=0.664 \\
&
\end{aligned}</script><p>实体1说真话时期望信息分最高。</p>
<p>注意，对于任意$n\geq 3$，RBTS是严格贝叶斯纳什激励相容且可接受先验的。我们会在下一部分证明这一点。</p>
<h2 id="IC（激励相容）"><a href="#IC（激励相容）" class="headerlink" title="IC（激励相容）"></a>IC（激励相容）</h2><p>在建立RBTS的激励相容性时，我们首先提出了一些技术性的定理。第一个定理还建立了随机相关性，因此，对于不同的信号观测，信号后验是不同的。然后，我们介绍了一个适当的评分规则，用于诱导信号而不是信念报告，并将其作为分析RBTS的基础部分。</p>
<p><strong>引理</strong>5：对于所有可接受先验，$1&gt;p_{\{h\}}&gt;Pr(S_j=h)&gt;p_{\{l\}}&gt;0$都成立。</p>
<p>证明：可接受先验的完全混合属性确保先验总是内部的，且$1&gt;p_{\{h\}}&gt;0$以及$1&gt;p_{\{l\}}&gt;0$。此外，如果$p_{\{h\}}&gt;Pr(S_j=h)$，则这意味着$Pr(S_j=h)&gt;p_{\{l\}}$，因为</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\operatorname{Pr}\left(S_j=h\right)=  p_{\{h\}} \operatorname{Pr}\left(S_i=h\right) +\operatorname{Pr}\left(S_j=h \mid S_i=l\right) \operatorname{Pr}\left(S_i=l\right) \\
&\Leftrightarrow \quad  \operatorname{Pr}\left(S_j=h\right)\left(1-p_{\{h\}}\right)=p_{\{l\}}\left(1-\operatorname{Pr}\left(S_j=h\right)\right) \\
&\underbrace{\Rightarrow}_{p_{\{h\}}>\operatorname{Pr}\left(S_j=h\right)}  \operatorname{Pr}\left(S_j=h\right)>p_{\{l\}} .
\end{aligned}</script><p>剩下的就是给定可接受先验的情况下证明$p_{\{h\}}&gt;Pr(S_j=h)$。证明的剩余部分由3步组成：</p>
<p>首先，将每一个状态与$H$和$L$这两个组中的一个联系起来。</p>
<h3 id="A-Proper-Scoring-Rule-for-Eliciting-Signals-The-“Shadowing”-Method"><a href="#A-Proper-Scoring-Rule-for-Eliciting-Signals-The-“Shadowing”-Method" class="headerlink" title="A Proper Scoring Rule for Eliciting Signals: The “Shadowing” Method"></a>A Proper Scoring Rule for Eliciting Signals: The “Shadowing” Method</h3><h2 id="Other-Properties-and-Discussion"><a href="#Other-Properties-and-Discussion" class="headerlink" title="Other Properties and Discussion"></a>Other Properties and Discussion</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>trustworthiness</tag>
        <tag>BTS</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Peer Prediction-Based Trustworthiness Evaluation and Trustworthy Service Rating in Social Networks</title>
    <url>/2022/11/10/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Peer%20Prediction-Based%20Trustworthiness%20Evaluation%20and%20Trustworthy%20Service%20Rating%20in%20Social%20Networks/</url>
    <content><![CDATA[<h1 id="Peer-Prediction-Based-Trustworthiness-Evaluation-and-Trustworthy-Service-Rating-in-Social-Networks"><a href="#Peer-Prediction-Based-Trustworthiness-Evaluation-and-Trustworthy-Service-Rating-in-Social-Networks" class="headerlink" title="Peer Prediction-Based Trustworthiness Evaluation and Trustworthy Service Rating in Social Networks"></a>Peer Prediction-Based Trustworthiness Evaluation and Trustworthy Service Rating in Social Networks</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>随着基于社交网络的在线应用的发展，出现了许多不同的方法来评估这些应用所提供的服务。终端用户就消费者的体验或意见所做的报告通常被用来评价不同的在线服务的质量。因此，确保用户报告的真实性，以及检测恶意用户的不诚实报告，都成为实现此类服务评级准确性的重要问题。在本文中，我们提出并评估了一个基于私人先验的同伴预测的可信服务评级系统，该系统要求用户报告他们对其同伴是否会报告高质量的服务意见的先验和后验信念。这些报告被送到一个数据处理中心，该中心通过应用严格恰当的评分规则来评估用户的可信度，并删除从可信度等级低的用户那里收到的报告。这种同行预测方法与激励用户诚实报告的激励措施相兼容。此外，还提出了一个不可靠指数，以识别恶意用户，以及在对质量进行判断时有高错误率的故障或不可靠的用户。因此，具有高不可靠值的报告也将被排除在服务评级系统之外。通过结合可信度和不可靠度，恶意用户面临的困境是，当他们的报告是虚假的，他们不能同时获得高可信度和低不可靠度的评级。仿真结果表明，所提出的基于同伴预测的可信服务评级能够有效地识别恶意行为和不可靠行为，并激励用户如实报告，而且所提出的系统能够达到比较高的服务评级准确率。</p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>研究背景：</p>
<ol>
<li>互联网服务发展很好</li>
<li>对互联网服务进行质量评级是一种常用的帮助用户进行选择的方法</li>
<li>现阶段质量评级的公平性和实用性受恶意用户的影响很大，有必要进行信任评估并激励用户输出真实反馈</li>
</ol>
<p>本文：基于对等预测的社会网络可信服务评级系统<br>假设：服务质量是一个独立于用户主观判断的客观评价</p>
<h3 id="相关研究"><a href="#相关研究" class="headerlink" title="相关研究"></a>相关研究</h3><p>略</p>
<h3 id="贡献与组织"><a href="#贡献与组织" class="headerlink" title="贡献与组织"></a>贡献与组织</h3><p>贡献：</p>
<ol>
<li>我们在社交网络的服务评级系统中引入了私有先验对等预测。通过某些严格恰当的打分规则获得的用户信任度被制定出来，以激励用户如实地报告。我们分析了基本对等预测机制在判断和报告的误报和漏报概率方面的激励兼容性。</li>
<li>我们提出了一个不可靠指数来消除服务评级系统中不可靠的报告。通过应用不可靠指数，恶意用户面临着一个困境，即他们在提供虚假报告时不能同时获得高可信度和低不可靠度。然而，诚实的用户的最佳选择仍然是如实报告，即使是功能差的，判断错误率高的。</li>
<li>基于提出的用户可信度和不可靠指数，我们设计了一个服务评级框架。在这个框架中，信任度被用来评估主体用户的报告是否不诚实，用户是否是恶意的。另一方面，不可靠指数被引入以确定报告是否可靠，但不考虑用户的类型，即诚实或恶意。通过从最终的评级程序中去除不可靠度高的反馈报告和从可信度低的用户那里收到的报告，可以实现准确和可信的服务评级。</li>
</ol>
<h2 id="基于用户报告融合的服务评级的数学模型"><a href="#基于用户报告融合的服务评级的数学模型" class="headerlink" title="基于用户报告融合的服务评级的数学模型"></a>基于用户报告融合的服务评级的数学模型</h2><p>重复了intro中的内容，表示本文设计了这样那样的机制</p>
<h3 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h3><p>场景：$N$个用户分布在社交网络中，共用一个服务平台。服务质量$Q$是一个二元评价，低质量和高质量分别用$\lbrace l,h\rbrace$表示，且服务质量是一个客观事实，即所有诚实的用户会给出相同的评价，而不受他们个人主观标准的影响。如图1所示，每个用户$i$收到服务$m$，然后决定他们对$m$的质量评价记作$S_i=s_i\in\lbrace l,h \rbrace$。用户同样会把服务评级上报到云，这些数据会有数据处理中心（DPC）处理。例如，意见报告$x_i\in \lbrace 0,1 \rbrace$是通过应用报告策略$r_i:S_i\rightarrow \lbrace 0,1 \rbrace$生成的。如果用户是诚实的，则当$S_i=h$时，用户$i$会向云报告$x_i=1$，当$S_i=l$时，用户会报告$x_i=0$。我们假设$x_i$是云发布到社会服务评估平台半公开信息，并且可以被与用户$i$有着好友关系的DPC和其他用户通过社交网络观察到。此外，$S_i$是只有用户$i$知道的私有或本地信息，其他用户甚至云都无法得到它。</p>
<p><img src="https://github.com/likun1208/image/blob/master/PeerPrediction-1.png?raw=true" alt="图1"></p>
<h3 id="基于用户报告融合的服务评级"><a href="#基于用户报告融合的服务评级" class="headerlink" title="基于用户报告融合的服务评级"></a>基于用户报告融合的服务评级</h3><p>判断的错误：实际是高质量的服务被错误的判定为低质量</p>
<p>用户$i$判断错误的概率：$P_{fa,i}=P(S_i=l|Q=h)$，简化记作$P_{fa}$.</p>
<p>判断的漏检：实际是低质量的服务被认为是高质量</p>
<p>判断漏检的概率：$P_{md,i}=P(S_i=h|Q=l)$，简化记作$P_{md}$</p>
<p>如前所述，质量是一个客观事实，因此诚实和恶意用户对它的判断都是相似的。因此我们假设判断错误和漏检的概率都小于0.5（就是说判断与实际不符的概率比随便猜一个要低）。</p>
<p>报告的错误：实际是高质量的服务被错误的报告为低质量（也许是判断错了，也许是故意的）</p>
<p>报告错误的概率：$P_{f,i}=P(x_i=0|Q=h)$，简化记作$P_f$</p>
<p>报告的漏检：实际是低质量的服务被错误地报告为高质量（同样，也许是判断错了，也许是故意的）</p>
<p>报告漏检的概率：$P_{m,i}=P(x_i=1|Q=l)$，简化记作$P_m$</p>
<p>用户类型$\theta_i \in \lbrace 0,1 \rbrace$，0表示诚实，1表示恶意，恶意用户的判断是高但故意报告低的概率为$P_{f,i}^c\in[0,1]$，判断是低但故意报告高的概率为$P_{m,i}^c\in [0,1]$</p>
<p>假设：无论判断准确率如何，诚实用户永远如实报告</p>
<p>对于任意用户$i$，可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
P_{f, i} &=\left\{\begin{array}{ll}
\left(1-P_{f a, i}\right) P_{f, i}^{c}+P_{f a, i}\left(1-P_{f, i}^{c}\right), & \theta_{i}=1 ; \\
P_{f a, i}, & \theta_{i}=0 ;
\end{array}\right.\\
P_{m, i} &=\left\{\begin{array}{ll}
\left(1-P_{m d, i}\right) P_{m, i}^{c}+P_{m d, i}\left(1-P_{m, i}^{c}\right), & \theta_{i}=1 ; \\
P_{m d, i}, & \theta_{i}=0 .
\end{array}\right.
\end{aligned}</script><p>这里简单描述一下就是说，诚实用户的报告与实际不符的概率和他判断出错的概率一致，而恶意用户的报告与实际不符的概率则分为两部分：判断没出错但上报的时候故意骗人+判断出错了但上报的时候没骗人。</p>
<p>根据云收到的用户报告，DPC可以获得每个用户的可信度$T_i$，并通过应用以下规则做出服务评级的决定：</p>
<script type="math/tex; mode=display">
R=\sum_{i \in T} x_{i}\left\{\begin{array}{ll}
<n, & \text { the DPC rates the service } Q=l \\
\geq n, & \text { the DPC rates the service } Q=h
\end{array}\right.</script><p>其中$n$是服务评级阈值。说人话就是大家总分达标就把服务判定为高质量，否则是低质量。公式中的$T$表示高可信的诚实用户集合。</p>
<h2 id="对等预测"><a href="#对等预测" class="headerlink" title="对等预测"></a>对等预测</h2><p>这一部分具体介绍私有先验对等预测机制，以及可信度的计算。</p>
<h3 id="私有先验对等预测机制"><a href="#私有先验对等预测机制" class="headerlink" title="私有先验对等预测机制"></a>私有先验对等预测机制</h3><p>私有先验对等预测是一种激励相容的机制，最初是为了激励代理人报告他们关于电子商务的私人先验和后验信号信念。在基础的私有先验对等预测机制中，每个代理$i$都和他的同行代理$j=i+1$成为一组，并被要求分别报告自己在观察信号前后的针对状态的先验和后验信号信念。根据两份报告，代理$i$的分数可以根据严格正确计分规则来计算。</p>
<ol>
<li><p>发给云的先验信念报告：在本研究所建立的系统中，任意两个收到相同服务的用户可以被看做是一对对等用户，由此建立了一种用户之间的关系和拓扑结构。为了对服务$m$的质量进行评级，我们认为每个用户$i$都有从其他收到相同服务$m$并将继续使用该服务的用户中随机选择的对等用户$j$。在体验服务之前，用户$i$需要向云上报他对于同事$j$会上报高质量信号即$x_j=1$的先验信念$y_{ij}\in[0,1]$，这个上报也可以称之为信息报告。则$y_{ij}$的计算方式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
y_{i j}=& P_{i}\left(x_{j}=1\right) \\
=& P_{i}\left(x_{j}=1 \mid Q=h\right) P_{i}(Q=h) \\
&+P_{i}\left(x_{j}=1 \mid Q=l\right) P_{i}(Q=l) \\
\triangleq & P\left(x_{j}=1 \mid S_{i}=h\right) P\left(S_{i}=h\right) \\
&+P\left(x_{j}=1 \mid S_{i}=l\right) P\left(S_{i}=l\right)
\end{aligned}</script><p>其中，$P_{i}\left(x_{j}=1 \mid Q=h\right)$和$P_{i}\left(x_{j}=1 \mid Q=l\right)$可以从用户$j$在网络中之前发布过的报告$x_j$中获取。前者表示当用户$i$判断服务质量为高质量（即$S_i=h$）时用户$j$提交的报告也说服务是高质量。用户$i$的判断是私有信息，只有他自己知道，而先验信念$P_i(Q=h)$是用户$i$对服务质量的主观先验，与$P(S_i=h)$相同。类似地，$P_i(Q=l)$也等于$P(S_i=l)$。因此，我们可以得到上面公式中用$\triangleq$相连的等式。</p>
</li>
<li><p>发给云的后验信念报告：体验过服务后，用户$i$决定他自己对服务质量的判断$S_i=s_i$，然后将他关于对等用户$j$会上报该服务的质量评估为高质量这件事的后验信念（或称之为预测报告）发送给云，记作$y_{ij}^{‘}(s_i)\in[0,1]$。则$y_{ij}^{‘}$可以表示如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
y_{i j}^{\prime}\left(s_{i}\right)=& P_{i}\left(x_{j}=1 \mid S_{i}=s_{i}\right) \\
=& P\left(x_{j}=1 \mid Q=h\right) P\left(Q=h \mid S_{i}=s_{i}\right) \\
&+P\left(x_{j}=1 \mid Q=l\right) P\left(Q=l \mid S_{i}=s_{i}\right) .
\end{aligned}</script><p>与前文分析类似，$y_{ij}^{‘}$可以被分为以下两种情况：</p>
<script type="math/tex; mode=display">
\begin{aligned}
y_{i j}^{\prime}(l) &=\frac{\varphi_{1}\left(1-P_{f, j}\right)+\varphi_{2} P_{m, j}}{\varphi_{1}+\varphi_{2}} \\
y_{i j}^{\prime}(h) &=\frac{\varphi_{3}\left(1-P_{f, j}\right)+\varphi_{4} P_{m, j}}{\varphi_{3}+\varphi_{4}}
\end{aligned}</script><p>其中，</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\varphi_{1}=P_{f a, i} P(Q=h), \quad \varphi_{2}=\left(1-P_{m d, i}\right) P(Q=l), \\
\varphi_{3}=\left(1-P_{f a, i}\right) P(Q=h), \quad \varphi_{4}=P_{m d, i} P(Q=l)
\end{array}</script><p>$\varphi_1$是服务为高质量且用户$i$出现误报的概率，$\varphi_2$是服务为低质量且用户$i$没有漏检的概率，加起来就是用户$i$给出的判断是低质量的概率。</p>
</li>
</ol>
<p>类似地，$\varphi_3$是服务为高质量且用户$i$没有误报的概率，$\varphi_4$是服务为低质量且用户$i$漏检的概率，加起来就是用户$i$给出的判断是高质量的概率。</p>
<script type="math/tex; mode=display">
\begin{align}
y_{ij}^{'}(l)&= P\left(x_{j}=1 \mid Q=h\right) P\left(Q=h \mid S_{i}=l\right)+P\left(x_{j}=1 \mid Q=l\right) P\left(Q=l \mid S_{i}=l\right)\\
&=(1-P_{f,j})P(Q=h|S_i=l)+P_{m,j}P(Q=l|S_i=l)\\
&=P(S_i=l|Q=h)P(Q=h)(1-P_{f,j})/P(S_i=l)+P(S_i=l|Q=l)P(Q=l)P_{m,j}/P(S_i=l)\\
&=P_{fa,i}P(Q=h)(1-P_{f,j})/P(S_i=l)+(1-P_{md,i})P(Q=l)P_{m,j}/P(S_i=l)\\
&=\varphi_1(1-P_{f,j})/(\varphi_1+\varphi_2)+\varphi_2P_{m,j}/(\varphi_1+\varphi_2)\\
&=\frac{\varphi_1(1-P_{f,j})+\varphi_2P_{m,j}}{\varphi_1+\varphi_2}
\end{align}</script><p>$y_{ij}^{‘}(h)$也是类似的计算方法，就不写了。</p>
<p>如前文定义，$x_{ij}$是用户$i$在体验服务之前对$x_j=1$的先验判断。在用户$i$体验服务并发送报告$s_i=h$后，他理所当然有很大概率会判断$x_j=1$，即$y_{ij}^{‘}(h)&gt;y_{ij}$，这意味着用户$i$对$x_j=1$的先验信念会被提高。与之相反，如果用户$i$收到了低质量服务，则$y_{ij}&gt;y_{ij}^{‘}(l)$。但是，当存在会提供不真实的服务评价的恶意用户时，上述不等式的关系将不再成立。引理1证明了会使得$y_{i j}^{\prime}(h)&gt;y_{i j}&gt;y_{i j}^{\prime}(l)$出现的充分条件。</p>
<p>引理1：在私有先验预测机制中，对于每个用户$i$，他对用户$j$的先验和后验信念报告分别是$y_{ij}$和$y^{‘}_{ij}$，当所有用户都满足$P_{fa}+P_{md}<1$且$P_f+P_m<1$时，$y_{i j}^{\prime}(h)>y_{i j}&gt;y_{i j}^{\prime}(l)$成立。</p>
<p>证明：在附录，先不看了</p>
<p>备注：假设$P_{fa}<0.5$且$P_{md}<0.5$，对于所有用户而言，$P_{fa}+P_{md}<1$都成立。根据公式1和2，对于诚实用户即$\theta_i=0$，我们可得$P_{f,i}+P_{m,i}<1$.另一方面，对于不诚实用户（$\theta_i=1$），$P_{f,i}+P_{m,i}<1$能否成立取决于他的两个谎报概率$P_{f,i}^c$和$P_{m,i}^c$。有着相对高的$P_f^c>0.5$且/或$P_m^c$的彻底的恶意用户会同样有高$P_f&gt;0.5$且/或$P_m&gt;0.5$。有上述两种或两种之一作弊行为的用户可以根据他们以前的报告很容易被识别出来，因为其中的错误报告概率很高。如果评分系统移除有着较高的$P_f$和/或$P_m$的用户报告，则这些恶意报告就不会在系统更新服务评价时造成影响。因此，要实现连续的欺骗，恶意用户需要控制他们的$P_f^c$和$P_m^c$，从而伪装成偶尔可信的用户，以确保$P_f<0.5$且$P_m<0.5$。因此，引理1中的条件$P_f+P_m<1$是合理的，且这种情况下，不等式$y_{i j}^{\prime}(h)>y_{i j}&gt;y_{i j}^{\prime}(l)$始终成立。</p>
<ol>
<li><p>推断意见报告：用户$i$发送他对同事$j$会报告$x_j=1$这件事的先验和后验信念概率，而不是报告自己对服务质量的私有评价$S_i$或$x_i$。我们可以注意到，$x_i$和$x_j$都不由相关用户直接提供。在基础私有先验对等预测中，用户$i$仅向云发送报告$y_{ij}$和$y_{ij}^{‘}(s_i)$，基于此，DPC推断意见报告$x_i$并将它向社交服务评估平台公布。推断意见报告$x_i$的计算方式如下：</p>
<script type="math/tex; mode=display">
x_{i}=x\left(y_{i j}, y_{i j}^{\prime}\right)=\left\{\begin{array}{ll}
1, & y_{i j}^{\prime}>y_{i j} \\
0, & y_{i j}^{\prime}<y_{i j}
\end{array}\right.</script><p>备注：根据引理1，当用户$i$和用户$j$都满足$P_{fa}+P_{md}<1$且$P_f+P_m<1$时，$y_{ij}^{'}(h)>y_{ij}>y_{ij}^{'}(l)$。换言之，当用户$i$在体验服务后对它的质量判断为高质量（$S_i=h$），不等式$y_{ij}^{'}(h)$始终成立。由此，根据公式8，DPC推断意见报告为$x_i=1$因为$y_{ij}^{'}>y_{ij}$。因此这个推断报告$x_i=1$与用户$i$的真实判断$S_i=h$是一致的。对称地，当$S_i=l$时，公式8仍然可以推断真实意见报告$x_i=0$。因此，在$P_{fa}+P_{md}&lt;1$和$P_f+P_m&lt;1$的条件下，由公式8所决定的规则可以如实反映诚实用户的判断。</p>
</li>
<li><p>用户可信度：基于报告$y_{ij}$和$y_{ij}^{‘}$，DPC通过一个确定的计分规则来计算用户$i$的可信度，信任度低的用户被归类为恶意用户，他们的报告将在服务评级系统中不被考虑。接下来，我们首先介绍严格正确的计分规则，它可以激励用户提供真实的报告$y_{ij}$和$y_{ij}^{‘}$。</p>
</li>
</ol>
<p>定义1（严格正确的计分规则）：如果一个二进制评分规则导致代理人可以通过如实提供自己的报告$y\in[0,1]$来最大化自己的得分，则该规则就是正确的，且如果一个代理人当且仅当如实报告时能最大化得分，则该规则是严格正确的。</p>
<p>分别如(9)和(10)所示的二元对数和二次函数评分规则是严格正确的，这在[30]中已经得到证明：</p>
<p>对数：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
R_{l}(y, \omega=1)=\ln y \\
R_{l}(y, \omega=0)=\ln (1-y) .
\end{array}</script><p>二次函数：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
R_{q}(y, \omega=1)=2 y-y^{2} \\
R_{q}(y, \omega=0)=1-y^{2}
\end{array}</script><p>在上面两组公式中，$\omega\in\lbrace 0,1\rbrace$表示一个二值报告。</p>
<p>我们定义用户$i$的可信度为关于$y_{ij},y_{ij}^{‘},x_j$的函数：</p>
<script type="math/tex; mode=display">
T_{i}=\alpha R\left(y_{i j}, x_{j}\right)+(1-\alpha) R\left(y_{i j}^{\prime}, x_{j}\right)+\beta</script><p> 其中，$R(y,\omega)$是严格正确评分规则，$\alpha\in[0,1]$是先验和后验重要性的权重参数。此外，可信度在服务和评分过程中会进行累积。负面的信任度可以是金钱上的惩罚，也可以是对相应用户提供报告的限制，而负面的收益将作为正面的收益转移给用户，作为对他们荣誉和准确报告的奖励。因此，为了保证预算均衡，$\beta$如下计算：</p>
<script type="math/tex; mode=display">
 \beta=-\frac{1}{N} \sum_{k=1}^{N}\left[\alpha R\left(y_{k j}, x_{j}\right)+(1-\alpha) R\left(y_{k j}^{\prime}, x_{j}\right)\right]</script><p>在公式11（$T_i$的公式）中，$y_{ij}$和$y_{ij}^{‘}$分别是用户$i$判定$S_i=s_i$前后的报告，$x_j$是DPC根据用户$j$的报告推断出的用户$j$的隐性意见报告。此外，根据上述分析，我们可以注意到，用户$i$的可信度是由用户$j$的推断意见报告$x_j$、用户$i$的先验信念报告$y_{ij}$和后验信念报告$y_{ij}^{‘}$决定的。换句话说，一个用户的可信度与系统中其他用户的报告或推断的报告无关。因此，恶意用户的合作作弊对用户可信度的评价影响不大，这是由（11）定义的。</p>
<h3 id="激励相容"><a href="#激励相容" class="headerlink" title="激励相容"></a>激励相容</h3><p>如[33]所说，用户$i$提出的先验信念报告$y_{ij}$和后验信念报告$y_{ij}^{‘}(s_i)$在时间上是分离的，因为它们分别发生在做出判断$S_i=s_i$前后。因此，$y_{ij}$和$y_{ij}^{‘}(s_i)$是独立的，可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E\left[T_{i}\right]=& E\left[\alpha R\left(y_{i j}, x_{j}\right)\right]+E\left[(1-\alpha) R\left(y_{i j}^{\prime}, x_{j}\right)\right]+E[\beta] \\
=& \alpha\left(1-\frac{1}{N}\right) E\left[R\left(y_{i j}, x_{j}\right)\right] \\
&+(1-\alpha)\left(1-\frac{1}{N}\right) E\left[R\left(y_{i j}^{\prime}, x_{j}\right) \mid S_{i}=s_{i}\right] \\
&-\frac{1}{N} \sum_{k=1, k \neq i}^{N}\left[\alpha R\left(y_{k j}, x_{j}\right)+(1-\alpha) R\left(y_{k j}^{\prime}, x_{j}\right)\right],
\end{aligned}</script><p>其中，$\alpha\left(1-\frac{1}{N}\right) R\left(y_{i j}, x_{j}\right)$和$(1-\alpha)\left(1-\frac{1}{N}\right) R\left(y_{i j}^{\prime}, x_{j}\right)$仍然是严格正确的[32]。</p>
<ol>
<li><p>二值对数评分规则<br>令$p_1=P(x_j=1)$且$p_2=P(x_j=1|S_i=s_i)$，由此可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E\left[T_{i}\right]=& \alpha\left(1-\frac{1}{N}\right)\left[p_{1} \ln y_{i j}+\left(1-p_{1}\right) \ln \left(1-y_{i j}\right)\right] \\
=& \alpha\left(1-\frac{1}{N}\right)\left[p_{1} \ln y_{i j}^{\prime}+\left(1-p_{1}\right) \ln \left(1-y_{i j}^{\prime}\right)\right] \\
&-\frac{1}{N} \sum_{k=1, k \neq i}^{N}\left[\alpha R\left(y_{k j}, x_{j}\right)+(1-\alpha) R\left(y_{k j}^{\prime}, x_{j}\right)\right] .
\end{aligned}</script><p>分别求偏导：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\frac{\partial E\left[T_{i}\right]}{\partial y_{i j}}=\alpha\left(1-\frac{1}{N}\right) \frac{p_{1}-y_{i j}}{y_{i j}\left(1-y_{i j}\right)}=0 \\
\frac{\partial E\left[T_{i}\right]}{\partial y_{i j}^{\prime}}=\alpha\left(1-\frac{1}{N}\right) \frac{p_{1}-y_{i j}^{\prime}}{y_{i j}^{\prime}\left(1-y_{i j}^{\prime}\right)}=0 .
\end{array}</script><p>因此可得最优值：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\hat{y}_{i j}=p_{1}=P\left(x_{j}=1\right) \\
\hat{y}_{i j}^{\prime}=p_{2}=P\left(x_{j}=1 \mid S_{i}=s_{i}\right)
\end{array}</script><p>然后求二阶偏导，令$y_{ij}=\hat{y}_{ij}$且$y_{ij}^{‘}=\hat{y}_{ij}^{‘}$，可得：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\left.\frac{\partial E^{2}\left[T_{i}\right]}{\partial y_{i j}^{2}}\right|_{y_{i j}=\hat{y}_{i j}}=\alpha\left(1-\frac{1}{N}\right) \frac{y_{i j}\left(y_{i j}-1\right)}{y_{i j}^{2}\left(1-y_{i j}\right)^{2}}<0, \\
\left.\frac{\partial E^{2}\left[T_{i}\right]}{\partial y_{i j}^{\prime 2}}\right|_{y_{i j}^{\prime}=\hat{y}_{i j}^{\prime}}=\alpha\left(1-\frac{1}{N}\right) \frac{y_{i j}^{\prime}\left(y_{i j}^{\prime}-1\right)}{y_{i j}^{\prime 2}\left(1-y_{i j}^{\prime}\right)^{2}}<0 .
\end{array}</script><p>因此，当$y_{ij}=p_1$且$y_{ij}^{‘}=p_2$时，$E[T_i]$可达到最大值，这意味着当且仅当用户$i$如实报告$y_{ij}$和$y_{ij}^{‘}$时他可以获取最大的可信度。</p>
</li>
<li><p>二值二次函数评分规则：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E\left[T_{i}\right] \\
=& \alpha\left(1-\frac{1}{N}\right)\left[p_{1}\left(2 y_{i j}-y_{i j}^{2}\right)+\left(1-p_{1}\right)\left(1-y_{i j}^{2}\right)\right] \\
&+(1-\alpha)\left(1-\frac{1}{N}\right)\left[p_{2}\left(2 y_{i j}^{\prime}-y_{i j}^{\prime}{ }^{2}\right)+\left(1-p_{2}\right)\left(1-y_{i j}^{\prime}{ }^{2}\right)\right] \\
&-\frac{1}{N} \sum_{k=1, k \neq i}^{N}\left[\alpha R\left(y_{k j}, x_{j}\right)+(1-\alpha) R\left(y_{k j}^{\prime}, x_{j}\right)\right] .
\end{aligned}</script><p>仍然是求偏导，可以得到和对数函数一样的最优值。然后求二阶偏导，可得下述不等式恒成立：</p>
<script type="math/tex; mode=display">
\frac{\partial E^{2}\left[T_{i}\right]}{\partial y_{i j}^{2}}=\frac{\partial E^{2}\left[T_{i}\right]}{\partial y_{i j}^{\prime 2}}=-2 \alpha\left(1-\frac{1}{N}\right)<0</script></li>
</ol>
<p>备注：无论是二值对数还是二值二次函数评分规则，$\partial^{2} E\left[T_{i}\right] / \partial y_{i j}^{2}&lt;0$和$\partial^{2} E\left[T_{i}\right] / \partial {y^{‘}_{i j}}^{2}<0$都成立，$E[T_i]$会在两个一阶导得到的最优值满足时取最大值。换言之，用户$i$当且仅当如实报告$y_{ij}$和$y_{ij}^{'}$时他可以获取最大的可信度。假设存在共谋，这意味着恶意用户可以相互联系并控制恶意行为。根据定义1，当对等用户$j$是恶意用户时，用户$i$谎报时得到的分数会比如实报告的分数低。例如，用户$i$体验了一个高质量任务，这意味着他的诚实报告满足$y_{ij}^{'}>y_{ij}$。但是，由于用户$j$是恶意的，他会谎报意见，即$x_j=0$，根据二值对数和二次函数评分规则，与如实报告相比，给出一个更低的$y_{ij}^{‘}&lt;y_{ij}$会使得用户$i$得到更高的评分。为了确保即使在社会网络中发生合作欺骗行为时，诚实的用户仍占主导地位，我们假设恶意用户的数量少于总数的一半。基于这个假设，拥有准确信息报告和预测报告的用户将长期获得更高的信任度；同时，恶意用户每次公布不诚实的报告导致作弊的意见报告时，都会受到信任度下降的惩罚。</p>
<p>感觉这篇文章和贝叶斯实话血清那个相似的地方就在于这里的评分函数形式。</p>
<h2 id="基于用户可信度和不可靠度的服务评级"><a href="#基于用户可信度和不可靠度的服务评级" class="headerlink" title="基于用户可信度和不可靠度的服务评级"></a>基于用户可信度和不可靠度的服务评级</h2><h3 id="用户报告的不可靠度"><a href="#用户报告的不可靠度" class="headerlink" title="用户报告的不可靠度"></a>用户报告的不可靠度</h3><p>在私有先验对等预测中，所有用户在体验服务之前都被要求报告他们关于对等用户会报告高质量的先验信念$y_{ij}=P_i(x_j=1)$。DPC可以从过去的报告$x_j$中推断出该报告，并由云发布，这意味着过去的报告$x_j$可以被$i$在社交网络中的其他好友、云和DPC获取。因此，对于恶意用户来说伪造信息报告$y_{ij}$是困难的。为了实现欺骗，恶意用户$i$需要控制他的信息并根据前文的公式预测报告，即当服务质量为低（$Q=l$）时有概率$p_{m,i}^{c}$会出现$y^{‘}_{ij}=y_{ij}+\varepsilon(\varepsilon&gt;0)$，当服务质量为高（$Q=h$）时有概率$P_{f,i}^{c}$出现$y^{‘}_{ij}=y_{ij}-\varepsilon$。同时，恶意用户需要让$\varepsilon$尽可能小，从而避免当他们的对等用户是诚实用户时自己要因为大量损失评分和可信度而受到惩罚。此外，我们可以注意到误报和漏检并不一定来自于诚实用户的错误判断，同样也来自不诚实用户的欺骗行为。上述两种情况都被认为是不可靠的行为，需要在最终的服务评级中加以识别和删除。因此，有必要设置阈值来限制$y_{ij}$和$y_{ij}^{‘}$之间的最小值。</p>
<p>接下来，我们分析了误报判断和漏检判断对分数的影响。分别对前文公式中的$P_{fa,i}$和$P_{md,i}$求导，可得：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\frac{\partial y_{i j}^{\prime}(l)}{\partial P_{f a, i}}=\Phi_{1}\left(1-P_{m d, i}\right)\left(1-P_{f, j}-P_{m, j}\right) \\
\frac{\partial y_{i j}^{\prime}(l)}{\partial P_{m d, i}}=\Phi_{1} P_{f a, i}\left(1-P_{f, j}-P_{m, j}\right) \\
\frac{\partial y_{i j}^{\prime}(h)}{\partial P_{f a, i}}=-\Phi_{2} P_{m d, i}\left(1-P_{f, j}-P_{m, j}\right) \\
\frac{\partial y_{i j}^{\prime}(h)}{\partial P_{m d, i}}=-\Phi_{2}\left(1-P_{f a, i}\right)\left(1-P_{f, j}-P_{m, j}\right)
\end{array}</script><p>其中，$\Phi_1=P(Q=h)P(Q=l)/(\phi_1+\phi_2)^2,\Phi_2=P(Q=h)P(Q=l)/(\phi_3+\phi_4)^2$。基于前文假设$P_{fa,i}&lt;0.5,P_{md,i}&lt;0.5,P_{f,j}+P_{m,j}&lt;1$，可得：</p>
<script type="math/tex; mode=display">
\frac{\partial y_{i j}^{\prime}(l)}{\partial P_{f a, i}}>\frac{\partial y_{i j}^{\prime}(l)}{\partial P_{m d, i}}>0, \quad \frac{\partial y_{i j}^{\prime}(h)}{\partial P_{m d, i}}<\frac{\partial y_{i j}^{\prime}(h)}{\partial P_{f a, i}}<0</script><p>因此，在$Q=h$和$Q=l$这两种情况下，当用户$j$如实报告时，用户$i$的分数会随着$P_{fa,i}$和$P_{md,i}$的增加而减少。换言之，对于固定的$P_f,P_j,P(Q=h)$，判断准确率高的诚实用户将获得更高的分数和可信度，相比之下，那些判断错误率高的诚实用户和恶意用户则反过来保守地报告他们的预测，给出错误的报告，将分数的损失降到最低。在服务评级系统中，既不应该考虑恶意用户的隐性意见报告，也不应该考虑判断准确性低的诚实用户。为了识别出这两种不可靠的行为，我们通过用户$i$的先验信念报告$y_{ij}$和后验信念报告$y_{ij}^{‘}$定义了不可靠指数来表征用户$i$的不可靠度：</p>
<script type="math/tex; mode=display">
\rho_{i}=\left\{\begin{array}{ll}
\frac{\left|y_{i j}^{\prime}-P_{m, j}\right| P(Q=l)}{\left|y_{i j}^{\prime}-\left(1-P_{f, j}\right)\right| P(Q=h)} & y_{i j}^{\prime}<y_{i j} \\
\frac{\left|y_{i j}^{\prime}-\left(1-P_{f, j}\right)\right| P(Q=h)}{\left|y_{i j}^{\prime}-P_{m, j}\right| P(Q=l)}, & y_{i j}^{\prime}>y_{i j}
\end{array}\right.</script><p>备注：在上面的公式中，第一种情况$y_{ij}^{‘}<y_{ij}$表示，服务为低质量时$y_{ij}^{'}$越接近$P\lbrace x_j=1|Q=l \rbrace$，或者服务为高质量时$y_{ij}^{'}$越远离$P\lbrace x_j=1|Q=h \rbrace$，则$y_{ij}^{'}$越可靠。同时，对于$y_{ij}^{'}>y_{ij}$，当报告$y_{ij}^{‘}$接近$P\lbrace x_j=1|Q=h \rbrace$且远离$P\lbrace x_j=1|Q=l \rbrace$，该报告可以被认为是可靠的。此外，根据该公式，$y_{ij}^{‘}(l)$会随$P_{fa,i}$和$P_{md,i}$的增长而增加，且对$P_{fa,i}$比$P_{md,i}$更敏感。$y_{ij}^{‘}(h)$随$P_{fa,i}$和$P_{md,i}$的增长而减少，且对$P_{md,i}$比$P_{fa,i}$更敏感。假设$P_{fa,i},P_{md,i}\in [0,1]$，我们可得$P_{m, j}&lt;y_{i j}^{\prime}(l), y_{i j}^{\prime}(h)&lt;1-P_{f, j}$，因此上面公式中关于不可靠度的定义可以改写为：</p>
<script type="math/tex; mode=display">
\rho_{i}=\left\{\begin{array}{cl}
\frac{\left[y_{i j}^{\prime}-P_{m, j}\right] P(Q=l)}{\left[\left(1-P_{f, j}\right)-y_{i j}^{\prime}\right] P(Q=h)} & y_{i j}^{\prime}<y_{i j} \\
\frac{\left[\left(1-P_{f, j}\right)-y_{i j}^{\prime}\right] P(Q=h)}{\left[y_{i j}^{\prime}-P_{m, j}\right] P(Q=l)}, & y_{i j}^{\prime}>y_{i j}
\end{array}\right.</script><p>为了计算用户报告的不可靠度，DPC需要基于历史数据观察每个用户的报告错误率$P_f,P_m$。此外，我们假设服务质量（记作$P(Q=l),P(Q=h)$）也可以根据较长的时间尺度和相对稳定的服务历史评级结果来获得。考虑到目前大多数基于服务的应用系统有能力提供这样的信息，这样的假设是可行和合理的。通过优化上述公式，不可靠度高的用户被认为是不确定的，他们可能是错误判断率高的诚实用户或恶意用户。来自这些用户的报告对于DPC评价服务质量是不可靠的。因此，DPC需要设置一个不可靠度的阈值，不可靠度超过该阈值的用户的报告将从服务评级程序中删除。阈值可以通过具有相对较高判断精度的诚实用户的典型错误率来设计。</p>
<p>接下来，我们描述前文公式中定义的用户不可靠度的有效性。以$Q=h$为例，恶意用户$i$为了实现欺骗会给出预测报告$y_{ij}^{‘}=y_{ij}-\varepsilon&lt;y_{ij}$。为了得到比阈值更低的不可靠度并使得自身的欺骗行为能对服务评级造成影响，用户$i$需要伪造报告$y_{ij}^{‘}$使得它接近$P_{m,j}$并远离$1-P_{f,j}$。当$P_{f,i}&lt;0.5$且$P_{m,i}&lt;0.5$时，$y_{ij}^{‘}$越小，不可靠度越低。另一方面，当$Q=h$时大多数诚实用户倾向于报告$x_j=1$。根据很前面的公式，当用户$i$的对等用户$j$给出的报告准确而诚实，则用户$i$的评分随$y_{ij}^{‘}$的减小而减小。对称地，$Q=l$时也存在相同的困境。因此，恶意用户如果欺骗性地报告，很难同时获得高可信度和低不可靠度。然而，对于那些判断错误率相对较高的“功能不好”的诚实用户来说，最好的选择仍然是如实报告$y_{ij}$和$y_{ij}^{‘}$。他们没有必要修改他们的$y_{ij}^{‘}$，因为他们的利益是由信息和预测报告决定的分数和可信度，这个利益与他们的报告是否被DPC接受没有关系。</p>
<h3 id="基于同行预测的服务评级"><a href="#基于同行预测的服务评级" class="headerlink" title="基于同行预测的服务评级"></a>基于同行预测的服务评级</h3><p>根据以上对用户可信度和不可靠度的分析，我们设计了基于私人优先同伴预测的服务评级方法，具体步骤如下。</p>
<ol>
<li>对于每个接受服务的用户$i$，在他/她的朋友中随机选择另一个不重叠的用户$j$作为$i$的同伴。</li>
<li>要求用户$i$提供他/她的先验信念报告$y_{ij}\in[0,1]$，即他/她的同行$j$将向云报告高质量的概率。</li>
<li>用户$i$体验服务，并作出自己对服务质量的判断$S_i=s_i$</li>
<li>问用户的后验信念报告$y_{ij}^{‘}\in[0,1]$</li>
<li>DPC计算不可靠度并移除超过阈值的用户报告</li>
<li>DPC从报告中推断用户的隐含意见报告$x_i$，移除低可信度的用户</li>
<li>DPC根据高可信度且低不可靠度的用户报告决定服务质量</li>
</ol>
<h2 id="仿真实验"><a href="#仿真实验" class="headerlink" title="仿真实验"></a>仿真实验</h2><p>实验部分略</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>基于云的服务评级架构</li>
<li>基于私有先验的对等预测</li>
<li>设计了不可靠指数</li>
<li>仿真结果表明方法有效</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>trustworthiness</tag>
        <tag>peer prediction</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Secure Balance Planning of Off-blockchain Payment Channel Networks</title>
    <url>/2022/11/08/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Secure%20Balance%20Planning%20of%20Off-blockchain%20Payment%20Channel%20Networks/</url>
    <content><![CDATA[<h1 id="Secure-Balance-Planning-of-Off-blockchain-Payment-Channel-Networks"><a href="#Secure-Balance-Planning-of-Off-blockchain-Payment-Channel-Networks" class="headerlink" title="Secure Balance Planning of Off-blockchain Payment Channel Networks"></a>Secure Balance Planning of Off-blockchain Payment Channel Networks</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>链下支付渠道可以通过实现“无需向区块链提交单笔支付即可在两个区块链节点之间进行大量小额支付”这一点来显著提高区块链的可扩展性。多个支付渠道可以形成一个支付网络，从而使得没有直接相连的两个节点也可以进行支付。构建支付网络的一个关键挑战在于决定应该将多少资金存入支付渠道作为初始余额，这严重影响了支付网络的性能，却少有研究。本文通过设计支付网络的余额规划服务<code>PnP</code>来解决这一问题。考虑到节点之间估计的支付需求，<code>PnP</code>可以决定通道余额，以较高的概率满足这些需求。它不依赖于任何可信第三方，并能以较低的开销提供强大的保护来防止恶意攻击。它包含两个创新点：加密排序和机会约束的平衡规划算法。在一个由30个节点组成的测试平台上的实验结果表明，<code>PnP</code>可以比其他设计多实现30%的支付。</p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><ol>
<li>区块链牺牲了可扩展性来实现去中心化和一致性，因为共识需要包含所有节点，例如比特币和以太坊每秒处理的交易都很少</li>
<li>近年来有研究提出了新的共识来，可以实现每秒上千交易，单仍然无法满足大规模应用的需求。例如Visa每秒47000笔交易。</li>
<li>交易渠道（payment channels）通过在两个区块链节点之间创建私有通道来解决可扩展性问题。具体来说，两个节点建立了一个特殊的渠道合约，该合约将一定数量的资金作为初始余额。随后，这两个节点可以在通道上进行交易并自行维护渠道余额。因为渠道上的交易并不提交给区块链，所以区块链的可扩展性就显著提升了。</li>
<li>节点之间的多个支付渠道可以构成支付网络，从而使得没有支付渠道直接相连的两个节点可以通过多跳的方式实现链下交易。如今已经有了实现这样功能的网络，例如比特币的Lighting Network和以太坊的Raiden Network。（注意这个闪电网络和闪电贷不是一个东西）</li>
<li>建立支付渠道的关键问题在于初始余额。如果钱给少了，则这个渠道要时不时重新构建，导致了更频繁的区块链访问操作。而钱给多了又是不必要的。如果考虑多跳交易的支付网络，这个问题就更复杂了。 现有研究大多假设支付渠道里的钱是足够的，但这并不现实。而一个考虑了这个问题的研究则引入了中心化的可信第三方，这更容易受到恶意攻击了。</li>
<li>本文研究了支付网络中的余额规划问题，即给定节点们的支付需求估计，如何决定支付渠道的初始余额。本文设计了一个余额规划服务<code>PnP</code>来实现这一点，它可以集成到现有的支付网络中。<code>PnP</code>可以利用对支付需求的了解，即使有估计误差，也能将渠道总存款降到最低。它不依赖可信第三方，因此可以抵御来自恶意节点的攻击。此外，它的通信和计算开销很低。<code>PnP</code>通过解决两个主要挑战来实现上述优势。<ol>
<li>很难精确估计节点的支付需求。直觉上的想法是根据历史需求预测未来需求从而设计算法，但是实际需求往往或多或少，一旦渠道余额用完，所有关联该渠道的交易就都会失败。当然也能改进预测方法来得到更准确的估计，但不能从根本上解决这个问题。本文的解决方法是：将这个余额规划问题表达为机会约束优化问题，进而设计算法从而从理论上保证高概率满足支付需求。</li>
<li>恶意节点攻击问题。现有工作很多都假设存在可行第三方，但这不现实。<code>PnP</code>能防御一定比例的拜占庭攻击。它随机选择一组节点作为决策委员会来产生正确的余额规划结果。它通过解决两个问题来保障安全性：谁应该被选中加入委员会，以及决策委员会如何在正确规划结果上达成共识。本文为委员会成员选举设计了加密排序机制。委员会中的每个节点独立运行本文提出的余额规划算法并通过拜占庭协议达成共识。</li>
</ol>
</li>
<li>本文在Ind上搭建虚拟支付网络做了实验，因为<code>PnP</code>是第一个余额规划研究，所以在对比的时候是和它的一些变种（不同设计选择）对比。</li>
<li>本文主要贡献如下：<ol>
<li>设计了<code>PnP</code>作为支付网络的余额规划，是第一个研究这个的。</li>
<li>为了防御攻击，设计了加密排序来选择决策委员会来运行规划算法。</li>
<li>描述了最小化支付渠道保证金又同时满足所有节点支付需求这一问题。使用机会约束来描述支付需求的不确定性，并使用近似技术解决相关问题。</li>
<li>在testbed上的30个节点测试了<code>PnP</code>，实验表明效果很好。</li>
</ol>
</li>
</ol>
<h2 id="PRELIMINARIES-AND-MOTIVATION"><a href="#PRELIMINARIES-AND-MOTIVATION" class="headerlink" title="PRELIMINARIES AND MOTIVATION"></a>PRELIMINARIES AND MOTIVATION</h2><h3 id="支付渠道"><a href="#支付渠道" class="headerlink" title="支付渠道"></a>支付渠道</h3><h3 id="支付网络"><a href="#支付网络" class="headerlink" title="支付网络"></a>支付网络</h3><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><h3 id="委员会选举"><a href="#委员会选举" class="headerlink" title="委员会选举"></a>委员会选举</h3><h3 id="非直连余额规划"><a href="#非直连余额规划" class="headerlink" title="非直连余额规划"></a>非直连余额规划</h3>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-A solution to the single-question crowd wisdom problem</title>
    <url>/2022/10/31/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-A%20solution%20to%20the%20single-question%20crowd%20wisdom%20problem/</url>
    <content><![CDATA[<h1 id="A-solution-to-the-single-question-crowd-wisdom-problem"><a href="#A-solution-to-the-single-question-crowd-wisdom-problem" class="headerlink" title="A solution to the single-question crowd wisdom problem"></a>A solution to the single-question crowd wisdom problem</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ol>
<li>群体智慧一度被认为优于个体观点，在一些领域已经逐渐用投票来取代专家决策</li>
<li>民主投票有局限性</li>
<li>本文方法：选择比人们预测的更受欢迎的答案</li>
</ol>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>假设你对美国地理知识一无所知，现在提问：</p>
<ol>
<li>费城是宾夕法尼亚州的首府吗？</li>
<li>哥伦比亚是南卡罗来纳州的首府吗？<br>你去找很多人问这两个问题，希望他们中的主流观点是正确的，这个方法在哥伦比亚的问题上是有效的，但在费城的问题上，大多数人都会回答“是”，而这是个错误答案。显然民主投票的方法是有问题的。</li>
</ol>
<p>针对该问题的标准回应是根据信任对投票进行加权平均。对于二值问题，信任度$c$表示一个受访者的投票有$c$的主观概率是正确的，有$1-c$的概率是错误的。概率可以线性或非线性平均，产生置信加权投票算法。然而该方法仅在正确答案是高置信的，而这在费城和哥伦比亚的问题中也不适用，因为这两个问题的两个选项的置信度都很相似，没法从中找出一个主流的回答。</p>
<p>本文提出一种替代算法，它要求受访者预测其他人对该问题的回答的分布，并选择那些比预测得到更多支持的回答。算法的直观描述如下：想象有两个平行宇宙，正宇宙里费城不是宾州的首府，而反宇宙里费城就是首府。针对“费城是否为宾州首府”这个问题，正宇宙里认为“是”的人比反宇宙要少。该问题可以形式化为扔有偏硬币的问题，该硬币在正宇宙有<code>60%</code>的概率扔出“是”，而在反宇宙有<code>90%</code>的概率扔出“是”。两个宇宙的主流观点都是“是”，人们知道硬币是有偏差的，但不知道哪个宇宙是正宇宙。因此，他们对赞成票的预测频率将在60%到90%之间。然而，正宇宙中的赞成票会收敛到60%，于是反对票就是那个比预测能得到更多支持的答案，同时也是正确答案。</p>
<p>我们将这个选择原则称为“出乎意料的受欢迎”（SP）算法，并在补充材料中严格定义了它。在一个问题(P)中，数据显示投赞成票的受访者相信几乎所有人都同意他们，而投反对票的人认为自己会占少数。投赞成票的平均预测百分比很高，导致实际投赞成票的百分比低于这些预测。因此，出乎意料受欢迎的回答是“否”，而这正是正确答案。相反，在哥伦比亚问题中，预测的赞成票低于实际的赞成票，出乎意料受欢迎的答案和实际确实受欢迎的答案是一致的，由此多数人的判断是正确的。</p>
<p>是否可以利用受访者的信心构建一个同样有效的算法？假设受访者知道先验的世界概率和硬币偏见。每个受访者观察他们的私人硬币投掷结果，并通过应用贝叶斯规则计算他们的信心。假设的算法将需要从报告的信任度的大样本中识别正宇宙的硬币。图2通过反例证明了不存在这样的算法(附件中的定理1提供了一个一般不可能的结果)。它展示了对于两个不同的有偏见的硬币问题，一个正确答案是肯定的，另一个正确答案是否定的，信心的相同分布是如何产生的。诚然，真实的人可能不会遵循理想化的贝叶斯模型。我们的观点是，如果基于后验概率(投票和信心)的方法对理想中的受访者无效，那么对真正的受访者也可能无效。</p>
<p>相比之下，SP算法有一个理论上的保证，即它总是根据现有证据选择最佳答案（补充资料中的定理2）。定理3将该算法扩展到多选题，并显示了投票预测如何能够识别出对正确答案给予最高概率的受访者。这些结果是基于一个共同的理论模型，该模型将有偏见的硬币的例子推广到多个多面硬币上。</p>
<p>为了测试SP算法，我们用四种类型的语义和知觉内容进行了研究（详情见SI）。研究1a, b, c使用了50个美国州首府问题，用不同的人群重复其格式（P）。研究2采用了80个一般知识问题。</p>
<p>研究3要求专业皮肤科医生将80张皮肤病变图片诊断为良性或恶性。研究4a、b向非专业人士和艺术专业人士展示了90件20世纪的艺术品（图3），并要求他们预测正确的市场价格类别。所有的研究都包括一个二分法的投票问题，总共产生了490个项目。研究1c、2和3另外还测量了信心。预测的投票频率是通过对所有受访者的预测进行平均来计算的（详情见补充资料）。</p>
<p>我们首先测试了四种算法的配对准确性：多数票、SP、信心加权票和最大信心，后者选择平均信心最高的答案。在所有490个项目中，相对于简单的多数票，SP算法减少了21.3%的错误（通过双侧匹配对符号测试，P &lt; 0.0005）。在测量信心的290个项目中，相对于多数票，减少了35.8%（P &lt; 0.001），相对于信心加权票，减少了24.2%（P = 0.0107），相对于最大信心，减少了22.2%（P &lt; 0.13）。</p>
<p>当同一研究中不同正确答案的频率不平衡时，百分比的一致可能是偶然的高。因此，我们通过分类相关系数，如Cohen’s kappa、F1得分或Matthews相关，评估一项研究中的分类准确性。SP算法在每项研究中的卡帕值都是最高的（图4）；其他系数产生类似的排名（扩展数据图1-3）。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-A Bayesian Truth Serum for Subjective Data</title>
    <url>/2022/10/24/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-A%20Bayesian%20Truth%20Serum%20for%20Subjective%20Data/</url>
    <content><![CDATA[<h1 id="A-Bayesian-Truth-Serum-for-Subjective-Data"><a href="#A-Bayesian-Truth-Serum-for-Subjective-Data" class="headerlink" title="A Bayesian Truth Serum for Subjective Data"></a>A Bayesian Truth Serum for Subjective Data</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>因为没有评估真实性的公共标准，因此主观判断作为科学和政策的重要信息来源是不可靠的。本文提出了一种在客观事实不可知的情况下获取真实主观数据的评分方法。这种方法不是传统的少数服从多数，而是选择那些比集体预测更常见的答案。这种对评分标准的简单调整，消除了所有有利于多数人的偏见，即使是那些认为自己的答案代表了少数人的观点的受访者，真实的答案也会使预期得分最大化。</p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>主观数据的重要性略</p>
<p>主观数据的价值受限于数据源的质量，但又没有一个标准来评价这个质量</p>
<p>本文提出了一种诱导主观信息的方法，是为客观事实本质上或实际上不可知的情况而设计的(6)。该方法包括一个信息评分系统，从理性（即贝叶斯）期望值最大化的受访者样本中诱导出真实的答案。与其他贝叶斯诱导机制不同（7-9），该方法并不假定研究者知道不同回答之间的概率关系。因此，它可以由一个对该领域完全不了解的研究者应用于以前没有问过的问题。与早期没有答案的理论测试方法(5)或德尔菲法(10)不同的是，它并不推崇共识答案。因此，受访者没有理由将他们的答案偏向于可能的群体平均值。即使有人确信自己的答案代表了少数人的观点，真实的回答仍然是正确的策略。</p>
<p>简单来说就是不再采用多数人共识作为答案，而是采用比集体预测更常见的作为答案。</p>
<blockquote>
<p>个人觉得就是用集体预测构建了一个先验，然后选比先验更常见的答案</p>
</blockquote>
<p>这项评分标准针对单一问题，例如：</p>
<ol>
<li>你估计人类能活过2100年的概率是多少(概率以百分比计量) ？</li>
<li>你会在下一届总统选举中投票吗(肯定/可能/可能不会/肯定不会) ？</li>
<li>在过去的一年里，你是否有超过20个性伴侣(是/否)</li>
<li>毕加索是你最喜欢的20世纪画家吗(是/否) ？</li>
</ol>
<p>每个受访者都会提供一个个人答案，并预测答案的经验分布(即，支持每个答案的人的比例)。本文对预测的准确性进行评分，也就是说，对它们与经验频率的匹配程度进行评分。作为主要关注对象的个人答案，其评分标准是令人惊讶的普遍性。在预测频率为5%的情况下，一个被10%的人认可的答案将是令人惊讶的普遍现象，并将获得较高的信息分；如果预测的平均频率为25%，这将是一个令人惊讶的不常见的答案，因此获得较低的分数。</p>
<p>该方法利用了关于人口频率的贝叶斯推理中一个被忽视的含义。在大多数情况下，人们应该预期其他人会低估自己的意见或个人特征的真实频率。这一含义是更常见的贝叶斯论证的必然结果，即对某一特定意见或特征在人群中的频率的最高预测应该来自持有该意见或特征的个人，因为持有该意见构成了一个关于其流行程度的有效和有利的信号。例如，将毕加索评为自己最喜欢画家的人应该——而且通常也是如此——对持有该观点的人群的百分比给出更高的估计，因为他们自己的感受是一个有信息量的样本。因此，毕加索爱好者有理由相信，与其他人的估计相比，他们对毕加索受欢迎程度的最佳估计会更高，他们会认为，毕加索的真实受欢迎程度被人们低估了。因此，一个人的真实意见也是最有可能出人意料的意见。（最后这句话和前文有什么关系我没理解）</p>
<p>这个结论的有效性并不取决于个人真实的答案是否被认为是罕见的或广泛的。例如，一个回答问题时有超过20个性伴侣的男性可能觉得很少有人属于这种滥交的类别。然而，根据贝叶斯推理，他应该期望他个人对这个百分比的估计（例如5%）会比从整个人口中收集的估计的平均值（例如2%）高一些。他有超过20个性伴侣的事实证明，包括伴侣较少的人在内的一般人群会低估这种情况的普遍性。</p>
<p>在说真话能最大化自己的期望信息分（也就是前面说的那个评分系统）时，说真话是个体理性和集体理性，是唯一的均衡。</p>
<p>均衡结果依赖于两个假设：</p>
<ol>
<li>受访者数量必须足够大，使得单个回答不会影响经验分布。这些结果对于大的有限种群来说确实成立，但对于可数的无限种群来说，说明起来更简单，就像这里所做的那样。受访者以$r\in \lbrace 1,2,… \rbrace$为索引，他们针对多选项问题的真实回答记为$t^r=(t_1^r,…,t_m^r)(t_k^r\in\lbrace 0,1\rbrace, \sum_k x_k^r=1)$。$t_k^r$表示第$k$个回答是否是第$r$个受访者的真实答案，如果是则值为1，否则为0。真实答案也被称为个人意见或特点。</li>
<li>受访者将个人意见视为关于人口分布的非个人信息信号，这是一个未知参数，$\omega = (\omega_1,…,\omega_m)\in \Omega$。形式上，本文假设所有受访者的公共知识是：后验信念$p(\omega |t^s)$ 都服从于$\omega$的单一分布的贝叶斯更新，也称之为公共先验，记作$p(\omega)$，且，当且仅当$t^r=t^s$时$p(\omega|t^r)=p(\omega|t^s)$。因此，个人意见提供了关于$\omega$的证据，但推论是非个人的：受访者相信其他与他们意见相同的人也会得出关于人口频率的相同推论。因此，我们可以用$t_j$表示意见为$j$的受访者，并在联合概率和条件概率中取消受访者上标：$Prob\lbrace t_j^r=1 |t_j^s=1\rbrace$变为$p(t_j|t_i)$，其他的也类似改写。</li>
</ol>
<h2 id="关于先验和后验的一个例子"><a href="#关于先验和后验的一个例子" class="headerlink" title="关于先验和后验的一个例子"></a>关于先验和后验的一个例子</h2><p>对于一个二值问题，一个人可以如下推断模型。每一个受访者私下进行一次有偏硬币抛掷，它出现头像那一面的概率是$\omega_H$。抛掷结果代表他的个人意见。以此为基准点，他构造了一个后验分布，$p(\omega_H|t^r)$，其期望是预测的出现头像的频率。例如，如果先验是均匀分布，则抛掷硬币后的后验分布是$[0,1]$的三角分布，倾向于正面还是反面取决于硬币结果，期望值是$\frac{1}{3}$或$\frac{2}{3}$。如果先验不是均匀分布，而是强烈地偏向于相反的结果(例如，反面) ，那么在抛出头像那面之后，头像的预期频率可能仍然相当低——这对应于一些一看就不常见的特征，例如一年有超过20个性伴侣。</p>
<blockquote>
<p>在接下来的内容中，我们把硬币头像那一面称为正面(head)，另一边成为反面(tail)。</p>
</blockquote>
<p>从先验计算后验的过程如下：<br>首先，贝叶斯公式为：</p>
<script type="math/tex; mode=display">
P(H|D)=\frac{P(D|H)P(H)}{P(D)}</script><p>其中，<code>H</code>是假设，<code>D</code>是数据，<code>P(H)</code>是先验概率（先验概率顾名思义是看到数据前的猜测），<code>P(H|D)</code>是后验概率（后验概率顾名思义是拿到数据之后的猜测），<code>P(D)</code>是数据发生的概率，<code>P(D|H)</code>是在这个假设下数据发生的概率，也叫似然函数 。 而<code>P(D)</code>和<code>P(D|H)</code>的关系是：</p>
<script type="math/tex; mode=display">
P(D)=\sum_{all\ H}[P(D \mid H) \times P(H)]</script><p>最初硬币是公平和不公平的概率分别是0.5，前者抛出正面和反面的概率也分别是0.5，后者抛出正面和反面的概率分别是1和0。我们把几个事件用如下字母表示：</p>
<ol>
<li>硬币是公平的——A</li>
<li>硬币是不公平的——B</li>
<li>硬币扔出正面——H</li>
<li>硬币扔出反面——T</li>
</ol>
<p>则显然，$P(A)=P(B)=0.5$。</p>
<p>如果一个受访者扔出了正面，则贝叶斯公式中的<code>D</code>为<code>正面</code>，在<code>A</code>和<code>B</code>两个事件发生的情况下，扔出正面的概率为：<br>$P(D|A)=0.5, P(D|B)=1$.</p>
<p>我们的要求是已知<code>D=正面</code>的情况下，判断这个硬币是<code>A</code>和<code>B</code>的概率分别有多少，也就是说要计算<code>P(A|D)</code>和<code>P(B|D)</code>。</p>
<p>利用贝叶斯公式，我们还有一个变量<code>P(D)</code>不知道，但是可以如下计算：</p>
<script type="math/tex; mode=display">
P(D)=P(D|A)P(A)+P(D|B)P(B)=0.5*0.5+1*0.5=0.75</script><script type="math/tex; mode=display">
P(A|D)=\frac{P(D|A)P(A)}{P(D)}=0.5*0.5/0.75=\frac{1}{3}</script><script type="math/tex; mode=display">
P(B|D)=\frac{P(D|B)P(B)}{P(D)}=1*0.5/0.75=\frac{2}{3}</script><p>也就是说，在扔出正面之后，认为硬币是公平的概率会变成$\frac{1}{3}$，而认为硬币不公平的概率会变成$\frac{2}{3}$。</p>
<p>而如果扔出了反面，从直觉上来说就可以判断出硬币肯定是公平的，从数学计算上来说，当<code>D=反面</code>时，$P(D|A)=0.5, P(D|B)=0$.</p>
<script type="math/tex; mode=display">
P(D)=P(D|A)P(A)+P(D|B)P(B)=0.5*0.5+0*0.5=0.25</script><script type="math/tex; mode=display">
P(A|D)=\frac{P(D|A)P(A)}{P(D)}=0.5*0.5/0.25=1</script><script type="math/tex; mode=display">
P(B|D)=\frac{P(D|B)P(B)}{P(D)}=0*0.5/0.75=0</script><p>可以看出来扔出反面后认为硬币是公平的概率会变成1，而不公平的概率会变成0.</p>
<h2 id="具体计算方法"><a href="#具体计算方法" class="headerlink" title="具体计算方法"></a>具体计算方法</h2><p>该方法的一个重要简化是不提取先验/后验分布，只提取答案和预测频率，答案和预测分别记作$x^r=(x_1^r,…,x_m^r)(x_k^r\in\lbrace 0,1\rbrace,\sum_k x_k^r=1)$和$y^r=(y_1^r,…,y_m^r)(y_k^r\geq 0,\sum_ky_k^r=1)$。我们按照下列公式计算人口认可频率$\bar{x_k}$，和预测频率的（几何）平均$\bar{y_k}$</p>
<script type="math/tex; mode=display">
\bar{x}_{k}=\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{r=1}^{n} x_{k}^{r},</script><script type="math/tex; mode=display">
\log \bar{y}_{k}=\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{r=1}^{n} \log y_{k}^{r}</script><p>说明：这里的$\bar{x_k}$就是计算选择这个回答的人占总人数的比例，而$\bar{y_k}$则是所有人对这个回答的预测频率的几何平均值</p>
<p>我们不使用预设的答案键，而是根据答案的信息得分来评估答案，这个得分就是实际频率与预测频率的对数比。</p>
<script type="math/tex; mode=display">\log \frac{\bar{x}_{k}}{\bar{y}_{k}}</script><p>至少一个答案的信息分非负。预测中的偏差往往会降低所有$\bar{y_k}$值，从而提高信息分值。</p>
<p>受访者的总分将信息分数与预测准确性的单独分数结合起来：<br>受访者$r$的得分 = 信息分 + 预测分 = </p>
<script type="math/tex; mode=display">\sum_{k} x_{k}^{r} \log \frac{\bar{x}_{k}}{\bar{y}_{k}}+\alpha \sum_{k} \bar{x}_{k} \log \frac{y_{k}^{r}}{\bar{x}_{k}}, 0<\alpha</script><p>上述公式是博弈的完全收益方程，它是对称的，如果 a = 1则为零和。第一部分是信息分，除了被受访者$r$选择的那个答案以外，其他答案的$x_k^r$都是<code>0</code>。第二部分是与经验分布和受访者$r$对该分布的预测之间的相对熵成正比的惩罚。最优预测分为0，是指预测完全符合现实，即$y_k^r=\bar{x_k}$（也就是说，所有人对这个答案出现的频率预测都一致并且符合真实情况）。期望预测分可以通过报告期望频率$y_k^r=E\lbrace \bar{x_k}|t^r \rbrace$来最大化。系数$\alpha$表示预测误差的权重。</p>
<p>接下来用硬币的例子来说明该公式是如何发挥作用的。想象有下述两种等可能性的事件：</p>
<ol>
<li>硬币是公平的</li>
<li>硬币不公平，它永远会扔出正面<br>在这个表述里，硬币是公平的先验概率为$\frac{1}{2}$</li>
</ol>
<p>接下来找一群人，让他们私下抛硬币并报告自己是哪一面，则可以分析出以下两种情况：</p>
<ol>
<li>一个扔出了反面的观测者会意识到这个硬币属于第一种情况，并由此预测整个群体观察到的正面和反面频率是五五开的。</li>
<li>一个扔出了正面的观测者会把“硬币是公平的”这件事的概率从先验的$\frac{1}{2}$降低到后验的$\frac{1}{3}$，进而使得他对扔出反面的预期概率降低到$\frac{1}{6}$，而扔出正面的预期概率就是$\frac{5}{6}$。</li>
</ol>
<p>我们从扔出反面的观测者的角度思考问题，其他人对抛硬币出反面这一结果的预期频率应该是$\frac{1}{2}$和$\frac{1}{6}$的混合，也就是说比他自己预测的$\frac{1}{2}$要小，因此他会期待实际结果中的反面更常见，从而得到较高的信息分。而相反，他会希望正面不常见，因为$\frac{1}{2}$和$\frac{5}{6}$的混合比他自己预测的$\frac{1}{2}$要大，这会导致一个较低的信息分。</p>
<p>类似的，扔出正面的观测者就会希望实际结果中正面更常见。由此可以发现，大家都会希望自己扔出的那一面更常见，而为此也会如实上报自己的结果从而试图增加这部分信息分。</p>
<p>该示例说明了信息分的一般属性。也就是说，如果最佳答案是由预期的信息得分精确定义的且其他受访者如实回答并给出真实的预测频率，那么一个真实的答案构成了对最令人惊讶的常见答案的最佳猜测。此属性不依赖于可能的答案的数量或先验。它直接导致均衡结果。</p>
<p>假设：</p>
<ol>
<li>每一个意见为$t^r$的受访者$r$通过对共同的先验$p(\omega)$应用贝叶斯法则形成了对意见的群体分布的后验$p(\omega|t^r)$。</li>
<li>当且仅当$t^r=t^s$时，$p(\omega|t^r)=p(\omega|t^s)$</li>
<li>分数按照前面的那个信息分+预测分来计算</li>
</ol>
<p>则：</p>
<ol>
<li>(T1) 对于任意$\alpha&gt;0$，说真话是纳什均衡：说真话可以最大化每一个相信其他人也会说真话的受访者的期望总分。</li>
<li>(T2) 期望均衡信息分是非负的，并且在所有受访者都说真话时取最大值。</li>
<li>(T3) 当$\alpha=1$时，博弈是零和的，总分在说真话均衡中为$log p(\omega|t^r)+K$，$K$由零和约束设置。</li>
</ol>
<p>说真话是指回答和预测都是真实的，即：$x^r=t^r$且$y^r=E\lbrace \omega|t^r \rbrace$。</p>
<p>T2指出，尽管存在其他均衡，可以通过将多个真实意见映射到一个反应类别中或通过随机化来构建，但这些揭示性较低的均衡会导致所有受访者的信息得分较低。如果需要，我们可以通过在公式2中给予信息分相对更多的权重来增强讲真话的战略优势。在$\alpha$足够小的情况下，讲真话均衡中的预期总分将以帕累托方式支配任何其他均衡中的预期分值。</p>
<p>T3说明，通过设置$\alpha=1$，我们可以将该博弈呈现为一个纯粹的竞争性的零和竞赛。总分根据受访者对答案的真实分布的预期程度进行排名。需要注意的是：评分系统只要求提供真实答案的预期分布$E\lbrace \omega|t^r \rbrace$而不是后验分布$p(\omega|t^r)$，后者是一个<code>m</code>维的概率密度函数。我们可以通过一个不直接引出这些概率的方法来推断哪些受访者对$\alpha$的实际值赋予了更多的概率。</p>
<p>在以往关于激励机制的经济学研究中，标准的做法是假设评分者（或中心）知道先验和后验，并将这种知识纳入评分函数。原则上，先验的任何变化，无论是问题措辞的变化、样本构成的变化，还是新的公共信息的变化，都需要重新计算计分函数。相比之下，我的方法采用了一个通用的一刀切的打分方程，不提先验或后验概率。这对实际应用有三个好处。首先，问题不需要局限于一些预先测试过的、可获得经验估计的基本比率和条件概率的集合；相反，人们可以利用自然语言的全部资源，为每个应用定制一套新问题。第二，可以对不同的人群进行相同的调查，或者在动态环境下进行调查（这与政治民意调查有关）。第三，人们可以诚实地指示受访者在制定自己的答案时不要猜测他人的答案。真实的答案对任何先验来说都是最佳的，而且没有公开的概率供他们考虑，或许还可以拒绝。</p>
<p>当涉及到为复杂、独特的问题打分时，这些都是决定性的优势。特别是，人们可以应用这种方法来获得关于任何明确陈述的命题的真实价值的诚实的概率判断，即使实际的真理是遥不可及的，也没有先验。例如，最近由一位著名的英国天文学家撰写的《我们最后的世纪》一书中，人类在2100年后生存的机会不超过50：50。这是一个挑衅性的评估，它不会很快被检验。用现在的方法，人们可以提出这样的问题：这是我们最后的世纪吗？并将其提交给一个专家样本，他们将各自提供一个主观概率，并估计其他概率的概率分布。T1意味着对主观概率的诚实报告将使预期信息得分最大化。专家们将面临类似的讲真话的激励，就像他们对实际结果下注一样，例如，在期货市场上，结果可以及时确定，以便评分。</p>
<p>我们用离散计算来说明。假设概率以1%为精度被分为100份，由此这个问题就成了一个有100个选项的选择题（在实际生活中，我们往往会有更少的类别，和更平滑的经验频率）。人口向量$\omega=\lbrace \omega_{00},…,\omega_{99} \rbrace$表示专家们之间的关于概率的未知分布。给定任意先验，$p(\omega)$，计算作为真实个人概率和被大众所认可的概率的函数的预期信息分数是一项费力但简单的工作。计算结果如下图所示，其中<code>A(90)</code>和<code>B(90)</code>分别表示两种不同先验（分别记作$p_A(\omega)$和$p_B(\omega)$）下专家认为90%的概率地球会在2100年之前毁灭。因此，专家们有着相同的评估，但对于他们的评估与其他人的评估之间的关系却有着不同的理论。虽然A90和B90不同，但在这两种情况下，预期信息分都是由90%的真实认可来计算的。这证实了T1。在这两种情况下，每个专家都认为他的主观概率相对于人群是悲观的。以个人估计的90%为条件，对他人概率的期望值在$p_A(\omega)$的情况下只有65%，在$p_A(\omega)$的情况下只有54%。</p>
<p>如果主观概率变成<code>50%</code>，这两条线会移动到<code>A(50)</code>和<code>B(50)</code>，则此时二者的最优策略就也会变成<code>50%</code>。总的来说就是无论主观信念怎么变，说实话都是最好的选择。</p>
<p>A线和B线的不同之处在于，A线的先验概率被假定为50%，B线为20%。B线的期望分数较高，因为90%的估计值在这种情况下更令人惊讶。<br><img src="https://github.com/likun1208/image/blob/master/BayesianTruth.jpg?raw=true" alt="概率统计图"></p>
<p>假设评分者能精确为估计值打分，则对比信息分与这个精确分是有意义的。激发关于可公开验证的事件的诚实概率的标准工具是对数适当得分规则。根据该规则，一个专家在<code>n</code>个互斥事件上宣布其概率分布为$z=(z_1,…,z_n)$，如果事件$i$发生了，则他得到的评分为$K+log z_i$。举个例子，一位专家对人类将在2100年之前灭亡的真实主观概率估计为90%，但他宣布的概率<code>z</code>可能不是90%，根据<code>z</code>可以计算出他的分数是$0.9log z+0.1log(1-z)$，再次强调，这里假设我们知道他真实的估计概率是90%。这个分数计算公式会在$z=0.9$时取最大值，就是图中PS90对应的那条线。可以看出来它和用信息分计算的A90、B90的趋势是基本一样的。</p>
<p>非个人信息性先验的假设可能在两方面会失败。首先，在存在关于人口频率的公共信息的情况下，一个真实的答案可能不会对这些频率提供信息。例如，一个人的性别对他们判断人口中的男女比例的影响很小。这意味着$t^r \neq t^s$但$p(\omega|t^r)=p(\omega|t^s)$，且诚实和欺骗性答案的预期信息分之间的差异几乎为零（尽管仍然是正数）。如下图所示，补救措施是将性别问题与一个与性别有关的意见问题结合起来。</p>
<p>第二，具有不同品味或特征的受访者可能出于不同的原因选择相同的答案，从而形成不同的后验。例如，具有非标准政治观点的人可能会把他或她对某位候选人的喜欢当作大多数人都会喜欢其他候选人的证据。这意味着尽管$t^r=t^s$，但是$p(\omega|t^r) \neq p(\omega|t^s)$。在这里，补救的办法也是扩大问卷，让当事人同时透露意见和特征。</p>
<p>最后一个例子，一个艺术评估，说明了这两种补救措施。这个例子假设存在专家和门外汉，以及一个二元性质的状态：一个特定的艺术家是否代表原创才能的问题。根据假设，艺术专家能很好地识别这种区别，但普通人的辨别能力很差，事实上，喜欢衍生艺术家的机会比喜欢原创艺术家的机会要大。专家的比例是众所周知的，其他的概率也是如此（表1）。</p>
<p>本例和其他例子中的信息分反映了与某一观点或特征相关的信息量。在表格中，专家有明显的优势，尽管他们在样本中占少数，因为他们的意见对人口频率的信息量更大。一般来说，意见<code>i</code>的期望信息分就等于分布$p(\omega|t_k,t_i)$和$p(\omega|t_k)$之间的期望相对熵，后者是所有$t_k$的平均值。换句话说，<code>i</code>的预期得分是信息论的衡量标准，即赞同<code>i</code>的意见会在多大程度上改变他人对人口分布的后验信念。专家的认可将导致信念的更大转变，因为它对驱动两个部分意见的基本变量的信息量更大。这种影响的衡量标准对专家群体的规模或专家与非专家意见之间的关联方向相当不敏感。</p>
<p><img src="https://github.com/likun1208/image/blob/master/BayesianTruth-2.png?raw=true" alt="表格"></p>
<p>通过建立说实话的激励机制，我并不是说人们在没有明确的经济回报的情况下就会欺骗或者不愿意提供信息。相反，人们担心的是，缺乏外部标准可能会助长自我欺骗和虚假的信心，即使是在善意的人之间。一个未来学家，或者一个艺术评论家，可以轻松地花一生的时间做出判断，而不用面对医生、科学家或者商业投资者的现实检查。在缺乏现实检验的情况下，人们很容易给予主流共识以特殊地位。明确得分的好处恰恰是抵消了非正式的压力，要求同意(或者也许是要突出(和不同意)。事实上，仅仅存在一个真相诱导评分系统就为社会科学提供了方法论上的保证，表明如果需要的话，主观数据可以通过一个既不基于信仰(所有的答案都同样好)也不偏向于例外观点的过程来获得。</p>
<h2 id="我的问题"><a href="#我的问题" class="headerlink" title="我的问题"></a>我的问题</h2><ol>
<li>公式里的$\bar{y_k}$如果是0怎么办？</li>
<li>信息分那里为什么要取对数？如果不取对数，效果是不是仍然一样？大小关系感觉没变。</li>
</ol>
<h2 id="补充材料"><a href="#补充材料" class="headerlink" title="补充材料"></a>补充材料</h2><p>是这篇论文作者附的一系列证明。</p>
<p>有一个无限可数的受访者群体，记作$r,s,…\in I=\lbrace 1,2,…\rbrace$，它们都面对同一个有着$m$个候选答案的多选项问题。受访者$r$的私有“信号”通过$m$维单位向量$t^r\in E^m$提供，该向量中，坐标对应了受访者$r$所选答案的元素的值是1，其他元素值为0。持有意见$i$的受访者记作$t_i$。</p>
<p>说明：我们用上标来指示个体，下标指示个体的类别，即$t^r$表示某个具体的受访者$r\in I$的意见，是一个向量，而$t_i$表示持有意见$i$的受访者。</p>
<p>每个受访者支持一个回答，并预测其他受访者中支持其他可能回答的频率。回答用$n$维单位向量$x^r=(x_1^r,…,x_m^r)\in E^m,(x_k^r\in\lbrace 0,1 \rbrace,\sum_k x_k^r=1)$来表示，而预测用相对频率分布$y^r=(y_1^r,…,y_m^r)\in \Delta^m(y_l^r\geq 0,\sum_k y_k^r=1)$来表示。$x_k^r$根据个体$r$是否支持这个答案而取值1或者0；$y_k^r$是个体$r$对支持答案$k$的受访者的比例的估计。$(x,y)$是回答和预测组成的向量（可数无限）</p>
<p>任意受访者的得分取决于他的回答、预测和经验平均：</p>
<script type="math/tex; mode=display">
\begin{array}{c}
\bar{x}_{k}=\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{r=1}^{n} x_{k}^{r}, \\
\log \bar{y}_{k}=\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{r=1}^{n} \log y_{k}^{r} .
\end{array}</script><p>其中，$\bar{x_k}$是答案$k$的平均频率，$\bar{y_k}$是答案$k$的预测频率的几何平均。如果$y_k^r=0$，则设$\bar{y_k}=0$，且设$log(0/0)=0$，$0log(0)=0$。</p>
<p>受访者$r$的得分，是$(x,y)$的函数，为：</p>
<script type="math/tex; mode=display">
u^{r}(x, y)=\sum_{k} x_{k}^{r} \log \frac{\bar{x}_{k}}{\bar{y}_{k}}+\alpha \sum_{k} \bar{x}_{k} \log \frac{y_{k}^{r}}{\bar{x}_{k}}</script><p>第一项为信息分，是受访者$r$所支持的答案对应的$log(\frac{\bar{x_k}}{\bar{y_k}})$。第二项是预测分。</p>
<h3 id="信息假设"><a href="#信息假设" class="headerlink" title="信息假设"></a>信息假设</h3><ol>
<li>A1：存在集合S的成员意见的公共先验$p(t^r,…,t^s)$。</li>
<li>A2：先验是可交换的：对于所有组合$\pi$，都有$p(t^r,…,t^s)=p(t^{\pi(r)},…,t^{\pi(s)})$。</li>
<li>A3：不同的意见代表不同的后验分布：$p(\cdot|t^r)=p(\cdot|t^s)$就意味着$t^r=t^s$。</li>
</ol>
<p>A1是贝叶斯博弈理论的标准假设。A2是至关重要的。根据De Finetti定理，它意味着$\Omega=\Delta^m$上存在一个概率分布$p(\omega)$，它将共同先验表达为条件独立随机变量的联合分布：</p>
<script type="math/tex; mode=display">
\begin{array}{l} 
p\left(t^{r}, ..., t^{s}\right)=\int_\Omega \prod_{q \in S} p\left(t^{q} \mid \omega\right) p(\omega) d \omega \\
p\left(t_{k}^{r} \mid \omega\right)=\omega_{k}=\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{q=1}^{n} t_{k}^{q} .
\end{array}</script><p>换句话说，受访者相信他们的意见是独立的，是以意见的人口频率$\omega$为条件的。条件独立性的假设可以直接引用，而不是从可交换性中推导出来。然而，交换性强调了关键的基本属性，即具有相同意见的受访者对人口中的意见分布具有相同的后验信念。最后一个假设（A3）是随机相关性的一个版本；它只影响到讲真话的纳什均衡是否严格。</p>
<p>这里$\omega$应该是指人口频率的分布情况，$\omega_k$是指在这样的人口频率下，支持第$k$个答案的人口百分比。</p>
<h3 id="贝叶斯纳什均衡策略"><a href="#贝叶斯纳什均衡策略" class="headerlink" title="贝叶斯纳什均衡策略"></a>贝叶斯纳什均衡策略</h3><p>受访者$r$的回答策略是一个函数$x^r(t^r)=(x_1^r(t^r),…,x_m^r(t^r)):E^m \rightarrow \Delta^m$，表示如果受访者$r$的真实回答是$t^r$，则他有概率$x_k^r(t^r)$给出答案$x_k$。如果$x^r(t^r)=t^r$则该策略是真实的。</p>
<p>受访者$r$的预测策略同样是一个函数$y^{r}\left(t^{r}\right)=\left(y_{1}^{r}\left(t^{r}\right), \ldots, y_{m}^{r}\left(t^{r}\right)\right): E^{m} \rightarrow \Delta^{m}$，表示如果受访者$r$持有意见$t^r$，则他会预测人群中有占比$y_k^r$的人会回答$k$。我们不需要考虑预测随机性，因为收益函数是关于$y_k^r$的严格凸函数(convex)。</p>
<p>二元组$(x^r(t^r),y^r(t^r))$是受访者$r$的策略。$(x(t),y(t))$表示所有受访者的策略。$(x^{-r}(t^{-r}),y^{-r}(t^{-r}))$是除了受访者$r$以外其他所有受访者的策略。如果所有的答案都是真实的，并且预测符合贝叶斯法则，那么$(x(t),y(t))$就是集体真实的。</p>
<p><strong>定义</strong>：如果对于所有受访者$r$、回答$x_k^r$和预测$y^r$，下列式子都成立，则$(x(t),y(t))$是贝叶斯纳什均衡(BNE)。</p>
<script type="math/tex; mode=display">
E\left\{u^{r}(x(t), y(t)) \mid t^{r}\right\} \geq E\left\{u^{r}\left(x^{r}, y^{r}, x^{-r}\left(t^{r}\right), y^{-r}\left(t^{r}\right)\right) \mid t^{r}\right\}, \text { for all } x^{r} \in E^{m}, y^{r} \in \Delta^{m}</script><p>如果不等式是严格的，则该BNE也是严格的</p>
<p><strong>定理1</strong>：如果A1~A3成立，则集体说真话是严格贝叶斯纳什均衡。<br>证明：如果大家都说真话，则人口平均是：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\bar{x}_{k} & =\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{s=1}^{n} x_{k}^{s} =\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{s=1}^{n} t_{k}^{s} =\omega_{k},\\
\log \bar{y}_{k} & =\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{s=1}^{n} \log y_{k}^{s} 
=\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{s=1}^{n} \log p\left(t_{k} \mid t^{s}\right) 
=\sum_{j=1}^{n} \omega_{j} \log p\left(t_{k} \mid t_{j}\right)
\end{aligned}</script><p>【记录一下我的理解】这里$y_k^s$表示受访者$s$持有意见$t^s$，他预测其他人有概率$y_k^s$支持答案$k$，由于假设其他人都说真话，也就是说支持答案$k$意味着持有意见$t^k$，因此$y_k^s$就可以表示持有意见$t^s$的受访者认为其他人持有意见$t^k$的概率，也就写作$p(t_k|t^s)$。接下来，虽然不知道这里为什么要把$s$变成$j$，但是前面的$s$和后面的$j$应该是等价的，表示支持某个回答的受访者。而在这个无限数量的人群中，任意一个受访者支持持有意见$t^j$的概率就是$\omega_j$，显然可以把前面的除以$n$取极限的形式直接改写成人口频率的形式，由此得到了$\sum_{j=1}^n \omega_j log p(t_k|t_j)$。</p>
<p>考虑持有意见$i$且相信其他人都说真话的个体，他应该支持哪个答案才能最大化自己的期望评分呢？因为期望预测错误并不取决于他自己的回答，我们可以先忽略评分公式的第二部分，只看第一部分信息分。如果他支持答案$j$，则他的期望信息分为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E\left\{\log \frac{\bar{x}_{j}}{\bar{y}_{j}} \mid t_{i}\right\} & =\int_{\Omega} p\left(\omega \mid t_{i}\right) E\left\{\log \frac{\bar{x}_{j}}{\bar{y}_{j}} \mid \omega\right\} d \omega \\
& =\int_{\Omega} p\left(\omega \mid t_{i}\right) \sum_{k=1}^{m} \omega_{k} \log \frac{\omega_{j}}{p\left(t_{j} \mid t_{k}\right)} d \omega \\
& =\sum_{k=1}^{m} \int_{\Omega} p\left(\omega, t_{k} \mid t_{i}\right) \log \frac{\omega_{j}}{p\left(t_{j} \mid t_{k}\right)} d \omega \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{\omega_{j}}{p\left(t_{j} \mid t_{k}\right)} d \omega \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(t_{j} \mid \omega\right) p\left(t_{k} \mid t_{j}, \omega\right)}{p\left(t_{j} \mid t_{k}\right) p\left(t_{k} \mid \omega\right)} d \omega \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(\omega \mid t_{k}, t_{j}\right)}{p\left(\omega \mid t_{k}\right)} d \omega
\end{aligned}</script><p>这个公式第一行计算了先验分布$p(\omega|t_i)$下的$log(\frac{\bar{x_j}}{\bar{y_j}})$的期望，大致意思就是说当受访者持有意见$i$时，他对人群整体的分布有一个先验的连续条件概率，因此用积分的形式计算最终的期望，$p(\omega|t_i)$表示先验概率，$E(xxx)$表示在这样的先验概率下的期望信息分，是一个条件期望。</p>
<p>第二行是从集体如实上报推导而来，按照期望的定义，$E\left\{\log \frac{\bar{x}_{j}}{\bar{y}_{j}} \mid \omega\right\}$的计算应该就是<br>在别人都说真话的情况下，$\bar{x}_j$就可以改写成$\omega_j$，而$log \bar{y}_j$则改写为$\sum_{k=1}^{n} \omega_{k} \log p\left(t_{j} \mid t_{k}\right)$。接下来是条件期望的公式套用，根据<a href="https://zhuanlan.zhihu.com/p/417592820" target="_blank" rel="noopener">链接</a>可知，由此第一行的那个条件期望就可以改写成$\sum$</p>
<p>第三行使用条件独立将$\omega_k p(\omega|t_i)$改写为$p(\omega,t_k|t_i)$。首先$\omega_k$可以直接写作$p(t_k|\omega)$，由此$\omega_k p(\omega|t_i)$就变成$p(t_k|\omega)p(\omega|t_i)$，在条件$\omega$下，$t_k$和$t_i$独立，所以$p(t_k|\omega)=p(t_k|\omega,t_i)$，于是就可以进一步改写成$p(t_k|\omega,t_i)p(\omega|t_i)$。根据贝叶斯条件概率的公式，$P(AB)=P(B)P(A|B)$，给这个公式加上条件概率就是$P(AB|C)=P(B|C)P(A|BC)$，这个式子就可以变成$p(t_k,\omega|t_i)$了。</p>
<p>第四行是使用贝叶斯规则从第三行推出的。还是根据前面的贝叶斯条件概率公式，对应到这里，就可以把$p(\omega,t_k|t_i)$改写为$p(t_k|t_i)p(\omega|t_k,t_i)$，而前面的$p(t_k|t_i)$与$\omega$的积分无关，所以可以提出来放积分外面。</p>
<p>第五行我们再次使用条件独立将$\omega_j$改写为$p(t_j|\omega)$，然后插入$\frac{p(t_k|t_j,\omega)}{p(t_k|\omega)}=1$，具体来说就是把第四行的$\omega_j$直接改写成$p(t_j|\omega)$，而因为$t_k$和$t_j$在条件$\omega$下是独立的，所以$\frac{p(t_k|t_j,\omega)}{p(t_k|\omega)}=1$。</p>
<p>第六行也是随之根据贝叶斯规则推导而来，过程如下：</p>
<script type="math/tex; mode=display">
\frac{p(t_j|\omega)p(t_k|t_j,\omega)}{p(t_j|t_k)p(t_k|\omega)}=\frac{\frac{p(t_j,\omega)p(t_k,t_j,\omega)}{p(\omega)p(t_j,\omega)}}{\frac{p(t_j,t_k)p(t_k,\omega)}{p(t_k)p(\omega)}}=\frac{\frac{p(t_k,t_j,\omega)}{p(t_k,t_j)}}{\frac{p(t_k,\omega)}{p(t_k)}}=\frac{p(\omega|t_k,t_j)}{p(\omega|t_k)}</script><p>由此，我们可以对比如实回答答案$i$和谎报答案$j$的信息分：</p>
<script type="math/tex; mode=display">
\begin{array}{l} 
E\left\{\ln \frac{\bar{x}_{i}}{\bar{y}_{i}} \mid t_{i}\right\}-E\left\{\ln \frac{\bar{x}_{j}}{\bar{y}_{j}} \mid t_{i}\right\}=\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(\omega \mid t_{k}, t_{i}\right)}{p\left(\omega \mid t_{k}\right)} d \omega \\
-\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(\omega \mid t_{k}, t_{j}\right)}{p\left(\omega \mid t_{k}\right)} d \omega \\
=-\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(\omega \mid t_{k}, t_{j}\right)}{p\left(\omega \mid t_{k}, t_{i}\right)} d \omega \\
>-\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \log \left(\int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \frac{p\left(\omega \mid t_{k}, t_{j}\right)}{p\left(\omega \mid t_{k}, t_{i}\right)} d \omega\right) \\
=\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \log \left(\int_{\Omega} p\left(\omega \mid t_{k}, t_{j}\right) d \omega\right)=\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \ln (1)=0
\end{array}</script><p>该不等式来源于Jensen不等式，且当A3成立时是严格的。它证明了当其他人都如实回答和预测时，说真话能最大化期望信息分。</p>
<p>接下来该证明同样应该如实预测。这次我们忽略信息分，来计算个体意见是$i$的条件下的期望预测分：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E\left\{\sum_{k=1}^{m} \bar{x}_{k} \log \frac{y_{k}}{\bar{x}_{k}} \mid t_{i}\right\} & =\sum_{k=1}^{m} E\left\{\bar{x}_{k} \mid t_{i}\right\} \log y_{k}-E\left\{\sum_{k=1}^{m} \bar{x}_{k} \log \bar{x}_{k} \mid t_{i}\right\} \\
& =\sum_{k=1}^{m} E\left\{\omega_{k} \mid t_{i}\right\} \log y_{k}-E\left\{\sum_{k=1}^{m} \omega_{k} \log \omega_{k} \mid t_{i}\right\} .
\end{aligned}</script><p>这里假定会如实回答，因此$\bar{x_k}=\omega_k$。第二个期望不包括$y_k$，因此，能最大化评分的针对$k$个答案占比的预测，就是回答$k$的期望频率，或者说等价于随机选一个人会持有意见$k$的概率：$y_k=E\lbrace \omega_k|t_i\rbrace=p(t_k|t_i)$。</p>
<p>由此完成了集体说真话是BNE的证明。</p>
<p><strong>定理2</strong>：如果A1~A3成立，则对于所有受访者而言下述内容都成立：</p>
<ol>
<li>任意BNE中的期望信息分是非负的</li>
<li>说真话对应的均衡解下的期望信息分会微弱地高于其他任意BNE对应的期望信息分</li>
</ol>
<p>证明(a)：期望信息分可以通过在定理1的公式那里设置$j=i$来计算：</p>
<script type="math/tex; mode=display">
E\left\{\ln \frac{\bar{x}_{i}}{\bar{y}_{i}} \mid t_{i}\right\}=\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \ln \frac{p\left(\omega \mid t_{k}, t_{i}\right)}{p\left(\omega \mid t_{k}\right)} d \omega \geq 0</script><p>这其实是分布$p(\omega|t_k,t_i)$和$p(\omega|t_k)$之间的相对熵，对所有$t_k$取平均。它衡量了“知道$t_i$”这件事能在多大程度上提升其他人对$\omega$的预测，也称为“数据期望效用”——将$t_i$看作数据（参考文献25的定理2.31）。当$i$的回答不会改变其他人对$\omega$的预测时，这个表达式最小为0。这证明了定理2的第一条。</p>
<p>证明(b)：我们考虑$q(\omega,\bar{x})$的联合分布，它是由一个特定的BNE推导而来的，该BNE记作$(x(t),y(t))$，$q$的边际与$p$重合，$q(\omega)=p(\omega)$。当真实意见是$i$而支持的答案是$j$时，期望信息分是：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E\left\{\log \frac{\bar{x}_{j}}{\bar{y}_{j}} \mid t_{i}\right\} & =\int_{\Omega} p\left(\omega \mid t_{i}\right) E\left\{\log \frac{\bar{x}_{j}}{\bar{y}_{j}} \mid \omega\right\} d \omega \\
& =\int_{\Omega} p\left(\omega \mid t_{i}\right) \sum_{k=1}^{m} \omega_{k} \log \frac{\bar{x}_{j}}{q\left(x_{j} \mid t_{k}\right)} d \omega \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{\bar{x}_{j}}{q\left(x_{j} \mid t_{k}\right)} d \omega \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\bar{X}} q\left(\bar{x} \mid t_{k}, t_{i}\right) \log \frac{\bar{x}_{j}}{q\left(x_{j} t_{k}\right)} d \bar{x} \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\bar{X}} q\left(\bar{x} \mid t_{k}, t_{i}\right) \log \frac{q\left(x_{j} \mid \bar{x}\right) q\left(t_{k} \mid x_{j} \bar{x}\right)}{q\left(x_{j} t_{k}\right) q\left(t_{k} \mid \bar{x}\right)} d \bar{x} \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\bar{X}} q\left(\bar{x} \mid t_{k}, t_{i}\right) \log \frac{q\left(\bar{x} \mid t_{k}, x_{j}\right)}{q\left(\bar{x} \mid t_{k}\right)} d \bar{x}
\end{aligned}</script><p>这和定理1中的证明很像，除了第二行不再假设一个说真话的均衡。</p>
<p>现在我们将$q\left(\omega, \bar{x} \mid t_{i},t_{k}\right)$和$q\left(\omega, \bar{x} \mid t_{k}\right)$之间的相对熵扩展到两个不同的方式，先把$\omega$作为条件，再把$\bar{x}$作为条件：</p>
<script type="math/tex; mode=display">
\begin{array}{l} 
\int_{\Omega, \bar{X}} q\left(\omega, \bar{x} \mid t_{k}, t_{i}\right) \log \frac{q\left(\omega, \bar{x} \mid t_{k}, t_{i}\right)}{q\left(\omega, \bar{x} \mid t_{k}\right)} d \omega d \bar{x}= \\
= \int_{\Omega} q\left(\omega \mid t_{k}, t_{i}\right) \log \frac{q\left(\omega \mid t_{k}, t_{i}\right)}{q\left(\omega \mid t_{k}\right)} d \omega \\
+\int_{\bar{X}, \Omega} q\left(\bar{x} \mid \omega, t_{k}, t_{i}\right) \log \frac{q\left(\bar{x} \mid \omega, t_{k}, t_{i}\right)}{q\left(\bar{x} \mid \omega, t_{k}\right)} d \bar{x} d \omega \\
= \int_{\bar{X}} q\left(\bar{x} \mid t_{k}, t_{i}\right) \log \frac{q\left(\bar{x} \mid t_{k}, t_{i}\right)}{q\left(\bar{x} \mid t_{k}\right)} d \bar{x} \\
\quad+\int_{\Omega, \bar{X}} q\left(\omega \mid \bar{x}, t_{k}, t_{i}\right) \log \frac{q\left(\omega \mid \bar{x}, t_{k}, t_{i}\right)}{q\left(\omega \mid \bar{x}, t_{k}\right)} d \omega d \bar{x}
\end{array}</script><p>第二行仅考虑了$q(\omega,\bar{x})$对于$\omega$的边界，因此我们可以用$p$代替$q$；因为$\bar{x}$完全取决于$\omega$，所以第三行是0。现在我们可以将第二行如下改写，并将第四行如下扩展：</p>
<script type="math/tex; mode=display">
\begin{array}{l} 
\int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(\omega \mid t_{k}, t_{i}\right)}{p\left(\omega \mid t_{k}\right)} d \omega \\
= \int_{\bar{X}} q\left(\bar{x} \mid t_{k}, t_{i}\right) \log \frac{q\left(\bar{x} \mid t_{k}, x_{j}\right)}{q\left(\bar{x} \mid t_{k}\right)} d \bar{x} \\
\quad+\int_{\bar{X}} q\left(\bar{x} \mid t_{k}, t_{i}\right) \log \frac{q\left(\bar{x} \mid t_{k}, t_{i}\right)}{q\left(\bar{x} \mid t_{k}, x_{j}\right)} d \bar{x} \\
\quad+\int_{\Omega, \bar{X}} q\left(\omega \mid \bar{x}, t_{k}, t_{i}\right) \log \frac{q\left(\omega \mid \bar{x}, t_{k}, t_{i}\right)}{q\left(\omega \mid \bar{x}, t_{k}\right)} d \omega d \bar{x}
\end{array}</script><p>对所有$t_k$求和可以得到一个表达式，该表达式关系到讲真话均衡中的预期信息分数和替代均衡中的预期信息分数。</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(\omega \mid t_{k}, t_{i}\right)}{p\left(\omega \mid t_{k}\right)} d \omega \\
=\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\bar{X}} q\left(\bar{x} \mid t_{k}, t_{i}\right) \log \frac{q\left(\bar{x} \mid t_{k}, x_{j}\right)}{q\left(\bar{x} \mid t_{k}\right)} d \bar{x} \\
+\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\bar{X}} q\left(\bar{x} \mid t_{k}, t_{i}\right) \log \frac{q\left(\bar{x} \mid t_{k}, t_{i}\right)}{q\left(\bar{x} \mid t_{k}, x_{j}\right)} d \bar{x} \\
+\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega, \bar{X}} q\left(\omega \mid \bar{x}, t_{k}, t_{i}\right) \log \frac{q\left(\omega \mid \bar{x}, t_{k}, t_{i}\right)}{q\left(\omega \mid x, t_{k}\right)} d \omega d \bar{x}
\end{array}</script><p>第一行是说真话均衡的期望信息分，第二行是在其他均衡中支持答案$j$的信息分，第三行和第四行是相对熵。这证明了期望信息分在不说真话的均衡里只会更低。</p>
<p><strong>定理3</strong>：如果A1~A3成立，且$\alpha=1$，则该博弈是零和博弈，且在说真话的均衡中，持有意见$i$的受访者的总分为$log p(\omega|t_i)+K$。</p>
<p>证明：对于$\alpha=1$，评分公式为：</p>
<script type="math/tex; mode=display">
u^{r}(x, y)=\sum_{k} x_{k}^{r} \log \frac{\bar{x}_{k}}{\bar{y}_{k}}+\sum_{k} \bar{x}_{k} \log \frac{y_{k}^{r}}{\bar{x}_{k}}</script><p>所有受访者的平均总分比等于0：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{r=1}^{n} u^{r}(x, y) & =\lim _{n \rightarrow \infty} \frac{1}{n}\left(\sum_{r=1}^{n} \sum_{k} x_{k}^{r} \log \frac{\bar{x}_{k}}{\bar{y}_{k}}\right)+\lim _{n \rightarrow \infty} \frac{1}{n}\left(\sum_{r=1}^{n} \sum_{k} \bar{x}_{k} \log \frac{y_{k}^{r}}{\bar{x}_{k}}\right) \\
& =\sum_{k}\left(\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{r=1}^{n} x_{k}^{r}\right) \log \frac{\bar{x}_{k}}{\bar{y}_{k}}+\sum_{k} \bar{x}_{k}\left(\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{r=1}^{n} \log \frac{y_{k}^{\prime}}{\bar{x}_{k}}\right) \\
& =\sum_{k} \bar{x}_{k} \log \frac{\bar{x}_{k}}{\bar{y}_{k}}+\sum_{k} \bar{x}_{k} \log \frac{\bar{y}_{k}}{\bar{x}_{k}}=0 .
\end{aligned}</script><p>为了计算说真话均衡中的总分，我们需要用期望信息分的类似表达莱补充期望预测分，说真话均衡意味着最前面计算期望预测分的公式中的$y_k=p(t_k|t_i)$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E\left\{\sum_{k=1}^{m} \bar{x}_{k} \log \frac{y_{k}}{\bar{x}_{k}} \mid t_{i}\right\} & =E\left\{\sum_{k=1}^{m} \omega_{k} \log \frac{p\left(t_{k} \mid t_{i}\right)}{\omega_{k}} \mid t_{i}\right\} \\
& =\int_{\Omega} p\left(\omega \mid t_{i}\right) \sum_{k=1}^{m} \omega_{k} \log \frac{p\left(t_{k} \mid t_{i}\right)}{\omega_{k}} d \omega \\
& =\sum_{k=1}^{m} \int_{\Omega} p\left(\omega, t_{k} \mid t_{i}\right) \log \frac{p\left(t_{k} \mid t_{i}\right)}{\omega_{k}} d \omega \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(t_{k} \mid t_{i}\right)}{\omega_{k}} d \omega \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(t_{k} \mid t_{i}\right) p\left(t_{k} \mid \omega\right)}{p\left(t_{k} \mid \omega\right) p\left(t_{k} \mid t_{i}, \omega\right)} d \omega \\
& =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(\omega \mid t_{i}\right)}{p\left(\omega \mid t_{k}, t_{i}\right)} d \omega \leq 0
\end{aligned}</script><p>这也是对所有$t_k$取平均后，$p(\omega|t_k)$和$p(\omega|t_k,t_i)$的分布之间的相对熵。它测量了通过了解另一个人的意见$k$而产生的$i$对$\omega$的信念的（负数的）熵减。如果了解其他人的回答并不会改变$i$对$\omega$的信念，则期望预测分为0。</p>
<p>在说真话均衡解中，期望总分就是结合了前面的两组公式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E\left\{\frac{\bar{x}_{i}}{\bar{y}_{i}}+\sum_{k=1}^{m} \bar{x}_{k} \log \frac{p\left(t_{k} \mid t_{i}\right)}{\bar{x}_{k}} \mid t_{i}\right\} & =\sum_{k=1}^{m} p\left(t_{k} \mid t_{i}\right) \int_{\Omega} p\left(\omega \mid t_{k}, t_{i}\right) \log \frac{p\left(\omega \mid t_{i}\right)}{p\left(\omega \mid t_{k}\right)} d \omega \\
& =\int_{\Omega} p\left(\omega \mid t_{i}\right) \sum_{k=1}^{m} \omega_{k} \log \frac{p\left(\omega \mid t_{i}\right)}{p\left(\omega \mid t_{k}\right)} d \omega
\end{aligned}</script><p>那么，当人口平均是$\omega$时，支持$i$的人的后验评分为：</p>
<script type="math/tex; mode=display">
\sum_{k=1}^{m} \omega_{k} \ln \frac{p\left(\omega \mid t_{i}\right)}{p\left(\omega \mid t_{k}\right)}=\ln p\left(\omega \mid t_{i}\right)-\sum_{k=1}^{m} \omega_{k} \ln p\left(\omega \mid t_{k}\right)</script><p>第二项是由零和约束决定的常数。由此证明了定理3.</p>
<h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><p><a href="https://wesselb.github.io/assets/write-ups/Bruinsma,%20A%20Bayesian%20Truth%20Serum.pdf" target="_blank" rel="noopener">资料来源</a><br>假设一些人参加了一个带有主观问题的调查。你被要求对这个问题的答案分布做出最佳猜测。作为一个人，你的猜测并非完全不知情：你知道自己对这个调查问题的看法。尽管这个样本可能不能说明人口的分布情况，但它确实构成了一个有效的样本，因此应该说明一些问题；也就是说，在某种程度上，一个人的意见是一个信息丰富的 “一个样本”。</p>
<p>你的最优猜测记作$f$，它由每一个答案的频率组成。与人口群体的平均最优猜测即公共预测$\langle f\rangle$相比，可以预计$f-\langle f\rangle$会在你的意见取最高值，因为与常见的预测不同，你的最佳猜测是由你的意见提供的，尽管是非常轻微的；这种现象在实践中确实被观察到。因此，如果你是一个元理性的贝叶斯代理人，并意识到这种情况，你应该相信你的意见具有最高的概率，比通常预测的更常见。</p>
<p>贝叶斯吐真剂是基于上述现象的。在BTS中，答案的评分标准是衡量一个答案与常见预测值相比有多普遍。事实上，如上所述，从受访者的角度来看，诚实回答就能获得最高分的概率最大。 </p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>除了给出每个问题的回答$x^n$，BTS还要求受访者$n$给出他对该问题答案分布的最优猜测$f^n$，这些随机变量的模型如下图所示，</p>
<p><img src="https://github.com/likun1208/image/blob/master/BTS-1.png?raw=true" alt="BTS模型图"></p>
<p>每一个个体$n$都持有意见$t^n$，我们将$t^n=i$简化表达为$t^n_i$。所有个体的意见都有条件独立，条件是给定潜在变量$\omega$，对于每个个体而言分布都是$p(t_i^n|\omega)=w_i$。此外，给定个体$n$的意见$t^n$，他们会根据回答策略$p(x^n|t^n)$来给出答案$x^n$，我们将$x^n=i$简化表达为$x^n_i$。个体$n$对其他回答$i$的频率预测记作$f^n_i$。需要注意的是，假设存在潜在变量$\omega$使得$p(t^n_i|\omega)=\omega_i$就意味着假设个体意见$t^n$服从一个可交换序列。</p>
<p>一般来说我们讨论哪一个个体都是无所谓的。为了简化，我们省略个体索引，例如$t_i$表示意见为$i$的个体，$x_j$表示回答为$j$的个体，$f_k$表示个体对回答$k$的频率预测为$f_k$。</p>
<p>【记录一下个人理解】BTS的模型应该是指，首先人群中持有的各个意见服从某个潜在分布$\omega$，在此基础上，随便一个受访者的个人意见是$i$的概率就记作$\omega_i$，而根据前文可知，个人意见会对回答和预测产生影响，从而使得受访者得出回答$x^n$和$f^n$，这俩应该都是向量，其中前者是受访者的答案对应的那个向量元素为1，其他都是0，表示他就选了这个答案；后者则是所有元素都小于1并且求和为1，表示后者对每个答案的频率预测，并且这些预测总和应该是1。</p>
<h3 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h3><p>给定回答$x^n$和预测频率$f^n$，BTS的评分为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
S\left(x_{i}, f\right) &=\overbrace{\log \frac{\langle x\rangle_{i}}{\langle f\rangle_{i}}}^{\text {information score }}-\overbrace{\sum_{j}\langle x\rangle_{j} \log \frac{f_{j}}{\langle x\rangle_{j}}}^{\text {prediction penalty }}, \\
\langle x\rangle_{i} &=\text { average of }\left(\mathbb{1}\left(x^{n}=i\right)\right), \\
\langle f\rangle &=\text { geometric average of }\left(f^{n}\right) .
\end{aligned}</script><p>评分函数由两部分组成：</p>
<ol>
<li>信息分衡量的是答案$i$与公共预测相比的常见程度。</li>
<li>预测惩罚形成了真实和预测的答案频率之间的Kullback-Leibler（KL）散度。</li>
</ol>
<p>KL散度描述了我们用分布$Q$来估计数据的真实分布$P$的编码损失。</p>
<p>【记录一下个人理解】对比一下前面的公式，这里信息分那里不太一样，不过仔细分析一下会发现其实是一个意思，就是指【该答案的实际频率（anwser’s actual frequency）】/【所有人对这个答案的预测频率的几何平均(mean of answer’s predicted frequency)】。举个例子，有10个人，其中2个人选了这个答案，大家对这个答案的预测频率都是0.1（姑且这么假设），那信息分就是$log\frac{0.2}{0.1}$。信息分如果大于0（就是说里面的分式大于1），就意味着这个答案是出乎意料受欢迎的（surprissingly common），实际选它的人比大家对它的预测频率要高。</p>
<p>通常来说，如果一个人持有某种意见，那么他会产生偏见，从主观上认为持有该意见的人相对多，也就是说他自己的预测频率会比真实的频率高一些，有点类似信息茧房。从数学上来说，受访者提出的预测实际上是一个条件概率，条件就是他自己的意见，公式表达一下就是$P(我觉得大家有x的概率选A，y的概率选B，z的概率选C，等等|我的意见是B)$。举个例子，关于是否作弊这个问题，$P(你觉得很多人都作弊|你作弊了)&gt;P（你觉得很多人都作弊|你没作弊）$。在这样的情况下，在预测总频率的时候，我们就会想：会有人不选这个答案，他们对这个答案的预测就会低一些。假如一个人本来觉得有20%的人会选这个答案，这样考虑一番之后他就会把自己预测的频率降低一些，比如降到15%。由此，信息分的分母就会变小，而此时这个人的真实意见就是那个出乎意料受欢迎的意见。</p>
<p>如何避免他人发言对偏见的影响</p>
<p>这里参考了<a href="https://www.youtube.com/watch?v=uOIqIeDFpS4" target="_blank" rel="noopener">一个视频</a>，不过感觉这个视频没太讲清楚，没说明白为什么说真话最好。</p>
<p>第二部分预测惩罚那里，是根据个人对所有答案频率的预测与所有答案真实频率的差距来计算的预测分，这个分越大，说明预测偏得越远。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><strong>假设3.1</strong>：可交换性。个体意见$t^n$组成了一个可交换序列。该假设证明了BTS所假设的图形模型的合理性。</p>
<p><strong>假设3.2</strong>：随机相关性。不同意见表示$\omega$的不同先验分布：如果$i\neq j$，则$p(\omega|t_i)\neq p(\omega|t_j)$。该假设是一个技术上的便利，将被用来得出最大化者的唯一性的结论。</p>
<p><strong>假设3.3</strong>：样本量足够大。$\langle x\rangle$和$\langle f\rangle$的方差足够小从而可以用极限来求近似。</p>
<p><strong>定理3.1</strong>：说真话是均衡解。假设一个受访者持有意见$k$、回答$i$和预测$f$，且其他人都如实回答和预测。则该受访者也最好如实回答和预测：</p>
<script type="math/tex; mode=display">
\max _{(i, f)} \mathbb{E}\left(S\left(x_{i}, f\right) \mid t_{k}\right)=\left(k, p\left(t \mid t_{k}\right)\right)</script><p>此外，</p>
<script type="math/tex; mode=display">
\mathbb{E}\left(\text { information score }\left(x_{i}\right) \mid t_{i}\right)=\sum_{j} p\left(t_{j} \mid t_{i}\right) \mathrm{D}_{\mathrm{KL}}\left(p\left(\omega \mid t_{i}, t_{j}\right) \| p\left(\omega \mid t_{j}\right)\right) \text {. }</script><p>证明：如果其他人如实回答和预测，则</p>
<script type="math/tex; mode=display">
\langle x\rangle_{i} \approx p\left(t_{i} \mid \omega\right)=\omega_{i}, \quad \log \langle f\rangle_{i} \approx \sum_{j} p\left(t_{j} \mid \omega\right) \log p\left(t_{i} \mid t_{j}\right)=\sum_{j} \omega_{j} \log p\left(t_{i} \mid t_{j}\right)</script><p>这里$\langle x\rangle_i$是人群中答案$i$的真实频率，如果大家都说真话，那么它应该就约等于那个潜在概率$w_i$。</p>
<p>而$\langle f\rangle_i$是人群对答案$i$的几何平均预测频率，根据几何平均数的公式，取对数后的计算方式就是每个元素取对数然后求和再平均，$p(t_i|t_j)$的含义看起来是说个人意见选$j$的个体对别人选$i$的频率预测，【每一种个人意见会出现的频率】乘log【该意见下的人对答案$i$的频率预测】，符合几何平均预测频率的定义。</p>
<p>信息分仅取决于回答$i$，而预测惩罚仅取决于预测$f$，因此我们可以分开考虑它们。</p>
<p>首先，</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbb{E}\left(\text { information score }\left(x_{i}\right) \mid t_{k}\right) & =\int p\left(\omega \mid t_{k}\right) \sum_{j} p\left(t_{j} \mid \omega\right) \log \frac{p\left(t_{i} \mid \omega\right)}{p\left(t_{i} \mid t_{j}\right)} \\
& =\sum_{j} p\left(t_{j} \mid t_{k}\right) \int p\left(\omega \mid t_{k}, t_{j}\right) \log \frac{p\left(\omega \mid t_{i}, t_{j}\right)}{p\left(\omega \mid t_{j}\right)} \mathrm{d} \omega \\
& \leq \sum_{j} p\left(t_{j} \mid t_{i}\right) \operatorname{D}_{\mathrm{KL}}\left(p\left(\omega \mid t_{i}, t_{j}\right) \| p\left(\omega \mid t_{j}\right)\right)
\end{aligned}</script><p>当且仅当$k=i$时取等号。</p>
<p>第二，</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbb{E}\left(\text { prediction penalty }(f) \mid t_{k}\right) & =\int p\left(\omega \mid t_{k}\right) \sum_{j} p\left(t_{j} \mid \omega\right) \log \frac{f_{j}}{p\left(t_{j} \mid \omega\right)} \frac{p\left(t_{j} \mid t_{k}\right)}{p\left(t_{j} \mid t_{k}\right)} \mathrm{d} \omega \\
& =\int p\left(\omega \mid t_{k}, t_{j}\right) \sum_{j} p\left(t_{j} \mid t_{k}\right) \log \frac{f_{j}}{p\left(t_{j} \mid t_{k}\right)} \frac{p\left(\omega \mid t_{k}\right)}{p\left(\omega \mid t_{k}, t_{j}\right)} \mathrm{d} \omega \\
& \leq-\mathrm{D}_{\mathrm{KL}}\left(f_{j} \| p\left(t_{j} \mid t_{k}\right)\right)-\sum_{j} p\left(t_{j} \mid t_{k}\right) \mathrm{D}_{\mathrm{KL}}\left(p\left(\omega \mid t_{k}, t_{j}\right) \| p\left(\omega \mid t_{k}\right)\right)
\end{aligned}</script><p>当且仅当$f_j=p(t_j|t_k)$时取等号。</p>
<p>定理3.1说明了说真话是贝叶斯纳什均衡。它还表明，讲真话的信息分数，也是最佳的信息分数，衡量的是另一个人的后验分布在得知你的意见后平均变化的程度；这表明专家可能享有更高的预期信息分数。下面的命题表明，讲真话也是最优贝叶斯纳什均衡。</p>
<p><strong>定理3.2</strong>：说真话是最优均衡。说真话的均衡解是最大化期望信息分的均衡。</p>
<p>证明：在任意一个均衡中</p>
<script type="math/tex; mode=display">
\langle x\rangle_{i} \approx p\left(x_{i} \mid \omega\right), \quad \log \langle f\rangle_{i} \approx \sum_{j} p\left(t_{j} \mid \omega\right) \log p\left(x_{i} \mid t_{j}\right)</script><p>则：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\left.\mathbb{E} \text { (information score }\left(x_{i}\right) \mid t_{k}\right) \\
\quad=\sum_{j} p\left(t_{j} \mid t_{k}\right) \int p\left(\omega \mid t_{k}, t_{j}\right) \log \frac{p\left(\omega \mid x_{i}, t_{j}\right)}{p\left(\omega \mid t_{j}\right)} \mathrm{d} \omega \\
\quad=\underbrace{\sum_{j} p\left(t_{j} \mid t_{k}\right) \int p\left(\omega \mid t_{k}, t_{j}\right) \log \frac{p\left(\omega \mid t_{k}, t_{j}\right)}{p\left(\omega \mid t_{j}\right)} \mathrm{d} \omega}_{\text {truth-telling equilibrium }}+\sum_{j} p\left(t_{j} \mid t_{k}\right) \underbrace{\int p\left(\omega \mid t_{k}, t_{j}\right) \log \frac{p\left(\omega \mid x_{i}, t_{j}\right)}{p\left(\omega \mid t_{k}, t_{j}\right)} \mathrm{d} \omega .}_{-\mathrm{D}_{\mathrm{KL}}\left(p\left(\omega \mid t_{k}, t_{j}\right) \| p\left(\omega \mid x_{i}, t_{j}\right)\right) \leq 0}
\end{array}</script><p>最后，在说真话的均衡中，BTS是零和博弈，分数表征了与先验期望频率相比一个答案有多普遍。</p>
<p><strong>定理3.3</strong>：零和博弈。在说真话博弈中，分数在极限时加起来是0：</p>
<script type="math/tex; mode=display">
\sum_{i} p\left(t_{i} \mid \omega\right) S\left(x_{i}, p\left(t \mid t_{i}\right)\right)=0 .</script><p>此外，</p>
<script type="math/tex; mode=display">
S\left(x_{i}, p\left(t \mid t_{i}\right)\right)=\log \frac{\omega_{i}}{\mathbb{E}_{p(\omega)}\left(\omega_{i}\right)}+\operatorname{constant}(\omega) .</script><p>证明：</p>
<script type="math/tex; mode=display">
S\left(x_{i}, p\left(t \mid t_{i}\right)\right)=\sum_{j} p\left(t_{j} \mid \omega\right) \log \frac{p\left(\omega \mid t_{i}\right)}{p\left(\omega \mid t_{j}\right)}=\log p\left(\omega \mid t_{i}\right)-\sum_{j} p\left(t_{j} \mid \omega\right) \log p\left(\omega \mid t_{j}\right)</script>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>trustworthiness</tag>
        <tag>BTS</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Eliciting Thinking Hierarchy without a Prior</title>
    <url>/2022/10/13/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Eliciting%20Thinking%20Hierarchy%20without%20a%20Prior/</url>
    <content><![CDATA[<h1 id="Eliciting-Thinking-Hierarchy-without-a-Prior"><a href="#Eliciting-Thinking-Hierarchy-without-a-Prior" class="headerlink" title="Eliciting Thinking Hierarchy without a Prior"></a>Eliciting Thinking Hierarchy without a Prior</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>针对无法验证答案的众包任务，传统思路：选择大多数人支持的答案</p>
<p>存在问题：大多数人犯系统性错误，会导致最终结果出错</p>
<p>本文希望：在没有任何先验的情况下，在所有答案中建立一个等级制度，使得根据该制度得到的排名较高的答案（可能不被大多数人支持）来自更可靠的人</p>
<p>本文提出：</p>
<ol>
<li><p>一个新的模型来描述人们的思维层次</p>
</li>
<li><p>两种算法来学习没有任何先验的思维层次</p>
</li>
<li><p>一种基于上述理论框架的新的公开回答的众包方法</p>
</li>
</ol>
<p>本文实验：</p>
<ol>
<li><p>本文方法所学习到的排名靠前的答案的准确度远远高于全体投票（在一个问题中，全体投票的答案得到了74名受访者的支持，但正确答案只得到了3名受访者的支持。我们的方法在没有任何先验的情况下将正确答案排在最高位置）</p>
</li>
<li><p>本文模型有很高的拟合度，特别是对于我们排名第一的答案是正确的问题</p>
</li>
</ol>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>群体智慧在面对系统性错误的时候往往会得出错误结果</p>
<p>一个例子：圆A的半径是圆B半径的1/3，圆A绕着圆B转了一圈后回到起点。圆A总共会旋转多少次？</p>
<p><img src="https://github.com/likun1208/image/blob/master/2109.jpg?raw=true" alt="圆圈问题"></p>
<p>根据实验，有11个人认为是1次，8个人选2次，134个人选3次，16个人选4次，27个人选6次，21个人选9次。显然在多数一致的众包任务中，这个题的答案会被认为是3次，但其实正确答案是4次，只有16个人选。</p>
<p>如果事先了解所有受访者的先验水平，我们也许能根据大家的专业水平来确定正确答案，但是在大多数众包场景中，往往没这样的先验知识。</p>
<p>为了解决上述问题，Prelc等人[15]提出了一种创新的方法，他们准备了多个选择，要求受访者挑选一个选项，并预测其他人的选择分布。他们使用预测结果来构建一个关于选择的先验分布，然后选择比先验分布更受欢迎的选择，这样就纠正了偏见（是2017年的nature）。许多其他工作[10, 5, 16]发展了使用先验或预测来纠正偏差的想法。</p>
<p>然而，首先，将以前的方法应用于运行中的例子，即圆圈问题，是不适用的，因为它们需要先验知识来设计选择。让受访者报告所有选择的整体分布也很费力。第二，以前的工作主要是利用预测来纠正偏见，而利用他们的预测来建立一个思维层次是内在的问题。这也导致了答案之间的层次性。著名的认知分层理论（CHT）[21, 22, 3]在人们玩游戏的场景中建立了一个思维理论，这样我们就可以学习不同复杂程度的玩家的行动。然而，CHT只是为游戏理论环境设计的。我们对在一般的问题解决场景中建立一个思维理论感到好奇。该问题的关键在于，水平较高的人知道水平较低的人的想法，但反之则不然[3, 9]。我们想应用这个见解来学习不同复杂程度的人的答案，称为思维层次，而不需要任何先验。</p>
<p><strong>关键问题</strong>：我们的目标是建立一个实用的方法，在没有任何先验的情况下学习思维层次。基于思维层次，我们可以对答案进行排序，这样，排名较高的答案，可能不被大多数人支持，但是来自更可靠的人。</p>
<p>层次性思维方式的优势除了在于选出正确答案以外，还有以下几点：</p>
<ol>
<li><p>一些主观性问题可能有多个高质量答案，完整的层次结构能提供更丰富的结果。</p>
</li>
<li><p>答案的层次性有助于更好地理解人们的思维方式，尤其当我们试图征求人们对某项政策的意见时这一点更重要。</p>
</li>
</ol>
<p><strong>本文方法</strong>：和以往研究一样，让受访者同时写出自己的回答和对其他人答案的预测，并将其扩展到一个更实用的基于开放回答的范式。该范式提出了一个单一的开放回答问题，并要求每个回答者的答案和对其他人的答案的预测。例如，在圆圈问题中，一个回答者可以提供：答案。”4”，预测。”3”。然后我们构建一个答案-预测矩阵A，记录报告特定答案-预测对的人数。（例如，图2（a）显示有28人回答 “3”，预测其他人回答 “6”）。</p>
<p><img src="https://github.com/likun1208/image/blob/master/fig2.png?raw=true" alt="圆圈问题的答案-预测矩阵"></p>
<p>为了学习思维层次，本文提出了一个新颖的模型，它描述了不同复杂程度的人如何回答问题，和预测其他人的答案。回答者的答案和预测的联合分布取决于描述人们思维层次的潜在参数。本文表明，鉴于回答者的答案和预测的联合分布，可以通过解决非负矩阵分解问题的一个新变体来推断潜在的思维层次，该问题被称为非负全等三角化（NCT）。基于对NCT的分析，本文提供了两个简单的答案排序算法，并表明在适当的假设下，给定应答者的答案和预测的联合分布，这些算法将学习潜在的思维层次。</p>
<blockquote>
<p>直接一些来说，就是专业人士不仅能答对，还能知道业余者会犯什么错。</p>
</blockquote>
<p>最后，本文将答案和预测的联合分布表示为答案-预测矩阵，并在该矩阵上实现了基于NCT的答案排序算法。默认的排序算法是使矩阵上三角区域内的元素的平方和最大化，在变体的排序算法中，为了让不同的答案具有相同的复杂程度，答案被分割以压缩矩阵，该算法使压缩后的矩阵的上三角区域的平方和最大化。</p>
<p>在实验方面，进行了包括数学、围棋、常识和字符发音的实证研究。</p>
<p>需要说明的是：在前面那个矩阵图中，因为默认算法不需要用对角线的元素，所以这里对角线上的元素不再是答案-预测的人数，而是选择了这个答案的人数，这样方便和普通的多数一致众包方法做对比，例如那个矩阵里<code>(3,3)</code>对应的134表示有134个人回答了3，而不是说这么多人自己回答3也预测别人回答3。</p>
<h3 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h3><p>先略，以下是从他们公众号的介绍里复制来的内容：</p>
<p>正如前文所言，在没有先验的情况下，很难对这些答案采取支持度以外的排序方式。Prelec [1], Prelec et al. [2] 通过在单选题中额外询问回答者对各个选项分布的预测，进而构造先验信息，并汇总答案为支持度“令人意外地高”的选项，并实验证明该方法比多数决有效。Rothschild and Wolfers [3] 在民调时除了询问“你会选谁”，还额外询问选民“你觉得谁会得到更多的支持”，并实验证明额外信息具有更高的信息量。</p>
<p>类似地，我们采用了一套基于填空题的问卷调查方式：  </p>
<p><strong>“你的答案是？”</strong></p>
<p><strong>“你觉得别人会答什么？”</strong>  </p>
<p>与之前工作不同，在以上框架下，询问者无需任何先验设计选项，回答者无需提供分布信息。针对答案的汇总，Kong and Schoenebeck [4] 提出一个猜想：“专业度高的人可以预测专业度低的答案，反之不然。”  </p>
<p>这个猜想和行为经济学有限理性理论中的等级 k（Level-k）[5] 以及认知等级（Cognitive Hierarchy）[6] 理论相似，都认为人在逻辑思考推理中存在不同的等级。等级 k 和认知等级理论认为高等级知道低等级的存在并采取针对低等级的最优策略。</p>
<h2 id="Learning-Thinking-Hierarchy"><a href="#Learning-Thinking-Hierarchy" class="headerlink" title="Learning Thinking Hierarchy"></a>Learning Thinking Hierarchy</h2><h3 id="Thinking-hierarchy"><a href="#Thinking-hierarchy" class="headerlink" title="Thinking hierarchy"></a>Thinking hierarchy</h3><p>给定一个问题<code>q</code>（例如圆圈问题），<code>T</code>表示思维类型的集合，<code>A</code>表示可能出现的回答的集合，这两个都是有限集，$\Delta_A$表示<code>A</code>的所有可能分布。</p>
<p><strong>Generating answers</strong>：说明不同思维类型的人是如何得出答案的。</p>
<p><strong>定义2.1</strong>：思维类型的预言机<code>W</code>：一个生成答案的预言机（an anwser generating oracle，不太理解这是指生成预言机的答案还是指生成答案的预言机，感觉是后者）将问题映射到集合<code>A</code>中的（随机）答案。每一个类型<code>t</code>都对应了一个预言机$O_t$，$O_t(q)$的输出是一个随机变量，其分布是$w_t\in \Delta_A$。$W$是一个$|T|\times|A|$矩阵，其中每一行是$w_t$。</p>
<p>每一个受访者都有概率$p_t$是类型$t$，且$\sum_t p_t=1$，类型<code>t</code>的受访者通过运行预言机$O_t$得到自己的答案。对于所有$a\in A$，一个受访者回答$a$的概率是$\sum_t p_tw_t(a)$，假设对于所有$a\in A$，概率都是正的。</p>
<p><strong>例2.2（运行示例）</strong>：有两种思维类型$T=\{0,1\}$，回答空间是$A=\{3,4,6\}$，预言机$O_0$有0.8的概率输出3，0.2的概率输出6；$O_1$会直接输出4。在这个例子中，$W=[\begin{matrix}0.8&amp;0&amp;0.2\\0&amp;1&amp;0 \end{matrix}]$，其中第一行是$O_0$的输出，第二行是$O_1$的输出。</p>
<p><strong>Generating predictions</strong>：说明不同思维类型的人会如何预测其他人的回答。这里的预测不是一个分布，而是一个其他人可能会报告的答案。当类型<code>t</code>的受访者预测时，她会运行一个预言机来得到预测结果$g\in A$，该预言机有概率$p_{t\rightarrow t’}$等于$O_{t’}$，其中$\sum_{t’}p_{t\rightarrow t’}=1$。</p>
<p><strong>Combination: answer-prediction joint distribution M</strong>：<code>M</code>表示一个$|A|\times |A|$的矩阵，其中$M_{a,g}$是受访者回答<code>a</code>且预测他人回答<code>g</code>的概率，$\Lambda$表示一个$|T|\times |T|$的矩阵，其中$\Lambda_{t,t’}$是受访者为类型<code>t</code>且预测他人类型<code>t&#39;</code>的概率。</p>
<p><strong>例2.3</strong>：在本例中，当类型<code>0</code>的受访者进行预测时，她会以概率<code>1</code>再次运行预言机$O_0$。当类型<code>1</code>的受访者进行预测时，她会以<code>0.5</code>的概率运行预言机$O_0$，<code>0.5</code>的概率运行预言机$O_1$。且受访者有<code>0.7</code>的概率是类型<code>0</code>，<code>0.3</code>的概率是类型<code>1</code>。则$\Lambda=[\begin{matrix}p_0p_{0\rightarrow 0}&amp;p_0p_{0\rightarrow 1}\\p_1p_{1\rightarrow 0}&amp;p_1p_{1\rightarrow 1}\end{matrix}]=[\begin{matrix}0.7&amp;0\\0.15&amp;0.15\end{matrix}]$</p>
<p><strong>观点2.4</strong>：基于以上生成过程，$M=W^{\top}\Lambda W$。<br><strong>证明</strong>：对于每一个受访者，她回答<code>a</code>且预测<code>g</code>的概率为</p>
<script type="math/tex; mode=display">M_{a, g}=\sum_t p_t \mathbf{w}_t(a) \sum_{t^{\prime}} p_{t \rightarrow t^{\prime}} \mathbf{w}_{t^{\prime}}(g)=\sum_{t, t^{\prime}} \mathbf{w}_t(a) p_t p_{t \rightarrow t^{\prime}} \mathbf{w}_{t^{\prime}}(g)</script><p>我们对所有受访者可能的类型进行求和，假定她的类型为<code>t</code>，则她会运行预言机$O_t$来得到答案，且有概率$w_t(a)$得到答案<code>a</code>。我们对她所有可能为了预测而运行的预言机进行求和，假定她运行$O_{t’}$，则预测为<code>g</code>的概率是$w_{t’}(g)$。</p>
<p>一些补充说明：这里从证明到2.4的过程我其实没完全搞明白，姑且写一下理解：</p>
<p>首先$w_t(a)$就是矩阵<code>W</code>的第<code>t</code>行第<code>a</code>列的元素，中间的$p_tp_{t\rightarrow t’}$是矩阵$\Lambda$的第<code>t</code>行第<code>t&#39;</code>列的元素，最后的$w_{t’}(g)$是第<code>t&#39;</code>行第<code>g</code>列的元素。</p>
<p>接下来回顾一下矩阵相乘的公式：<br>矩阵<code>A</code>和矩阵<code>B</code>相乘得到矩阵<code>C</code>，其计算方法是：</p>
<script type="math/tex; mode=display">
C_{i,j} = \sum_{k=0}A_{i,k}B_{k,j}</script><p>由此可以推导出，三个矩阵连乘法的计算方式：</p>
<script type="math/tex; mode=display">
D_{i,m}=\sum_{j=0}(\sum_{k=0}A_{i,k}B_{k,j})C_{j,m}=\sum_{j=0,k=0}A_{i,k}B_{k,j}C_{j,m}</script><p>回到前面2.4的公式来看，</p>
<script type="math/tex; mode=display">
M_{a, g}=\sum_{t, t^{\prime}} \mathbf{w}_t(a) p_t p_{t \rightarrow t^{\prime}} \mathbf{w}_{t^{\prime}}(g)=\sum_{t, t^{\prime}}W_{t,a}\Lambda_{t,t'}W_{t',g}</script><p>显然，如果能把第一个$W_{t,a}$的行列交换一下，这个公式就可以改写为三个矩阵连乘了，而这恰好就是矩阵转置，即$W_{t,a}=W_{a,t}^\top$。由此，就可以得出$M=W^{\top}\Lambda W$。</p>
<p><strong>关键假设</strong>：上三角(<code>upper-triangular</code>)$\Lambda$. 我们假设，水平较低的人永远无法运行水平较高的预言机。类型$\pi:\lbrace 1,2,3,…,|T| \rbrace \mapsto T$的线性排序将排名位置映射到类型。例如，$\pi(1)\in T$是排序最高的类型。</p>
<p><strong>假设2.5</strong>：我们假设，在类型的适当排序$\pi$下，$\Lambda$是一个上三角矩阵。形式上而言，存在$\pi$使得$\forall i &gt; j, \Lambda_{\pi(i),\pi(j)}=0$。任意能使$\Lambda$为上三角形式的$\pi$都是这些类型的一种有效的思维层次。</p>
<p>在运行示例（例2.2）中，有效的思维层次是$\pi(1)$为类型1，$\pi(2)$为类型0。需要注意的是，在上面的假设中，并不要求$\forall i \leq j, \Lambda_{\pi(i),\pi(j)}&gt;0$，当$\Lambda$为对角矩阵时，类型之间不能相互预测，而且同样复杂，因此任何排序都是有效的思维层次。</p>
<p>给定由未知的<code>w</code>和$\Lambda$生成的<code>M</code>，算法可以寻找其思维层次，并输出矩阵$W^\ast$，它等价于行顺序是有效思维层次的行置换后的<code>W</code>。形式上而言，存在一种有效的思维层次$\pi$使得$W^\ast$的第<code>i</code>行是$W$的第$\pi(i)$行，即$w_i^\ast=w_{\pi(i)}$。</p>
<h3 id="Non-negative-Congruence-Triangularization-NCT"><a href="#Non-negative-Congruence-Triangularization-NCT" class="headerlink" title="Non-negative Congruence Triangularization (NCT)"></a>Non-negative Congruence Triangularization (NCT)</h3><p>在上述模型中，推断思维层次引出了一个新的矩阵分解问题，这个问题类似于对称非负矩阵分解问题(NMF)。</p>
<p><strong>定义2.6</strong>：非负同余三角化(NCT)。给定非负矩阵<code>M</code>，<code>NCT</code>旨在寻找非负矩阵<code>W</code>（是不止一个非负矩阵）和非负上三角矩阵$\Lambda$，使得$M=W^\top\Lambda W$。在一个基于 Frobenius 范数的近似版本中，给定矩阵<code>W</code>的集合，<code>NCT</code>旨在寻找非负矩阵<code>W</code>（是不止一个非负矩阵）和非负上三角矩阵$\Lambda$，从而最小化：</p>
<script type="math/tex; mode=display">\min _{\mathbf{W} \in \mathcal{W}, \boldsymbol{\Lambda}}||\mathbf{M}-\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}||_F^2</script><p>得到的最小值被定义为：<code>M</code>关于$\mathcal{W}$的不适度(lack-of-fit)。</p>
<p>类似NMF，要求结果的严格唯一性是不可能的。令$P_{\Lambda}$表示能使得$\Pi^\top\Lambda\Pi$仍然是上三角的置换矩阵的集合。如果$(W,\Lambda)$是一个解，则当<code>D</code>是所有元素为正数的对角矩阵且$\Pi\in P_\Lambda$时，$(\Pi^{-1}DW, \Pi^\top D^{-1}\Lambda D^{-1}\Pi)$也是一个解。我们将唯一性结果陈述如下，并在附录C中证明。</p>
<p><strong>定理2.7</strong>：唯一性。如果$|T|\leq |A|$，且<code>W</code>的<code>T</code>列包含一个置换正对角矩阵，则$M=W^\top\Lambda W$的<code>NCT</code>是唯一的，因为对于所有的$W’^\top\Lambda’ W’=W^\top\Lambda W$，都存在一个正对角矩阵<code>D</code>和一个$|T|\times |T|$置换矩阵$\Pi\in P_\Lambda$，使得$W’=\Pi^{-1}DW$。</p>
<p>当我们将<code>W</code>限制为半正交时，就可以在不需要寻找最优$\Lambda$的情况下得到<code>NCT</code>的简洁格式。$\mathcal{I}$是所有半正交矩阵<code>W</code>的集合，其中<code>W</code>的每一列有且仅有一个非零元素，且$WW^\top=I$。例如，例2.2中的矩阵<code>W</code>可以被标准化为半正交矩阵，下面的引理来自于 Frobenius 范数的扩展，我们在附录C中进行证明。</p>
<p><strong>引理2.8</strong>：半正交：最小F范数=最大化平方的上三角和。对于所有矩阵$\mathcal{W}\subset \mathcal{I}$的集合，$\min _{\mathbf{W} \in \mathcal{W}, \boldsymbol{\Lambda}}||\mathbf{M}-\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}||_F^2$等价于求解$max_{\mathbf{W} \in \mathcal{W}}\sum_{i\leq j}(\mathbf{W}\mathbf{M}\mathbf{W}^{\top})^2_{i,j}$，且设置$\Lambda$为$Up(\mathbf{W}\mathbf{M}\mathbf{W}^{\top})$，即$\mathbf{W}\mathbf{M}\mathbf{W}^{\top}$的上三角区域。</p>
<p>这里总的来说就是：让回答排名靠前且预测排名靠后的受访者尽量多</p>
<h3 id="Inferring-the-thinking-hierarchy-with-answer-prediction-joint-distribution-M"><a href="#Inferring-the-thinking-hierarchy-with-answer-prediction-joint-distribution-M" class="headerlink" title="Inferring the thinking hierarchy with answer-prediction joint distribution M"></a>Inferring the thinking hierarchy with answer-prediction joint distribution M</h3><p>给定<code>M</code>，推断其思维层次，等价于求解<code>NCT</code>问题。虽然我们并没有<code>M</code>，但我们可以获取其代理。为了简化实际应用，我们基于引理2.8引入了两个简单的排序算法。排序算法以<code>M</code>为输入，输出所有回答的线性排序结果$\pi:\lbrace 1,2,…,|A| \rbrace \mapsto A$，它表示了排序位置到回答的映射。</p>
<p><strong>回答排序算法（默认）</strong>：记作AR(M)，该算法计算</p>
<script type="math/tex; mode=display">
\boldsymbol{\Pi}^* \leftarrow \arg \max _{\Pi \in \mathcal{P}} \sum_{i \leq j}\left(\boldsymbol{\Pi} \mathbf{M} \boldsymbol{\Pi}^{\top}\right)_{i, j}^2</script><p>其中，$\mathcal{P}$是所有$|A|\times |A|$的置换矩阵的集合。对于所有<code>i</code>，在每一个置换矩阵$\Pi$和一个线性顺序$\pi:\Pi_{i,\pi(i)}=1$ 之间都存在一个一对一的映射。因此，最优$\Pi^\ast$会引出所有回答的最优排序，而默认算法也可以表示为：</p>
<script type="math/tex; mode=display">
\pi^* \leftarrow \arg \max _\pi \sum_{i \leq j} M_{\pi(i), \pi(j)}^2</script><p>默认算法隐含假设$|T|=|A|$，且所有预言机都是确定的。为了允许$|T|\leq|A|$和不确定的预言机，我们引入了一个变体，将$\mathcal{P}$推广到半正交矩阵$\mathcal{I}$的一个子集。每一个$|T|\times |A|$的半正交矩阵<code>W</code>表示一个硬聚类，每一类$t\in T$包含了所有使得$W_{t,a}&gt;0$成立的回答。例如，例2.2中的矩阵<code>W</code>可以被标准化为半正交矩阵，并表示一个硬聚类<code>{4},{6,3}</code>。因此，变体算法将把回答划分为多个聚类，并为之分配一个层次结构。</p>
<p><strong>回答排序算法（变体）</strong>：记作$AR^{+}(M,\mathcal{W})$，该算法计算</p>
<script type="math/tex; mode=display">
\mathbf{W}^{*} \leftarrow \arg \max _{\mathbf{W} \in \mathcal{I}} \sum_{i \leq j}\left(\mathbf{W M W}^{\top}\right)_{i, j}^{2}</script><p>其中，$\mathcal{W}\subset \mathcal{I}$。$\mathbf{W}^{\ast}$被标准化为每行之和是1。</p>
<p>$\mathbf{W}^{\ast} \Rightarrow$ Answer rank  输出$\mathbf{W}^{\ast}$表示了所有回答的硬聚类。我们按照如下方式对所有回答进行排序：对于任意$i&lt;j$，聚类<code>i</code>中的回答比聚类<code>j</code>中的回答有着更高的排序。对于所有<code>i</code>，任意两个聚类<code>i</code>中的回答<code>a</code>和<code>a&#39;</code>，如果$W_{i,a}^\ast &gt;W_{i,a’}^\ast$，则<code>a</code>排序高于<code>a&#39;</code>。</p>
<p><strong>理论论证</strong>：当<code>M</code>完全符合模型约束条件，即隐含的<code>W</code>为置换矩阵或硬聚类时，我们的算法就找到了思维层次。否则，我们的算法会找到由 Frobenius 范数度量的“最接近”的解。</p>
<p><strong>定理2.9</strong>：当存在$\Pi_0 \in \mathcal{P}$和非负上三角矩阵$\Lambda_0$使得$\mathbf{M}=\boldsymbol{\Pi}_{0}^{\top} \boldsymbol{\Lambda}_{0} \boldsymbol{\Pi}_{0}$，算法AR(M)可以找到思维层次。一般来说，AR(M)会输出$\boldsymbol{\Pi}^\ast$，其中$\boldsymbol{\Pi}^\ast,\Lambda^\ast = Up(\boldsymbol{\Pi}^\ast M {\boldsymbol{\Pi}^\ast}^\top)$是$\arg \min _{\Pi \in \mathcal{P}, \Lambda}\left|\mathbf{M}-\boldsymbol{\Pi}^{\top} \Lambda \Pi\right|_{F}^{2}$的一个解。把$\mathcal{P}$换成$\mathcal{W}\subset \mathcal{I}$，把AR(M)换成$AR^{+}(M,\mathcal{W})$，上述语句仍然成立。</p>
<p>证明仍然在附录C。</p>
<h3 id="A-proxy-for-answer-prediction-joint-distribution-M"><a href="#A-proxy-for-answer-prediction-joint-distribution-M" class="headerlink" title="A proxy for answer-prediction joint distribution M"></a>A proxy for answer-prediction joint distribution M</h3><p>在实践中，我们没有完美的<code>M</code>。我们使用下面的开放式反应范式来获得<code>M</code>的代理。</p>
<p><strong>回答-预测范式</strong>：受访者会被问两个问题：</p>
<ol>
<li>你的回答是什么？</li>
<li>你认为其他人会回答什么？</li>
</ol>
<p>在圆圈问题中，可能的反馈是：“回答4，预测3”、“回答3，预测6，9，1”等。我们用<code>A</code>表示所有回答的集合。在圆圈问题的例子中，$A=\lbrace 1,2,3,4,6,9 \rbrace$。我们同样允许受访者不进行预测或者预测多个值。</p>
<p><strong>回答-预测矩阵</strong>：我们聚合反馈并通过回答-预测矩阵将其可视化。回答-预测矩阵<code>A</code>是一个$|A|\times |A|$的方阵，其中$|A|$是受访者提供的不同答案的数量。每一项$A_{a,g}, a,g\in A$是回答<code>a</code>且预测<code>g</code>的受访者的数量。</p>
<p>我们将证明，在适当的假设下，回答-预测矩阵<code>A</code>的期望与<code>M</code>成正比。首先，为了便于分析，我们假设每个受访者的预测都是独立样本。其次，由于我们允许人们有选择地提供预测，因此我们还需要假设每个受访者愿意提供的预测数量与她的类型和答案无关。我们将形式化的结果陈述如下，并在附录 C中进行证明。</p>
<p><strong>定理2.10</strong>：当每一个受访者的预测都是独立样本，并且她给出的预测数量与她的类型和答案无关时，回答-预测矩阵<code>A</code> 的期望与<code>M</code>成正比。</p>
<h2 id="Studies"><a href="#Studies" class="headerlink" title="Studies"></a>Studies</h2><p>我们进行了四组研究，分别是：研究1(35道数学题) ，研究2(30道围棋题) ，研究3(44道常识题)和研究4(43道汉字发音题)。</p>
<p><strong>数据收集</strong>：通过在线众包平台发送调查问卷来收集数据，所有受访者被要求不能上网搜索或者与其他人交流，受访者可以填写“我不知道”这样的答案。除围棋问题以外，所有问卷采用定额支付的方式，具体过程在附录A。允许受访者参加多个研究，因为算法分别独立计算每一个问题。</p>
<p><strong>数据处理</strong>：合并等价的答案，例如0.5和50%。忽略那些选择人数小于等于3%或者只有一个人选择的答案。剩下的答案包括“我不知道”共同组成了大小为$|A|$的回答集合。接下来构建回答-预测矩阵并执行算法，伪代码在附录B。本文算法不要求任何先验知识或受访者的专业水平。</p>
<h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p>基线算法：投票，即多数一致方案</p>
<p>对比结果：本文的两种算法都比基线算法好</p>
<p>152个问题中，有138个问题变体算法和默认算法得出了相同的思维层次。其他问题中，变体算法得到的排名靠前的答案可能有不止一个。有一个问题，变体算法得到的答案是错的，而默认算法得到的是正确的。</p>
<p>我们同样计算了算法的不适度指标，发现那些算法能输出正确答案的问题都有着低不适度，进而更符合思维层次模型。因此我们可以用不适度作为算法可靠性的指标。</p>
<p>我们还从每个研究中都选取了几个代表性的例子，其矩阵采用默认算法进行排列，对角线区域修改为例1.1所示。所有例子中，多数一致方案得到的答案是错的，而本文算法得到的答案是对的。其他问题的答案在<a href="https://elicitation.info/classroom/1/" target="_blank" rel="noopener">这个网站</a>上有展示。</p>
<p>选出来的题和对应的矩阵如下：</p>
<ol>
<li>Monty Hall 问题（三门问题）：在三个关闭的门中任选一个打开，三个中有一个门后面是车，两个门后面是山羊。当你选好一个以后，Monty Hall会把剩下两个门中的一个打开，并展示说明这个门后面是山羊，然后问你是否要改选另一个门。那么如果你改选了，则你得到车的概率是多少？<br> <img src="https://github.com/likun1208/image/blob/master/ETHP-1.png?raw=true" alt="三门问题"></li>
<li>出租车问题：这个城市85% 的出租车是绿色的，其他的都是蓝色的。一个目击者看到一辆蓝色的出租车。她通常正确的概率是80% 。目击者看到的出租车确实是蓝色的概率是多少？<br> <img src="https://github.com/likun1208/image/blob/master/ETHP-2.png?raw=true" alt="出租车问题"><br> 说明：这里论文插入的矩阵可能有错，我在数据网站上找到了它的正确矩阵，如下图：<br> <img src="https://github.com/likun1208/image/blob/master/ETHP-9.png?raw=true" alt="出租车问题矩阵"></li>
<li>为黑棋选择一步能使其活下来的走法<br> <img src="https://github.com/likun1208/image/blob/master/ETHP-3.png?raw=true" alt="围棋死活题1"></li>
<li>为黑棋选择一步能使其活下来的走法（原文最后的ko不清楚是指活下来并取胜，还是打错了）<br><img src="https://github.com/likun1208/image/blob/master/ETHP-4.png?raw=true" alt="围棋死活题2"></li>
<li>边界问题：中国和朝鲜交界处的河流是什么？<br> <img src="https://github.com/likun1208/image/blob/master/ETHP-5.png?raw=true" alt="常识题1"></li>
<li>中世纪新年问题：中世纪时期新年是哪天？<br> <img src="https://github.com/likun1208/image/blob/master/ETHP-6.png?raw=true" alt="常识题2"></li>
<li>“睢”这个字的读音是什么？<br> <img src="https://github.com/likun1208/image/blob/master/ETHP-7.png?raw=true" alt="汉字读音题1"></li>
<li>“滂”这个字的读音是什么？<br> <img src="https://github.com/likun1208/image/blob/master/ETHP-8.png?raw=true" alt="汉字读音题2"></li>
</ol>
<p>根据这些实验，有以下发现：</p>
<ol>
<li>本文方法能够得到丰富的思维层次，例如在出租车问题中，过往研究认为人们通常会忽略基本比例而报告 “80%”，设想中的层次可以是<code>41%, 80%</code>，而本文则发现了更丰富的思维层次：<code>41%, 50%, 80%, 12%, 15%, 20%</code>。（这里都是按思维水平从专业到普通再到离谱排序的）</li>
<li>最专业的思维水平可能没法预测最离谱的思维水平。例如在出租车问题中，回答了<code>41%</code>的专业人士能预测到常见的错误回答<code>80%</code>，却没法预测到<code>12%, 15%</code>这样比较离谱的回答。反之，回答了<code>80%</code>的普通人却预测到了这种离谱答案。</li>
<li>对于没有明显错误的问题（例如围棋），本文方法仍然有效。</li>
<li>在边界问题中，只有3个人回答了正确答案，但我们的算法仍然在没有任何先验的情况下选出了这个正确答案。</li>
</ol>
<p>上述例子是多数一致方案出错的。在一些多数一致方案正确的问题中，本文算法也能得出更丰富的思维层次。例如，一个题目问：唐太宗李世民什么时候登基？出于启发效应，还补充了一句是大于50岁还是小于50岁？这个题目要求回答年龄，多数一致方案和本文算法都能得出正确答案（28岁）。本文算法得出的思维层次是<code>28,27,30,35,40,50</code>，可以看出来，使用了锚定与调整性法则的回答被本文算法排到了后面，因为其思维层次较简单。</p>
<p>在我们的研究中，人们犯了一些系统性的错误，比如做了一个错误的统计假设(三门问题的“1/2”) ，忽略了基准率(出租车的“80%”) ，使用了可得性启发法，即依赖于易于搜索的记忆(“鸭绿江”，“ Songhua River”，“ju1”，“12月25日，1月1日”) ，回答了一个更容易的替代问题(使用贪婪的动作或看起来优雅的动作，发音成分) ，以及使用锚定与调整性法则(“40,50”李世民问题)[24]。重要的是，我们的实验结果表明，在没有任何先验的情况下，我们的算法将这些错误标记为不那么复杂的思维类型。</p>
<h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p><strong>本文算法什么情况下出错</strong>：</p>
<ol>
<li>一些复杂问题，我们没法从任何人那里得到正确答案。</li>
<li>一些回答空间很少的问题，例如只能回答<code>yes</code>或<code>no</code>，每个人都不需要专业知识就能很容易猜到其他人的回答。</li>
<li>不适用于人们同意不同意的情况，因为人们能预测出其他人的回答，但仍然坚持己见。例如在问题“中国古代从哪个朝代开始把最高统治者称为<code>王</code>？”这个问题得出的矩阵如下：<br><img src="https://github.com/likun1208/image/blob/master/ETHP-10.png?raw=true" alt="不合适的问题"><br>正确答案是商，但本文算法排序把周放到了第一位，这可能是因为我们平常总把“夏商周”放到一起提，所以每个人都能猜出来别人的回答，而无需专业知识。如前文所说，可以用不适度来衡量算法是否能找出正确答案。</li>
</ol>
<p><strong>部分顺序与DAG</strong>：我们观察到，在我们的研究中，最专业的人可能不知道最离谱的人的思想。一个潜在的原因是，最专业的人数量很少。另一个潜在的原因是人们有认知限制，他们可能需要大量的努力来推理那些专业程度与他们相去甚远的人。未来的发展方向是通过多种实验来探究其原因。</p>
<p><strong>激励与对手</strong>：本文没考虑激励和奖励设计。同时如果模型中存在对手，对手能比多数一致方案更容易地操控本文的算法。因此未来研究方向一方面是引入激励，另一方面是考虑对手的存在，增加模型稳定性。</p>
<p><strong>开放性问题</strong>：前文所述实验都是已经有确切答案的问题，或虽然是开放性问题，但答案空间由潜在的文字片段或数字组成，我们进一步针对没有确切答案的开放性问题进行了实验，将本文方法扩展到从人群中获取主观意见的场景，例如“为什么酒吧的椅子很高”。这里的关键挑战是自动对人们的意见进行分类，一个可能的方向是与学习算法相结合，另一个挑战是验证得出的层次结构。我们在北大的一个班级里问了酒吧椅子这个问题，并手动统计。回答人数最多的是“因为酒吧柜台很高”，而本文算法排名第一的是“与站着的人有更好的目光接触”。看起来，后者会导致前者进而导致提问中的“椅子很高”，所以本文算法能得到一个更为根本性的回答。</p>
<p><strong>总结</strong>：</p>
<ol>
<li>本文提出了思维层次模型和无先验情况下寻找思维层次的方法</li>
<li>实验说明本文方法的优越性</li>
<li>方法可用于众包的语音识别，图像描述，植物物种识别等</li>
</ol>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><h4 id="默认算法"><a href="#默认算法" class="headerlink" title="默认算法"></a>默认算法</h4><ol>
<li>总体思路是挨个看哪种顺序得到的上三角平方和最大</li>
<li>利用了动态规划的思想，先把矩阵拆成2维的，看2维情况下怎么排列最合适，然后在每一个2维的左上增加三维，看3维怎么排列最合适。</li>
</ol>
<p>这个过程如下图所示：<br><img src="https://github.com/likun1208/image/blob/master/ETHP-11.png?raw=true" alt="默认算法示意图"></p>
<h4 id="变体算法"><a href="#变体算法" class="headerlink" title="变体算法"></a>变体算法</h4><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><h4 id="引理2-8的证明"><a href="#引理2-8的证明" class="headerlink" title="引理2.8的证明"></a>引理2.8的证明</h4><p><strong>引理2.8</strong>：半正交：最小F范数=最大化平方的上三角和。对于所有矩阵$\mathcal{W}\subset \mathcal{I}$的集合，$\min _{\mathbf{W} \in \mathcal{W}, \boldsymbol{\Lambda}}||\mathbf{M}-\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}||_F^2$等价于求解$max_{\mathbf{W} \in \mathcal{W}}\sum_{i\leq j}(\mathbf{W}\mathbf{M}\mathbf{W}^{\top})^2_{i,j}$，且设置$\Lambda$为$Up(\mathbf{W}\mathbf{M}\mathbf{W}^{\top})$，即$\mathbf{W}\mathbf{M}\mathbf{W}^{\top}$的上三角区域。</p>
<script type="math/tex; mode=display">
\begin{array}{l}
||\mathbf{M}-\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}||_F^2 &= Tr((\mathbf{M}-\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W})(\mathbf{M}^\top-\mathbf{W}^{\top} \boldsymbol{\Lambda}^\top \mathbf{W}))\\
& = ||\mathbf{M}||_F^2-Tr(\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}\mathbf{M})-Tr(\mathbf{M}\mathbf{W}^{\top} \boldsymbol{\Lambda}^\top \mathbf{W})+Tr(\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W} \mathbf{W}^{\top} \boldsymbol{\Lambda}^\top \mathbf{W})\\
& = ||\mathbf{M}||_F^2-2Tr(\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}\mathbf{M})+Tr(\mathbf{W}^{\top} \boldsymbol{\Lambda}\boldsymbol{\Lambda}^\top \mathbf{W})\\
& = ||\mathbf{M}||_F^2-2Tr(\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}\mathbf{M})+||\boldsymbol{\Lambda}||_F^2
\end{array}</script><p>接下来，</p>
<script type="math/tex; mode=display">
\begin{array}{l}
||\boldsymbol{\Lambda}-\mathbf{WMW^\top}||_F^2 &=Tr((\boldsymbol{\Lambda}-\mathbf{WMW^\top})(\boldsymbol{\Lambda}^\top-\mathbf{WM^\top W^\top}))\\
&= ||\boldsymbol{\Lambda}||_F^2-2Tr(\mathbf{\Lambda WM^\top W^\top})+||\mathbf{WMW^\top}||_F^2
\end{array}</script><p>需要注意的是：$Tr(\mathbf{\Lambda WM^\top W^\top})=Tr(\mathbf{W^\top \Lambda WM^\top })$，由此可得：</p>
<script type="math/tex; mode=display">
||\mathbf{M}-\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}||_F^2 = ||\boldsymbol{\Lambda}-\mathbf{WMW^\top}||_F^2 -||\mathbf{WMW^\top}||_F^2+||\mathbf{M}||_F^2</script><p>因此，</p>
<script type="math/tex; mode=display">
\underset{\mathbf{W}, \boldsymbol{\Lambda}}{\arg \min }\left\|\mathbf{M}-\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}\right\|_{F}^{2}=\underset{\mathbf{W}, \boldsymbol{\Lambda}}{\arg \min }\left\|\boldsymbol{\Lambda}-\mathbf{W} \mathbf{M} \mathbf{W}^{\top}\right\|_{F}^{2}-\left\|\mathbf{W} \mathbf{M} \mathbf{W}^{\top}\right\|_{F}^{2}</script><p>最优上三角矩阵$\boldsymbol\Lambda^\ast$ 应该是$\mathbf{W} \mathbf{M} \mathbf{W}^{\top}$的上三角部分，即，对于所有$i\leq j$，$\Lambda_{i,j}^\ast=\mathbf{W} \mathbf{M} \mathbf{W}^{\top}_{i,j}$。当$\Lambda$取最优时，$||\boldsymbol{\Lambda}^{*}-\mathbf{W M W}^{\top}||_{F}^{2}-||\mathbf{W M W}^{\top}||_{F}^{2}$就等于$-\sum_{i\leq j}(\mathbf{W M W}^{\top})_{i,j}^2$。因此，$\min _{\mathbf{W} \in \mathcal{W}, \boldsymbol{\Lambda}}||\mathbf{M}-\mathbf{W}^{\top} \boldsymbol{\Lambda} \mathbf{W}||_F^2$等价于求解$max_{\mathbf{W} \in \mathcal{W}}\sum_{i\leq j}(\mathbf{W}\mathbf{M}\mathbf{W}^{\top})^2_{i,j}$。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>crowdsourcing</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Using game theory to thwart multistage privacy intrusions when sharing data</title>
    <url>/2022/09/23/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Using%20game%20theory%20to%20thwart%20multistage%20privacy%20intrusions%20when%20sharing%20data/</url>
    <content><![CDATA[<h1 id="Using-game-theory-to-thwart-multistage-privacy-intrusions-when-sharing-data"><a href="#Using-game-theory-to-thwart-multistage-privacy-intrusions-when-sharing-data" class="headerlink" title="Using game theory to thwart multistage privacy intrusions when sharing data"></a>Using game theory to thwart multistage privacy intrusions when sharing data</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>问题：针对个人的生物医学数据共享引起的隐私问题，尤其是匿名记录的再识别</p>
<p>思路：再识别风险评估框架</p>
<p>常规方法：数据接收者只使用一种资源</p>
<p>存在问题：攻击者可以访问多种资源来增加攻击成功率</p>
<p>本文方法：构建完全信息双人Stackelberg博弈模型来表示再识别博弈，提出基于隐私-效用权衡的最优数据共享策略</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>背景：生物医学数据共享有很大好处，但带来隐私问题</p>
<p>面临的问题：针对匿名生物医学数据的再识别攻击</p>
<ol>
<li><p>简化的攻击模型会导致隐私风险被高估或低估；</p>
</li>
<li><p>攻击逐渐从过去的单阶段（将去除标识符的数据库与没有去除标识符的数据库通过一些共有属性链接起来）转变为现在的多阶段（每阶段披露目标个体的一部分信息）</p>
</li>
</ol>
<p>本文：通过明确建模和量化数据主体在面对多阶段攻击时的隐私-效用权衡来评估和战略性地减轻风险，弥补了更复杂的攻击模型和数据共享决策之间的差距。</p>
<p>攻击模型：Gymrek提出的两阶段攻击——针对基因组计划数据库的姓氏推断与进一步的其他数据库链接推断</p>
<p>现有方法：</p>
<ol>
<li><p>从监管和技术两个角度出发</p>
</li>
<li><p>关注最坏的情况——影响不明确</p>
<ol>
<li><p>不考虑攻击成本——高估隐私风险</p>
</li>
<li><p>没有测量参数影响就设置参数——牺牲数据效用</p>
</li>
</ol>
</li>
<li><p>由此出现了引入博弈论的风险评估</p>
</li>
</ol>
<p>本文：</p>
<ol>
<li><p>博弈论模型可以向数据主体揭示最佳的共享策略</p>
</li>
<li><p>使用真实世界的数据集或大规模模拟数据集进行反多阶段攻击的实验</p>
</li>
<li><p>博弈论模型可以有效地评估和有效地减轻隐私风险</p>
</li>
<li><p>模型所推荐的细粒度共享策略可以最大限度地减少数据主体被成功再识别的可能性，同时最大限度地提高数据效用，并保持发布的数据集的有效性和数据共享过程的公平性</p>
</li>
</ol>
<h2 id="Materials-and-Methods"><a href="#Materials-and-Methods" class="headerlink" title="Materials and Methods"></a>Materials and Methods</h2><p>研究场景：数据主体选择在公共库中分享多少主体的基因数据</p>
<p>研究目标：决定主体的最优共享策略，平衡数据共享带来的经济效益与再识别风险</p>
<p>再识别风险来源：</p>
<ol>
<li><p>有动机和手段试图确定匿名共享数据集中的主体身份的人</p>
</li>
<li><p>已经向公众提供的关于主体的其他数据</p>
</li>
</ol>
<p>攻击模型：Gymrek攻击</p>
<ol>
<li><p>第一阶段：根据目标基因库和遗传族谱数据库进行姓氏推断</p>
</li>
<li><p>第二阶段：将姓氏推断结果和公共数据库进行链接，从而确定数据主体的身份</p>
</li>
</ol>
<p>博弈模型：Stackelberg 博弈 或 leader-follower 博弈</p>
<ol>
<li><p>假设数据主体和攻击者对攻击成功的概率有相同的信念</p>
</li>
<li><p>数据主体作为leader，选择共享多少数据</p>
</li>
<li><p>攻击者作为follower，选择是否进行再识别攻击</p>
</li>
<li><p>攻击者不知道被隐藏的信息，只能估计成功的概率，而数据主体则掌握更多信息</p>
</li>
</ol>
<p>主体决策：$s=\langle s_1,…,s_j,…,s_m \rangle \in B^m$ 表示要共享的数据，其中<code>m</code>是记录中的属性数量，如果第<code>j</code>个属性被隐藏，则$s_j=0$，反之如果第<code>j</code>个属性被共享，则$s_j=1$</p>
<p>攻击者决策：$a\in \{0,1\}$表示是否进行再识别攻击，<code>a=1</code>表示攻击，<code>a=0</code>表示不攻击</p>
<p>对手攻击方式：两阶段Gymrek攻击，可以有更多个阶段，每阶段推断出一些新的信息</p>
<p>博弈过程：主体（leader）先决定自己的策略<code>s</code>，攻击者（follower）观察数据并基于此决定是否攻击，即攻击者的策略是主体策略的函数</p>
<p>引入新的符号和假设：</p>
<ol>
<li><p>$b(s)$表示策略<code>s</code>为主体带来的经济效益，公开信息，假设该函数非递减</p>
</li>
<li><p>如果一个记录成功被再识别，假设该主体损失<code>L</code>，攻击者获得<code>L</code></p>
</li>
</ol>
<p>攻击成功的概率取决于数据主体采取的策略，数据主体对这个概率以及再识别风险比攻击者更清楚，攻击者只能大致估计。</p>
<p>首先，假设数据主体和攻击者对每个策略分配的成功率都相同，记作$p(s)$。在已知$p(s)$的情况下，数据主体和攻击者可以最大化各自的期望收益。</p>
<p>然后，将期望收益视作真实收益，可得完美信息下的Stackbelberg博弈，并研究均衡。</p>
<p>数据主体的期望收益函数：$v_d(s,a)=b(s)-Lp(s)a$</p>
<p>攻击者的收益函数：$v_a(s,a)=(Lp(s)-C)a$</p>
<p>其中，<code>C</code>是攻击者的攻击成本</p>
<ol>
<li><p>如果攻击者不攻击则其收益为0</p>
</li>
<li><p>可以通过重定义$b(s)$和重识别$p(s)$将该模型推广到其他数据共享的场景中</p>
</li>
</ol>
<p>令$\phi(s)=\{a|(Lp(s)-C)a\geq(Lp(s)-C)(1-a)\}$，函数$\phi(s)$表示攻击者针对主体策略<code>s</code>的最优策略</p>
<p>均衡解对应的主体优化问题：$max_{s,a\in\phi(s)}b(s)-Lp(s)a$</p>
<p>主体求解方法：逆向归纳法——先计算攻击者对所有可能策略<code>s</code>的最优对策$\phi(s)$，然后选择自己的最优策略。</p>
<p>该方法问题：数据主体掌握了完整的数据，因此他们可以计算再识别概率$p(s)$，而攻击者则不能。</p>
<p>解决方法：攻击者使用再识别概率的估计值，记作$\hat{p}(s)$，并以此计算自己的收益和最优对策函数。数据主体同样可以用估计值来计算攻击者的策略，但他们会随后用真实的再识别风险概率计算自己的最优选择。</p>
<p>总结一下：攻击者和数据主体都可以用$\hat{p}(s)$来估计计算$\phi(s)$，记作$\hat\phi(s)=\{a|(L\hat{p}(s)-C)a\ge(L\hat{p}(s)-C)(1-a)\}$，在得到攻击者最优策略后，数据主体使用真实概率计算自己的最优策略$max_{s,a\in\hat\phi(s)}b(s)-Lp(s)a$。</p>
<blockquote>
<p>说明：利用了Stackelberg博弈中leader只能做一次决策这一特点，使得该方法可以在计算过程中使用不同的再识别风险概率函数。</p>
</blockquote>
<p>在两阶段攻击中，给定主体策略<code>s</code>，第一阶段攻击成功概率$p_1(s)$、在一阶段攻击成功基础上的第二阶段攻击成功概率$p_2(s)$、攻击者估计的一阶段成功概率$\hat{p}_1(s)$、攻击者估计的忽略一阶段情况下二阶段成功概率$p’(s)$的计算方式如下：</p>
<script type="math/tex; mode=display">
p(s)=p_1(s)p_2(s)a'(s)+p'(s)(1-a'(s))    \\
\hat{p}(s)=\hat{p}_1(s)p_2(s)a'(s)+p'(s)(1-a'(s))\\
a'(s)=\left\{
\begin{aligned}
1,\hat{p}_1(s)p_2(s) > p'(s)\\
0, \hat{p}_1(s)p_2(s)\le p'(s)
\end{aligned}
\right.</script><p>如果一阶段攻击更好，则$a’(s)$为1，反之则为0. 上面几个参数的具体值取决于攻击模型和攻击中用的数据集。</p>
<p>由此，如果$a’(s)$为1，优化问题可以表达为：</p>
<script type="math/tex; mode=display">
max_{s,a\in\hat{\phi}(s)}b(s)-Lp_1(s)p_2(s)a</script><p>其中，$\hat\phi(s)=\{a|(L\hat{p}_1(s)p_2(s)-C)a\ge(L\hat{p}_1(s)p_2(s)-C)(1-a)\}$</p>
<p>详细推公式过程在附录，稍后再看。</p>
<blockquote>
<p>所有的参数都可以根据用例进行合理的设置。具体来说，它们可以根据特定的数据集、攻击模型或受试者提供的估价进行调整。此外，正如结果所示，广泛的敏感性和稳健性分析（即压力测试）可以帮助验证参数设置对环境或主体知识的不确定性的敏感性和稳健性。</p>
</blockquote>
<p>选择进入博弈：在一些情况，数据主体只有两种选择：加入并完全共享信息 或者 退出不共享任何信息。这样的场景可以由前文定义的博弈来刻画，其数据主体的策略被限制为两个选项：完全共享$s=<1,...1>$和完全不共享$s=<0,...0>$。</p>
<p>遍历求解博弈耗时多，附录中介绍了可以用于加速求解的算法，稍后再看。</p>
<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><h3 id="Experimental-design"><a href="#Experimental-design" class="headerlink" title="Experimental design"></a>Experimental design</h3><p>分别在真实数据集和仿真数据集上进行实验，后者更大一些</p>
<p>在基因数据集<code>D</code>中共享数据的<code>n</code>个数据主体的平均收益：$\overline{V}=\sum_{i=1}^{n}V_i$，其中$V_i$表示第<code>i</code>个数据主体的最优收益</p>
<p>平均数据效用：$\overline{U}=\sum_{i=1}^{n}U_i$</p>
<p>主体平均隐私：$\overline{P}=\sum_{i=1}^{n}P_i$</p>
<p>第<code>i</code>个数据主体的数据效用：$U_i=b(s_i^\ast)/B$，即部分共享带来的收益除以完全共享带来的收益</p>
<p>第<code>i</code>个数据主体的隐私：$P_i=1-p(s_i^\ast)a_i^\ast$，即1减去隐私风险（被成功攻击的概率）</p>
<p>第<code>i</code>个数据主体的最优收益：$V_i=v_d(s_i^\ast, a_i^\ast)=BU_i-L(1-P_i)=BU_i+LP_i-L$，即数据效用和隐私的线性组合，其中，<code>L</code>是再识别成功带来的损失。</p>
<blockquote>
<p>作为有效性的主要衡量标准，这些主体的平均报酬与效用和隐私的衡量标准呈正相关。</p>
</blockquote>
<p>实验设置：20个模拟数据属性，4个博弈场景，4个baseline场景，8种数据保护情况</p>
<p>攻击者目标：在理性权衡攻击收益的基础上，尽可能再识别数据集<code>D</code>中的所有数据。</p>
<p>8种情况的简要说明：</p>
<ol>
<li><p>no protection：无保护，数据集<code>D</code>中的每个主体都共享其数据记录中的所有属性</p>
</li>
<li><p>demographics only：数据集<code>D</code>中的每个主体仅共享人口统计学属性</p>
</li>
<li><p>random opt-in：数据集<code>D</code>中的每个主体根据实际设置，以一定的概率随机决定共享整个数据记录</p>
</li>
<li><p>random masking：数据集<code>D</code>中的每个主体随机决定以固定的概率分享其数据记录中的每个属性</p>
</li>
<li><p>opt-in game：主体只能决定选择加入共享整个数据记录或选择退出</p>
</li>
<li><p>masking game：主体可以在共享前隐藏一部分数据</p>
</li>
<li><p>no-attack masking game：假设主体不选择任何会使对手攻击的策略</p>
</li>
<li><p>one-stage masking game：假设攻击只有一阶段，二阶段的那个数据集不可用</p>
</li>
</ol>
<p>评估在每种情况下采用的数据保护/共享策略的效果：有用性和公平性</p>
<ol>
<li><p>数据共享方案的有用性是基于共享数据和未受保护数据的分布之间的距离（详见附录S7）。</p>
</li>
<li><p>数据共享方案的公平性（例如，有用性方面的公平性或隐私方面的公平性）是基于每个人口群体对应的具体措施的基尼系数（详见附录S8）。</p>
</li>
</ol>
<h3 id="Experiments-based-on-a-large-scale-simulated-population"><a href="#Experiments-based-on-a-large-scale-simulated-population" class="headerlink" title="Experiments based on a large-scale simulated population"></a>Experiments based on a large-scale simulated population</h3><p>这部分是针对大规模仿真数据的实验</p>
<p>从平均收益来看有以下结论：</p>
<ol>
<li><p>受试者的平均收益在没有保护的情况下是最低的，在有掩膜的博弈中是最高的。</p>
</li>
<li><p>与选择进入博弈相比，受试者的平均收益在掩膜博弈中得到了很大的改善。说明在数据共享过程中提供某种程度的细化选择的基本优势之一。</p>
</li>
<li><p>当攻击者使用较少的数据资源，从而在攻击中保持较少的阶段时，掩膜博弈效果更好。</p>
</li>
<li><p>无论是共享所有的数据还是只分享人口统计资料，或者是一个随机的策略，都会给受试者带来负的或可忽略的平均回报。</p>
</li>
</ol>
<p>从效用与隐私的结合看有以下结论：</p>
<ol>
<li><p>与其他情况相比，掩膜博弈能同时实现高效用和高隐私</p>
</li>
<li><p>受试者在无攻击掩膜博弈中的策略在大量共享数据的情况下保证了完全的隐私保护</p>
</li>
<li><p>当攻击只有一个阶段时，还能实现稍高的数据效用水平</p>
</li>
<li><p>与掩膜博弈相比，随机选择加入场景和随机掩膜场景给受试者带来了类似的隐私水平，但数据效用的水平却低得多</p>
</li>
<li><p>相比之下，与选择加入游戏相比，纯人口统计学方案给受试者带来类似的效用水平，但隐私水平较低</p>
</li>
<li><p>与无保护方案的结果相比，纯人口统计学方案总是为主体提供高得多的隐私水平，这突出了Gymrek攻击中姓氏推理阶段的力量</p>
</li>
<li><p>在博弈论的保护下，姓氏推断阶段的力量可以减少到最低限度，这一点从掩膜博弈和它的单阶段变化之间的差异可以看出</p>
</li>
</ol>
<p>其他实验现象就不细看了，总结下来都是说掩膜博弈在效用、公平性、有用性这几方面更好。</p>
<p>还分析了后向归纳和剪枝贪婪在不同场景的计算效率。</p>
<h3 id="Sensitivity-and-robustness-analyses-on-parameters-and-settings-based-on-simulated-datasets"><a href="#Sensitivity-and-robustness-analyses-on-parameters-and-settings-based-on-simulated-datasets" class="headerlink" title="Sensitivity and robustness analyses on parameters and settings based on simulated datasets"></a>Sensitivity and robustness analyses on parameters and settings based on simulated datasets</h3><p>这部分仍然是大规模仿真数据，分析了在攻击成本、数据集记录数和再识别成功数这三方面的敏感性和稳定性。</p>
<p>实验设置：8个场景，11组实验，针对不同的参数使用不同的测试集进行了20次实验</p>
<p>实验结论：掩膜博弈更好</p>
<p>一些其他与各参数相关的实验不记录了，与博弈无关，更偏向生物医学</p>
<p>此外，分析了少数人支持系数，说明了掩膜博弈在公平性方面同样优秀</p>
<h3 id="Experiments-based-on-Craig-Venter’s-data-and-the-Ysearch-dataset"><a href="#Experiments-based-on-Craig-Venter’s-data-and-the-Ysearch-dataset" class="headerlink" title="Experiments based on Craig Venter’s data and the Ysearch dataset"></a>Experiments based on Craig Venter’s data and the Ysearch dataset</h3><p>这部分是真实数据集的实验，同样说明了掩膜博弈更好。</p>
<h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>本文：针对再识别攻击，为数据主体提供共享策略</p>
<p>发现：</p>
<ol>
<li><p>额外阶段会增加再识别的准确率，但同样更有利于我们通过博弈的方式反攻击，因为可以误导攻击者从而使其推断出错误的中间信息，从而减轻隐私风险。</p>
</li>
<li><p>如果数据库不允许进行部分数据共享（即：只能加入并完全共享或者退出），大多数理性的数据主体会选择退出；反之，如果允许部分共享，则大多数主体愿意共享大部分数据，这表明向主体提供选择可以鼓励更大程度的数据共享，同时避免再识别。</p>
</li>
<li><p>本文方案使得主体可以选择共享大量数据，获取高收益，同时不会面临再识别风险。</p>
</li>
<li><p>敏感性分析说明了参数对主体策略的影响，由此能进一步研究：政策制定者如何增加对隐私泄露的惩罚、数据持有者如何增加对数据共享的奖励等。</p>
</li>
</ol>
<p>不足之处和后续研究：</p>
<ol>
<li><p>仅考虑了一个攻击者和两阶段攻击实验</p>
</li>
<li><p>使用的决策模型较为简单，假设数据主体之间的决策相互独立，或所有主体选择相同的策略</p>
</li>
<li><p>目前的博弈模型所模拟的博弈双方并没有完全推理出所有的不确定性。双方都可能有不完全和/或不完善的信息。为了更加现实，可以使用更复杂的博弈论模型，如贝叶斯博弈，来模拟不完全和/或不完善的信息</p>
</li>
<li><p>没有研究数据持有者的最优策略，它们有动机控制付给数据主体的报酬</p>
</li>
<li><p>博弈模型可能会在发布的数据集中引起非随机缺失（MNAR）的值，这对数据集的使用可能会有不可忽略的影响</p>
</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>stackelberg game</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Budgeted Unknown Worker Recruitment for Heterogeneous Crowdsensing Using CMAB</title>
    <url>/2022/09/11/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Budgeted%20Unknown%20Worker%20Recruitment%20for%20Heterogeneous%20Crowdsensing%20Using%20CMAB/</url>
    <content><![CDATA[<a id="more"></a>
<p>这篇论文是在<a href="https://likun1208.github.io/2020/07/05/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Combinatorial%20Multi-Armed%20Bandit%20Based%20Unknown%20Worker%20Recruitment%20in%20Heterogeneous%20Crowdsensing/https://likun1208.github.io/2020/07/05/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Combinatorial%20Multi-Armed%20Bandit%20Based%20Unknown%20Worker%20Recruitment%20in%20Heterogeneous%20Crowdsensing/">之前看过的论文</a>的基础上扩展的，因此前面的内容暂时先不看，直接看多出来的部分，这部分针对的问题是一些workers总被分配任务而另一些则没有任务。</p>
<h2 id="FAIRNESS-CONSTRAINT-OF-WORKERS"><a href="#FAIRNESS-CONSTRAINT-OF-WORKERS" class="headerlink" title="FAIRNESS CONSTRAINT OF WORKERS"></a>FAIRNESS CONSTRAINT OF WORKERS</h2><p>公平性：众包平台必须保障每一个worker的最小选择频率，从而避免出现一些workers任务很多而另一些没有任务的场面。</p>
<p>因为：没任务的workers会永久性离开平台，导致workers数量减少，这有损于其他requesters的数据结果。因此公平性约束潜在地保障了所有requesters的全局长期传感性能。</p>
<p>方法：</p>
<ol>
<li><p>引入参数$\eta_i$：多轮招募中第$i$个worker至少被招募的部分</p>
</li>
<li><p>公平性约束：$\liminf _{B \rightarrow \infty} \mathbb{E}\left[n_i(\tau(B))\right] \geq \tau(B) \cdot \eta_i$, for $\forall i \in \mathcal{N}$</p>
<p>其中，$\tau(B)$表示预算为B时招募的总轮数，$n_i(\tau(B))$表示预算为B时第i个worker被招募的总轮数</p>
</li>
<li><p>引入虚队列，队列长度计算：$V_i(t)=\max \left\{0, V_i(t-1)+\eta_i-\mathbb{I}\left\{i_{t-1}=i\right\}\right\}$</p>
</li>
<li><p>将队列长度也纳入多臂赌博机的计算公式中：</p>
<script type="math/tex; mode=display">
p_{i}^{l}=\underset{p_{i^{\prime}}^{l^{\prime}} \in\left(\mathcal{P} \backslash \mathcal{P}^{t}\right)}{\operatorname{argmax}}\left\{\frac{u_{\left[\widehat{q}_{i}(t-1)\right]}\left(\mathcal{P}^{t} \cup\left\{p_{i^{\prime}}^{l^{\prime}}\right\}\right)-u_{\left[\widehat{q}_{i}(t-1)\right]}\left(\mathcal{P}^{t}\right)}{c_{i^{\prime}}^{l^{\prime}}}+\varrho \cdot V_{i}(t)\right\}</script></li>
</ol>
<ol>
<li>其余内容没有改变</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>crowdsourcing</tag>
        <tag>Combinatorial Multi Armed Bandit</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Theories of Bargaining Delays</title>
    <url>/2022/08/31/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Theories%20of%20Bargaining%20Delays/</url>
    <content><![CDATA[<h1 id="Theories-of-Bargaining-Delays"><a href="#Theories-of-Bargaining-Delays" class="headerlink" title="Theories of Bargaining Delays"></a>Theories of Bargaining Delays</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>各类争端的解决过程中可能会出现罢工、谈判等延迟现象，而这是有代价的。博弈论说明程序性特征可能会导致拖延，但主要原因可能是各方之间的信息差异。本文描述了几个模型，并与罢工的数据相关。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>商业和法律场景广泛存在着讨价还价，而这带来了各方面的有代价的延迟。如果参与者知道最终达成的结果本应能在更早的时候以更低的代价达成，则会觉得遗憾。这是发生冲突的双方在利益分配上的对立所引起的，每个人都相信坚持自己的利益值得付出延迟的代价。</p>
<p>以其他领域的类似的场景为例：</p>
<ol>
<li><p>昂贵的经济和政治斗争发生在竞争公司之间的市场份额竞争（价格战）</p>
</li>
<li><p>国家之间的军备竞赛和战争</p>
</li>
<li><p>其他 “霍布斯式 “的背景下的事情</p>
</li>
</ol>
<p>这些例子是缺乏可执行合同和支付手段的讨价还价的变种。同样，动物之间为争夺配偶或猎物而进行的战斗也会选择赢家；其代价是受伤或能量消耗。</p>
<p>然而，在一些物种中，会通过事先进行的锦标赛建立等级制度；在其他物种中，会通过仪式化的战斗降低竞争成本。这些例子表明，一些优势的竞争是信息性的，揭示了参与者的相对实力。在经济背景下，公平分配的行为规范和道德规则模仿了仪式化解决冲突的效果。</p>
<p>前文所提到的个人激励（也就是利益）会促进双方为分蛋糕而付出高昂的代价，这促使人们尝试改善讨价还价的过程——替代性争议解决方案：</p>
<ol>
<li><p>雇用第三方调解员来加强沟通并提出妥协方案</p>
</li>
<li><p>由仲裁员对争论进行判断并作出有约束力的决定</p>
</li>
</ol>
<p>针对替代程序的潜力分析，现有研究侧重于如何快速解决谈判的基本障碍。本文提出了来自博弈论的一些结论：</p>
<ol>
<li><p>在实践中，讨价还价受到公平观念和强烈情绪的影响。博弈论的表述从这些方面进行了抽象，以找到与每一方不懈的优化行为相一致的结果范围。</p>
</li>
<li><p>一个主要目的是确定允许或要求延迟达成协议的情况。拖延是低效率的一个重要来源，在这些数据中可以观察到的是罢工时间，但它不是唯一的一个。其他的可能性是低效的合同条款，以及当存在互利协议时却未能达成协议。</p>
</li>
</ol>
<p>博弈论所引用的假设是严格的。最大化行为的假设通过以下假设得到了加强：各方都确切地知道管理这一过程的程序规则，并且他们有强大的计算能力。程序的固定性排除了用自然语言的自由流动来传达信息和意图的谈判；相反，语言被限制在提议、接受或拒绝，以及诸如罢工的补充决定。然而，它使人们能够研究替代程序的效果和各方之间的信息差异。计算包括选择自己的策略，以及不太可信的对对方策略的预期。这种均衡的假设——各方的策略都是对对方的最佳反应——是博弈论的一个标志。它不是一个规范性的公理，也不是对经验事实的近似，充其量是模糊的，它是识别快速解决谈判的根本障碍的先决条件。为了获得有用的结果，需要一个更强有力的假设：每一方的策略不仅在最初是最优的，而且在随后的每一个突发事件中也是最优的。这一限制排除了一种策略：其最初的最优性取决于用一种不可思议的威胁来恐吓另一方，从这个意义上说，执行这种威胁并不是最优。</p>
<p>虽然是限制性的，但这些假设使我们能够把讨价还价作为一个策略问题来分析，并以程序规则和有关各方的偏好和信息的数据为条件。这种分析模式与基于公理的规范或道德标准的分析，或基于从行为规律性得出的经验预测的分析形成了对比。我们首先回顾了强调程序性规则影响的模型，然后描述了信息差异的影响。</p>
<h2 id="Models-of-Procedural-Effects"><a href="#Models-of-Procedural-Effects" class="headerlink" title="Models of Procedural Effects"></a>Models of Procedural Effects</h2><p>一个基本的例子：买卖双方针对价值为$v$的商品进行讨价还价，卖家的供应成本是$c$，且$v&gt;c$。</p>
<p>$t$时刻双方就价格$p$达成共识这一结果意味着：这次交易的利润在分蛋糕（总量为$v-c$）时，卖家分到的是$p-c$，买家分到的是$v-p$。一个简单的过程是双方交替报价：以$\Delta$为时间间隔将讨价还价的时间划分为离散的时间段，一方报价后另一方在下一个时间段立即选择同意或者再次报价。</p>
<p>我们考虑所有延迟代价的可能性中的两种极端情况：</p>
<ol>
<li><p>代价与延迟成正比，因此卖方净赚$p-c-d_st$，买方净赚$v-p-d_bt$，其中参数$d_s$和$d_b$是卖方和买方在每个延迟时间段里产生的成本。</p>
</li>
<li><p>它们代表了投资收益中放弃的利息收益，即卖方净赚$[p-c]\delta_s^t$，买方净赚$[v-p]\delta_b^t$。参数$\delta_s$和$\delta_b$是反映利率$r_s$和$r_b$的贴现因子。例如：$\delta_s=e^{-r_s\Delta}$。</p>
</li>
</ol>
<p>法律和仲裁的背景增加了一个特点，即在某个时候，如果双方仍有分歧，则由法官对争议进行裁决。</p>
<p>它规定了一个明确的程序，并且偏好表现出对解决的不耐烦，在这个意义上，延迟是昂贵的。这个例子的一个主要预测是，协议立即发生，均衡价格是唯一的。唯一性需要详细的证明，但由此产生的没有延迟是合理的：延迟的协议会被双方预料到，因此在任何较早的时间，提议的一方可以提供对双方有利的条款。例如，卖方可以提前提出一个较高的价格，而买方宁愿接受这个价格，也不愿承担等待以后预期的较低价格的成本。</p>
<p>均衡价格取决于谁第一个报价。如果卖家报价$p_s$，买家报价$p_b$，则$p_s$是买家为了在下一轮能报价$p_b$的不能拒绝的最高价格，而$p_b$是卖家不能拒绝的最低价格并在下一轮中报价$p_s$。</p>
<p>在第2种情况下（延迟成本等价于投资收益中放弃的利息收益），这两个价格由下面的公式决定：</p>
<script type="math/tex; mode=display">
v-p_s=[v-p_b]\delta_b\\
p_b-c=[p_s-c]\delta_s</script><p>这个公式粗浅的理解如下：左边是最初报价就达成共识的收益，右边是讨价还价后用贴现因子折算之后的收益，如果上述等式成立，则说明，如果第一轮是卖家报价，则该报价所对应的买家收益，与之后买家自己报价折算后的收益相等；如果第一轮是买家报价，则该报价所对应的卖家收益，也与之后卖家自己报价折算后的收益相等。由此达成均衡。在这种情况下，当利率相近且报价之间的时间间隔较小时，任何一种价格都能提供几乎均匀的分红。</p>
<p>而在第一种情况下，则会产生一种不对称的分蛋糕结果：成本较小的一方如果能先报价，则会得到整个蛋糕，反之，则会得到除了能抵消对方成本以外的剩下蛋糕。如果某一方有替代选项，例如买家能去其他地方以价格$p$购买该商品，则当卖家先报价时，预测价格是$p$和$p_s$中较小的一个。</p>
<p>在这个例子中，拖延显然是没有必要的。如果各方能预见到最终的分裂，而且程序允许更早的解决，那么他们就有动力迅速决定事情。类似的主张也适用于Mnookin和Kornhauser(7)研究的 “法律阴影下的讨价还价”。在法律索赔的审前讨价还价中，如果法院对纠纷的最终解决方式事先是明确的，那么当事人就有强烈的动机去和解。Bulow和Rogoff(8)提供了这些观点的另一个应用，即银行和主权国家之间关于重组债务合同的讨价还价。</p>
<p>然而，这个命题需要限定，为了说明这一点，我们描述了一个支持多个均衡的程序性修改，从而使得延迟是必要的。假设时间是连续的，且参数$\Delta$和$\Delta’$表示两个固定的时间段。每一方可以在任意时间$t\ge0$提出一个价格，只要他在对方上一轮报价后至少等待了$\Delta$，且在他自己上一轮报价后至少等待了$\Delta’$（如果自己有上一轮报价的话）。当一方重复另一方的报价或他们同时提出相同的价格时，就达成了协议。这种修改后的程序有一个优点，即它减轻了对报价时间的限制。然而，作为均衡结果，它允许在零时和更晚的时间有广泛的价格；因此，延迟是可能的，但不是必须的。拖延的近因是立即达成协议的多样性，允许对任何试图提前解决的人附加 “烙印”。</p>
<p>假设当他们都保持沉默直到同时报价$p^0$时，一个价格为$p^0$的延迟协议出现，接下来的内容完全没有看懂，大致意思是说，这个修改了程序的讨价还价博弈由于有着多重均衡，而使得博弈双方总是无法达成共识，从而导致了延迟的出现。这种延迟是所有允许多重均衡的博弈的特点。事实上，如果同时提出的建议被排除在外，比如说通过忽略其中一个建议，那么同样存在着一个唯一的均衡，没有延迟。</p>
<p>多重性也会在其他博弈程序中出现。Fernandez和Glazer[10]分析了以工会和公司之间的讨价还价为例的在固定间隔内交替报价的程序，新增的一个特点是在每个没有就新合同达成协议的时期，工会可以选择罢工或者按前一个合同规定的工资工作[11]。工会可利用的这种报复性选择的多重性，允许有一系列的即时工资协议；因此，就像前面的例子一样，仪式性的延迟也是可能的。</p>
<p>第二个条件是，各方必须能够预见最终的协议。当任何一方拥有关于该过程的某些方面的私人信息时，这一点就失效了。例如，在法律背景下，一方可能知道受制于证据或随后在审判证词中披露的信息。其他的可能性是，程序是模糊的，或者任何一方对另一方的偏好不确定。我们用后者来说明私人信息的影响。</p>
<h2 id="Models-of-Informational-Effects"><a href="#Models-of-Informational-Effects" class="headerlink" title="Models of Informational Effects"></a>Models of Informational Effects</h2><p>关于信息差异如何导致延迟，有三个主要例子被研究。根据参考文献[12]，我们把它们称为损耗、筛选和信号的模型。</p>
<h3 id="Attrition-损耗"><a href="#Attrition-损耗" class="headerlink" title="Attrition 损耗"></a>Attrition 损耗</h3><p>损耗模型假设偏好符合情况1，但是每一方都不确定其他人的延迟成本，只假设其符合一个确定的概率分布。虽然是为了描述动物之间为生存或繁殖而竞争而开发的，但损耗模型也适用于讨价还价。因为它的成本是相互的，延迟类似于一场战斗，以确定较强的一方（成本较小的一方），然后像上面的基本模型一样要求得到整个蛋糕。损耗模型恰当地描述了为生存或市场份额而竞争的公司之间的军备竞赛和价格战，以及其他隐性议价的情况。它们捕捉到了回顾性的遗憾感：如果一开始就确定较强的一方，那么战斗的浪费是可以避免的；但悲剧的是，战斗可能是对实力的唯一可信的测试。双方的动机前瞻性地说明了一类更广泛的声誉模式：每一方的持续斗争都是对可能更强大的声誉的投资，如果对方先投降，就能获得有利的回报。</p>
<p>损耗模型似乎与工资和价格的明确讨价还价不太相关，因为它们依赖于影响利润的延迟成本的信息隐私，而且它们对赢家通吃结果的预测似乎不现实。</p>
<h3 id="Screening-筛选"><a href="#Screening-筛选" class="headerlink" title="Screening 筛选"></a>Screening 筛选</h3><p>筛选模型通常假设偏好符合情况2，在最简单的版本中，卖方对买方的估价是不确定的。尽管$v$对买方来说是已知的，但卖方认为它是一个符合某一公开的概率分布的随机变量。我们进一步简化，假设卖方在离散时间$t=0,\Delta,2\Delta,…$时进行报价。</p>
<p>在这个版本中，卖方使用 “撇脂 “策略对买方的可能类型进行排序。也就是说，他提供连续较低的价格，直到买方接受。这种策略利用了高价值买家对交易的不耐烦。买家等待低于其估值的价格，然后在进一步拖延的成本超过等待下一个更低价格的优势时接受。预测到买方的行为，卖方设计了一个最佳的报价序列，均衡基本上是唯一的，假设卖方的成本严格小于买方的所有可能的值，所以交易的收益肯定是正的。</p>
<p>然而，这个模型对延迟的预测是短暂的。随着报价之间的间隔$\Delta$的缩短，最大的延迟缩减为零，卖方的报价下降到买方的最小可能值。只要均衡具有上述唯一均衡的一些一般特征，这一引人注目的属性就会在更一般的版本（包括交替报价）中持续存在。因此，只有在报价不频繁的情况下，重大延迟才是必要的。</p>
<p>关于报价频率的理论（除了简单的物理限制和 “继续尝试 “的诱因）必须与重要的声誉方面相抗衡。在罢工期间，公司拒绝工会提出的工资会产生一种激励，即迅速提出更低的工资以缩短罢工时间。但是，工会可以预见到科斯属性：准备好的提议经常鼓励公司预见到并等待更低的工资提议，这最终会产生快速的协议，但条件对工会是不利的。通过在提供更低的工资之前忍受相当长的罢工时间，使公司为拒绝的后果付出代价，这是工会获得可观份额的力量的来源。因此，筛选模型有一个微妙的含义：建立一个强硬的声誉（被理解为维持成员的士气以在相当长的时间内不妥协地维持工资要求的能力）是一个成功战略的主要特征。建立声誉可能涉及到与一家公司或一个行业中的许多公司在连续的合同谈判中反复讨价还价。在这个意义上，延迟是由于买方价值的不确定性而加剧的，这就证明了卖方的撇脂策略，以及建立声誉的首要动机是不经常修改报价。</p>
<h3 id="Signaling-信号"><a href="#Signaling-信号" class="headerlink" title="Signaling 信号"></a>Signaling 信号</h3><p>与上述声誉解释一样，信号模型提供了报价之间的重要间隔的解释。然而，它通过解决买方的动机来证明低价是合理的，从而避免了科斯产权理论。该模型中允许随时报价，但必须双方轮流，一方报价后另一方要等一段时间。假设买方的价值是私有的。</p>
<p>现有一种信号装置，其运作方式如下：在收到卖方提出的价格后，买方可以在间隔时间$\Delta$后接受，或者等待更长的时间，以表明他的价值很小，然后提出一个更低的价格。为了使这种信号可信，他必须等待足够长的时间来反驳任何关于他的价值可能很高的猜想。因此，他等待的时间和他提出的价格必须是这样的，如果他的价值更高，那么这样做是无利可图的。只要强制区间$\Delta$足够短，弱技术假设就意味着有这种形式的唯一均衡。特别是，如果卖方的价值足够高，他最初提出一个被买方接受的价格，否则，他通过等待一个适当长的时间间隔来提出他的价值（因为现在他的价值已经被可信地发出信号），即最初描述的没有不确定性的基本模型所预测的价格。</p>
<p>在双方都有私人信息的情况下，也会得到类似的结果。更没有耐心的一方，比如说卖方，在提出最初的建议之前，会等待足够长的时间来发出可信的成本信号；然后，如果买方的价值非常高，他会迅速接受，否则会等待足够长的时间来发出可信的价值信号，然后提出反建议，卖方会迅速接受。根据这种情况，双方通常在没有私人信息的情况下就预测的价格达成一致：与筛选模型不同，信息差异对商定的条款影响不大。延迟的作用仅仅是可信地传达彼此的私人信息。后悔的因素体现在事后意识到早期对卖方的成本和买方的价值进行可信的核查可以避免延迟的成本。</p>
<p>根据这一设想，拖延是信息不对称的必然结果。特别是，最多只有两个正式报价，其余的都是多余的拖延，例如在工资谈判中，公司发出的信号，即它无法承担高工资。从严酷的形式来看，这种观点违反了偶然的观察，但一些特征，如可变的反应间隔和稀少的认真报价是现实的。此外，工资是公平的，因为在没有信息差异的情况下，工资是相同的。筛选模型有很大的不同，因为它们预测工资和延迟主要取决于程序性参数，如报价的频率，反过来又取决于对士气或声誉的辅助考虑；此外，如果报价频繁，那么结果就会对拥有优势信息的一方非常有利。</p>
<p>这三种延迟模式代表着极端情况，其中有可能出现各种混合情况。例如，如果当事人的延迟成本是(i)和(ii)的混合物，那么结果也是损耗和信号结果的混合物：与纯粹的损耗模型相比，延迟可能更短，分割更公平。新的特征也出现了。买方的最高值意味着立即接受，但最低值也会导致买方终止谈判，即使交易的收益是正面的：可信的信号传递太昂贵了。如果卖方的成本和买方的价值是相关的或有因果关系的，就会出现更多的可能性；特别是，即使双方都知道收益必须是正的，也可能阻止收益的实现。</p>
<h2 id="Strike-Data"><a href="#Strike-Data" class="headerlink" title="Strike Data"></a>Strike Data</h2><p>损耗模型预测，平均工资结算与罢工持续时间无关，加拿大的数据就是如此，尽管美国的数据显示工资随着持续时间的增加而有所下降。他们还预测，解决率（每天在仍未解决的问题中解决的百分比）会下降，这与数据基本一致。如果只有公司有私人信息，筛选和信号模型预测工资会随着时间的推移而下降，如前所述，这在美国的数据中也有发生，但它们在下降的速度上有所不同。筛选模型的合理规格可以预测适当幅度的结算率（每天2％或3％），如果包括非罢工放缓（如下所述），信号模型也可以。这些模型预测的结算率大多随着时间的推移而增加，但这与总体数据中观察到的结算率下降并不矛盾：因为不同的工会-公司对可以有不同的结算率，而那些有高结算率的公司倾向于早期结算，总体结算率仍然可以在很长一段时间内下降。</p>
<p>信号模型可以适应对其他特征的考虑，如工会在放缓或罢工之间的战术选择，以向公司施压。事实上，罢工和停工在合同到期和结算之间所占的平均时间不到一半；另外，大多数合同的续签都会发生延误，但其中只有不到三分之一涉及罢工，而罢工通常是迅速启动的。信号模型很好地预测，只有在旧工资较低的情况下，工会才会在最初选择罢工。值得注意的是，合理的假设意味着减速和罢工以类似的速度传递信息，以被延迟成本耗尽的部分来衡量；因此，当旧工资不是太低时，减速是相对有效的，对工会有吸引力。</p>
<p>还需要进一步的工作来确定每个模型在整体上对数据的适合程度。一些孤立的事实支持了这些模型的一般假设，即战略行为，因信息不对称而变得复杂，是很重要的。这些模型预测，在纽约，工人在8周后有资格获得失业补偿，这鼓励了较高的早期结算率和较低的后期结算率，事实上也是如此。他们还预测，魁北克省禁止企业雇用替代工人的法律增加了平均工资和罢工持续时间，事实上，平均持续时间的估计增长超过了50%。这种影响在筛选模型中是最明显的，在这种情况下，排除替代工人会增强工会根据企业的盈利能力进行歧视的权力，而不受来自非工会工人的竞争的阻碍。另一方面，在实践中，延迟成本似乎比这些模型预测的要低。在美国，只有大约15%的劳动合同谈判涉及罢工（在加拿大为22%），与持续3年的合同相比，中值持续时间通常为3周。同样地，约有10%的法律索赔进入审判阶段（儿童监护权等问题的比率更高）。在接受强制性约束性仲裁的政府工作人员的合同谈判中，约有三分之一涉及仲裁听证，但这些谈判的成本比罢工或审判要低。对这些现象的一个可能的解释是，只有少数争端受到信息不对称的困扰。</p>
<h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>这里描述的模型对昂贵的讨价还价延迟的根本原因提出了建议。没有信息差异的模型表明，拖延不是固有的。合理的程序能够避免任何拖延的必要性。然而，有信息差异的三个模型表明，拖延可能是可能的或必要的。尽管它们依赖于偏好的不同结构特征，但损耗和信号模型都有一个共同的预测，即延迟主要是一种激发信息的手段。拖延的成本性确保了其作为信号的可信度，所以如果没有其他的验证手段，那么各方可能会依赖它。另一方面，筛选模型则提出了允许操纵延迟的程序。频繁的报价使延迟最小化，这在社会上是有效的，但却使条件对信息较差的一方有偏见。</p>
<p>这些不同类型和数量的延迟的可能性也反映在对任何议价过程的任何均衡所隐含的基本激励兼容条件的研究中。这些条件与程序性规则无关，但它们对信息不对称很敏感。一个基本的含义是，关于贸易收益是否为正数的相互不确定性需要一些无效率，要么是延迟，要么是谈判的破裂。在满足这些条件的方式中，发现了大量的可能性，每一种都会对各方获得的相对优势、延迟成本和结果的整体效率产生影响。一个实际的建议是，通过建立（在信息差异出现之前）长期合同来调节争端，从而避免这些条件的咬合。另外，单方支付可以补偿预期的不利因素；例如，在一个筛选模型中，报价之间的短间隔对卖方不利，但可以减少延迟，因此作为补偿，买方可以向卖方支付费用以加快进程。</p>
<p>这些评论并不意味着所提到的延迟来源是详尽的。由于情感和认知反应，如不信任或归因于恶意，造成的延迟是很常见的。即使在匿名的情况下，每一方都可能不愿意放弃他应得的、期望的或承诺给选民的份额。即使对于 “超理性 “的一方，也有相互竞争的假说。其中一个重要的假设是，受雇于各方的代理人可能有动机去拖延（如果他们有报酬去谈判）或避免达成协议（如果这将对他们的未来产生不利影响）。后者的一个可能的例子是，在职管理层或董事有动机阻挠敌意收购或兼并要约，或阻挠股东诉讼的解决。一个常见的观点是，在问题成熟时才会结束谈判。就上述模型而言，成熟性可以被解释为进一步拖延或获取或推断新信息的成本增加；但也可能是拖延使后果或偏好得到澄清。在法律背景下的一个相关例子是，延迟提供了进行发现或辅助性法庭测试的机会，如上诉。</p>
<p>最后一段我也没理解，大致意思应该是说关于讨价还价博弈中的延迟分析依赖于各方的理性，而这限制了其应用。它对程序和偏好的详细说明的依赖也带来了应用上的限制性。接下来举了几个例子说明这种限制。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
      </tags>
  </entry>
  <entry>
    <title>获取B站数据说明</title>
    <url>/2022/05/29/%E8%8E%B7%E5%8F%96B%E7%AB%99%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="获取B站数据说明"><a href="#获取B站数据说明" class="headerlink" title="获取B站数据说明"></a>获取B站数据说明</h1><h2 id="用到的包"><a href="#用到的包" class="headerlink" title="用到的包"></a>用到的包</h2><ol>
<li><p><code>bilibili_api</code>：必用，获取视频数据的接口</p>
</li>
<li><p><code>json</code>：选用，用于格式化输出获取的字典数据</p>
</li>
<li><p><code>time</code>：选用，用于转换获取的时间戳数据</p>
</li>
<li><p><code>csv</code>：选用，用于将数据输出到csv文件</p>
</li>
<li><p>其他说明：如果需要更高级的表格数据输出，建议用pandas</p>
</li>
</ol>
<h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><p>通过下列代码可以获取指定<code>bv</code>号的视频数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v = video.Video(bvid)        <span class="comment"># 实例化video类</span></span><br><span class="line">info = <span class="keyword">await</span> v.get_info()    <span class="comment"># 获取信息</span></span><br></pre></td></tr></table></figure>
<p><code>info</code>是一个字典类型的数据，包含了视频的标题、作者、播放量等等大量信息，我们可以用以下代码格式化输出来看一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(json.dumps(info,indent=<span class="number">4</span>,ensure_ascii=<span class="literal">False</span>))    <span class="comment"># 格式化输出</span></span><br></pre></td></tr></table></figure>
<p>输出结果如下图，这个字段信息很多，就不一一列出说明了。</p>
<p><img src="https://s2.loli.net/2022/05/29/oHEL1jBekdJzXZ2.png" alt=""></p>
<p><img src="https://s2.loli.net/2022/05/29/IVlywznM7u9cdJK.png" alt=""></p>
<p>目前我们需要获取的是标题、发布时间、播放量和三连数据，可以看出，标题对应的字段是<code>title</code>，发布时间是<code>pubdate</code>，而播放量和三连数据则是在<code>stat</code>中的<code>view, favorite, coin, like</code>，需要注意的是这里发布时间是用的时间戳，因此要使用<code>time</code>来转换成标准时间。总的来说，就是以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">title = info[<span class="string">'title'</span>]                                    <span class="comment"># 获取标题</span></span><br><span class="line">view = info[<span class="string">'stat'</span>][<span class="string">'view'</span>]                              <span class="comment"># 获取播放量</span></span><br><span class="line">like = info[<span class="string">'stat'</span>][<span class="string">'like'</span>]                              <span class="comment"># 获取点赞</span></span><br><span class="line">coin = info[<span class="string">'stat'</span>][<span class="string">'coin'</span>]                              <span class="comment"># 获取投币</span></span><br><span class="line">favorite = info[<span class="string">'stat'</span>][<span class="string">'favorite'</span>]                      <span class="comment"># 获取收藏</span></span><br><span class="line">time_tmp = info[<span class="string">'pubdate'</span>]                               <span class="comment"># 获取发布时间</span></span><br><span class="line">timeArray = time.localtime(time_tmp)                     <span class="comment"># 时间戳转为标准时间的数组形式</span></span><br><span class="line">time_pub= time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, timeArray)  <span class="comment"># 时间数组转为常见的可直接输出的字符串形式</span></span><br></pre></td></tr></table></figure>
<p>在得到数据以后，可以直接打印输出、写入本地文件或者进行后续其他需要的操作，这里我们要把数据作为函数返回值，因此把它们放到一个列表中，从而一起返回，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">videoinfo = [title, time_pub, view, like, coin, favorite]</span><br><span class="line"><span class="keyword">return</span> videoinfo</span><br></pre></td></tr></table></figure>
<p>获取数据的部分到此结束，需要注意的是，由于最初获取数据用到了<code>awati</code>，因此该函数是异步的，在声明的时候需要用如下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(bvid)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>接下来是如何把数据写入文件。</p>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>首先是设置<code>bv</code>号，然后异步地调用前面写好的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bvid = <span class="string">"BV1MR4y1K7Tv"</span></span><br><span class="line">info = asyncio.get_event_loop().run_until_complete(main(bvid))</span><br></pre></td></tr></table></figure>
<p>如果要连续获取多个视频的信息，就可以直接循环。</p>
<p>接下来由于输出的文件格式比较特殊，所以要对获取到的数据列表进行处理，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="literal">None</span>,<span class="literal">None</span>,info[<span class="number">0</span>],<span class="string">"https://www.bilibili.com/video/"</span>+bvid,info[<span class="number">1</span>],<span class="literal">None</span>,<span class="literal">None</span>,info[<span class="number">2</span>],<span class="literal">None</span>,<span class="literal">None</span>,<span class="literal">None</span>,<span class="literal">None</span>,str(info[<span class="number">3</span>])+<span class="string">'/'</span>+str(info[<span class="number">4</span>])+<span class="string">'/'</span>+str(info[<span class="number">5</span>])]</span><br></pre></td></tr></table></figure>
<p>这行代码的含义是把列表的前两个字段设置为空，接着是<code>info</code>中的第一个数据即标题，随之是视频链接，再次是投稿时间，接着继续两个空，然后是播放量，在四个空位之后是<code>点赞/投币/收藏</code>这种形式的三连数据。之所以置空，是因为要写入表格中在这些位置有其他列，需要用其他方式写入数据。</p>
<p>数据按格式排好后就可以写入了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"bilibili.csv"</span>, <span class="string">'a'</span>, newline=<span class="string">''</span>, encoding=<span class="string">'utf-8-sig'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.writer(f)</span><br><span class="line">    f_csv.writerow(list)</span><br></pre></td></tr></table></figure>
<p>第一行表示以追加写入的方式打开<code>bilibili.csv</code>这个文件，文件编码是<code>utf-8-sig</code>，<code>a</code>表示是追加写入，也就是在文件最后一行新增要写入的内容，<code>newline</code>表示换行符为空，最后的<code>as f</code>表示把打开的这个文件变量命名为<code>f</code>，这个名字只影响后面对文件变量的操作，不影响文件名本身。</p>
<p>第二行是调用函数表示要对文件<code>f</code>进行写入操作，第三行是指将名为<code>list</code>的列表作为新的一行直接写入到csv文件中。</p>
<p>写入文件以后就结束。 </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://bili.moyu.moe/#/" target="_blank" rel="noopener">bilibili-api 开发文档</a></p>
]]></content>
      <categories>
        <category>无分类项</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Web3行业总结</title>
    <url>/2022/05/06/Web3%E8%A1%8C%E4%B8%9A%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Web3-0总结"><a href="#Web3-0总结" class="headerlink" title="Web3.0总结"></a>Web3.0总结</h1><h2 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h2><p>2014年 Gavin Wood：</p>
<ol>
<li><p>让互联网更去中心化、可验证、安全而发起的一组广泛的运动和协议；</p>
</li>
<li><p>愿景是实现无服务器、去中心化的互联网，即用户掌握自己身份、数据和命运的互联网；</p>
</li>
<li><p>将启动新全球数字经济系统，创造新业务模式和新市场，打破平台垄断，推动广泛的、自下而上的创新。</p>
</li>
</ol>
<p>Web3.0 是信息聚联与价值共享的用户互联网，是下一代互联网技术体系，是 用户共建、隐私保护、平台开放的生态体系，是去平台中心化的组织形式所构建的新型经济系统，是以用户为中心的互联网，用户既是内容的生产者和所有者，也是内容的传播者和价值拥有者。</p>
<p>概述：</p>
<ol>
<li><p>Web3.0 是信息聚联与价值共享的用户互联网</p>
</li>
<li><p>Web3.0 是下一代互联网技术体系，是 用户共建、隐私保护、平台开放的生态体系</p>
</li>
<li><p>Web3.0 是去平台中心化的组织形式所构建的新型经济系统</p>
</li>
<li><p>Web3.0 是以 用户 为中心的互联网，用户既是内容的生产者和所有者，也是内容的传播者和价值拥有者</p>
</li>
</ol>
<p>特点：开放、隐私、共建</p>
<p>核心特征：将去平台中心化 实现用户自主价值创造 、价值确权 、 价值交换三位一体 使现实世界与虚拟世界双向渗透</p>
<p>主要特点：</p>
<ol>
<li><p>用户或将拥有更高的权限</p>
</li>
<li><p>用户有可能通过所拥有的数据获利</p>
</li>
<li><p>虚拟世界与现实世界融合</p>
</li>
<li><p>实现价值安全、透明、可信的转移</p>
</li>
</ol>
<p>Web3.0生态主要组成要素及特点：</p>
<ol>
<li><p>用户身份：传统中心化身份容易产生安全和隐私风险，web3构建了一个去中心化的身份标识，以DID作为web3的用户身份表现形式；</p>
</li>
<li><p>组织形式：web3的核心观点是用户共建、用户所有，所以会形成用户共建自治的组织形式，即DAO；</p>
</li>
<li><p>经济系统：数字资产是web3的核心要素，数据资产将以通证的形式构成整个经济系统。截至2021年4月2日，DeFi各项目总计拥有约712万活跃用户，相比自2021年1月的160.78万增长了约3.5倍，NFT主流项目资产规模合计也超过100亿美元，成为元宇宙项目中发展最为迅猛的领域；</p>
</li>
<li><p>呈现形式：web3中的所有活动和交互都需要依赖于特定的应用来实现，通过dApp的交互最终构成动态的web3世界；5）从中心化存储到去中心化存储：去中心化的存储方案即IPFS，为web3提供基础支撑。在web3生态中，区块链是核心支撑，其具有的技术、金融和社会属性将帮助构建一个去中心化的、可信的数字化价值交互网络。</p>
</li>
</ol>
<p>5个特征：</p>
<ol>
<li><p>计算和特定的计算设备解绑分离：Web3.0构成了一种全新的计算范式，计算和存储行为并不会因为特定的设备出现问题，这个计算和服务就被关停。</p>
</li>
<li><p>基于密码学技术实现身份认证及数据确权：不同于以往传统互联网基于中心化机构和数据库来进行授权和认证。身份必将成为一种主权资产。这个身份不管是人的身份，同时还包含机器等终端在Web3.0中的身份。</p>
</li>
<li><p>数据的记录和存储都是通过不可篡改的方式进行：Web3.0中，数据的存储倾向于永不删除和修改，而是不断累加数据，但是这种模式的前提是，存储成本极低，规模极大。</p>
</li>
<li><p>资源分配通过基于通证的市场机制来进行：区别于以往的中心化授权调配的方式，而是双方通过通证的交易来进行资源的配置优化。</p>
</li>
<li><p>权益分配上的去中心化和透明化。</p>
</li>
</ol>
<p>Web3背景下的商业逻辑：</p>
<ol>
<li><p>去中心化的通用数字身份认证体系</p>
</li>
<li><p>数据确权</p>
</li>
<li><p>价值分配结构优化</p>
</li>
<li><p>产品设计和服务定价权向用户转移</p>
</li>
</ol>
<p>Web3.0的发展路径应该是资产、身份和数据</p>
<h2 id="历史与发展"><a href="#历史与发展" class="headerlink" title="历史与发展"></a>历史与发展</h2><p><img src="https://s2.loli.net/2022/05/06/bNOo6RnIBpYLXEQ.png" alt=""></p>
<h3 id="Web1：单向、只读互联网"><a href="#Web1：单向、只读互联网" class="headerlink" title="Web1：单向、只读互联网"></a>Web1：单向、只读互联网</h3><p>1991年—2004年，门户网站提供信息，用户被动浏览，内容创造者很少，绝大多数用户只能接受平台信息的投喂。</p>
<h3 id="Web2：双向、可读写互联网"><a href="#Web2：双向、可读写互联网" class="headerlink" title="Web2：双向、可读写互联网"></a>Web2：双向、可读写互联网</h3><p>2004年至今，允许用户自主生成内容，与网站和他人进行交互和协作。网络是专有的、封闭的，属于某个互联网公司的，用户自身并未真正拥有这些平台上的用户数据。</p>
<h3 id="Web3：聚联、价值互联网"><a href="#Web3：聚联、价值互联网" class="headerlink" title="Web3：聚联、价值互联网"></a>Web3：聚联、价值互联网</h3><p>内容由用户创造，数据归用户所有，每个人都能掌握自己的（数字）身份、资产和数据，进而掌握自己的命运。</p>
<h3 id="和国外对比"><a href="#和国外对比" class="headerlink" title="和国外对比"></a>和国外对比</h3><p>市场差异：中国是战略驱动型 美国是产业驱动型<br>应用场景：中国以元宇宙 、 沉浸式体验和可视化相关产业为主 美国优势在于基础设施和 链上经济发展</p>
<h2 id="发展Web3的必要性"><a href="#发展Web3的必要性" class="headerlink" title="发展Web3的必要性"></a>发展Web3的必要性</h2><h3 id="从Web2的现状问题出发"><a href="#从Web2的现状问题出发" class="headerlink" title="从Web2的现状问题出发"></a>从Web2的现状问题出发</h3><ol>
<li><p>Web2.0 的中心化平台遵循可预测的生命周期，平台与网络参与者的关系已经从正和变为零和；</p>
</li>
<li><p>Web2.0 发展到后期逐渐显现的寡头垄断局面，让用户的数据安全和隐私保护问题变得更加尖锐；</p>
</li>
<li><p>Web1.0 到Web2.0，用户实现了内容的消费者向内容生产者的转变，但并未相应地转变生产关系。</p>
</li>
</ol>
<h3 id="Web3的作用"><a href="#Web3的作用" class="headerlink" title="Web3的作用"></a>Web3的作用</h3><p>Web3.0 将解决 Web2.0 时代互联网大多数控制权集中在各个中心化公司的核心问题，实现价值向用户的安全、透明、可信转移</p>
<p><img src="https://s2.loli.net/2022/05/06/ORoW7FsyB3w2Vax.png" alt=""></p>
<h3 id="发展驱动力"><a href="#发展驱动力" class="headerlink" title="发展驱动力"></a>发展驱动力</h3><ol>
<li><p>战略层面：美国的战略推动者是产业界，中国则应发挥自身战略驱动型市场优势，顶层设计先行；Web3.0已成美国构建虚拟世界金融话语权的手段，中国需要建立自身特色的 Web3.0 体系</p>
</li>
<li><p>政策层面：反垄断监管持续推进，用户数据安全、隐私保护成为关注重点</p>
</li>
<li><p>技术层面：区块链技术特性适配Web3.0 设想，且技术趋于成熟，应用场景不断落地</p>
</li>
<li><p>产业层面：Web3.0行业发展周期即将从幼稚期迈入成长期，未来各个细分领域将会迎来快速发展</p>
</li>
<li><p>金融层面：数字货币逐渐获主流经济体认可，各国倾向于自主发行数字货币，对加密货币监管态度不一</p>
</li>
</ol>
<h2 id="行业市场现状"><a href="#行业市场现状" class="headerlink" title="行业市场现状"></a>行业市场现状</h2><p>Web3.0协议栈的各部分都是以去中心化、点对点的加密协议为特征，是一个无信任交易或协作基础设施，以达到用户能控制自己的资产、身份和数据的目的。从这个角度看，一定是资产是先行，因为资产相关领域具有可投机性，可以吸引大批资金和人员进入。如果从资产入手，下一步可能会解决的是身份，如果不解决身份问题是没办法解决数据问题的，因为没有个人的标识就没有办法去掌握自己的数据。所以应该是从资产、身份和数据这样的时间线去推进。</p>
<h3 id="商业趋势"><a href="#商业趋势" class="headerlink" title="商业趋势"></a>商业趋势</h3><ol>
<li><p>将Web2.0 的Apps 升级为Web3.0 的DApps。</p>
</li>
<li><p>重构Web3.0 网络的基础设施和应用协议，并初步形成Web3.0 的核心堆栈。</p>
</li>
<li><p>Web3.0 的新项目获客模式创新：定向奖励精准用户。</p>
</li>
</ol>
<h3 id="典型项目"><a href="#典型项目" class="headerlink" title="典型项目"></a>典型项目</h3><ol>
<li><p>开放：ENS、MASK Network 和Polkdot</p>
</li>
<li><p>隐私：Horizen、NuCypher</p>
</li>
<li><p>共建：Mirror、Gitcoin</p>
</li>
</ol>
<h3 id="生态体系现状"><a href="#生态体系现状" class="headerlink" title="生态体系现状"></a>生态体系现状</h3><ol>
<li><p>底层基础设施：行业整体产业链各环节已比较完备，部分环节海外仍处垄断地位</p>
</li>
<li><p>软件层与交互层现状：VR/AR行业发展迎来拐点，终端硬件出货量将持续走高</p>
</li>
<li><p>应用层现状：应用集中游戏和社交，致力于沉浸体验、观看体验、交互体验</p>
</li>
<li><p>NFT：NFT资产类型不断丰富中，但仍存在资产无法满足流动性需求的庞氏骗局风险；中国NFT 生态应用尚在孕育中，中国本土化之路刚刚开始，建议先建立监管体系</p>
</li>
<li><p>GameFi：GameFi将加速用户和 NFT 资产积累，推动更多企业和资本深入布局 Web3.0</p>
</li>
<li><p>DAO：去中心化组织应该更侧重于去平台化，让用户从被平台捆绑的状态中解放</p>
</li>
<li><p>DeFi：DeFi作为 Web3.0 生态中的金融体系，维持虚拟世界的核心信任体系，但未来尚不明朗</p>
</li>
</ol>
<h3 id="中美对比"><a href="#中美对比" class="headerlink" title="中美对比"></a>中美对比</h3><ol>
<li><p>国家层面：中国从顶层设计自上而下布局，美国从产业端自下而上推动</p>
</li>
<li><p>产业层面：美国优势领域在于底层基础设施和应用层，中国着力发展软件层和交互层</p>
</li>
<li><p>企业层面：中国企业更注重底层赛道布局，应用层布局不足，美国企业布局更为全面；美国科技巨头布局时间跨度更长；中国近三年才开始布局并加大海外投资收购力度</p>
</li>
</ol>
<h3 id="元宇宙"><a href="#元宇宙" class="headerlink" title="元宇宙"></a>元宇宙</h3><ol>
<li>Web3.0与元宇宙是一体两面的关系，二者具有多样状态，可重合、可交叉、可分离</li>
</ol>
<h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><p>区块链是Web 3 0 的关键技术 其去中心化 、防篡改特征是价值归属用户 、 用户隐私保护的基础；此外 操作系统 、分布式存储等底层技术VR/AR 、 3 D 建模等沉浸式 、 可视化技术也需与 Web 3 0 发展相适配.</p>
<p><img src="https://s2.loli.net/2022/05/06/fX2NdFY3x5RbHlB.png" alt=""></p>
<h3 id="分类方法1"><a href="#分类方法1" class="headerlink" title="分类方法1"></a>分类方法1</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ol>
<li>应用层通常都是去中心化应用协议，类别繁多，目前已经有所发展的主要包括：DEFI、GameFi、Social Messaging、Media、Ecomerce、Security。</li>
</ol>
<h4 id="用户控制层"><a href="#用户控制层" class="headerlink" title="用户控制层"></a>用户控制层</h4><ol>
<li>用户控制层包括：Exchange、Wallet、DAO、Broswers 等。</li>
</ol>
<h4 id="可扩展传输层"><a href="#可扩展传输层" class="headerlink" title="可扩展传输层"></a>可扩展传输层</h4><ol>
<li>统称为Layer2 协议。主要包括6 类：侧链、状态通道、Plasma、Optimisitc Rollup、ZK Rollup、Volidium等。</li>
</ol>
<h4 id="组件层"><a href="#组件层" class="headerlink" title="组件层"></a>组件层</h4><ol>
<li><p>组件建立在计算层上，重复使用标准化的智能合约模版。</p>
</li>
<li><p>组件层不是必不可少的。</p>
</li>
<li><p>可选组件主要包括：查询层（The Graph、dfuse）、预言机（Chainlink、Band Protocol）、DID、DDNS、Digital Assets（BTC、ETH 等）、Crypto Currencies（ERC20、ERC721 等）、Stablecoin（USDC、DAI）等。</p>
</li>
</ol>
<h4 id="计算层"><a href="#计算层" class="headerlink" title="计算层"></a>计算层</h4><ol>
<li>计算层允许人类指示状态层做他们想做的事。具体指状态转换机，如EVM、WASM 等。</li>
</ol>
<h4 id="状态层"><a href="#状态层" class="headerlink" title="状态层"></a>状态层</h4><ol>
<li><p>状态层主要是公链的集合，如Bitcoin、Ethereum、Solana等；</p>
</li>
<li><p>状态层还可以细分为状态转化层、共识层、分片层、P2P 层等。</p>
</li>
</ol>
<h4 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h4><ol>
<li>成本高，链外分布式存储，IPFS、Arweare 和Swarm。</li>
</ol>
<p>除了上述核心堆栈外，Web3.0 还有一些距离终端用户较远的基础设施，比如：可信执行环境（TEE）、互联网协议（IP）、混合网络数据包路由等。</p>
<h3 id="分类方法2"><a href="#分类方法2" class="headerlink" title="分类方法2"></a>分类方法2</h3><ol>
<li><p>协议层</p>
</li>
<li><p>应用层</p>
</li>
<li><p>网络基础层</p>
</li>
</ol>
<h3 id="分类方法3"><a href="#分类方法3" class="headerlink" title="分类方法3"></a>分类方法3</h3><ol>
<li><p>交互层</p>
</li>
<li><p>平台层</p>
</li>
<li><p>基础层</p>
</li>
</ol>
<h3 id="分类方法4"><a href="#分类方法4" class="headerlink" title="分类方法4"></a>分类方法4</h3><p><img src="https://s2.loli.net/2022/05/06/sUKBNh65QxqeMvk.png" alt=""></p>
<h3 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h3><ol>
<li><p>零知识证明</p>
</li>
<li><p>EVM</p>
</li>
<li><p>跨链</p>
</li>
<li><p>分片、L2、链外计算</p>
</li>
<li><p>预言机</p>
</li>
<li><p>人工智能超算</p>
</li>
<li><p>去信任的交互协议和平台</p>
</li>
<li><p>分布式存储</p>
</li>
</ol>
<h3 id="隐私相关技术"><a href="#隐私相关技术" class="headerlink" title="隐私相关技术"></a>隐私相关技术</h3><ol>
<li><p>隐私匿名币</p>
</li>
<li><p>智能合约隐私</p>
</li>
<li><p>Layer1 和 Layer2 各自的技术</p>
</li>
<li><p>多方安全技术</p>
</li>
<li><p>同态加密</p>
</li>
<li><p>可信执行环境TEE</p>
</li>
</ol>
<h2 id="未来趋势"><a href="#未来趋势" class="headerlink" title="未来趋势"></a>未来趋势</h2><p>中国经济未来的增长点在于数字经济Web3.0是数字经济发展的关键。目前海外Web3.0 体系仍存在一定经济金融风险。中国应发挥战略驱动作用完善监管体系,在合规框架下探索Web3.0的中国化之潞。</p>
<h3 id="发展挑战"><a href="#发展挑战" class="headerlink" title="发展挑战"></a>发展挑战</h3><p>商业逻辑变化可能导致经济风险，监管需相应适配</p>
<ol>
<li><p>国家层面：探索带来认知升级挑战，各国发展路径不一</p>
</li>
<li><p>产业层面：底层技术需持续攻破</p>
</li>
<li><p>经济层面：具有一定资本操纵和经济风险，监管难度加大</p>
</li>
<li><p>企业层面：短期内互联网中心化特征难以打破</p>
</li>
</ol>
<h3 id="投融资分析"><a href="#投融资分析" class="headerlink" title="投融资分析"></a>投融资分析</h3><p>海外Web3.0 投资如火如荼，中国侧重元宇宙“沉浸式应用”</p>
<h3 id="发展趋势"><a href="#发展趋势" class="headerlink" title="发展趋势"></a>发展趋势</h3><ol>
<li><p>全球或将分区发展，全新商业模式亟待探索</p>
<ol>
<li><p>海外投资：海外机构将加大对Web3.0的投资</p>
</li>
<li><p>商业模式：流量价值依旧重要，激励机制对流量影响较大</p>
</li>
<li><p>企业探索：大量Web2.0的公司或将尝试进入 Web3.0</p>
</li>
<li><p>国家监管：各国在本国合规政策下探索不同的发展道路</p>
</li>
</ol>
</li>
<li><p>中国化之路：数字经济体系下构建中国Web3.0生态，新型科技在合规市场提供服务</p>
<ol>
<li><p>中国经济未来的增长点在于数字经济</p>
</li>
<li><p>Web3.0是数字经济发展的关键</p>
</li>
<li><p>Web3.0在中国发展首先需要发展新型科技</p>
</li>
<li><p>中国需在合规框架下探索路线</p>
</li>
</ol>
</li>
</ol>
<h3 id="监管趋势"><a href="#监管趋势" class="headerlink" title="监管趋势"></a>监管趋势</h3><ol>
<li><p>对于沟通Web3.0 和Web2.0 两个世界的通道/业务，将首当其冲，寻求适合的监管模式，以适应Web3.0 的发展；</p>
</li>
<li><p>隐私和匿名方面，有可能存在底层实现KYC，应用层实现适度匿名；</p>
</li>
<li><p>DAO 治理过程中，势必会引入监管作为治理一方。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>行业总结</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-众包相关论文调研</title>
    <url>/2022/05/06/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-%E4%BC%97%E5%8C%85%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h3 id="1-Two-Stage-Auction-Mechanism-for-Long-Term-Participation-in-Crowdsourcing"><a href="#1-Two-Stage-Auction-Mechanism-for-Long-Term-Participation-in-Crowdsourcing" class="headerlink" title="1-Two-Stage Auction Mechanism for Long Term Participation in Crowdsourcing"></a>1-Two-Stage Auction Mechanism for Long Term Participation in Crowdsourcing</h3><p>针对小型任务的众包（例如：图像打标签、录音），workers愿意完成的任务数量上限不同，并且会在投标阶段谎报；拍卖随时间推移重复多轮，失败的workers可能退出系统。</p>
<p>针对的问题：workers竞标时说的任务数量不一定真的能完成。workers通常可以负担大量的工作，尽管由于时间限制和边际收益递减会有一定的限制。此外，workers很难确保他们所有的工作都符合requester设定的质量标准，因此，requester需要根据工作的实际数量支付报酬。</p>
<p>本文思路：workers的投标包括单个任务的报酬、自己愿意完成的最大任务数量和自己实际完成的任务数量。基于迈尔森拍卖机制推广得到两阶段博弈机制（这部分公式非常相似），证明了该机制的激励相容和个体理性；提出了使得requester能在成本效率和公平性之间取得平衡的任务分配机制，从而让wokers有意愿长期留在系统中参与众包。</p>
<p>使用参数进行了仿真实验分析。</p>
<blockquote>
<p>这篇文章后面出现了直接成本和间接成本，还没有细看是什么。</p>
</blockquote>
<h3 id="2-Quality-Aware-Incentive-Mechanisms-Under-Social-Influences-in-Data-Crowdsourcing"><a href="#2-Quality-Aware-Incentive-Mechanisms-Under-Social-Influences-in-Data-Crowdsourcing" class="headerlink" title="2-Quality Aware Incentive Mechanisms Under Social Influences in Data Crowdsourcing"></a>2-Quality Aware Incentive Mechanisms Under Social Influences in Data Crowdsourcing</h3><p>利用用户之间的社会影响作为激励来激励用户的参与，以降低招募用户的成本。设计了激励机制，以实现高质量的众包数据和低成本的激励用户参与为目标。</p>
<p>把用户的社会影响力看作是一个影响用户完成任务所需成本的参数。设计两阶段博弈，第一阶段通过任务分配最大化质量，第二阶段通过决定招募用户的顺序来最小化成本。</p>
<p>在完全信息情景下，设计了任务分配和用户招聘机制，以优化数据质量，同时降低激励成本。在部分信息场景中，用户的质量和成本是未知的。由用户上报质量和成本，假设是异构任务，利用任务之间的相互关系来克服信息不对称。在动态社会影响场景中，考察了用户社会影响力的动态性，并为用户设计额外的奖励，以充分利用社会影响力，实现最大限度的成本节约。</p>
<p>使用数值结果来评估激励机制。</p>
<h3 id="3-SocialRecruiter-Dynamic-Incentive-Mechanism-for-Mobile-Crowdsourcing-Worker-Recruitment-With-Social-Networks"><a href="#3-SocialRecruiter-Dynamic-Incentive-Mechanism-for-Mobile-Crowdsourcing-Worker-Recruitment-With-Social-Networks" class="headerlink" title="3-SocialRecruiter: Dynamic Incentive Mechanism for Mobile Crowdsourcing Worker Recruitment With Social Networks"></a>3-SocialRecruiter: Dynamic Incentive Mechanism for Mobile Crowdsourcing Worker Recruitment With Social Networks</h3><p>现有研究大都在大量workers的场景下分析如何选择workers，本文则针对有限人数的众包系统中的参与不足问题，提出利用社会网络招募完成任务的员工，扩大员工库。提出了一种动态激励机制，SocialRecruiter，鼓励众包平台上的工作人员通过社交网络传播任务，从而邀请朋友加入众包平台，进一步传播和完成任务。</p>
<p>受SIR传染病模型的启发，本文提出了一个新的任务特定的传染病模型来刻画用户在任务传播和通过社会网络完成任务时的状态变化。为了鼓励员工完成和传播任务，根据员工的行为给予宣传奖励和完成奖励。特别是，为了在财务预算内最大限度地完成任务，根据实时员工招聘进度，在每个周期动态更新奖励的宣传和完成情况。</p>
<p>在两个真实数据集上的大量实验结果表明，社会化招聘者在员工招聘和任务完成方面的表现优于最先进的方法。</p>
<blockquote>
<p>这个和任务分配以及众包其实关系不大，有点拼多多拉新用户砍一刀的感觉。</p>
</blockquote>
<h3 id="4-A-Game-Theoretical-Approach-for-Secure-Crowdsourcing-Based-Indoor-Navigation-System-With-Reputation-Mechanism"><a href="#4-A-Game-Theoretical-Approach-for-Secure-Crowdsourcing-Based-Indoor-Navigation-System-With-Reputation-Mechanism" class="headerlink" title="4-A Game Theoretical Approach for Secure Crowdsourcing Based Indoor Navigation System With Reputation Mechanism"></a>4-A Game Theoretical Approach for Secure Crowdsourcing Based Indoor Navigation System With Reputation Mechanism</h3><p>本文的共谋场景在于：恶意接包方和发包方勾结从而在声誉系统中刷好评。针对众包中的共谋问题，引入完全可信的雾服务器平台进行众包数据交易。提出了一种新的基于响应者行为的声誉激励机制，使用攻防博弈来建模雾服务器平台和响应者之间的相互作用，通过这种相互作用建立一个社会福利最佳化问题，使系统的社会福利最大化。其次，利用复制动力学方程求出了博弈均衡，并讨论了博弈的稳定性。进行了仿真实验。</p>
<blockquote>
<p>从摘要看也和任务分配没什么关系。</p>
</blockquote>
<h3 id="5-Hierarchical-Pricing-Mechanism-With-Financial-Stability-for-Decentralized-Crowdsourcing-A-Smart-Contract-Approach"><a href="#5-Hierarchical-Pricing-Mechanism-With-Financial-Stability-for-Decentralized-Crowdsourcing-A-Smart-Contract-Approach" class="headerlink" title="5-Hierarchical Pricing Mechanism With Financial Stability for Decentralized Crowdsourcing A Smart Contract Approach"></a>5-Hierarchical Pricing Mechanism With Financial Stability for Decentralized Crowdsourcing A Smart Contract Approach</h3><p>传统众包平台的集中性会带来信息披露和审计不透明问题，本文引入区块链系统，通过两个专用的智能合约集成了任务分配和资源借贷的功能。其次，为了保证区块链激活市场的金融稳定性，并使接受任务的难度与工作人员的能力相匹配，我们设计了一种基于经济建模方法和异质代理理论的动态分层定价机制。在这种机制下，根据顾客报酬和员工资源的市场价值，市场被动态地划分为多个层次。提出了额外的限制，以避免工人在资源借贷过程中可能的恶意交易行为。我们从理论上证明了模型的合理性，并对模型的动力学性质进行了论证。我们证明了市场价格和需求是收敛的，并测试了执行这两个智能合同的成本。最后，大量的实验结果验证了该平台的正确性和可行性，并证实了分层定价机制能够保持市场的稳定性。</p>
<blockquote>
<p>时间问题没来得及看这篇中分配任务的合约是怎么设计的。</p>
</blockquote>
<h3 id="第6篇是我的，略"><a href="#第6篇是我的，略" class="headerlink" title="第6篇是我的，略"></a>第6篇是我的，略</h3><h3 id="7-Strategic-Information-Revelation-Mechanism-in-Crowdsourcing-Applications-Without-Verification"><a href="#7-Strategic-Information-Revelation-Mechanism-in-Crowdsourcing-Applications-Without-Verification" class="headerlink" title="7-Strategic Information Revelation Mechanism in Crowdsourcing Applications Without Verification"></a>7-Strategic Information Revelation Mechanism in Crowdsourcing Applications Without Verification</h3><p>这篇是看过的黄建伟老师的论文。</p>
<ul>
<li>本文研究：无需验证解决方案、激励员工提供高质量解决方案的众包平台</li>
<li>本文假设：信息不对称、平台具有信息优势——平台知道有关workers解决方案的平均准确性的更多信息，可以向workers策略性披露信息。根据平台公开的信息，workers判断自己认真完成任务后所获得的奖励。</li>
<li>workers类型：<ol>
<li>naive workers：完全信任平台公开的信息</li>
<li>strategic workers：基于平台公开信息更新自己的先验信念</li>
</ol>
</li>
<li>本文发现：<ol>
<li>对于naive workers：始终宣布高平均精度</li>
<li>对于strategic workers：有动机宣布低于实际值的平均精度</li>
<li>平台的回报可能减少高精度workers</li>
</ol>
</li>
</ul>
<h3 id="8-Generalized-Lottery-Trees-Budget-Balanced-Incentive-Tree-Mechanisms-for-Crowdsourcing"><a href="#8-Generalized-Lottery-Trees-Budget-Balanced-Incentive-Tree-Mechanisms-for-Crowdsourcing" class="headerlink" title="8-Generalized Lottery Trees Budget-Balanced Incentive Tree Mechanisms for Crowdsourcing"></a>8-Generalized Lottery Trees Budget-Balanced Incentive Tree Mechanisms for Crowdsourcing</h3><p>现有研究大多假设用户已经处于众包系统中并知道众包任务，然而，在没有这种假设的现实生活场景中，更有效的做法是利用激励树机制，激励用户的直接贡献和对其他用户的诱惑。本文提出预算平衡激励树机制，称为广义彩票树。</p>
<blockquote>
<p>也和任务分配没有关系</p>
</blockquote>
<h3 id="9-Incentive-Mechanism-for-Spatial-Crowdsourcing-with-Unknown-Social-Aware-Workers-A-Three-Stage-Stackelberg-Game-Approach"><a href="#9-Incentive-Mechanism-for-Spatial-Crowdsourcing-with-Unknown-Social-Aware-Workers-A-Three-Stage-Stackelberg-Game-Approach" class="headerlink" title="9-Incentive Mechanism for Spatial Crowdsourcing with Unknown Social-Aware Workers A Three-Stage Stackelberg Game Approach"></a>9-Incentive Mechanism for Spatial Crowdsourcing with Unknown Social-Aware Workers A Three-Stage Stackelberg Game Approach</h3><p>在空间众包场景下，大多数现有的工作假设工人的素质是事先知道的，或不能考虑到所有各方的效用一起，特别是没有考虑到社会网络的影响。针对同时招募高素质的工人和最大限度地发挥各方的效用这一目标，提出了一种基于多臂老虎机和三阶段 Stackelberg 博弈的激励机制，称为 TACT。首先设计了一个贪婪选臂方案来招募工人，这不仅可以解决探索-剥削的困境，而且考虑到工人的社会关系。在招聘结果的基础上，进一步设计了考虑劳动者社会利益的效用函数，并将支付计算问题建模为三阶段 Stackelberg 博弈。接下来，推导出最优策略群，使每一方都能最大化自己的效用，从而形成一个多赢的局面。并从理论上证明了Stackelberg 均衡的唯一存在性和最坏后悔界的存在性。</p>
<p>我们在一个真实的轨迹上进行了广泛的模拟，以证实 TACT 的性能。</p>
<blockquote>
<p>这个主要是招募workers，具体是否有任务分配还不了解。</p>
</blockquote>
<h3 id="列表中的第10篇和前面第3篇重复了。"><a href="#列表中的第10篇和前面第3篇重复了。" class="headerlink" title="列表中的第10篇和前面第3篇重复了。"></a>列表中的第10篇和前面第3篇重复了。</h3><h3 id="11-Differentially-Private-Mechanisms-for-Budget-Limited-Mobile-Crowdsourcing"><a href="#11-Differentially-Private-Mechanisms-for-Budget-Limited-Mobile-Crowdsourcing" class="headerlink" title="11-Differentially Private Mechanisms for Budget Limited Mobile Crowdsourcing"></a>11-Differentially Private Mechanisms for Budget Limited Mobile Crowdsourcing</h3><p>本文考虑了在激励用户参与众包这一过程中的隐私问题。在本文的场景中，移动众包平台的目标是在一个预算限制下最大化众包收入，而用户期望是最大化他们的效用，同时保护他们的成本隐私。大致浏览了一下应该是用多臂赌博机在预算限制下实现最大化收入，用差分隐私实现隐私保护。</p>
<blockquote>
<p>偏重隐私保护，不确定是否有任务分配和定价等内容。</p>
</blockquote>
<h3 id="12-Privacy-Preserving-Incentive-Mechanisms-for-Truthful-Data-Quality-in-Data-Crowdsourcing"><a href="#12-Privacy-Preserving-Incentive-Mechanisms-for-Truthful-Data-Quality-in-Data-Crowdsourcing" class="headerlink" title="12-Privacy-Preserving Incentive Mechanisms for Truthful Data Quality in Data Crowdsourcing"></a>12-Privacy-Preserving Incentive Mechanisms for Truthful Data Quality in Data Crowdsourcing</h3><p>接包方的任务质量与数据是隐私信息，因此她有动机谎报。此外，接包方的质量和数据可能依赖于一些敏感信息（例如位置），这可以从对手的任务分配和数据聚合的结果中推断出来（没理解这句话）。本文设计了保护隐私的机制（PDQE）来获取接包方的质量和数据。在这些机制中，本文设计了不同的私有任务分配和数据聚合算法，以防止从这些算法的结果推断接包方的质量和数据。与此同时，这些机制还鼓励接包方如实报告质量和数据，并做出预期的努力。我们首先关注单个任务的机制(S-PDQE)，然后将其扩展到多个任务的情况(M-PDQE)。我们进一步证明，这两种机制实现了一个有限的性能差距相比，最优策略。</p>
<p>我们使用基于真实数据的仿真来评估所提出的机制，这些仿真证实了它们在真实数据质量提取、数据准确性和隐私保护等方面的优良性能。</p>
<blockquote>
<p>这篇应该有涉及任务分配的内容，时间关系没有详细看了。</p>
</blockquote>
<h3 id="13-Reward-or-Penalty-Aligning-Incentives-of-Stakeholders-in-Crowdsourcing"><a href="#13-Reward-or-Penalty-Aligning-Incentives-of-Stakeholders-in-Crowdsourcing" class="headerlink" title="13-Reward or Penalty Aligning Incentives of Stakeholders in Crowdsourcing"></a>13-Reward or Penalty Aligning Incentives of Stakeholders in Crowdsourcing</h3><p>本文针对二值众包问题场景（例如接包方只需要回答是或者否），考虑三方利益：接包方、发包方和众包平台，分析四个评价指标：质量、成本、延迟和平台改进。从整个众包系统的角度出发，设计了一个众包机制，将利益相关者的动机结合起来。具体来说，根据接包方的报告解决方案给予其奖励或处罚，在此基础上，找到了一系列合适的奖惩函数对，并计算出接包方的个人秩序值，这些秩序值可以根据接包方的报告信念和个人历史绩效提供不同的奖惩数额，同时保持接包方的激励。该机制有助于延迟控制，促进众包系统的质量和平台演进，并改进上述四个关键评价指标。理论分析和实验结果分别验证和评价了提出的机理。</p>
<blockquote>
<p>没有细看方法，粗略浏览感觉像是根据先验信念等估计接包方的准确性等。</p>
</blockquote>
<h3 id="14-Strategic-Social-Team-Crowdsourcing-Forming-a-Team-of-Truthful-Workers-for-Crowdsourcing-in-Social-Networks"><a href="#14-Strategic-Social-Team-Crowdsourcing-Forming-a-Team-of-Truthful-Workers-for-Crowdsourcing-in-Social-Networks" class="headerlink" title="14-Strategic Social Team Crowdsourcing Forming a Team of Truthful Workers for Crowdsourcing in Social Networks"></a>14-Strategic Social Team Crowdsourcing Forming a Team of Truthful Workers for Crowdsourcing in Social Networks</h3><p>本文针对的场景是社交网络中的团队众包，即发包方雇佣一个专业workers团队，而团队内的接包方有社交关联，可以协同工作。在传统的最大化社会福利的机制下，存在自私的接包方会损害发包方的利益，为避免这一问题，本文提出了两种有效机制来优化社会福利，同时降低不同规模应用的时间复杂度。对于小规模的应用，如果任务需要少量的技能，则首先从社会网络中提取出一个二叉树网络，然后在二叉树中形成一个基于动态规划的最优团队。对于任务需要大量技能的大规模应用，根据工人的社会结构、技能和工作成本使用贪婪算法形成团队。</p>
<blockquote>
<p>这篇应该有任务分配问题，不过还没看是怎么分配的。</p>
</blockquote>
<h3 id="15-Eliciting-Information-from-Heterogeneous-Mobile-Crowdsourced-Workers-Without-Verification"><a href="#15-Eliciting-Information-from-Heterogeneous-Mobile-Crowdsourced-Workers-Without-Verification" class="headerlink" title="15-Eliciting Information from Heterogeneous Mobile Crowdsourced Workers Without Verification"></a>15-Eliciting Information from Heterogeneous Mobile Crowdsourced Workers Without Verification</h3><p>本文场景：</p>
<ol>
<li>workers求解准确率异构（即，不同workers以不同概率生成高质量数据）</li>
<li>考虑数据质量与平台成本之间的平衡</li>
</ol>
<p>本文方法：多数投票机制</p>
<p>需要解决的问题：</p>
<ol>
<li>给定奖励，多数投票机制下，异构workers会如何行动；</li>
<li>workers的异构性如何影响平台的最优奖励设计和均衡；</li>
<li>在提升平台均衡方面，知道workers异构方案准确性有什么价值。</li>
</ol>
<p>本文的两阶段博弈：</p>
<ol>
<li>平台决定多数投票机制的奖励等级，目标是最大化收益，该收益考虑了workers解决方案质量和平台总支出之间的均衡；</li>
<li>每个worker选择自己的努力等级和报告策略，目标是最大化自己收益。</li>
</ol>
<p>本文考虑两种情况：</p>
<ol>
<li>不完全信息博弈（平台不知道workers的准确率）</li>
<li>完全信息博弈（平台知道workers的准确率）</li>
</ol>
<p>本文贡献：</p>
<ol>
<li>分析了IEWV问题中异构workers场景下的平台均衡</li>
<li>分析了多均衡共存的场景</li>
<li>刻画了workers的最优策略</li>
<li>刻画了workers异构性对平台均衡的影响</li>
<li>刻画了得知workers异构性的价值</li>
</ol>
<h3 id="16-Data-Poisoning-Attacks-and-Defenses-in-Dynamic-Crowdsourcing-with-Online-Data-Quality-Learning"><a href="#16-Data-Poisoning-Attacks-and-Defenses-in-Dynamic-Crowdsourcing-with-Online-Data-Quality-Learning" class="headerlink" title="16-Data Poisoning Attacks and Defenses in Dynamic Crowdsourcing with Online Data Quality Learning"></a>16-Data Poisoning Attacks and Defenses in Dynamic Crowdsourcing with Online Data Quality Learning</h3><p>为了提高数据的准确性和成本效益，工人的数据质量可以通过在线方式从他们的数据中学习，可以用于任务分配和数据聚合。然而，众包很容易受到数据病毒攻击，攻击者报告恶意数据以降低聚合数据的准确性。</p>
<p>本文研究了任务按顺序分配和执行的动态众包中的恶意数据攻击，探讨了作为一种防御机制的在线质量学习如何通过发现低质量的恶意工作者来抵御攻击。首先关注每个接包方的质量都被请求者准确学习的渐近设置，然后在此基础上转向一般的有误差非渐近设置。对于每个设置，首先描述了攻击策略可以有效降低聚合数据准确性的条件。结果表明，恶意噪声方差需要在一定范围内的攻击是有效的。然后分析了有效攻击策略的危害。研究结果表明，由于有效的攻击，在线质量学习算法的遗憾性会增加。为了进一步减轻攻击，研究了基于估计的数据聚合作为防御机制的中值和最大影响。研究结果为数据中毒攻击的影响提供了有用的见解，当在线高质量学习被用来抵御攻击时。我们通过基于真实数据的大量仿真结果对提出的攻击和防御方案进行了评估，验证了攻击和防御方案的有效性。</p>
<blockquote>
<p>这篇论文偏向数据污染问题，和我们可能关系不大。</p>
</blockquote>
<h3 id="17-Using-Truth-Detection-to-Incentivize-Workers-in-Mobile-Crowdsourcing"><a href="#17-Using-Truth-Detection-to-Incentivize-Workers-in-Mobile-Crowdsourcing" class="headerlink" title="17-Using Truth Detection to Incentivize Workers in Mobile Crowdsourcing"></a>17-Using Truth Detection to Incentivize Workers in Mobile Crowdsourcing</h3><p>众包模式相比于传统机构的工作模式，其工人通常是高度分散的，且工作过程也是不受监督的，这给他们上报低质量的解决方案提供了温床。并且这种现象在众包平台无法验证工人解决方案的质量时尤为突出。比如，在慕课上的学生作业互评，就曾出现过网上学生恶意打分的现象。</p>
<p>在平台无法验证工人提交的解决方案时，现有的众包激励机制主要通过对比不同工人上报方案之间的相似性来进行奖励，而这有可能造成众包工人共谋。比如，目前比较流行的激励方法是输出一致机制。在输出一致机制中，当一个工人和其他工人的上报方案高度一致时，这个工人会获得奖励。可是，在上述机制下，如果平台不能对工人进行有效的管控，那么工人之间可以共谋上报相同但低质量的方案。这种情况对平台来说是灾难性的，因为不仅平台得到的方案质量低，而且还需要给每一个工人发放奖励。</p>
<p>为了缓解上述的工人共谋问题，我们创新性地提出一种测谎机制。具体而言，工人们不再因为自己的上报方案和其他工人相似而获得奖励，而是根据工人回答一个指定测谎问题的答案进行计算。我们可以发现，基于该测谎问题的激励设计会可以有效缓解工人共谋。这是因为，众包工人能否获得奖励只和自己对测谎问题的回答有关，而不和他人的上报方案有关。</p>
<p>其实在现实世界中，我们已经发现测谎技术的一些应用场景了。比如一些欧洲国家在边境检查的时候利用测谎技术来对过境人士的身份进行认证（详情请见：<a href="https://iborderctrl.no/%EF%BC%89%E3%80%82%E7%84%B6%E8%80%8C%EF%BC%8C%E6%B5%8B%E8%B0%8E%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E6%8A%80%E6%9C%AF%E8%BF%98%E4%B8%8D%E5%A4%9F%E6%88%90%E7%86%9F%EF%BC%8C%E4%B8%80%E8%88%AC%E8%80%8C%E8%A8%80%E8%83%BD%E8%BE%BE%E5%88%B0%E7%9A%84%E5%87%86%E7%A1%AE%E7%8E%87%E4%B9%9F%E4%B8%8D%E9%AB%98%EF%BC%88%E6%99%AE%E9%81%8D%E4%BD%8E%E4%BA%8E65%%EF%BC%89%E3%80%82%E4%B8%BA%E4%BA%86%E6%9C%80%E5%A4%A7%E5%8C%96%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%88%A9%E7%9B%8A%EF%BC%8C%E6%88%91%E4%BB%AC%E6%8F%90%E5%87%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E8%BF%91%E4%BC%BC%E5%87%B8%E7%9A%84%E6%B5%8B%E8%B0%8E%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8C%96%E6%A1%86%E6%9E%B6%E3%80%82%E5%9C%A8%E8%AF%A5%E6%A1%86%E6%9E%B6%E4%B8%8B%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%91%E7%8E%B0%E5%8D%B3%E4%BD%BF%E6%B5%8B%E8%B0%8E%E7%B2%BE%E5%BA%A6%E5%8F%AA%E6%9C%8960%%EF%BC%8C%E6%88%91%E4%BB%AC%E7%9A%84%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%B9%B3%E5%8F%B0%E6%94%B6%E7%9B%8A%E5%8F%AF%E4%BB%A5%E8%B6%85%E8%BF%87%E5%9C%A8%E6%B5%8B%E8%B0%8E%E7%B2%BE%E5%BA%A6%E4%B8%BA100%%E4%B8%8B%E5%B9%B3%E5%8F%B0%E6%94%B6%E7%9B%8A%E7%9A%8485%%E3%80%82%E8%BF%99%E8%A1%A8%E6%98%8E%E6%88%91%E4%BB%AC%E6%8F%90%E5%87%BA%E7%9A%84%E6%B5%8B%E8%B0%8E%E6%9C%BA%E5%88%B6%E6%9C%89%E8%89%AF%E5%A5%BD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%8E%B0%E3%80%82" target="_blank" rel="noopener">https://iborderctrl.no/）。然而，测谎机制的底层技术还不够成熟，一般而言能达到的准确率也不高（普遍低于65%）。为了最大化平台的利益，我们提出了一个近似凸的测谎机制优化框架。在该框架下，我们发现即使测谎精度只有60%，我们的机制实现的平台收益可以超过在测谎精度为100%下平台收益的85%。这表明我们提出的测谎机制有良好的系统表现。</a></p>
<blockquote>
<p>这篇是黄建伟老师团队的，上述总结为公众号直接复制。看参考文献有贝叶斯实话血清的那个论文，推测是用了一样的方法。</p>
</blockquote>
<h3 id="18-Towards-Personalized-Task-Oriented-Worker-Recruitment-in-Mobile-Crowdsensing"><a href="#18-Towards-Personalized-Task-Oriented-Worker-Recruitment-in-Mobile-Crowdsensing" class="headerlink" title="18-Towards Personalized Task-Oriented Worker Recruitment in Mobile Crowdsensing"></a>18-Towards Personalized Task-Oriented Worker Recruitment in Mobile Crowdsensing</h3><p>移动众包系统中的任务通常具有时间敏感性和位置依赖性，这在员工招募中也起着至关重要的作用。基于此，本文提出了一种新颖的基于个性化任务驱动的移动众包系统员工招募机制，该机制基于对员工偏好的详细刻画，充分利用内容信息(例如，任务类别，任务描述)与上下文信息(例如，任务时间，任务位置)从工人出勤的隐性反馈，以准确地模型工人对任务的偏好。大致方法是做了一个分类器，识别workers所属的类别，进而分配相同类别的任务。</p>
<h3 id="19-Eliciting-Joint-Truthful-Answers-and-Profiles-from-Strategic-Workers-in-Mobile-Crowdsourcing-Systems"><a href="#19-Eliciting-Joint-Truthful-Answers-and-Profiles-from-Strategic-Workers-in-Mobile-Crowdsourcing-Systems" class="headerlink" title="19-Eliciting Joint Truthful Answers and Profiles from Strategic Workers in Mobile Crowdsourcing Systems"></a>19-Eliciting Joint Truthful Answers and Profiles from Strategic Workers in Mobile Crowdsourcing Systems</h3><p>在移动众包场景中，workers需要上传自己的个人信息（例如位置、专业能力等），本文设计激励机制保证workers上传的是真实信息，并招募志愿者进行了真实实验。</p>
<p>这篇论文也是针对二值回答的众包问题，用的方法基于贝叶斯推断，看上去和黄建伟老师那个有点像，没细看。</p>
<h3 id="20-Heterogeneous-Multi-Task-Assignment-in-Mobile-Crowdsensing-Using-Spatiotemporal-Correlation"><a href="#20-Heterogeneous-Multi-Task-Assignment-in-Mobile-Crowdsensing-Using-Spatiotemporal-Correlation" class="headerlink" title="20-Heterogeneous Multi-Task Assignment in Mobile Crowdsensing Using Spatiotemporal Correlation"></a>20-Heterogeneous Multi-Task Assignment in Mobile Crowdsensing Using Spatiotemporal Correlation</h3><p>现有的多任务分配方法大多侧重于同类任务，由于不同的时空任务需求和感知环境，众包系统中的任务往往在许多方面存在差异(如空间覆盖率、时间间隔)。为此，本文提出并形式化了移动众包系统中一个重要的异构多任务分配问题（HMTA），并尝试最大化数据质量和最小化总的激励预算。利用异构任务之间的隐含时空相关性，提出了一种两阶段 HMTA 问题求解方法，有效地处理共享资源池中的多个并发任务。最后，为了提高分配搜索效率，设计了一个分解组合框架来适应大规模的问题/情景。我们广泛地使用两个大规模的真实世界数据集来评估我们的方法。实验结果验证了该方法的有效性和有效性。</p>
<blockquote>
<p>具体是怎么解决的还没细看。</p>
</blockquote>
<h3 id="21-Secure-Crowdsensed-Data-Trading-Based-on-Blockchain"><a href="#21-Secure-Crowdsensed-Data-Trading-Based-on-Blockchain" class="headerlink" title="21-Secure Crowdsensed Data Trading Based on Blockchain"></a>21-Secure Crowdsensed Data Trading Based on Blockchain</h3><p>本文提出了一个基于区块链的众包数据交易(BCDT)系统，该系统靠智能合约保证数据交易的可靠性，采用基于区块链的反向拍卖(BRA)将感知任务分配给接包方，该机制可以保证数据收集者如实报告数据收集成本，防止卖方操纵拍卖。此外还实现了一个基于同态密码的安全真相发现和可靠性评级机制(STDR) ，该机制可以激励接包方上传真实数据，鼓励发包方在不泄露数据隐私的情况下，根据收集到的数据对接包方的可靠性进行真实评级。在以太坊测试网络上进行了智能合约的性能测试。</p>
<h3 id="列表中的第22篇和前面第2篇重复了。"><a href="#列表中的第22篇和前面第2篇重复了。" class="headerlink" title="列表中的第22篇和前面第2篇重复了。"></a>列表中的第22篇和前面第2篇重复了。</h3><h3 id="23-Two-Stage-Game-Design-of-Payoff-Decision-Making-Scheme-for-Crowdsourcing-Dilemmas"><a href="#23-Two-Stage-Game-Design-of-Payoff-Decision-Making-Scheme-for-Crowdsourcing-Dilemmas" class="headerlink" title="23-Two Stage Game Design of Payoff Decision-Making Scheme for Crowdsourcing Dilemmas"></a>23-Two Stage Game Design of Payoff Decision-Making Scheme for Crowdsourcing Dilemmas</h3><p>为了解决发包方和众包平台之间的合作困境，首先提出了一种基于信誉质量规则的发包方动态支付方法，然后开发了一种估算平台成本的合作评估算法，最后设计了一个共同确定算法来判断平台是否采用了合作策略。</p>
<p>为了解决众包平台与员工之间的服务质量困境，首先提出了一种拍卖筛选方法来估算员工的合理招聘范围，并利用成本评价算法对其进行优化，然后利用报酬分配方法来激励员工按时、高质量地完成任务。</p>
<h3 id="24-Data-Driven-Pricing-for-Sensing-Effort-Elicitation-in-Mobile-Crowd-Sensing-Systems"><a href="#24-Data-Driven-Pricing-for-Sensing-Effort-Elicitation-in-Mobile-Crowd-Sensing-Systems" class="headerlink" title="24-Data-Driven Pricing for Sensing Effort Elicitation in Mobile Crowd Sensing Systems"></a>24-Data-Driven Pricing for Sensing Effort Elicitation in Mobile Crowd Sensing Systems</h3><p>一些众包场景通过数据聚合来评估接包方的数据质量，但面临接包方策略性降低传感工作效率（存疑，原文是strategic reduction of their sensing effort）的问题，基于此，本文提出了一种名为 Theseus 的支付机制，它处理工人的这种战略行为，并激励工人的高努力感知。我们确保，在Theseus诱导的非合作博弈的贝叶斯纳什均衡点中，所有参与的工作人员都将尽可能地花费在感知上，从而提高了他们的数据质量。</p>
<blockquote>
<p>该机制具体是怎么实现的没有看。</p>
</blockquote>
<h3 id="25-Truthful-Mobile-Crowdsensing-for-Strategic-Users-With-Private-Data-Quality"><a href="#25-Truthful-Mobile-Crowdsensing-for-Strategic-Users-With-Private-Data-Quality" class="headerlink" title="25-Truthful Mobile Crowdsensing for Strategic Users With Private Data Quality"></a>25-Truthful Mobile Crowdsensing for Strategic Users With Private Data Quality</h3><p>众包数据准确性与接包方的私有信息相关，接包方可能出于个人利益控制这些信息和自己的努力程度，进而导致发包方对数据准确性有错误认知。本文设计了质量和努力启发(QEE)的真实众感机制，激励策略型用户如实地揭示他们的个人质量，如实地按照请求者的要求做出努力。QEE机制通过克服用户数据对其私有质量和隐藏努力的复杂依赖性来实现真实的设计。在 QEE 机制下，我们证明了发包方的最优努力分配(RO)只分配给具有最小“虚拟估值”的最优用户，这取决于用户的质量和质量的分布。我们还发现，随着用户数量的增加，RO 努力分配和社会最优努力分配之间的性能差距减小，并渐近收敛到0。我们进一步讨论了 QEE 机制的一些扩展。</p>
<blockquote>
<p>具体实现方法没看。</p>
</blockquote>
<h3 id="26-Differentially-Private-Incentive-Mechanism-for-Crowdsourced-Radio-Environment-Map-Construction"><a href="#26-Differentially-Private-Incentive-Mechanism-for-Crowdsourced-Radio-Environment-Map-Construction" class="headerlink" title="26-Differentially Private Incentive Mechanism for Crowdsourced Radio Environment Map Construction"></a>26-Differentially Private Incentive Mechanism for Crowdsourced Radio Environment Map Construction</h3><p>本文提出了一种基于众包的频谱感知的差分私有逆向拍卖机制。提出的机制允许 DBA 选择预算限制的频谱感知参与者，同时提供差别投标隐私、近似真实性和近似准确性最大化。</p>
<h3 id="27-Mechanism-design-games-for-thwarting-malicious-behavior-in-crowdsourcing-applications"><a href="#27-Mechanism-design-games-for-thwarting-malicious-behavior-in-crowdsourcing-applications" class="headerlink" title="27-Mechanism design games for thwarting malicious behavior in crowdsourcing applications"></a>27-Mechanism design games for thwarting malicious behavior in crowdsourcing applications</h3><p>是春池的论文。</p>
<p>采用发包方主导的契约型反恶意众包机制，根据个体恶意众包和集群恶意众包的不同特性，发包方将针对性地提出满足激励相容原则的契约，迫使接包方按照契约根据自己的真实私有信息（包括与恶意攻击相关的真实信息）制定最优策略，并据此可使发包方反推自己的最优策略，实现资源的最佳配置（最优任务量和最优酬金），通过经济手段遏制恶意众包。</p>
<p>设计接包方参与的契约型反恶意众包机制，使得接包方可针对契约制定提出意见、发包方在意见约束下制定契约，最终实现隐私保护的全局帕累托最优。</p>
<h3 id="28-Minimizing-Entropy-for-Crowdsourcing-with-Combinatorial-Multi-Armed-Bandit"><a href="#28-Minimizing-Entropy-for-Crowdsourcing-with-Combinatorial-Multi-Armed-Bandit" class="headerlink" title="28-Minimizing Entropy for Crowdsourcing with Combinatorial Multi-Armed Bandit"></a>28-Minimizing Entropy for Crowdsourcing with Combinatorial Multi-Armed Bandit</h3><p>衡量最终聚合结果的不确定性的工作者结果的经验熵，自然成为评估众包任务结果的一个合适的度量。因此，本文设计了一个工人选择机制，使参与者提交的结果的经验熵最小化。具体来说，我们将连续到达任务下的工作者选择规划为一个组合多臂老虎机问题，该问题将每个工作者视为一只手臂，旨在学习最佳的手臂组合，以最小化累积的经验熵。利用信息论方法，详细推导了经验熵极小化的置信上界估计，并将其应用到最小熵置信上界(ME-UCB)算法中，以平衡勘探与开发。</p>
<blockquote>
<p>总的来说就i是用多臂赌博机的模型，把经验熵作为衡量赌博机的遗憾函数。</p>
</blockquote>
<h3 id="29-Truthful-Incentive-Mechanisms-for-Crowdsourcing"><a href="#29-Truthful-Incentive-Mechanisms-for-Crowdsourcing" class="headerlink" title="29-Truthful Incentive Mechanisms for Crowdsourcing"></a>29-Truthful Incentive Mechanisms for Crowdsourcing</h3><p>针对接包方之间的竞争与合作，建立3种众包模型，并分别设计激励机制。</p>
<p>SS模型：一个发包方，一个投标（指每个接包方报价时只能报一个任务和自己愿意做任务的最低报酬）</p>
<p>SM模型：一个发包方，多个投标（指每个接包方报价时可以报多个任务和对应的最低报酬）</p>
<p>MM模型：多个发包方，多个投标</p>
<blockquote>
<p>具体的方法还需要之后再看。</p>
</blockquote>
<h3 id="30-Crowdsourcing-System-for-Numerical-Tasks-based-on-Latent-Topic-Aware-Worker-Reliability"><a href="#30-Crowdsourcing-System-for-Numerical-Tasks-based-on-Latent-Topic-Aware-Worker-Reliability" class="headerlink" title="30-Crowdsourcing System for Numerical Tasks based on Latent Topic Aware Worker Reliability"></a>30-Crowdsourcing System for Numerical Tasks based on Latent Topic Aware Worker Reliability</h3><p>本文针对的场景是采用依据主题进行任务分配的众包系统，本文旨在对数值任务中潜在主题的细粒度工作者可靠性进行精确估计，以进一步提高结果质量。提出了一种基于工作者行为的贝叶斯概率模型——高斯潜在主题模型(GLTM) ，用于挖掘数值任务的潜在主题，并估计工作者的主题级可靠性。利用该算法，提出了一种真值推理算法 ti-GLTM，可以同时准确推断任务的真值和主题，并动态更新工作者的主题级可靠性。我们还设计了一种在线任务分配机制，称为 MRA-GLTM，该机制利用最大限度减少模糊度原则为工作者分配合适的任务。</p>
<h3 id="31-MOMD-A-multi-object-multi-dimensional-auction-for-crowdsourced-mobile-video-streaming"><a href="#31-MOMD-A-multi-object-multi-dimensional-auction-for-crowdsourced-mobile-video-streaming" class="headerlink" title="31-MOMD A multi-object multi-dimensional auction for crowdsourced mobile video streaming"></a>31-MOMD A multi-object multi-dimensional auction for crowdsourced mobile video streaming</h3><p>针对场景：移动视频流资源共享，让附近的移动视频用户聚合他们的网络资源，以提高视频流的性能。</p>
<p>问题：用户自私，用户的异步下载行为以及对多比特率编码视频的私有估值</p>
<p>本文方法：基于多目标多维拍卖的激励框架，通过这个框架，用户可以下载多个不同比特率的视频片段给多个邻近的用户(和他们自己)。基于这一激励框架，我们提出了维克里分数拍卖，这是第一个多目标多维度拍卖，达到了真实性和效率。</p>
<h3 id="32-Incentivizing-crowdsourcing-systems-with-network-effects"><a href="#32-Incentivizing-crowdsourcing-systems-with-network-effects" class="headerlink" title="32-Incentivizing crowdsourcing systems with network effects"></a>32-Incentivizing crowdsourcing systems with network effects</h3><p>将网络效应看作是内在奖励的影响因素，并研究其对外在奖励设计的影响。我们没有假设参与者是固定的，而是展示了参与用户的数量进化到一个稳定的平衡，这要归功于网络效应和众包者提供的外部奖励之间的微妙互动。考虑到网络效应，我们设计了更复杂的外部奖励机制，并为众包者提出了新的最优策略以获得更高的效用。</p>
<blockquote>
<p>这个网络效应实际上和前面的社会关系、社会影响等是一样的。</p>
</blockquote>
<h3 id="33-Truthful-online-double-auctions-for-dynamic-mobile-crowdsourcing"><a href="#33-Truthful-online-double-auctions-for-dynamic-mobile-crowdsourcing" class="headerlink" title="33-Truthful online double auctions for dynamic mobile crowdsourcing"></a>33-Truthful online double auctions for dynamic mobile crowdsourcing</h3><p>把移动众包场景中发包方和接包方的双向互动建模为在线双向拍卖，明确考虑到用户和供应商的动态特性。我们提出了一个通用框架，用于设计动态移动众包的真实在线双向拍卖。该框架是表达性的，可以与不同的价格时间表。我们提出了四个价格表的价格排序在线双向拍卖来实现该框架，适用于不同的场景。</p>
<h3 id="34-How-to-crowdsource-tasks-truthfully-without-sacrificing-utility-Online-incentive-mechanisms-with-budget-constraint"><a href="#34-How-to-crowdsource-tasks-truthfully-without-sacrificing-utility-Online-incentive-mechanisms-with-budget-constraint" class="headerlink" title="34-How to crowdsource tasks truthfully without sacrificing utility Online incentive mechanisms with budget constraint"></a>34-How to crowdsource tasks truthfully without sacrificing utility Online incentive mechanisms with budget constraint</h3><p>现有的大多数机制仅适用于所有用户信息都是先验知道的离线场景。相反，我们关注的是一个更加现实的场景，在这个场景中，用户以随机顺序一个接一个地到达网上。基于在线拍卖模型，我们研究了用户到达时向众包者提交其私有类型的问题，众包者的目标是在指定的截止日期之前选择一个用户子集，以最大化选定用户在预算线下提供的服务的价值(假设是一个非负的单调子模块函数)。我们设计了两个在线机制，OMZ 和 OMG，分别满足零到达-离开时间和更一般情况下的计算效率、个体理性、预算可行性、真实性、消费者主权和持续竞争性。</p>
<blockquote>
<p>这篇看起来是结合了拍卖和排队论</p>
</blockquote>
<h3 id="35-Reputation-based-incentive-protocols-in-crowdsourcing-applications"><a href="#35-Reputation-based-incentive-protocols-in-crowdsourcing-applications" class="headerlink" title="35-Reputation-based incentive protocols in crowdsourcing applications"></a>35-Reputation-based incentive protocols in crowdsourcing applications</h3><p>内在的激励问题存在于众包应用中，因为员工和请求者都是自私的，他们的目标是战略性地最大化他们自己的利益。本文提出了一种基于重复博弈的新的博弈论模型来激励员工努力工作。针对工人追求自身利益时出现的非合作均衡与理想帕累托有效结果之间的社会福利差距，本文提出了一类基于社会规范的激励协议，将声誉机制与众包网站目前实施的定价机制相结合，以改善这类应用中出现的非合作均衡的性能。我们首先在一个众包网站上制定交换双边市场，请求者和工作者相互匹配，并重复博弈。随后，我们研究了协议设计者如何为该网站寻找一个最优且可持续的(均衡)协议以获得最高的社会福利的问题。我们证明了提议的激励协议可以使网站运行接近帕累托最优。此外，我们还研究了另一个场景，其中协议设计者的目标是最大化网站的收入，并评估最优协议的性能。</p>
<h3 id="36-TRAC-Truthful-auction-for-location-aware-collaborative-sensing-in-mobile-crowdsourcing"><a href="#36-TRAC-Truthful-auction-for-location-aware-collaborative-sensing-in-mobile-crowdsourcing" class="headerlink" title="36-TRAC: Truthful auction for location-aware collaborative sensing in mobile crowdsourcing"></a>36-TRAC: Truthful auction for location-aware collaborative sensing in mobile crowdsourcing</h3><p>在这篇文章中，我们解决了激励智能手机用户加入智能手机移动众包应用程序的问题。与现有的机构设计工作不同，我们在智能手机传感任务分配时，独特地考虑了位置信息的关键维度。然而，位置感知在很大程度上增加了理论和计算的复杂度。在本文中，我们引入了一个逆向拍卖框架来建立平台和智能手机之间的交互模型。我们严格地证明，最佳地确定中标是 NP 难的。本文设计了一种由两个主要部件组成的 TRAC 机构。第一部分是一个近似最优的近似算法，用于确定中标的多项式时间计算复杂度，它逼近的最优解在1 + ln (n) ，其中 n 是一个智能手机可以容纳的感知任务的最大数量。第二个组成部分是一个关键的支付方案，它保证提交的智能手机报价反映了执行感应任务的实际成本。</p>
<blockquote>
<p>这篇具体是什么方法还没看。</p>
</blockquote>
<h3 id="37-Incentivize-crowd-under-budget-constraint"><a href="#37-Incentivize-crowd-under-budget-constraint" class="headerlink" title="37-Incentivize crowd under budget constraint"></a>37-Incentivize crowd under budget constraint</h3><p>在这篇论文中，我们关注于激励群体工作者将一系列二元任务标记为严格的预算线。在众包系统中，我们正确地描述了任务的难度级别和工人的质量，在众包系统中，收集到的标签用序列贝叶斯方法进行聚合。为了激励员工进行群体标记任务，员工和平台之间的互动被建模为一个反向拍卖。我们揭示了平台效用最大化可能是难以解决的，为此我们提出了一个激励机制，用多项式时间计算复杂度来确定中标和付款。并从理论上证明了我们的机制是真实的、个体理性的、预算可行的。</p>
<h3 id="38-Free-Market-of-Crowdsourcing-Incentive-Mechanism-Design-for-Mobile-Sensing"><a href="#38-Free-Market-of-Crowdsourcing-Incentive-Mechanism-Design-for-Mobile-Sensing" class="headerlink" title="38-Free Market of Crowdsourcing Incentive Mechanism Design for Mobile Sensing"></a>38-Free Market of Crowdsourcing Incentive Mechanism Design for Mobile Sensing</h3><p>现有研究没有考虑到智能手机用户在感兴趣的领域的机会主义性质。具体来说，对于一般的智能手机感应应用程序，该平台会在每个用户到达时分配任务，并根据用户的回复立即做出决定。为了适应这种一般情况，我们设计了三种基于在线逆向拍卖的在线激励机制： TBA、 TOIM 和 TOIMAD。TBA 旨在追求平台效用最大化，TOIM 和 TOIM-ad 则实现了真实性的关键属性。所有的机制都具有期望的计算效率、个体理性和收益性。此外，与最佳离线解决方案相比，它们具有很强的竞争力。</p>
<blockquote>
<p>这篇也是用了拍卖，看上去可能还考虑了前面的社会关系。</p>
</blockquote>
<h3 id="39-Expertise-Aware-Truth-Analysis-and-Task-Allocation-in-Mobile-Crowdsourcing"><a href="#39-Expertise-Aware-Truth-Analysis-and-Task-Allocation-in-Mobile-Crowdsourcing" class="headerlink" title="39-Expertise-Aware Truth Analysis and Task Allocation in Mobile Crowdsourcing"></a>39-Expertise-Aware Truth Analysis and Task Allocation in Mobile Crowdsourcing</h3><p>针对众包数据准确性问题，现有方案大多从噪声数据中推断和利用移动用户的可靠性来识别真实性的技术，并将任务分配给具有较高可靠性的用户。但是存在问题：用户可能只对某些问题(在某些领域)具有专业知识，而对其他问题没有专业知识，从而导致真值分析的估计精度低和任务分配无效。</p>
<p>基于此，本文提出了专家意见真值分析和任务分配(ETA 2) 方案，它可以有效地推断用户的专家意见，然后根据推断出的专家意见评估真相和分配任务。ETA 2依赖于一种新颖的语义分析方法来识别专家，以及一种专家意识的真理分析方法来发现真理。针对 ETA 2中基于专家意识的任务分配问题，本文提出并解决了两个基于优化目标的问题: 最大质量任务分配问题和最小成本任务分配问题。基于两个实际数据集和一个合成数据集的实验结果表明，ETA 2的性能明显优于现有的解决方案。</p>
<blockquote>
<p>这篇具体是怎么进行任务分配的还需要再看看。</p>
</blockquote>
<h3 id="40-Online-mobile-Micro-Task-Allocation-in-spatial-crowdsourcing"><a href="#40-Online-mobile-Micro-Task-Allocation-in-spatial-crowdsourcing" class="headerlink" title="40-Online mobile Micro-Task Allocation in spatial crowdsourcing"></a>40-Online mobile Micro-Task Allocation in spatial crowdsourcing</h3><p>现有的研究大多集中在离线场景上，给出了微任务和群体工作者的所有时空信息。然而，由于微任务和群体工作者在实际应用中是动态出现的，而且他们的时空信息是不能事先知道的，因此这种方法是不切实际的。针对现有离线方法的不足，本文首先提出了一个更为实用的微任务分配问题，称为空间众包(GOMA)中的全球在线微任务分配问题。我们首先将在线最大加权二部匹配问题的最新算法扩展到<br> GOMA 问题作为基线算法。虽然基线算法为最坏情况提供了理论保证，但由于最坏情况发生的概率在现实世界中非常低，其实际平均性能不够好。因此，我们考虑了在线算法的平均性能，即在线随机序列模型，提出了一个基于两阶段的框架，在此基础上我们提出了在线随机序列模型下1/4竞争比的 TGOA 算法。为了提高其效率，我们进一步设计了 TGOA-Greedy 算法，该算法运行速度快于 TGOA 算法，但竞争比为1/8。</p>
<h3 id="41-Multi-Objective-Optimization-based-Allocation-of-Hetrogeneous-Spatial-Crowdsourcing-Tasks"><a href="#41-Multi-Objective-Optimization-based-Allocation-of-Hetrogeneous-Spatial-Crowdsourcing-Tasks" class="headerlink" title="41-Multi-Objective Optimization based Allocation of Hetrogeneous Spatial Crowdsourcing Tasks"></a>41-Multi-Objective Optimization based Allocation of Hetrogeneous Spatial Crowdsourcing Tasks</h3><p>在本文中，我们考虑一个空间众包场景：除了特定的空间约束，每个任务有一个有效的持续时间，操作复杂性，预算限制，和所需的工人数量。每个志愿工作者在完成日常工作的同时完成指定的任务。该系统具有期望的任务概率覆盖率和预算线。在这种情况下，我们研究了一个重要的问题，即异质空间众包任务分配问题(HSC-TA)，该问题致力于为多目标最佳化问题搜索一组具有代表性的帕累托最优分配方案，使分配的任务覆盖最大化，同时激励成本最小化。为了适应异质空间众包中的多种约束条件，我们建立了一个与分配过程相一致的工作者移动行为预测模型。证明了 HSC-TA 问题是 np 难问题。我们提出了有效的启发式方法，包括多轮线性权重优化和增强的多目标粒子群优化算法，以实现足够的帕累托最优分配。</p>
<h3 id="42-Group-Oriented-Task-Allocation-for-Crowdsourcing-in-Social-Networks"><a href="#42-Group-Oriented-Task-Allocation-for-Crowdsourcing-in-Social-Networks" class="headerlink" title="42-Group-Oriented Task Allocation for Crowdsourcing in Social Networks"></a>42-Group-Oriented Task Allocation for Crowdsourcing in Social Networks</h3><p>以往的众包研究通常采用面向个人的方法，将任务外包给个人员工或基于团队组成的方法，将任务外包给人为组成的员工团队。如今，工人们通常通过社交网络自然而然地组织成群。为了解决实际众包系统中的群体工作者这一常见问题，本文探讨了一种新颖的众包范式，其中任务分配目标是自然存在的工作者群体，而不是像以前那样是个体工作者或人工组成的团队。由于一个自然群体可能不具备完成复杂任务所需的所有技能，并且需要与社会网络环境中的其他群体进行协调，因此提出了语境众包价值的概念，通过与其语境群体进行协调来衡量一个群体完成任务的能力，语境群体决定了该群体被分配任务的优先级;然后，设计了任务分配算法，包括分配群体和实际参与执行任务的工人。在现实数据集上的实验表明，与以往的基准个体导向和团队组建方法相比，我们提出的面向群体的方法几乎总是能够获得更好的协同性能、一致性能、冲突性能、适应性和降低成本的有效性。</p>
<h3 id="43-Target-Tracking-via-Crowdsourcing-A-Mechanism-Design-Approach"><a href="#43-Target-Tracking-via-Crowdsourcing-A-Mechanism-Design-Approach" class="headerlink" title="43-Target Tracking via Crowdsourcing A Mechanism Design Approach"></a>43-Target Tracking via Crowdsourcing A Mechanism Design Approach</h3><p>本文提出了一种基于众包的近视目标跟踪框架，在无线传感器网络中设计了一种最优的激励相容机制，该机制包含自私和利益驱动的传感器。在传感器带宽有限的典型无线传感器网络中，融合中心(FC)必须在传感器之间分配传输到 FC 的总比特数。在这里考虑的公式中，FC 通过向自私的传感器征求出价来进行拍卖，这反映了它们对能源成本的估值。此外，该模型还保证了传感器的合理性和真实性。最后一个问题是多项选择背包问题问题(MCKP) ，这个问题用动态规划方法在伪多项式时间中得到了解决。仿真结果表明了该方法在跟踪性能和传感器网络生存期方面的有效性。</p>
<blockquote>
<p>这篇是针对近视目标跟踪的，不清楚是否涉及任务分配等。</p>
</blockquote>
<h3 id="44-Crowdsourcing-Sensing-to-Smartphones-A-Randomized-Auction-Approach"><a href="#44-Crowdsourcing-Sensing-to-Smartphones-A-Randomized-Auction-Approach" class="headerlink" title="44-Crowdsourcing Sensing to Smartphones A Randomized Auction Approach"></a>44-Crowdsourcing Sensing to Smartphones A Randomized Auction Approach</h3><p>因为对于来自众包者的某个给定的传感作业，只选择一小部分智能手机执行传感任务，其余的则不予选择，所以向移动用户提供众包的最先进的拍卖机制通常具有确定性。这种确定性拍卖机制的一个明显缺点是减少了感知作业的多样性。因此，收集到的传感数据的质量也下降了。这是由于未能利用移动众包网络中大量不同的移动用户的内在优势。针对社会成本最小化问题，提出了一种随机组合拍卖机制，证明了该机制是 np 难的。设计了一种近似最优的任务分配算法，该算法具有多项式时间复杂度，并以此为基础构造了整个随机拍卖机制。与确定性拍卖机制相比，提出的随机拍卖机制增加了给定感知任务的贡献用户的多样性。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>crowdsourcing</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Fast randomized consensus using shared memory</title>
    <url>/2022/03/03/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Fast%20randomized%20consensus%20using%20shared%20memory/</url>
    <content><![CDATA[<h1 id="使用共享内存的快速随机共识"><a href="#使用共享内存的快速随机共识" class="headerlink" title="使用共享内存的快速随机共识"></a>使用共享内存的快速随机共识</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>我们提出了一个新的随机算法，用于在读写共享寄存器进行通信的异步进程之间达成共识。过去已知的最快的算法时间复杂度为指数运行时间，我们的算法是多项式的，$O(n^4)$。该算法的应用包括从并发数据结构中消除关键部分，以及构建渐进无偏的共享硬币。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>共识协议</strong>：一组$n$个通过将操作应用于<strong>共享对象</strong>进行通信的异步处理器。</p>
<p>​    对象：信道、读写寄存器数组等</p>
<p><strong>进程</strong>：从输入值开始（0或1），运行到选择决策值后停止</p>
<p>当共识协议是<strong>一致</strong>、<strong>有效</strong>、<strong>无等待</strong>时，就是<strong>正确</strong>的。</p>
<p>​    共识协议的<strong>一致</strong>：没有两个进程选择不同的决策值。</p>
<p>​    共识协议的<strong>有效</strong>：决策值是某些进程的输入值。</p>
<p>​    共识协议的<strong>无等待</strong>：每个进程都在有限数量步骤后决定。</p>
<p>编码共享数据的并发访问的传统方式：依赖于<strong>临界区</strong></p>
<p>​    <strong>临界区</strong>：同一时间只允许一个进程操作对象</p>
<p>临界区不适用于异步、容错系统：如果在一个临界区中，错误进程停止或延迟了，非容错进程也会被停止和延迟。反之，如果并发数据对象的实现保证任何进程将在$n$个步骤中完成任何操作，而不受其他停止故障或速度变化的进程的影响，则该实现是免等待的。如果针对对象$X$存在一个共识协议，则我们可以使用$X$构建针对任一并发数据对象的无等待实现。</p>
<p>如果共享对象$X$是提供读写操作的寄存器数组，那就无法达成共识了。如果$X$是提供TAS指令（把给定的内存地址设置为1，然后返回之前的旧值的原子操作）或FAA指令（内存位置增加一个数量的原子操作）的寄存器数组，则可以在两个进程间达成共识，但不能在三个进程间达成共识。然而，在这两种情况下，任意数量的进程之间仍然可以在概率上达成共识。本文提出了两种新的随机共识协议，一种是进程通过读取和写入共享寄存器进行通信，另一种是通过应用FAA操作进行通信。这些协议是一致的，非平凡的，它们保证每个进程在有限的预期步骤数之后决定。读写协议中，目前最快的算法时间复杂度是$2^{O(n^2)}$，本文则改进为$n^2$次写操作和$n^4$次读操作；FAA协议则预期需要$n^2$次FAA操作。</p>
<p>我们描述了一个简单的协议，如果对手调度程序以同步方式运行进程，该协议具有指数级的预期运行时间。每个进程在每轮中掷出一个无偏的硬币，当所有$n$个进程同时掷出”正确”值时，协议停止。在任何特定回合终止的概率为$\frac{1}{2}^n$。因此，在终止之前的预期回合数为$2^n$。加速协议的一种方法是用进程共享的单个无偏硬币替换$n$个独立的硬币翻转。但是，在异步系统中实现无偏的共享硬币被证明是不可能的（见下文第8节）。</p>
<p>类似于Chor，Merritt和Shmoys[13]提出的见解，它足以确保进程有足够的可能性翻转相同的值，并且对手调度程序对选择哪个值的影响足够弱。我们的共识协议的核心是一个弱共享硬币协议，它保证：</p>
<ol>
<li>进程可能观察到相同的结果；</li>
<li>对手调度程序对该结果的影响很小；</li>
<li>协议在进程数量上具有预期的运行时间多项式。</li>
</ol>
<p>共识通常被视为一种博弈。进程一方试图与对手调度器达成协议。进程将读和写操作应用到共享寄存器，对手选择操作实际发生的时间。我们的对手非常强大，它拥有关于进程协议、它们的内部状态和共享内存状态的完整信息。它不局限于多项式资源，因此它不能被加密方案所超越。然而，对手无法预测未来的硬币投掷。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Best reply structure and equilibrium convergence in generic games</title>
    <url>/2021/11/11/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Best%20reply%20structure%20and%20equilibrium%20convergence%20in%20generic%20games/</url>
    <content><![CDATA[<h1 id="通用博弈中的最优回复结构和均衡收敛"><a href="#通用博弈中的最优回复结构和均衡收敛" class="headerlink" title="通用博弈中的最优回复结构和均衡收敛"></a>通用博弈中的最优回复结构和均衡收敛</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>博弈论被广泛用于模拟相互作用的生物和社会系统。在某些情况下，博弈者可能会趋同于一个均衡，例如纳什均衡，但在另一些情况下，他们的战略动态会内生振荡。如果系统的设计不是为了鼓励趋同，那么我们可以先验地预期这两种行为中的哪一种呢？为了解决这个问题，我们采用了理论生态学中流行的一种方法来研究生态系统的稳定性： 我们根据可能代表现实世界博弈属性的约束条件随机生成回报矩阵。我们的研究表明，最优回复循环是博弈中的基本拓扑结构，它预示着六种著名的学习算法不会收敛，这些算法在生物学中得到了应用，或在人类玩家的实验中得到了支持。最优回复循环在复杂的竞争性博弈中占主导地位，这表明在这种情况下，均衡通常是一个不切实际的假设，我们必须明确地建立学习动态模型。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>博弈论是一套针对决策者之间战略互动的数学模型，可应用于各种问题，如合作的出现、语言的形成以及道路和互联网的拥堵。同样的数学工具也被用于生态学和种群生物学中的进化建模。一个长期存在的问题是，当玩家通过反复玩博弈进行学习时，他们是否会趋同于一个均衡点。人们对一般情况知之甚少，因为答案取决于博弈的属性和学习算法。在这里，我们引入了一种我们称之为最优回复结构的形式主义，它可以粗略度量各种学习算法在任何双人正态博弈中的收敛概率。生态学中的定性稳定性理论和使用雷诺数来理解流体动力学中的湍流都可以类比说明我们的方法在其他领域的实用性。</p>
<p>解决博弈论均衡收敛问题的标准方法是关注具有特殊数学性质的博弈类，选择它们作为现实世界情景的程式化模型。例如，在<a href="https://www.zhihu.com/question/26666055" target="_blank" rel="noopener">势博弈</a>（potential games，也翻译成潜在博弈）中，单方面改变策略的所有收益差异都可以用一个全局势函数来表示;  <a href="https://www.zhihu.com/question/481180778" target="_blank" rel="noopener">拥塞博弈</a>属于这一类，所以势博弈可以作为交通的程式化模型。势博弈中大多数学习算法收敛到一个纳什或相关的均衡在潜在的对策，在优势可解博弈（dominance-solvable game）、协调博弈（coordination game）、超模博弈（supermodular game）和弱非循环博弈（weakly acyclic game）中也是如此。研究具有特殊属性的博弈在机制设计等某一方玩家可以选择博弈形式的情况下是非常有用的。在这些情况下，也可以设计玩家将要使用的学习算法，并选择最有可能收敛到均衡的算法，例如在线拍卖和网络路由。</p>
<p>然而，在其他一些问题中，博弈和学习算法并不是设计出来的，而是由设置的内在性质决定的。例如，金融市场可以被看作是一场博弈，其中有许多可能的行动与交易者可以买卖的资产相对应。结果可能趋于均衡，也可能内生波动。如果系统的设计不是为了鼓励趋同，我们应该期待这两种行为中的哪一种？</p>
<p>为了解决这个问题，我们采用了一种在理论生态学和发育生物学中卓有成效、在物理学中也很普遍的方法。梅（May）的理论生态学开创性论文就是这种方法的一个例子。他研究了一组随机产生的捕食者-猎物相互作用，并将其作为一般生态系统的空模型。他的主要结果是，随机生态系统往往会随着规模的扩大而变得更加不稳定。当然，梅很清楚，真实的生态系统并不是随机的；相反，它们是由进化选择和其他力量塑造而成的。许多大型生态系统已经存在了很长时间，这表明它们实际上是稳定的。因此，这一矛盾表明，真实的生态系统并不是梅模型中使用的随机集合的典型成员，这就提出了一个重要的问题：这些生态系统究竟是如何变得不典型的，它们又是如何以及为什么进化成稳定的？45 年后的今天，对这一问题的正确回答仍然是一个活跃的研究课题。例如，约翰逊等人最近发现，真实的生态系统具有一种他们称之为营养相干性的特性，并证明将这种特性作为随机生成的生态系统集合的约束条件可以确保稳定性。</p>
<p>在这里，我们将类似的方法应用于博弈论，将随机生成的双人博弈集合作为一个空模型。出于可操作性的考虑，我们利用可以系统地枚举所有可能博弈的事实，研究正态博弈。在这里，我们详细研究了一个参数$G$，它可以调整两位博弈者收益的相关性。这可以调节博弈中的竞争强度，并将零和博弈作为 $G = -1$ 的一个特例。我们还简要介绍了如何构建其他约束条件，例如，研究潜在博弈的偏差。通过这种方法，我们可以看到偏离特定类别博弈会如何影响学习动态的稳定性。</p>
<p>随机生成的博弈和一般学习算法不具备允许精确求解的数学特性。为了克服这一局限性，我们开发了一种形式主义，以简单指标的函数形式获得收敛的近似概率。通过与流体力学的类比，我们可以清楚地了解这些近似解是如何发挥作用的。当流体被驱离平衡状态时，通常会从稳定流（或层流）过渡到不稳定流（或湍流）。描述流体动力学的纳维-斯托克斯方程没有解析解，但这种过渡可以用一个称为雷诺数 (7) 的非一维参数来粗略描述。雷诺数越大，发生湍流的可能性就越大。尽管这一预测并不精确—它只是一条经验法则—但却非常有用。我们对博弈的类似估计没有简单的封闭形式，但却具有类似的预测能力。与我们的方法类似的另一种方法是理论生态学中的定性稳定性理论 (6)。生态学中的许多模型都会考虑食物网中不同物种之间相互作用的程度。例如，这些模型会考虑兔子吃了多少草，狐狸吃了多少兔子。而定性稳定性方法只考虑捕食者与被捕食者之间关系的符号—兔子吃草，狐狸吃兔子。这样，仅从食物网的拓扑特性就可以对生态系统的稳定性进行近似评估。与定性稳定性理论一样，我们的方法只依赖于博弈的拓扑特性，而不依赖于收益的细节。</p>
<p>我们的形式主义基于最优回复动力学，在此动力学下，每个玩家都会对对手的最后一个行动做出近视的最优回复。最优回复动力学在博弈论中是众所周知的，并被广泛用于发展学习的直觉，但我们以一种新的方式使用它，以获得一般博弈中收敛的近似概率。在最优回复动力学条件下，系统要么会渐进地收敛到一个与纯策略纳什均衡相对应的固定点，要么会陷入一个循环。我们根据最优回复循环与博弈固定点的相对大小，考虑了一个非常简单的博弈不收敛指标。请注意，我们并没有假设玩家遵循最优回复动态。相反，我们假设回报矩阵的最优回复结构构成了一阶骨架，形成了玩家试图学习的博弈的主干，这对于理解许多学习算法的收敛性非常有用。</p>
<p>为了验证这一假设，我们选择了一组从真人博弈实验中得到的学习算法，包括强化学习、<a href="https://blog.csdn.net/weixin_40814740/article/details/109734014" target="_blank" rel="noopener">虚拟博弈</a>、有噪声和无噪声的经验加权、k-level学习。我们也引入了（二种群）复制因子动力学在生态学和种群生物学中的重要性。基于最优回复动力学的方法预测了这些算法在$R^2≥0.78$时的不收敛频率。</p>
<p>在此，我们要强调的是，我们的目标是描述性的，而不是规范性的。在机制设计中，人们或机器使用的算法被设计为具有良好的收敛特性。例如，有些算法会收敛到相关均衡，这是纳什均衡的一种概括，允许博弈者在所有博弈中根据共同的信号进行协调。遗憾匹配就是这样一种算法，在这种算法中，玩家会考虑过去所有的博弈历史，并计算如果他们采取任何其他行动，他们的回报会是多少。虽然这些算法可以由机器或有足够记录能力的人来执行，但除非经过专门训练，否则不太可能被真人使用。据我们所知，这些算法只有间接的经验支持。我们将重点放在经过实验测试的算法上。当达到一个固定点时，这些算法会收敛到纳什均衡或接近纳什均衡的点，而不是更一般的相关均衡。</p>
<p>在证明最优回复结构形式主义可行之后，我们分析了最优回复周期或固定点是如何随着博弈的两个属性的变化而变化的。我们根据玩家可用的行动数$N$来定义一个博弈的复杂程度。简单的博弈只有几个行动，而复杂的博弈则有很多行动。博弈的竞争性由两名玩家的收益之间的相关性$G$来定义。相关性越负，博弈的竞争性越强。当我们改变博弈的这两个属性时，最优回复循环与固定点的相对比例会跟踪我们所考虑的六种算法的收敛频率，竞争性博弈中的虚拟博弈除外。</p>
<p>我们的研究表明，在一端，简单且无竞争性的博弈不太可能有循环，而在另一端，复杂且有竞争性的博弈很可能有循环。我们之前提到的几类博弈，即潜在博弈、优势可解博弈、协调博弈、超模态博弈和弱非循环博弈，在构造上都是非循环的。这些类别中的任何一类都可能是简单非竞争博弈集合的典型成员，在这些博弈中，非循环行为很常见，但对于复杂竞争博弈来说，它们肯定不是典型的非循环行为。这些结果与我们的直觉相吻合，即复杂博弈更难学习，当一个博弈者的收益就是另一个博弈者的损失时，博弈者就更难协调均衡。我们的形式主义可以量化这一点。例如，在每个玩家有两个行动、两个玩家的收益之间没有相关性（$G=0$）的情况下，非循环博弈约占总数的 85%。然而，在$N=10$和$G=-0.7$的情况下，非循环博弈只占总数的 2.7%。</p>
<p>我们还展示了如何利用最优回复形式主义来研究给定博弈类别（如势博弈）的稳定性，以了解它们在偏离给定类别情况下的稳定性。我们展示了这种行为可能是非线性的，例如，势博弈的微小扰动会导致不收敛性不成比例地大幅增加。</p>
<p>在收益不相关（$G=0$）的情况下，我们使用受统计力学启发的组合方法来分析计算不同长度的最优回复周期的频率。使用受统计力学启发的方法并不是博弈论中的新想法。以前的研究已经量化了纯策略纳什均衡、混合策略均衡和帕累托均衡的属性，但我们是第一个量化最优回复周期的频率和长度并展示其与学习相关性的研究。加拉和法默以前用不同的方法研究了随机博弈中经验加权吸引力在$N\rightarrow \infty$时的收敛频率；在这里，我们将其扩展到任意$N$，研究了一系列不同的学习算法，并对不稳定性的起源有了更深入的了解。我们引入的形式主义可以向多个方向扩展，并应用于不同领域。例如，我们的研究结果也与通过复制器动力学的食物网稳定性有关，并可映射到布尔网络中。</p>
<p>当收敛到均衡状态失败时，我们经常会观察到混乱的学习动态。当这种情况发生时，博弈者并没有收敛到任何形式的时际“混沌均衡”，即他们的预期与博弈结果不匹配，甚至在统计意义上也是如此。在许多情况下，由此产生的吸引子维度很高，这使得“理性”的玩家很难通过统计方法预测其他玩家的行动，从而获得优于其他玩家的结果。一旦至少有一名玩家系统性地偏离均衡状态，学习和启发式方法就能超越均衡思维，并能更好地描述玩家的行为。</p>
<p>我们首先开发了最优回复框架。接下来，我们将展示如何利用它来预测我们在此研究的六种学习算法的非收敛频率，首先提出一些论点，给出一些直观的解释，说明为什么这样做可行，然后提供更多量化证据。然后，我们研究了最优回复循环是否会随着博弈的某些属性的变化而变得普遍，并说明了两个不同的约束条件的影响，这两个约束条件代表了与众所周知的博弈类别的偏差。最后，我们开发了一种分析性组合方法，用于计算在收益不相关的情况下最优回复循环的频率。</p>
<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><h3 id="Best-reply-structure"><a href="#Best-reply-structure" class="headerlink" title="Best reply structure"></a>Best reply structure</h3><p>首先，我们将介绍一个框架，该框架将证明，我们所分析的学习算法系列将收敛到一个固定点的可能性可以得到一个有用的估计。正如我们将演示的，这提供了一种框架，可以通过分析给出算法在玩家尝试学习博弈时将遇到的稳定性问题的一阶近似值。表 1 总结了我们将要介绍的术语。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Table 1. Terminology.</th>
<th>NE, Nash equlibrium.</th>
</tr>
</thead>
<tbody>
<tr>
<td>Best reply</td>
<td>Action that gives the best payoff in response to a given action by an opponent</td>
</tr>
<tr>
<td>Best reply structure</td>
<td>Arrangement of the best replies in the payoff matrix</td>
</tr>
<tr>
<td>Best reply matrix</td>
<td>Derived payoff matrix, with one for the best reply to each possible move of the opponent and zero everywhere else</td>
</tr>
<tr>
<td>Best reply dynamics</td>
<td>Simple learning algorithm in which the players myopically choose the best reply to the last action of their opponent</td>
</tr>
<tr>
<td>Best reply k-cycle</td>
<td>Closed loop of best replies of length k (each player moves k times)</td>
</tr>
<tr>
<td>Best reply fixed point</td>
<td>Pure NE, i.e., the action for each player that is a best reply to the move of the other player</td>
</tr>
<tr>
<td>Best reply vector u</td>
<td>List of the number of distinct attractors of the best reply dynamics, ordered from longest cycles to fixed points</td>
</tr>
<tr>
<td>Free action/free best reply</td>
<td>Best reply to an action that is neither part of a cycle nor a fixed point</td>
</tr>
<tr>
<td>Best reply configuration</td>
<td>Unique set of best replies by both players to all actions of their opponent</td>
</tr>
</tbody>
</table>
</div>
<p>假设在一个双人正则表达式博弈中，玩家分别是行玩家和列玩家，各自的行动（或移动，或纯策略）记作$i, j = 1, …, N$。最佳回应是指在回应对手给定行动时给出最佳回报的行动。最佳回应结构是最佳回应在收益双矩阵（即描述双方收益的两个矩阵）中的排列。(本文中，我们将使用 “收益矩阵 “一词来指双矩阵）在最佳回复动态下，每个玩家都会对对手的最后一个行动做出最佳回复。我们考虑的是最佳回应动态的一个特殊版本，即两位玩家交替下棋，各自选择对对手最后一个行动的最佳回应。</p>
<p>为了理解基本思想，我们考虑如下图所示的$N=4$的博弈。在图中，$S^R=\{1,2,3,4\}$和$S^C=\{1,2,3,4\}$分别是行玩家和列玩家的可能行动，矩阵中的每个格子反映了他们各自的收益，行玩家在左边。最优回复箭头指向了这个格子对应的最优回复格，垂直箭头对应行玩家，水平箭头对应列玩家。红色箭头表示该箭头是循环的一部分，橘黄色表示该箭头不在循环里，但会导向循环，蓝色表示直接指向固定点，天蓝色表示通过不止一步导向固定点。图B中的最优回复矩阵是布尔约简，其构造为具有与图A中的收益矩阵相同的最佳回复结构，但只有1和0作为其条目。假设我们选择了$(1,1)$作为初始条件，假设列玩家先行动，作为对$S^R=1$的最优回应，他选择了$S^C=2$。接下来行玩家行动，最优回应是$S^R=2$，由此列玩家又会再移动到$S^C=1$，等等。这样两个玩家将陷入循环$(1,1)\rightarrow(1,2)\rightarrow(2,2)\rightarrow(2,1)\rightarrow(1,1)$。我们将这样的循环称为最优回复双循环，因为每个玩家都移动两次。这个循环是一个吸引子，如果从$(3,2)$开始博弈，且行玩家先行，则博弈还是会进入到这个循环。先行玩家可以随机抽选，如果玩家的行动已经在循环了，那先行者的抽选对结果没有任何影响，因为至多有一个玩家有动机偏离当前的情况。然而如果当前不在循环，则玩家行动顺序就重要起来了。例如在这个例子中，存在两个吸引子，还是从$(3,2)$开始，列玩家先行，则博弈会一步到达最优回复固定点$(3,3)$，它是一个纯策略纳什均衡（NE）。<br><img src="https://github.com/likun1208/image/blob/master/bestreply-1.png?raw=true" alt="图1"><br>给定$N\times N$的收益矩阵$\Pi$，我们通过最优回复向量$v(\Pi)=(n_N,…,n_2,n_1)$来表征一组最优回复动力学的吸引子，其中$n_1$是固定点的数量，$n_2$是双循环的数量，以此类推。例如，图1中的向量是$v=(0,0,1,1)$，表示有1个固定点和1个双循环。</p>
<p>如上图B所示，将收益矩阵还原为最优回复矩阵是非常有用的。具体做法是将每位玩家的所有最佳回复替换为 1，所有其他条目替换为 0。最佳回复矩阵的最佳回复结构与其衍生的收益矩阵相同，但它忽略了收益的其他方面。最佳回复矩阵具有与原始博弈相同的循环和纯策略近似值，但一般来说，混合策略近似值有所不同。一旦知道了最佳回复动态的吸引子，就可以列出所有的混合策略近似值。每个最佳回复循环都有一个混合 NE，循环和固定点的所有可能组合都有一个混合 NE。与给定循环相关的混合策略近似值对应于随机走每一步，其频率与循环中出现的频率相同。例如，图 1B 中与最佳回复周期相关的混合策略均衡为$x,y=(0.5, 0.5, 0, 0), (0.5, 0.5, 0, 0)$。与每种可能的循环和固定点组合相关的混合策略 NE 对应于组合行动集的平均值。例如，在图 1B 中，与循环和固定点组合相关的混合 NE 为 $x, y = (0.33, 0.33, 0.33, 0),(0.33, 0.33, 0.33, 0)$。对于最佳回复矩阵，不存在其他混合策略近似点。</p>
<p>在从最佳回复矩阵到原始博弈的过程中，一些混合近似解可能会存活下来，而另一些则可能不会，并且可能会引入新的混合近似解。例如，在图 1A 中，它们都没有存活下来，而且在 $x, y = (0.32, 0, 0, 0.68), (0.36, 0.64, 0, 0)$ 和 $x, y = (0.26, 0.15, 0, 0.59), (0.32, 0.24, 0.44, 0)$处有两个混合均衡，它们与相关的最佳回复动态没有关系。我们在第 S2 节中对随机生成的 1000 个 $N = 10$ 的博弈进行了量化说明。</p>
<h3 id="Learning-dynamics"><a href="#Learning-dynamics" class="headerlink" title="Learning dynamics"></a>Learning dynamics</h3><p>为了解决学习何时收敛的问题，我们研究了六种不同的学习算法。这些算法的选择跨越了不同的信息条件和理性水平。我们的重点是有经验支持的算法。这包括在生物学中用于动物学习或种群遗传学等目的的算法，以及用于在实验室环境中进行人类博弈行为实验的算法。我们在 “材料与方法 “中对六种算法逐一进行了简短总结，并在第 S1 节中介绍了详细内容。在此，我们仅讨论每种算法背后的基本思想，并说明将其纳入本研究的原因。</p>
<p>强化学习基于这样一种理念，即玩家更有可能采取过去收益更好的行动。它是标准的学习算法，用于信息有限和/或没有复杂推理的情况下，例如动物学习。我们研究的是布什-莫斯泰勒（Bush-Mosteller）算法，该算法已在实验中进行了广泛测试。</p>
<p>虚拟博弈需要更多的复杂性，因为它假定玩家构建了一个对手的心理模型。每个玩家都假定对手过去行动的经验分布就是她的混合策略，并根据这一信念下出最佳对策。一种常用的变体——加权虚拟博弈——假定过去的行动会打折扣。关于标准虚拟博弈和加权虚拟博弈的经验证据不一。从理论的角度来看，标准虚拟博弈在许多情况下会趋同于混合策略 NE，而加权虚拟博弈则不会。正如我们将看到的，如果学习算法经常达到混合均衡，我们的最佳回复形式主义就不能很好地发挥作用。我们选择标准版本的虚拟博弈来说明这一点，因为它提供了更有力的检验。</p>
<p>复制动力学常用于生态学和种群生物学。它表示种群中某些性状随世代的演变，每个性状的适合度取决于种群中所有其他性状的份额。复制动力学也可以看作是一种学习算法，其中每个性状都对应着一种行动。在这里，我们考虑的是双种群复制动力学，而不是更标准的单种群版本，因为在单种群版本中，两个参与者的收益矩阵顾名思义是对称的，而我们要研究的是收益的相关性。</p>
<p>经验加权吸引力（EWA）已被提出，用于归纳强化学习和虚拟博弈，并已被证明能很好地适应实验数据。其成功的关键在于一个权衡已实现报酬和已放弃报酬的参数。EWA 还包括其他参数，如记忆和报酬敏感性。与上述三种学习算法不同，其参数是决定收敛性的关键： 对于某些参数值，它总是收敛到固定点，而这些固定点可能离纳什均衡或相关均衡任意遥远。正如我们在 “补充材料 “中详细讨论的那样，由于缺乏对一般博弈中参数的实验指导，我们选择的参数值有可能使收敛接近近邻均衡。EWA 不会收敛到更一般的相关均衡，除非它们对应于NE。</p>
<p>上述算法都基于批量学习的概念，这很方便，因为这意味着它们都是确定性的。在批量学习中，棋手在更新自己的策略之前会大量观察对手的行动，因此会根据对手在每个时间点的实际混合策略进行学习。确定性假设有助于从数字上识别静止状态。在许多实验情况下，更现实的假设是，棋手在观察对手的单次行动后更新策略，而对手的行动是从其混合策略中随机取样的。这就是所谓的在线学习。作为在线学习的一个例子，我们研究了 EWA 的随机版本。</p>
<p>上述五种算法都是向后看的。为了与具有前瞻性行为的例子进行比较，我们使用了水平-k 学习或预期学习，其中棋手试图通过提前 k 步思考来战胜对手。level-k思维的观点得到了相当多的经验支持，一些研究还特别支持预期学习。在这里，我们通过使用第 2 层 EWA 学习来实现 k 级推理。两位棋手都假设对手是一级学习者，并使用 EWA 更新策略。因此，棋手会尝试根据对手的预测行动先发制人，而不是仅仅根据对手的历史行动频率采取行动。这为前瞻性行为提供了一个衡量标准。</p>
<p>总之，我们之所以选择这六种算法，是因为它们本身就很重要，而且能说明不同的特性。我们感兴趣的是生态学和生物学中使用的算法，或者在实验室人类实验中观察到的有界理性算法。我们特别不研究那些与计算机科学或机制设计相关，但与行为学观点无关的复杂算法。这些算法的收敛特性可能与本文研究的算法截然不同。遗憾匹配就是我们不研究的这类算法的一个例子，它被认为是一种 “自适应启发式”，是有界理性和近视的。然而，它仍然要求博弈者计算如果他们在之前的所有时间步骤中采取任何其他行动，他们会得到什么回报，而且没有经验证据表明人类实验中的博弈者会使用它。其他能达到相关均衡的算法，如校准学习法，则更为复杂。</p>
<h3 id="How-does-the-best-reply-structure-shape-learning-dynamics"><a href="#How-does-the-best-reply-structure-shape-learning-dynamics" class="headerlink" title="How does the best reply structure shape learning dynamics?"></a>How does the best reply structure shape learning dynamics?</h3><p>我们的工作假设是，最佳回复结构会影响这些学习算法的收敛特性，即使学习轨迹可能并不详细遵循最佳回复周期。更具体地说，我们的假设是，最佳回复周期的存在与否与学习动态的稳定性相关。当没有最佳回复周期时，学习更有可能收敛，而当存在最佳回复周期时，学习则不太容易收敛。我们无法在一般博弈中分析证明这一点，但轶事实例支持了这一点。我们不可能详细介绍这些例子，但在这里，我们将举出几个有代表性的例子来说明对应关系。在下一节中，我们将提出更多量化证据。</p>
<p>为了直观地了解最佳回复结构是否以及为什么能够预测上述学习算法的收敛性，在图 2 中，我们分析了四个$N=3$的博弈，显示了四维策略空间三维投影中的一些学习轨迹（混合策略向量有六个分量，有两个归一化约束。轴标 $x_1$和$x_2$分别是行玩家采取$s^R=1$和$s^R=2$行动的概率，$y_1$是列玩家采取$s^C=1$行动的概率。策略空间$(x_1, y_1, x_2)=(1, 1, 0)$和$(0, 1, 1)$的角分别对应行动轮廓$(1, 1)$和$(2,1)$。</p>
<p><img src="https://github.com/likun1208/image/blob/master/bestreply-2.png?raw=true" alt="图2"></p>
<p> 在图 2A 中，我们考虑了一个具有 2 循环和单一纯策略 NE 的最佳回复矩阵。我们的第一个示例使用了复制动力学。学习算法的吸引子与最佳回复动力学的吸引子非常相似；根据初始条件，所有轨迹都会到达固定点或极限循环。本例中的极限循环与最佳回复循环相对应，因为我们始终保持 $y_3=0$（由于六维系统的三维投影，坐标$y_3$ 未显示）。强化学习、EWA 和带噪声的 EWA 的表现类似。相反，虚拟博弈总是收敛到一个固定点，要么收敛到纯策略 NE，要么收敛到循环支持中的混合策略均衡，这取决于初始条件。我们从未观察到它收敛到另一个混合 NE，即对应于两个吸引子的组合。在第 S2 节中，我们证明了在 $N=10$ 的一般博弈中，就现有混合均衡的比例而言，虚拟博弈更有可能收敛到最佳回复循环支持下的混合均衡，而不是其他混合均衡。k 级 EWA 也会收敛（接近）到相同的混合均衡。我们将在下一节中定量地说明，在行动较少的博弈中，level-k EWA 的行为类似于虚拟博弈，而在行动较多的博弈中，它更类似于其他四种算法。对于最佳回复矩阵来说，学习动态模仿最佳回复结构并不奇怪，但由于学习算法具有自由参数和对过去的记忆，因此它们应该如此紧密地模仿最佳回复结构并不明显。</p>
<p>图 2B 中的收益矩阵与图 2A 中的最佳回复结构相同，但收益是通用的。为了展示更多的学习算法，我们这次用强化学习和带噪声的 EWA 来说明学习动态。在这两种情况下，学习轨迹要么收敛到纯策略 NE，要么不收敛。强化学习会收敛到一个与最佳回复周期相关的极限周期，即使该轨迹被扭曲并更深入地渗透到策略空间的中心。如图 2A 所示，复制动力学和 EWA 的表现类似，而虚拟博弈和水平-k EWA 收敛到或接近于混合均衡。</p>
<p>为了了解取消最佳回复循环后的情况，在图 2C 中，我们考虑了与图 2B 相同的报酬矩阵，只是位于$(3,1)$处的行的报酬是 2.0，而不是 0.1。在这种情况下，最佳回复动态的唯一吸引子是位于$(3,3)$处的纯策略 NE。在所有初始条件下，强化学习都会收敛到纯策略 NE，这说明了移除最佳回复循环是如何使固定点全局稳定的。然而，对于复制动力学，存在一些初始条件反而会导致极限循环，这表明即使没有最佳回复循环，不稳定学习动力学的小盆地仍可能存在。(虚拟博弈和水平-k EWA 的表现类似于强化学习，而 EWA 和带有噪声的 EWA 的表现类似于复制动力学）。</p>
<p>这个例子说明了学习动态如何从本质上偏离最佳答案动态。当复制器动态达到$(x_1, y_1, x_2)=(0.86, 0.87, 0.14)$ 点（图中黑色箭头所示）时，行玩家的预期报酬为 0.25。如果行玩家改用 $s^R=3$（他的最佳回答），他的报酬将增加到 1.60。如果换成$s^R=1$，行玩家的预期报酬仍会增加到 0.29，因此我们说行动 1 是更好的回复。随着时间的推移，在复制器的动态作用下，与更好的回复相对应的行动的概率也会增长，尽管增长率低于最佳回复。在这里，由于过去的博弈，$x_3$ 非常小（10-53 的数量级），所以 $x_1$ 在 $x_3$ 达到类似值之前就增加到了 1，动态过程陷入了图中所示的循环。</p>
<p>在图 2D 中，我们考虑了一个具有 2 循环且无纯策略 NE 的收益矩阵。在所有初始条件下，EWA 都会达到一个混沌吸引子。需要注意的是，这个吸引子与最佳回复循环的某些结构相同，会紧密访问策略空间的两个角，即 $(x_1, y_1, x_2) = (1, 0, 0)$ 和$(1, 1, 0)$，而另外两个角则较为松散。而水平-k EWA 则收敛到混沌吸引子中心的混合 NE 附近。由于有限记忆和有限报酬敏感性，EWA、带噪声的 EWA 和水平-k EWA 无法精确达到混合均衡。其他算法的表现类似： 有噪声的 EWA 和复制动力学都会达到一个混沌吸引子，而强化学习则会遵循一个极限循环。虚拟博弈在混合均衡附近波动，混合策略向量的每个分量与均衡点的最大距离为 0.03。</p>
<p>因此，我们看到，尽管这些算法的学习动态并未详细模仿最佳回复动态，但在大多数情况下，在学习动态中可以看到它的残余。即使对应关系不准确，最佳回复结构也会影响学习动力。</p>
<h3 id="Quantitative-evidence"><a href="#Quantitative-evidence" class="headerlink" title="Quantitative evidence"></a>Quantitative evidence</h3><p>现在，我们将对这一假设进行定量检验，即至少对于这些学习算法而言，最佳回复周期的存在与不收敛性呈正相关。为此，我们首先证明了一个非常有用的定理，它将循环和固定点的配置与不稳定最佳回复动态吸引盆地的相对大小联系起来。假设$n_k$是长度为$k$的最佳回复循环的数量，那么让 $C=\sum_{k=2}^N n_kk$ 是属于最佳回复循环中的行动数。数量$F(v)=C/(C+n_1)$测量的是吸引子上属于循环与固定点的相对数量。在图 1 的例子中，有一个固定点和一个周期，$F(0, 0, 1, 1)=2/3$。</p>
<p>这也衡量了最佳回复动态下循环与固定点吸引盆地的相对大小。例如，对于图 1 所示的博弈，8 个初始条件中有 5 个会导致循环，8 个初始条件中有 3 个会导致固定点。然而，如果我们对所有可能的 4 × 4 博弈进行平均，这些博弈都有一个长度为 2 的最佳回复循环和一个单一的纯策略 NE，而且没有其他最佳回复吸引子（对每个可能的博弈给予相同权重），那么导致最佳回复循环的初始条件的相对大小正好是 2/3。正如我们在补充材料中所展示的，这在一般情况下是正确的。</p>
<p>为了测试最佳回复动态与我们的学习算法系列的收敛特性之间的关系，我们随机生成博弈。正如第 S1.2 节所述，正态分布是最大熵分布，因此是自然选择。在此，我们让两位玩家的收益互不相关。然后，我们在收益矩阵固定不变的情况下，在重复博弈中模拟博弈者的学习过程。我们使用 “材料与方法 “和 “补充材料 “中解释的标准来检验纯策略和混合策略 NE 的收敛性。我们生成了 1000 个不同的博弈；对于每个博弈，我们从 100 个不同的初始条件开始模拟所有六种学习算法。作为比较，我们使用与随机生成的 1000 个博弈中的每个博弈相关的最佳回复矩阵重复整个过程。$N=20$的结果见图 3，$N=5$和$N=50$的结果见图 S8 和 S9。</p>
<p>图3比较了最佳回复周期$F(v)$ 与不收敛频率的比例。为了检验最佳回复向量$v$与学习动态之间的关系，我们将具有相同$v$的收益矩阵的结果分组，并画出一个半径与采样次数对数成正比的圆。我们根据每个最佳回复向量在最佳回复周期$F(v)$中所占的比例，将其放在横轴上。在纵轴上，我们绘制了使用该最佳回复向量的结果的平均不收敛频率。因此，如果最佳回复结构能完美预测其他学习算法的收敛速度，那么所有圆圈都应以同一直线为中心。我们使用与每个最佳回复向量采样次数相对应的权重来估算加权相关系数$R^2_w$。</p>
<p>我们使用最佳回复矩阵进行模拟的结果如图 3 顶部一行所示。除了虚拟博弈之外，所有算法的相关性都接近于 1。一方面，鉴于最佳回复矩阵没有更好的回复，这似乎并不太令人惊讶。但另一方面，这些学习算法都使用了对过去的记忆（除了最近的行动之外），而且它们中的大多数都有自由参数，而最佳回复动态则没有这些参数。有鉴于此，具有不同功能形式的学习算法的吸引力盆地的大小如此接近最佳回复动力学，这一点非常了不起。虚拟博弈之所以失败，是因为它有收敛到混合策略 NE 的强烈倾向，不过即使在这种情况下，它通常也无法在较长的周期内收敛。在大多数情况下，虚拟对局在 2 循环时收敛，但在 3 循环时则无法收敛，这与 Miyazawa（50）和 Shapley 的观点一致。图 3 顶部面板中的结果加强了我们的直觉，即对于最佳回复矩阵，学习算法的吸引子与除虚拟对弈之外的所有算法的最佳回复动态密切相关。</p>
<p>一般情况如图 3 底行所示。相关性仍然很强，虚构游戏的加权相关系数$R^2_w=0:78$，所有其他算法的相关系数$R^2_w≈0:84$。最佳回复动态并不能完美预测收敛性，但其预测结果仍然很好，非常有用。</p>
<p><img src="https://github.com/likun1208/image/blob/master/bestreply-3.png?raw=true" alt="图3"></p>
<p>这一分析还提供了关于导致不收敛的其他一些因素的线索。例如，即使$F(v)=0$表示不存在最佳答案循环，收敛也并不确定。这一点从每个图左边的垂直圆柱中可以明显看出。这一列对应的是没有循环的最佳回复矢量，即形式为$v=(0,…,0,0,x)$的矢量，其中$x=1,2,3,4$是不同固定点的数目。最高的圆对应一个固定点，其下的圆对应两个固定点，等等。在存在唯一的纯近地轨道且不存在循环的情况下，不收敛频率通常约为35%，如果存在两个纯均衡点，则不收敛频率降至约 20%。多个纯均衡的存在，使得像图 2C 中那样存在较好回复循环的可能性降低。相反，当存在没有任何固定点的循环时，也会出现收敛的情况。这与图 2C 右侧的垂直圆柱（$F(v)=1$）相对应，它适用于 k 级 EWA、虚拟博弈和强化学习。</p>
<p>在存在唯一的纯 NE 且没有循环的情况下，不收敛对于复制动力学尤其明显，当存在单个固定点时，约 60% 的时间会发生不收敛。正如我们在补充材料中所解释的，这部分是由于随着 N 的增长而变得更加严重的数值限制，因此如果$N\geq 50$，我们将放弃对复制动力学的观察。</p>
<p>在没有固定点的情况下，收敛完全是由于向混合策略 NE 的收敛。如图 S10 所示，这种影响几乎与 $F(v)$无关，因此会导致恒定偏移。如图 S10 所示，这种影响几乎与 $F(v)$无关，因此会导致恒定偏移。这就是当$F(v)&gt;0$时，圆圈位于同一直线下方的原因。这种效应在强化学习和虚构游戏中尤为明显，强化学习有 21% 的时间收敛到混合均衡状态，而虚构游戏有 32% 的时间收敛到混合均衡状态。相比之下，（双种群）复制器动力学则不存在这种效应，因为它无法收敛到混合策略 NE (52)。其他算法收敛到混合策略 NE 的频率低于 15%。一旦考虑到这些影响，包括虚构游戏在内的所有学习算法的$F(v)$和非收敛率之间都存在很强的比例关系。</p>
<p>在图 S11 中，我们显示了六种学习算法收敛的相关矩阵。图 S11 显示了六种学习算法收敛的相关矩阵。我们发现，收敛平均有 60% 的时间是同时出现的，这表明算法之间存在很大程度的异质性，这与图 2 中的直觉是一致的。</p>
<p>总之，即使 $F(v)$ 忽略更好的回复并低估混合策略 NE 的收敛，收敛的平均概率与最佳回复周期的份额之间也存在稳健的相关性。这表明最佳回复结构与这些算法的稳定性密切相关。</p>
<h3 id="Variation-of-the-best-reply-structure"><a href="#Variation-of-the-best-reply-structure" class="headerlink" title="Variation of the best reply structure"></a>Variation of the best reply structure</h3><p>现在，我们将研究随着博弈属性的变化，最佳回复循环和固定点的普遍性，并检验随着参数的变化，非收敛性的预测。我们研究的参数是可能行动的数量$N$和两位棋手报酬之间的相关性$\Gamma$。(稍后，我们还会考虑一个参数$\xi$，用于在随机博弈和势博弈之间进行插值）。</p>
<p>和以前一样，我们随机生成博弈，但现在我们对从中抽取博弈的集合施加了限制。为了理解$\Gamma$如何影响收敛性，我们通过从二元正态分布中抽取来生成收益矩阵，这样在任何给定的行动组合中，行玩家和列玩家的收益乘积的期望值都等于$\Gamma$。负相关（$\Gamma<0$）意味着博弈是竞争性的，因为对一个玩家有利的事情很可能对另一个玩家不利。极端的情况是$G =-1$，这意味着博弈是零和的。相反，$G>0$则鼓励合作，因为收益往往对双方都有利，或者对双方都不利。</p>
<p>在图 4 中，我们展示了最佳回复周期的份额是如何随$N$和$\Gamma$的变化而变化的。对于给定的$N$和$\Gamma$值，我们随机生成收益矩阵，并计算最佳回复周期的平均份额$<F(v)>_{N,\Gamma}$。我们将$<F(v)>_{N,\Gamma}$与六种学习算法的平均不收敛频率进行比较。结果大致吻合。虚拟博弈是一个显著的例外，当$N$较大且$\Gamma$为负数时，它的收敛率较高。这与其他算法不同，其他算法很少在这一参数范围内收敛，而且与预测结果非常接近。因此，正如预期的那样，必须以不同于其他算法的方式来看待虚拟博弈。</p>
<p><img src="https://github.com/likun1208/image/blob/master/bestreply-4.png?raw=true" alt="图4"></p>
<p>我们想强调的是，这些预测都是先验的，不涉及任何参数拟合。除虚拟博弈外，预测结果符合数据的整体趋势，既能正确估计幅度，又能捕捉函数依赖性。对于其他五种算法，当$N$较大且$\Gamma$为强负值时，预测结果尤为出色，$N&gt;10$时的拟合效果近乎完美。</p>
<p>当我们改变$N$和$\Gamma$时，有可能趋同的情况结论是什么？当$\Gamma$为正数时（意味着博弈不具有竞争性），几乎可以保证收敛，与$N$无关；但当$\Gamma$为强负数时，只有当$N$非常小时才有可能收敛。当$\Gamma=-0.7$ 时，对于$N=4$，不收敛率大约为$70\%$，到$N=8$时迅速上升到接近$100\%$。我们的分析表明，这是因为复杂的竞争博弈被循环所支配。在参数空间的这一区域，非循环博弈极为罕见。因此，优势可解博弈、协调博弈、势博弈和超模态博弈都是非典型的。</p>
<p>最后，我们将简要介绍如何引入其他约束条件来研究上述博弈类别的偏差。在这里，我们只做一个高层次的讨论，技术细节将在第 S4 节中报告。我们考虑的是势博弈，在势博弈中，单方面转换到另一个行动的所有报酬差异都可以用一个全局势函数来表示。势函数将每个行动轮廓映射为一个实数。我们随机生成收益矩阵，并为每个回报矩阵生成一个相关的势函数。然后，我们修改博弈，使收益差异符合势函数。这可以通过参数 $x\in [0,1]$ 来调整： 当$x=0$时，没有任何修正，因此博弈是完全随机的；当$x=1$时，收益矩阵描述了一个完美的势博弈。</p>
<p>改变$N$和$x$的效果如何？我们重复上述过程，对1000个报酬矩阵进行$N=3,10,50$ 和$x\in [0.0, 0.1, …, 0.5, …,0.9,1.0]$ 的取值。如图 S12 所示，当$x$接近 1 时，最佳回复循环的份额$<F(v)>_{N,\xi}$如期归零。当$N=3$和$x=0.8$时，它仅为$<F(v)>_{N,\xi}=0.05$，但当$N=50$和$x=0.8$时，它为$<F(v)>_{N,\xi}=0.35$。这表明，在某些情况下，与通常研究的博弈类别的微小偏差可能会导致最佳回复循环的份额显著增加，从而使它们在学习下变得不那么稳定。</p>
<h3 id="Analytical-approach"><a href="#Analytical-approach" class="headerlink" title="Analytical approach"></a>Analytical approach</h3><p>对于$\Gamma=0$，我们可以分析得出最佳回应结构是如何随$N$变化的。我们的推导遵循统计力学框架，这表明诸如最佳回应结构中是否存在相变等问题都可以在我们的形式主义中进行研究。我们将最佳回复配置定义为双方对对手所有可能行动的唯一一组最佳回复。由于最佳回复矩阵是布尔矩阵，因此对于任何给定的$N$，都有可数的可能性。可能的最佳回复配置总数为$N^{2N}$。对于不相关的回报($\Gamma=0$)，所有最佳回复配置的可能性相同。因此，我们可以通过计算导致$v$的最佳回复配置的数量来计算任意吸引子集$v$的频率$\rho(v)$。</p>
<p>在此，我们仅简要说明推导过程，详细解释请参阅第 S5.1 节。由于独立性，$\rho(v)$频率可以写成与获得每种吸引子的方法数量相对应的项$f$乘以自由行动（不在吸引子上的最佳回复）项$g$的乘积。我们用$n$表示每个玩家不属于循环或固定点的行动数。</p>
<p>函数$f(n, k)$会统计$k$循环的方式（包括固定点，即长度为$k=1$的循环）:</p>
<script type="math/tex; mode=display">
f(n,k)=\binom{n}{k}^2k!(k-1)!</script><p>其中，二项式系数意味着，对于每个玩家，我们可以从$n$个行动中任意选择$k$个行动来形成循环或定点，而阶乘则量化了所选$k$个行动产生循环或定点的所有最佳回复组合。例如，在图 1 中，对于每个玩家，我们可以从 4 个行动中任意选择 2 个行动来形成 2 循环，而对于每一个行动，都有两种可能的循环（一种是顺时针，另一种是逆时针）。形成 2 循环的方法数为$f(4, 2)=72$。同样，对于每个玩家，我们可以从剩下的两个动作中选择任意一个动作来形成一个固定点，方法数为$f(2, 1)=4$。</p>
<p>在这个例子中，对于两个玩家，我们仍然可以自由选择一个最佳回复，前提是这不会形成另一个固定点（否则，最佳回复向量就会不同）。在图 1 中，行玩家的自由最佳回复为$(3,4)$，列玩家的自由最佳回复为 (4，1)。一般来说，$g_N(n,d)$ 计算的是将$N\times N$ 报酬矩阵中剩余的$n$个自由最佳回复组合起来，使其不形成其他循环或固定点的方法数</p>
<script type="math/tex; mode=display">
g_N(n, d)=N^{2 n}-\sum_{k=1}^n f(n, k) g_N(n-k, d+1) /(d+1)</script><p>第一项$N^{2n}$ 量化了自由最佳回复的所有可能组合，求和计算“禁止”组合，即形成循环或固定点的组合。这个项具有递归结构。它先计算形成每种吸引子的方式数，然后计算在剩余的$n-k$个行动中没有其他吸引子的方式数。请注意，$N$是一个参数，因此用下标表示，而$n$是一个递归变量。最后，需要用$d+1$除法来防止吸引子的重复计算、三重计算等。在图 1 的例子中，$g_4(1,0)=15$。</p>
<p>对于任意给定最优回复向量，$v=(n_N,…,n_2,n_1)$，其频率$\rho$的通用表达式为：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\rho(\mathbf{v})=\left(\prod_{k=1 j=1}^N \prod_{n_k} \frac{f\left(N-\sum_{l=k+1}^N n_l l-(j-1) k, k\right)}{j}\right) \\
\times g_N\left(N-\sum_{l=1}^N n_l l, 0\right) /\left(N^{2 N}\right)
\end{gathered}</script><p>第一个括号是计算包含吸引子$v$的所有可行方法数量。$f$的第一个参数$N-\sum_{l=k+1}^N n_l l-(j-1) k$迭代量化了不属于其他吸引子的行动的数量。除以$j$，就像公式3中除以$d+1$一样，是为了防止吸引子的重复计算、三重计算等。第二个项$g_N$计算了所有可能的方法来定位自由最佳回复，使其不形成其他吸引子。$g_N$的第一个参数是不属于吸引子的行动计数，初始递归深度为0。最后，我们通过除以所有可能的配置$N^{2N}$得到频率。对于图1中的收益矩阵，$\rho(0,0,1,1) =f(4,2)f(2,1)g_4(1,0)/4^8=0.07$。</p>
<p>然后，可以利用公式 4 计算然后，可以利用公式 4 计算出任何给定$N$的最佳回复周期$F$的集合平均值，并对所有可能的$v$求和，使得$\sum_{k=1}^N n_k k \leq N$。</p>
<script type="math/tex; mode=display">
\mathcal{F}_N=\sum_{\mathbf{v}} \rho(\mathbf{v}) \mathcal{F}(\mathbf{v})</script><p>我们还可以计算其他量，包括没有固定点$F(v)=1$和没有循环$F(v)=0$的收益矩阵的分数。我们将在第 S5.2 节中提供表达式并解释其推导过程。</p>
<p>在图 5 中，我们分析了$N$值增大时的最佳回复结构。我们从下往上报告了没有固定点的回报矩阵的比例、最佳回复循环$F_N$的平均比例以及至少有一个循环的博弈比例。例如，对于$N=30$，36% 的收益矩阵没有固定点，84% 的收益矩阵至少有一个循环（因此 16% 的收益矩阵没有循环，48% 的收益矩阵混合了循环和固定点），平均$F_N=0.70$。分析结果（实线）与蒙特卡罗取样（标记）之间的一致性非常好。有循环的博弈比例是$N$的递增函数；要计算大N的这一比例在计算上很难，但它似乎正趋向于1。然而，至少有一个固定点的博弈分数似乎在$N\rightarrow \infty$ 时达到一个固定值。在第 S5.3 节中，我们证明这个值近似为 1/3，与数值模拟结果一致，并接近精确结果$1/e$。</p>
<h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>我们描述了双人、正常形式、通用博弈中的不稳定性，表明最佳回复结构可以预测各种学习算法的收敛频率。这一结果非常了不起，因为这些算法与最佳回复动态没有明确的关系。最佳回复动态只取决于其他玩家的前一步棋，而这些算法都有较长的记忆，还因为最佳回复动态没有自由参数，而这些算法中的大多数都有。为什么这种对应关系有效？我们猜想，最佳回复循环的存在使得不稳定动态在统计上更有可能存在吸引盆地，而它们的不存在则使得纯策略 NE 有可能是全局稳定的固定点。这并不总是正确的—有些学习动力可能被困在最佳回复循环中，而另一些学习动力有时会收敛到混合策略近似点，但这是一个有效的近似，极大地简化了问题。它使我们有可能利用统计力学的概念框架，使用组合学来分析探索微观博弈集合下的一般博弈空间。</p>
<p>为什么最佳回复形式的预测结果如此之好？为了理解这一点，我们可以明确地将最佳回复的报酬矩阵视为一阶近似值，然后研究沿着与之相关的报酬矩阵族的连续路径移动时的行为。我们可以用这种方法来研究导致偏差的因素，例如混合均衡或最佳回复的出现和消失。这有可能导致一种扰动扩展，用于理解正态博弈中学习算法的收敛性。这超出了本文的研究范围，但可能是进一步研究的一个有趣课题。</p>
<p>我们还证明，在报酬没有任何限制的情况下，增加每个玩家的可用行动数量会使最佳回复循环占主导地位，从而使收敛到均衡的可能性降低。这类似于梅在大型生态系统上的结果（14）。我们考虑了一个竞争参数，该参数限制了双方玩家的报酬对。在负相关的情况下，博弈是竞争性的（在报酬完全反相关的极端情况下为零和），最佳回复周期变得更加普遍。相反，正相关会使最佳回复周期变得罕见。</p>
<p>我们还对博弈进行了限制，使报酬的差异符合全局势函数，就像在势博弈中一样。这种对应关系由一个参数来调整，该参数在完美随机博弈和完美势博弈之间进行插值。我们已经证明，当行动数量较多时，与完美势博弈的微小偏差会带来相当大比例的最佳回复循环。</p>
<p>还可以加入许多其他限制条件。超模态博弈在文献中也受到了极大的关注。在这些博弈中，行动是有序的，如果一个玩家增加她的行动，其他所有玩家的边际报酬都会增加（这就是策略互补性的概念）。我们可以随机生成具有这种约束条件的博弈，并观察最佳回复循环的份额在接近完美超模态博弈时是如何变化的。总的来说，我们的形式主义使我们有可能评估约束条件是否会使正态博弈集合变得更稳定或更不稳定。在大多数情况下，对于我们在此研究的学习算法，只需检查约束是否使最佳回复循环变得常见或罕见，而无需模拟学习动态。</p>
<p>我们在这里研究的是正态博弈，因为它们很容易理解，但我们的研究有可能扩展到其他类型的博弈。例如，在广义形式博弈中，不同行动的排序和私人信息的存在都是恰当的模型。虽然我们的理论并不直接适用，但广泛形式博弈有一个正常形式表示，这表明这种扩展应该是可能的。同样，我们已经开始研究有两个以上玩家的博弈。之前对无限行动数$N$的竞争博弈的研究表明，非收敛变得更有可能，而我们的初步结果表明，$N&lt;\infty$时也是如此。</p>
<p>在生态学中，生态系统如此持久这一事实本身就表明，它们必须相当稳定。相比之下，有许多生物和社会系统会随着时间的推移而波动，而且它们的动态是外生的还是内生的，先验地并不明确。当使用博弈论对这些系统进行建模时，没有任何先验条件说它们应该是稳定的。因此，与预先知道答案的生态系统不同，在这些系统中，我们应该对它们是一般稳定还是不稳定持开放态度。在没有选择机制或有意设计的稳定性的情况下，我们的方法可以揭示这个问题。如果存在上述任何一种机制，我们的方法就能提供一个无效假设，据此来衡量这些机制的有效性。</p>
<p>这些结果很有用，因为它们对假设均衡是危险的情况提出了警告。在现实世界中，有许多情况下可能采取的行动数量很大，而且回报很可能是反相关的。在没有其他约束条件的情况下，我们的结果表明，在这些情况下，均衡不太可能是一个好的行为假设。虽然均衡是存在的，但只要正常形式博弈适用，只要我们在这里研究的学习算法类型相关，在这些情况下，收敛就不太可能。</p>
<h2 id="Materials-and-methods"><a href="#Materials-and-methods" class="headerlink" title="Materials and methods"></a>Materials and methods</h2><p>我们在此总结了用于模拟图 3 和图 4 中学习算法的协议。我们只报告了能够复制结果的最基本信息。我们将在 S1 部分提供更详细的说明，其中包括行为解释和其他规格。我们不得不对收敛标准和参数值进行任意选择，但在测试替代规格时，我们发现相关系数的变化不超过小数点后几个单位。这证实了最佳回复周期的份额与六种学习算法的非收敛频率之间存在稳健的相关性。</p>
<p>考虑一个双人、$N$种行动的正态博弈。我们用$\mu\in\{Row=R, Column=C\}$ 来表示玩家，用$i,j=1, … N$ 来表示他们的行动。让$x_i^\mu(t)$成为玩家$\mu$在$t$时刻采取$i$行动的概率，即她的混合策略向量的第$i$个分量。为方便记述，我们还用$x_i(t)$表示玩家R在$t$时刻采取$i$行动的概率，用$y_j(t)$ 表示玩家$C$在$t$时刻采取$j$行动的概率。我们进一步用$s_m(t)$表示玩家$m$在$t$时刻实际采取的行动，用$s_{- m}(t)$表示其对手采取的行动。玩家$m$的收益矩阵为$P_m$，$P_m(i, j)$ 表示如果玩家$m$采取行动$i$，而对方选择行动 $j$，那么玩家$m$得到的收益。</p>
<h3 id="Reinforcement-learning"><a href="#Reinforcement-learning" class="headerlink" title="Reinforcement learning"></a>Reinforcement learning</h3><p>我们只描述行玩家，因为列的学习算法是一样的。行玩家在时间$t$有一个抱负水平$AR(t)$，其更新为:</p>
<script type="math/tex; mode=display">
A^{\mathrm{R}}(t+1)=(1-\alpha) A^{\mathrm{R}}(t)+\alpha \sum_{i, j} x_i(t) \Pi^{\mathrm{R}}(i, j) y_j(t)</script><p>其中$\alpha$是参数。对于动作$i$和时间$t$，行玩家的满意度$\sigma_i^R(t)$为</p>
<script type="math/tex; mode=display">
\sigma_i^{\mathrm{R}}(t)=\frac{\sum_{i j} x_i(t) y_j(t)\left(\Pi^{\mathrm{R}}(i, j)-A^{\mathrm{R}}(t)\right)}{\max _{i, j}\left|\Pi^{\mathrm{R}}(i, j)-A^{\mathrm{R}}(t)\right|}</script><p>混合策略向量的所有元素都被更新。更新规则为</p>
<script type="math/tex; mode=display">
x_i(t+1)=x_i(t)+x_i(t) \Delta x_i(t)+\sum_{j \neq i} x_j(t) \Delta x_{i j}(t)</script><p>这里$\Delta x_i(t)$是行玩家选了动作$i$所带来的贡献（出现概率为$x_i(t)$），且$\Delta_{ij}(t)$是选了另一个动作$j$而对动作$i$的贡献（即标准化更新），发生的概率是$x_j(t)$。我们有：</p>
<script type="math/tex; mode=display">
\Delta x_i(t)=\left\{\begin{array}{cc}
\beta \sigma_i^{\mathrm{R}}(t)\left(1-x_i(t)\right), & \sigma_i^{\mathrm{R}}(t)>0 \\
\beta \sigma_i^{\mathrm{R}}(t) x_i(t), & \sigma_i^{\mathrm{R}}(t)<0
\end{array}\right.</script><p>和</p>
<script type="math/tex; mode=display">
\Delta x_{i j}(t)=\left\{\begin{array}{cc}
-\beta \sigma_j^{\mathrm{R}}(t) x_i(t), & \sigma_j^{\mathrm{R}}(t)>0 \\
-\beta \sigma_j^{\mathrm{R}}(t) \frac{x_j(t) x_i(t)}{1-x_j(t)}, & \sigma_j^{\mathrm{R}}(t)<0
\end{array}\right.</script><p>其中$\beta$是参数。</p>
<p>从随机混合策略向量——混合策略的初始化对于后面的所有学习算法都是相同的——以及愿望和满意度的空水平开始，我们在 5000 个时间步长内重复公式 6 至 10 中的动态过程（我们设置$a=0.2$和$b=0.5$）。为了确定模拟运行是否收敛，我们只考虑了最后 20% 的时间步数，以及在此时间间隔内平均概率大于 0.05 的混合策略向量成分。如果这些成分和时间步数的平均标准偏差大于 0.01，则该模拟运行被认定为非收敛。</p>
<h3 id="Fictitious-play"><a href="#Fictitious-play" class="headerlink" title="Fictitious play"></a>Fictitious play</h3><h3 id="Replicator-dynamics"><a href="#Replicator-dynamics" class="headerlink" title="Replicator dynamics"></a>Replicator dynamics</h3><h3 id="Experience-weighted-attraction"><a href="#Experience-weighted-attraction" class="headerlink" title="Experience-weighted attraction"></a>Experience-weighted attraction</h3><h3 id="EWA-with-noise"><a href="#EWA-with-noise" class="headerlink" title="EWA with noise"></a>EWA with noise</h3><h3 id="Level-k-learning"><a href="#Level-k-learning" class="headerlink" title="Level-k learning"></a>Level-k learning</h3><h3 id="Payoff-matrices"><a href="#Payoff-matrices" class="headerlink" title="Payoff matrices"></a>Payoff matrices</h3>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Optimal and Quantized Mechanism Design for Fresh Data Acquisition</title>
    <url>/2021/11/01/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Optimal%20and%20Quantized%20Mechanism%20Design%20for%20Fresh%20Data%20Acquisition/</url>
    <content><![CDATA[<h1 id="新鲜数据采集的优化量化机制设计"><a href="#新鲜数据采集的优化量化机制设计" class="headerlink" title="新鲜数据采集的优化量化机制设计"></a>新鲜数据采集的优化量化机制设计</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><h2 id="System-Model-and-Problem-Formulation"><a href="#System-Model-and-Problem-Formulation" class="headerlink" title="System Model and Problem Formulation"></a>System Model and Problem Formulation</h2><h3 id="System-Model"><a href="#System-Model" class="headerlink" title="System Model"></a>System Model</h3><p>数据源集合：$\mathcal{I}=\{1\leq i\leq I\}$，生成数据包并发送给目标</p>
<p>目标：需要平衡与数据新鲜度相关的成本和与数据本身的货币成本</p>
<p>数据源：需要平衡收益、采样成本和更新频率</p>
<ol>
<li><p>数据更新与调度：</p>
<p>随时生成模型——数据源可以在目标要求时生成并发送数据；忽略数据传输延迟。</p>
<p>目标的数据获取策略：更新策略$\mathcal{X}$和调度策略$\mathcal{S}$</p>
<p>​    更新策略：表示两次更新间隔时间的集合，$\mathcal{X}=\{x_k\}_{k\in \mathbb{N}}$，$x_k$表示第k-1次更新和第k次更新之间的时间间隔</p>
<p>​    调度策略：用来指定选哪个数据源来更新的二值集合，$\mathcal{S}=\{s_{i,k}\}_{i\in\mathcal{I},k\in\mathbb{N}}$，$s_{i,k}=1$表示第k次更新选了第i个数据源，反之为0表示没选这个数据源，每次更新只选择一个源，因此$\sum_{i\in \mathcal{I}} s_{i,k}=1, s_{i,k}\in\{0,1\}$</p>
<p>​    第i个数据源的第k-1次更新到第k次更新之间的时间间隔用$y_{i,k}$表示，计算方法是把中间的$x_k$加起来</p>
<p>​    每个数据源的更新受限于最大更新频率：$f_{i,max}$</p>
</li>
<li><p>信息年龄AoI：时间t的AoI定义：$\Delta_t\{\mathcal{X}\}=t-U_t$，$U_t$表示在t时刻之前的最近一次更新时间</p>
</li>
<li><p>数据源采样成本和隐私信息：</p>
<p>第i个数据源的单位采样成本是$c_i$，是私有信息，认为该成本在$\mathcal{C}_i=[\underline{c}_i,\hat{c}_i]$，</p>
<p>累计分布函数和概率密度函数分别是$\Gamma_i(c_i)$和$\gamma_i(c_i)$，是公开信息</p>
</li>
<li><p>目标的AoI成本：</p>
<p>AoI成本函数$g(\Delta_t(\mathcal{X}))$，用于表示目标对数据陈旧的不满程度，是以AoI为自变量的一个非负增函数</p>
<p>目标的累计AoI成本：$G(x)=\int_0^x g(\Delta_t)d\Delta_t$，表示时间范围x内的累计成本，是凸函数（二阶导大于0的那种）</p>
</li>
</ol>
<h3 id="Mechanism-Design-and-Reporting-Game"><a href="#Mechanism-Design-and-Reporting-Game" class="headerlink" title="Mechanism Design and Reporting Game"></a>Mechanism Design and Reporting Game</h3><p>数据源和目标之间的两阶段博弈：</p>
<ol>
<li>目标设计机制$m=(\mathcal{P},\mathcal{X},\mathcal{S})$，并发布给数据源，分别是支付策略、更新策略和调度策略，这三个都是以数据源的报告成本$\widetilde{c}_i$为自变量的函数，目标支付的报酬会根据更新频率和数据源的选择而不同。</li>
<li>数据源提交自己的采样成本$\widetilde{c}_i$，可能是假的</li>
</ol>
<h4 id="多源系统"><a href="#多源系统" class="headerlink" title="多源系统"></a>多源系统</h4><p>报告博弈(Reporting Game) $\mathcal{G}=\{\mathcal{I},\{\mathcal{C}_i\}_{i\in I},\{\mathcal{P}_i\}_{i\in I}\}$</p>
<p>玩家：所有数据源$\mathcal{I}$的集合</p>
<p>策略空间：每个数据源$i$的报告策略是$\widetilde{c}_i\in C_i$</p>
<p>收益：每个数据源$i$的收益函数如下</p>
<script type="math/tex; mode=display">
P_i(\widetilde{c}_i,\widetilde{c}_{-i},m)=lim\ inf_{K->\infty}\frac{\sum_{k=1}^K s_{i,k}(\widetilde{c})(p_{i,k}(\widetilde{c})-c_i)}{\sum_{k=1}^K x_k(\widetilde{c})}</script><p>这个收益函数的解释：每个数据源的收益是一个长时间累积收益的单位时间平均值（这里是净收益，也就是到手的报酬减去成本）</p>
<p>根据一些参考文献，一个深思熟虑的数据源并不是策略性的，而是短视的，即：并不会最大化他们可见的 长期收益（也就是上面这个公式）</p>
<p>由于每个数据源都不知道其他数据源的具体成本$\widetilde{c}_{-i}$，只知道相关的先验分布，因此可得到下述贝叶斯均衡：</p>
<p><strong>定义1</strong>（贝叶斯均衡）：贝叶斯均衡是：对于每一个数据源$i$，在机制$m$和其他数据源的报告$\widetilde{c}_{-i}$不改变的情况下，使得该数据源收益最大的那个报告<script type="math/tex">\tilde{c}^{*}(m)=\left\{\tilde{c}_{i}^{*}(m)\right\}_{j \in \mathcal{T}}</script></p>
<p>而目标的目的是设计一个最优机制来最小化自己的总期望支出（长期平均值），总支出由AoI支出和数据源支出组成，函数如下：</p>
<script type="math/tex; mode=display">
J(m)=\mathbb{E}_{\boldsymbol{c}} \left[\operatorname { lim sup} _ { K \rightarrow \infty } \left(\frac{\sum_{k=1}^{K} G\left(x_{k}\left(\tilde{\boldsymbol{c}}^{*}(m)\right)\right)}{\sum_{k=1}^{K} x_{k}\left(\tilde{\boldsymbol{c}}^{*}(m)\right)}\right.\right.
+\left.\left.\frac{\sum_{k=1}^{K} \sum_{i \in \mathcal{I}} s_{i, k}\left(\tilde{\boldsymbol{c}}^{*}(m)\right) p_{i, k}\left(\tilde{\boldsymbol{c}}^{*}(m)\right)}{\sum_{k=1}^{K} x_{k}\left(\tilde{\boldsymbol{c}}^{*}(m)\right)}\right)\right],</script><p>其中$\tilde{\boldsymbol{c}}^{*}(m)$是贝叶斯均衡。</p>
<p>每个数据源都有动机谎报成本，根据显示原理，对于任意机制$m$，一定存在一个激励相容机制$\tilde{m}$，使得$J(m)=J(\tilde{m})$</p>
<p>总结一下这里就是说，我们设计出的机制要满足激励相容约束和个体理性约束，前者保证数据源如实上报，后者保证数据源期望收益非负，这两个约束写成公式的形式如下：</p>
<script type="math/tex; mode=display">
\mathrm{IC}: \quad c_{i} \in \arg \max _{\tilde{c}_{i} \in \mathcal{C}_{i}} \mathbb{E}_{\boldsymbol{c}_{-i}}\left[P_{i}\left(\tilde{c}_{i}, \boldsymbol{c}_{-i}, m\right)\right], \quad \forall i \in \mathcal{I}</script><script type="math/tex; mode=display">
\operatorname{IR}: \quad \max _{\tilde{c}_{i} \in \mathcal{C}_{i}} \mathbb{E}_{c_{-i}}\left[P_{i}\left(\tilde{c}_{i}, \tilde{\boldsymbol{c}}_{-i}^{*}(m), m\right)\right] \geq 0, \quad \forall i \in \mathcal{I}</script><h4 id="单源系统"><a href="#单源系统" class="headerlink" title="单源系统"></a>单源系统</h4><p>只有一个数据源的特殊情况下，不存在数据源之间的博弈，激励相容和个体理性简化成下述形式：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\mathrm{IC}-\mathrm{S}: & c \in \arg \max _{\tilde{c} \in \mathcal{C}} P(\tilde{c}, m) \\
\mathrm{IR}-\mathrm{S}: & \max _{\tilde{c} \in \mathcal{C}} P(\tilde{c}, m) \geq 0
\end{array}</script><h3 id="Problem-Formulation"><a href="#Problem-Formulation" class="headerlink" title="Problem Formulation"></a>Problem Formulation</h3><p>目标需要找一个在满足约束的前提下最小化自己支出$J(m)$的机制$m$，约束包括：</p>
<ol>
<li>一轮选一个数据源；</li>
<li>更新频率不能超过数据源的上限；</li>
<li>激励相容约束</li>
<li>个体理性约束</li>
</ol>
<p>接下来证明了一类最优机制。</p>
<p><strong>定义2</strong>（等间距和统一费率机制）：一个机制$m=(\mathcal{P},\mathcal{X},\mathcal{S})$在满足以下条件时，我们称之为等间距和统一费率机制：</p>
<script type="math/tex; mode=display">
p_{i, k}(\cdot)=p_{i}(\cdot) \text { and } x_{k}(\cdot)=x(\cdot), \quad \forall k \in \mathbb{N}, i \in \mathcal{I}</script><p>其中，$p_{i}: \mathcal{C} \rightarrow \mathbb{R}_{+}$ ，$x: \mathcal{C} \rightarrow \mathbb{R}_{+}$。</p>
<p>意思就是对于数据源$i$，每一轮支付给它的钱都是一样的；而每一轮的更新频率也设置成一样的。</p>
<p><strong>定义3</strong>（<em>随机</em>固定调度）：一个调度策略$\mathcal{S}$在满足下述描述时，我们称之为固定调度：如果对于所有的数据源$i$，给定任意成本$c$，每个时间$k$的调度策略$s_{i,k}(c)$都是随机选择且在$k$上独立同分布，并且满足：</p>
<script type="math/tex; mode=display">
\operatorname{Pr}\left(s_{i, k}(\tilde{\boldsymbol{c}})=1\right)=\pi_{i}(\tilde{\boldsymbol{c}}), \quad \forall \tilde{\boldsymbol{c}} \in \mathcal{C}, k \in \mathbb{N}, i \in \mathcal{I}</script><p>其中，$\pi_{i}: \mathcal{C} \rightarrow[0,1]$ 满足 $\sum_{i \in \mathcal{T}} \pi_{i}(\tilde{\boldsymbol{c}})=1$</p>
<p>意思就是固定调度每一轮的调度策略与这一轮的时间$k$无关。</p>
<p>接下来说明最优机制的一些特性。</p>
<p><strong>引理1</strong>：</p>
<h2 id="Single-Source-Optimal-Mechanism-Design"><a href="#Single-Source-Optimal-Mechanism-Design" class="headerlink" title="Single-Source Optimal Mechanism Design"></a>Single-Source Optimal Mechanism Design</h2><h2 id="Multi-source-Optimal-Mechanism"><a href="#Multi-source-Optimal-Mechanism" class="headerlink" title="Multi-source Optimal Mechanism"></a>Multi-source Optimal Mechanism</h2><h2 id="Quantized-Optimal-Mechanism"><a href="#Quantized-Optimal-Mechanism" class="headerlink" title="Quantized Optimal Mechanism"></a>Quantized Optimal Mechanism</h2><h2 id="General-Virtual-Cost-Function"><a href="#General-Virtual-Cost-Function" class="headerlink" title="General Virtual Cost Function"></a>General Virtual Cost Function</h2><h2 id="Performance-Comparison"><a href="#Performance-Comparison" class="headerlink" title="Performance Comparison"></a>Performance Comparison</h2><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>crowdsourcing</tag>
        <tag>mechanism design</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-An Efficient Anonymous Authentication and Reputation Management Scheme for Mobile Crowdsensing in Vehicular Networks</title>
    <url>/2021/10/19/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-An%20Efficient%20Anonymous%20Authentication%20and%20Reputation%20Management%20Scheme%20for%20Mobile%20Crowdsensing%20in%20Vehicular%20Networks/</url>
    <content><![CDATA[<h1 id="车联网中的高效匿名认证与信誉管理框架"><a href="#车联网中的高效匿名认证与信誉管理框架" class="headerlink" title="车联网中的高效匿名认证与信誉管理框架"></a>车联网中的高效匿名认证与信誉管理框架</h1><p>这篇是投稿到<a href="mailto:onbehalfof@manuscriptcentral.com">IEEE Transactions on Vehicular Technology</a>的论文，现在要写审稿意见。</p>
<p>作者：三个暨南大学，一个澳门城市大学</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>车联网的众包系统中，匿名认证和信誉管理很重要，也面临很多问题。本文提出了一个既提高参与者相互认证效率，又实现传感车辆声誉管理的新方案。具体来说，匿名身份验证机制用于实现数据请求者、云服务器和传感车辆之间的相互认证，信誉评分更新方法将评分转化为模糊的信誉评级，以提高不可连接性（？）。传感数据使用Paillier算法保护。模拟实验中分析了隐私、计算和通信成本，表明效率优于现有方案。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>MCS（移动群智感知）越来越重要，车联网中的实时传感提升了传感结果精度；但是由于数据上传和匿名认证过程中的庞大、开放、稀疏、高度动态性的特点，车联网在面对攻击时是脆弱的；此外，多个传感器同时参与传感任务会增加计算和通信的负担。因此，如何获取高质量数据和实现高效匿名认证是亟待解决的问题。信誉评分系统可以用于构建可信车联网，但因为传感车辆的轨迹和驾驶模式可以通过接入信誉评分来推断，仅仅使用这个系统是不够的。信誉评分系统和匿名认证过程中面临的隐私问题直接影响传感车辆接入车联网的意愿和采集数据的精度。综上，本文提出了一个新方案，主要贡献如下：</p>
<ol>
<li>通过采用定期更新和模糊化方法，实现了假名和信誉评分的不可链接性。</li>
<li>提出了一种有效的匿名认证方法，根据该方法，可以减少计算和通信费用，提高身份验证效率。</li>
<li>通过分发诚实传感车辆的高信誉分数和恶意车辆的低声誉分数，实现了高效、实时的声誉管理。</li>
<li>对隐私和安全性进行了理论分析，模拟实验表明本文方法的计算和通信开销以及信誉更新算法的性能优于现有方案。</li>
</ol>
<h2 id="Related-Word"><a href="#Related-Word" class="headerlink" title="Related Word"></a>Related Word</h2><h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><h3 id="Bilinear-pairing（双线性配对）"><a href="#Bilinear-pairing（双线性配对）" class="headerlink" title="Bilinear pairing（双线性配对）"></a>Bilinear pairing（双线性配对）</h3><p>对称加密技术。$G_1$、$G_2$、$G_T$是三个素数$p$阶群乘法循环群，双线性配对是有这下列属性的$\hat{e}:G_1\times G_2 \rightarrow G_T$：</p>
<ol>
<li>双线性：对于所有$g\in G_1, h\in G_2, a,b \in Z_p,\hat{e}(g^a,h^b)=\hat{e}(g,h)^{ab}$</li>
<li>非退化性：对于所有$g\neq1_{G_1},h\neq1_{G_2},\hat{e}(g,h)\neq 1_{G_T}$</li>
<li>可计算性：$\hat{e}$是可计算的</li>
</ol>
<h3 id="Beta-distribution"><a href="#Beta-distribution" class="headerlink" title="Beta distribution"></a>Beta distribution</h3><p>Beta分布是定义在区间<code>(0,1)</code>的连续概率分布，两个参数分别是$\alpha$和$beta$。随机变量X服从Beta分布记作$X~Beta(\alpha,\beta)$，其概率密度函数$f(x|\alpha,\beta)$是Gamma函数的函数：</p>
<script type="math/tex; mode=display">
f(x|\alpha,\beta)=\frac{\Gamma(\alpha+\beta)}{\Gamma(\alpha)\Gamma(\beta)}x^{\alpha-1}(1-x)^{\beta-1}</script><p>其中，</p>
<script type="math/tex; mode=display">
\Gamma(\alpha)=\int_0^\infty x^{\alpha-1}e^{-x}dx,0\leq x\leq 1,\alpha>0,\beta>0</script><p>Beta分布的数学期望$E(x)=\frac{\alpha}{\alpha+\beta}$。</p>
<h3 id="Paillier-algorithm"><a href="#Paillier-algorithm" class="headerlink" title="Paillier algorithm"></a>Paillier algorithm</h3><p>是同态加密算法，内容如下：</p>
<ol>
<li>初始化：选择两个大质数$p$和$q$，计算$n=p\cdot q$</li>
<li>密钥生成：计算$\delta = LCM(p-1,q-1)$，选择随机数$g_a\in Z_{n^2}^*$，计算非公开参数$\eta=(L(g_\alpha^\delta\ \ mod\ \ n^2))^{-1}mod\ \ n$，其中L是$L(x)=(x-1)/n$。公钥和私钥分别是$P_k=(n,g_a)$和$S_k=(\delta,\eta)$</li>
<li>加密：选择随机数$r\in Z_{n^2}^*$，对信息$m$使用公钥$P_k$加密，得到密文C：$C=g_a^m\cdot r_i^n\ \ mod\ \ n$</li>
<li>解密：使用密钥对密文C解密，得到信息m：$m=L(C^\delta\ \ mod\ \ n^2)\cdot \eta\ \ mod\ \ n$</li>
</ol>
<h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><h3 id="System-architecture"><a href="#System-architecture" class="headerlink" title="System architecture"></a>System architecture</h3><ol>
<li>可信认证（TA）：完全被信任，有强大算力，具体来说，TA 负责系统参数设置、实体注册以及车辆网络中的恶意 SV 跟踪和撤销。此外，TA 还分发和更新 SV 的信誉评分和身份证明。此外，它存储其他实体的注册信息，并保存其私钥，其公钥为 SV 所知。</li>
<li>数据请求者：分配传感任务</li>
<li>云服务器：有强大的存储空间和算力，收集和处理来自SV的密文，对SV的传感数据进行评分并反馈给TA</li>
<li>传感车辆（SV）：装备多种传感器、可互相通信的实体</li>
</ol>
<p>匿名认证和信誉管理系统步骤如下：</p>
<ol>
<li>实体注册：数据请求者、云服务器和SV在TA进行注册从而参与传感任务</li>
<li>任务分配：数据请求者在云服务器上分配传感任务，云服务器向SV广播</li>
<li>车辆选择：注册后，每个SV向云服务器发送认证信息，云服务器根据信誉评分和身份认证选择SV</li>
<li>数据收集：SV收集数据并加密发送到云服务器</li>
<li>数据处理：云服务器验证并聚合密文</li>
<li>结果提交：云服务器把聚合密文交给数据请求者</li>
<li>反馈报告：云服务器生成所有参与传感任务的SV的信誉反馈报告并发送给TA</li>
<li>更新评分和认证：TA更新SV的信誉评分和身份认证，并将其发送给相应的SV</li>
</ol>
<h3 id="Security-model"><a href="#Security-model" class="headerlink" title="Security model"></a>Security model</h3><p>TA完全被信任；数据请求者和云服务器诚实却对SV的隐私感到好奇；SV对其他SV的传感数据感到好奇，</p>
<p>信誉/假名攻击：当SV上传数据时，攻击者可能会链入信誉评分系统和假名进行攻击</p>
<p>中间人攻击：恶意SV会窃取认证信息欺骗云服务器并提供假数据</p>
<p>女巫攻击：恶意SV会建立多个实体从而传输多份假数据</p>
<p>替换攻击：恶意SV会用错误数据替换正确数据从而通过数据评估</p>
<h3 id="Design-goals"><a href="#Design-goals" class="headerlink" title="Design goals"></a>Design goals</h3><p>隐私目标：</p>
<ol>
<li>认证隐私：SV的真实身份不会暴露，假名不会被恶意攻击链接</li>
<li>数据隐私：传感数据受保护，除数据请求者以外的其他实体无法获取</li>
</ol>
<p>安全目标：防止前面提到的四种攻击</p>
<h2 id="The-Design-Of-Our-Scheme"><a href="#The-Design-Of-Our-Scheme" class="headerlink" title="The Design Of Our Scheme"></a>The Design Of Our Scheme</h2><h3 id="System-initialization"><a href="#System-initialization" class="headerlink" title="System initialization"></a>System initialization</h3><ol>
<li>TA初始化：TA首先运行系统生成算法<code>Gen(k)</code>生成系统参数$\{p,q,P_1,P_2,G_1,G_2,G_T,\hat{e}\}$​，该算法中的<code>k</code>是安全参数，$G_1,G_2,G_T$​是三个$p$​阶循环群，$\hat{e}$​是双线性映射，$P_1\in G_1,P_2\in G_2$​. 接下来TA计算$G=\hat{e}(P_1,P_2)$​，定义一个非对称加密算法<code>Ene()</code>和一个加密哈希函数$H(0,1)^<em>\rightarrow Z_n^</em>$​，其中$n=p\cdot q$​，此外，TA初始化密码对$(Sk_T,Pk_T)(Sk_T\in Z_n^*,Pk_T=Sk_T\cdot P_1)$​，并计算认证参数$A=\frac{1}{Sk_T}\cdot P_2$​. 最后，TA将$(p,q,Sk_T)$​作为隐私，公开$(n,P_1,P_2,G_1,G_2,G_T,\hat{e},Pk_T,H,Enc(),A)$​</li>
<li>云服务器注册：TA把密码对$(Sk_C,Pk_C)(Sk_C\in Z_n^*,Pk_C=Sk_C\cdot P_1)$​分配给云服务器</li>
<li>数据请求者注册：当一个新的数据请求者$D_i$​​注册时，TA分配给它一个独一无二的标识$Rid_{D_i}$​​​​​和两个密码对，其中一个是非对称加密，并基于此计算身份认证$Cert_{D_i}$​​，另一个是同态加密，由Paillier算法生成</li>
<li>传感车辆注册：当一个新的传感车辆$V_i$​注册时，TA分配给它一个独一无二的标识$Sid_{V_i}$​。然后TA选择随机数$r_i$​并用<code>Enc()</code>计算假名$Pid_{V_i}$​，同时，TA把密码对$(Sk_{V_i},Pk_{V_i})(Sk_{V_i}\in Z_n^*,Pk_{V_i}=Sk_{V_i}\cdot P_2)$​，并计算身份验认证$Cert_{V_i}$​</li>
</ol>
<p>车联网中有不同类型的车辆。我们可以根据不同的权力级别将其分为三类，分别表示为高级权力（HL）（例如执法车辆）、中级权力（如公共服务车辆）和低级权力（LL）（例如私人控制车辆）。针对这三种，TA对其初始化信誉评分$Rs_{V_i}^0$​时会有不同的值：高级是0.9，中级是0.5，低级是0.1。</p>
<p>精确的信誉评分会转化为信誉评级$Rl_{V_i}^0$，采用k匿名算法来避免信誉链接攻击，每个等级的SV数量至少是k个，具体的评级<sup><a href="#fn_1" id="reffn_1">1</a></sup>：</p>
<script type="math/tex; mode=display">
Rl_{V_i}^0=\left\{
\begin{aligned}
L_1=0,if\ \ 0<Rs_{V_i}^0<\frac{1}{n}\\
L_2=\frac{1}{n},if\ \ \frac{1}{n}<Rs_{V_i}^0<\frac{2}{n}\\
...\\
L_n=\frac{n-1}{n}, otherwise
\end{aligned}
\right.</script><p>最后，TA把$\{Sk_{V_i},Pk_{V_i},Cert_{V_i},Pid_{V_i},Rl_{V_i}^0\}$通过安全信道发给$V_i$。</p>
<h3 id="Sensing-task-assignment"><a href="#Sensing-task-assignment" class="headerlink" title="Sensing task assignment"></a>Sensing task assignment</h3><p>数据请求者$D_i$确定传感数据类型、任务序列号$Tid$、内容$m$、位置$L_m$、到期时间$T_m$和最小信誉等级要求$Rl$。</p>
<p>然后$D_i$​决定任务为$\{Tid,m,L_m,T_m,Rl\}$​并定义传感数据$d$​的标准值$d_0$​和错误值阈值$\Delta d$​。</p>
<p>最后，$D_i$把$m$​和同态加密公钥发送给云服务器。</p>
<p>云服务器验证$D_i$的身份公钥，如果没通过，则身份无效；如果通过，则云服务器向SV广播$\{Tid,T_m,T_{C_2},Rl\}$。</p>
<h3 id="Sensing-vehicle-selection"><a href="#Sensing-vehicle-selection" class="headerlink" title="Sensing vehicle selection"></a>Sensing vehicle selection</h3><p>收到任务的SV们如果想做任务，就发送自己的公钥、信誉评级、身份认证等给云服务器，云服务器经过一番验证，向通过验证的SV们发送$\{C_2,C_3,C_4,H(\vartheta_i)\}$，$H(\vartheta_i)$是用来标识该SV被选中了。</p>
<h3 id="Data-collection-and-processing"><a href="#Data-collection-and-processing" class="headerlink" title="Data collection and processing"></a>Data collection and processing</h3><p>收到传感任务内容的SV们对$\{C_2,C_3,C_4\}$进行解密，得到任务内容$m$，并完成任务得到传感数据$d_{V_i}$。为了实现数据隐私，每个SV对数据进行同态加密。</p>
<p>最后SV们把一系列参数上传云服务器。</p>
<p>云服务器首先检查参数中的时间参数，是否超过任务期限<sup><a href="#fn_2" id="reffn_2">2</a></sup>；其次检查$H(\vartheta_i)$​​是否存在；然后找任务对应的$D_i$获取标准值和错误值阈值，接着$D_i$就把经过一番加密的数据发送给云服务器。</p>
<p>由于传感数据、标准值、错误值阈值都是同态加密，所以云服务器直接对加密后的文本进行运算验证即可。云服务器将通过验证的传感数据聚合起来一起发给对应的$D_i$。</p>
<p>$D_i$用私钥解密得到聚合数据。</p>
<p>云服务器最后要根据传感数据计算信誉评分的反馈值，在错误值阈值范围内的就反馈1，否则反馈0.</p>
<blockquote id="fn_2">
<sup>2</sup>. 这里的问题是，如果时间参数是SV自己传的，那么如何保证是真实的而不是为了避免过期的假参数。<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<h3 id="Reputation-and-certificate-updating"><a href="#Reputation-and-certificate-updating" class="headerlink" title="Reputation and certificate updating"></a>Reputation and certificate updating</h3><p> 对于每个车辆$V_i$，TA根据反馈的报告更新其信誉评分和身份认证。反馈报告用连续随机变量X表示信誉评分，并用beta分布评估信誉评分。传感任务成功完成和失败分别用$F_{V_i}=1$和$F_{V_i}=0$来表示。</p>
<p>具体来说，TA收集$\omega$份$V_i$的反馈报告，其中$\omega_i$次成功，$\omega_j$次失败，因此TA用beta分布表示$V_i$的任务表现，分布式中的$\alpha$和$\beta$分别表示成功和失败的次数。由此可知，$V_i$的评分X服从beta分布，期望是$\frac{\alpha}{\alpha+\beta}$，具体评分$Rs_{V_i}=\frac{\alpha}{\alpha+\beta}=\frac{\omega_i}{\omega}$。</p>
<p>为了提升信誉评分的准确率，我们引入了遗忘因子$F_f\in [0,1]$和平衡权重$B_\omega$来减少时间和反馈错误对信誉评分的影响。</p>
<p>因此，最终的评分公式如下<sup><a href="#fn_3" id="reffn_3">3</a></sup>：</p>
<script type="math/tex; mode=display">
Rs_{V_i}^\omega=\frac{F_f\omega_{i-1}+B_\omega s_i}{(F_f\omega_{i-1}+B_\omega s_i)+(F_f\omega_{j-1}+B_\omega u_i)}</script><p>其中，$B_\omega=\frac{s_i}{s_i+u_i}$</p>
<blockquote id="fn_3">
<sup>3</sup>. 这里的问题是，首先这个公式中的s_i和u_i需要解释，虽然前面表格中有了，但这里也应该再说一下。其次这个公式整个都需要解释，比如\omega_{i-1}是表达什么，前一个车辆的成功次数吗？为什么这个车辆的评分会和前一个车辆发生关系？此外，上面这段话中，在车辆V_i那里，字母i表示对第i个车，而到了s_i和u_i的时候，就表示第i次反馈报告，这样的符号很容易引起混淆。<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<p>更新评分以后，TA把评分存到本地数据库并转成评级数，然后更新身份认证，更新过程也是和前面差不多的加密算法。</p>
<h3 id="Sensing-vehicle-revocation"><a href="#Sensing-vehicle-revocation" class="headerlink" title="Sensing vehicle revocation"></a>Sensing vehicle revocation</h3><p>TA计算车辆$V_i$的失败率，如果这个车辆的评分低且失败率高，就不再更新这个车的评分，相当于不允许接入了。<sup><a href="#fn_4" id="reffn_4">4</a></sup></p>
<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>这一部分是分析隐私和安全性问题，都是加密算法保障的，就不详细看了。</p>
<h2 id="Performance-evaluation"><a href="#Performance-evaluation" class="headerlink" title="Performance evaluation"></a>Performance evaluation</h2><p>分析了计算量和通信负担，评估了遗忘因子和平衡权重对评分更新算法的影响。</p>
<p>实验部分的问题有以下几点：</p>
<ol>
<li>没说实验环境和数据来源等；</li>
<li>实验中，参与者最多10个，这对于众包的场景不太合理；</li>
<li>实验展示了遗忘因子和平衡权重对评分的影响，但是没有说明原因，希望能补充解释这两个因素是如何影响评分的。</li>
</ol>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ol>
<li>提出了有效的匿名认证机制</li>
<li>提出了新的信誉评分系统，基于beta分布</li>
<li>分析了隐私和安全问题，并进行了模拟实验</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.zhihu.com/question/39641890" target="_blank" rel="noopener">双线性配对</a></li>
</ol>
<h2 id="审稿意见"><a href="#审稿意见" class="headerlink" title="审稿意见"></a>审稿意见</h2><ol>
<li>公式4中的n需要解释</li>
<li>有一些符号表达并没在表1中列出，建议补充完整</li>
<li>加上前面文中的一些问题，总的来说大修吧+</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>审稿意见</tag>
        <tag>crowdsourcing</tag>
        <tag>车联网</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode记录-3</title>
    <url>/2021/08/25/Leetcode%E8%AE%B0%E5%BD%95-3/</url>
    <content><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>从今天起，先跟着<a href="https://github.com/changgyhub/leetcode_101" target="_blank" rel="noopener">LeetCode 101</a>做题，首先是贪心算法。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode记录-2</title>
    <url>/2021/06/18/Leetcode%E8%AE%B0%E5%BD%95-2/</url>
    <content><![CDATA[<h1 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">链接</a></p>
<p>给你两个<strong>非空</strong>的链表，表示两个非负的整数。它们每位数字都是按照<strong>逆序</strong>的方式存储的，并且每个节点只能存储<strong>一位</strong>数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><p>每个链表中的节点数在范围 <code>[1, 100]</code> 内</p>
</li>
<li><p><code>0 &lt;= Node.val &lt;= 9</code></p>
</li>
<li><p>题目数据保证列表表示的数字不含前导零</p>
</li>
</ol>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode* l3 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* p = l3;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> l1val;</span><br><span class="line">            <span class="keyword">int</span> l2val;</span><br><span class="line">            <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l1val = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                l1val = l1-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l2val = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                l2val = l2-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = l1val+l2val;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i = <span class="number">1</span>;</span><br><span class="line">                tmp = tmp%<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* q = <span class="keyword">new</span> ListNode(tmp);</span><br><span class="line">            p-&gt;next = q;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l3-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><ol>
<li>要注意空指针，无论是取值还是往下一个节点移动都要判断是否是空指针；</li>
<li>这里的<code>if else</code>语句其实可以用三目运算符简写成一行；</li>
<li>这个题并不能把链表转数字加起来求和再转链表，因为输入的参数会超出数字长度；</li>
<li>链表本质上是指针+结构体的组合，现在我觉得我又会写链表了！</li>
</ol>
<h2 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h2><p><a href="https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode-solution/" target="_blank" rel="noopener">参考链接</a></p>
<ol>
<li><p>相同思路但写法简单一些</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode root = new ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cursor = root;</span><br><span class="line">        int carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != null || l2 != null || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            int l1Val = l1 != null ? l1.val : 0;</span><br><span class="line">            int l2Val = l2 != null ? l2.val : 0;</span><br><span class="line">            int sumVal = l1Val + l2Val + carry;</span><br><span class="line">            carry = sumVal / <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            ListNode sumNode = new ListNode(sumVal % <span class="number">10</span>);</span><br><span class="line">            cursor.next = sumNode;</span><br><span class="line">            cursor = sumNode;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(l1 != null) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != null) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更短的写法，这个写法很巧妙</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode dummyHead = new ListNode(<span class="number">-1</span>), pre = dummyHead;</span><br><span class="line">        int t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != null || l2 != null || t != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1 != null) &#123;</span><br><span class="line">                t += l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != null) &#123;</span><br><span class="line">                t += l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next = new ListNode(t % <span class="number">10</span>);</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Online Organizing Large-scale Heterogeneous Tasks and Multi-skilled Participants in Mobile Crowdsensing</title>
    <url>/2021/05/26/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Online%20Organizing%20Large-scale%20Heterogeneous%20Tasks%20and%20Multi-skilled%20Participants%20in%20Mobile%20Crowdsensing/</url>
    <content><![CDATA[<h1 id="Online-Organizing-Large-scale-Heterogeneous-Tasks-and-Multi-skilled-Participants-in-Mobile-Crowdsensing"><a href="#Online-Organizing-Large-scale-Heterogeneous-Tasks-and-Multi-skilled-Participants-in-Mobile-Crowdsensing" class="headerlink" title="Online Organizing Large-scale Heterogeneous Tasks and Multi-skilled Participants in Mobile Crowdsensing"></a>Online Organizing Large-scale Heterogeneous Tasks and Multi-skilled Participants in Mobile Crowdsensing</h1><p>是TMC的审稿。</p>
<a id="more"></a>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>目的：在线收集大规模异构任务和多技能参与者</p>
<p>方法：层次树和时间序列</p>
<p>内容：计算模式、树的创建方法和任务分配策略</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>场景：多技能参与者的在线众包平台上实时分配大规模异构任务</p>
<p>面临的问题：</p>
<ol>
<li>丰富的技能类型。技能类型太多，甚至需要一些领域的专业知识才能合理分类，平台应该如何处理。</li>
<li>不规则的任务时空要求。</li>
<li>多任务时空重叠。针对相同内容的任务，平台可以去除冗余；不同内容的任务，平台分给同一个workers可以减少其移动成本。</li>
<li>参与者和任务的动态性。任务和参与者随时到达或者离开平台。考虑参与者接了任务却没完成就离线的情况。任务一旦被分配了就不能被删除。</li>
<li>多技能参与者。</li>
<li>参与感知和机会感知。两种类型的参与者都应该能参与进来。</li>
<li>点推荐和轨迹推荐。两种任务推荐算法共存。</li>
</ol>
<p>现有文献主要在线多任务分配问题的不同方面提出了具体解决方案：</p>
<ol>
<li>针对即时任务分配问题，提出了基于贪婪的任务分配算法</li>
<li>针对时空异构任务分配，提出了分布式参与者选择框架</li>
<li>在任务动态异构的场景，考虑任务成本和能力等约束，选择能满足任务需求的最少数量的参与者</li>
<li>自组织移动众包框架，任务提供者可以主动、实时地向周围的移动参与者发布任务，从而快速获取高质量的传感数据。</li>
<li>两阶段任务分配框架，将机会感知和参与感知的优势结合起来。</li>
<li>多时空约束（包括任务位置、时间窗口、参与者轨迹等）的任务分配问题</li>
<li>不同预算的多任务，满足信息质量需求，考虑不同参与者的激励需求、传感能力和移动性。</li>
</ol>
<p>上述解决方案的问题：没能同时解决这些问题</p>
<p>存在这一问题的原因：数据结构过于简单</p>
<p>本文方案：</p>
<ol>
<li>原子化时间和空间——处理不规则时空问题，简化多任务时空重叠问题</li>
<li>将异构任务划分为原子任务，使用层次树进行组织——包括技能层、时间层、空间层和原子化任务层（叶节点），技能是需求驱动的，并不提前列出所有技能。技能层、时间层和空间层是可扩展、自适应的。</li>
<li>使用时间序列组织动态参与者，将空间、时间和技能约束等封装，根据时间限制加入队列，参与感知和机会感知都可以，点推荐和轨迹推荐共存。</li>
<li>综合上述，得到在线大规模异构任务分配算法。</li>
</ol>
<p>本文贡献：</p>
<ol>
<li>第一个研究这个的</li>
<li>两个数据结构结合</li>
<li>实验表明了有效性</li>
</ol>
<p>本文组织结构：略</p>
<h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p>单任务场景：</p>
<p>多任务场景：</p>
<p>数据结构相关：</p>
<h2 id="3-Methodology"><a href="#3-Methodology" class="headerlink" title="3. Methodology"></a>3. Methodology</h2><p>平台架构：</p>
<ol>
<li>资源层：包括任务池和参与者池。任务发布者完善任务内容和技能类型。</li>
<li>数据结构和算法层：包括原子化任务、任务层次树、参与者时间序列队列和任务分配算法。首先，根据任务的技能、时间和空间对任务进行原子化处理；其次把原子化的任务根据技能时间和空间属性插入层次树中；同时封装所有参与者的属性并基于时间属性更新到时间序列队列中；最后根据时间序列队列和层次树进行匹配，输出结果。</li>
<li>输出层：任务成功执行，则返回传感数据；任务失败，如果没到ddl，就加入任务池变成新的任务；如果到了ddl，就删了并返回失败结果。</li>
</ol>
<h3 id="3-1-Atomized-tasks"><a href="#3-1-Atomized-tasks" class="headerlink" title="3.1 Atomized tasks"></a>3.1 Atomized tasks</h3><p>把任务按技能、空间、时间进行原子化处理，技能的原子化是按任务发布者所确定的技能数据库来做，空间和时间原子化是考虑具体场景，比如时间按一分钟划分、空间按一平米划分等。具体来说可以参考下图的任务划分。</p>
<p><img src="https://i.loli.net/2021/05/27/iaSz6o5dOTYZkVl.png" alt="image-20210527143503549"></p>
<h3 id="3-2-Task-hierarchy-tree"><a href="#3-2-Task-hierarchy-tree" class="headerlink" title="3.2 Task hierarchy tree"></a>3.2 Task hierarchy tree</h3><h4 id="3-2-1-Create-task-hierarchy-tree"><a href="#3-2-1-Create-task-hierarchy-tree" class="headerlink" title="3.2.1 Create task hierarchy tree"></a>3.2.1 Create task hierarchy tree</h4><p>任务的层次树有4层：技能层、时间层、空间层、原子任务层（叶节点）</p>
<p>技能层并不提前列好所有技能，而是需求驱动</p>
<p>前面那个图中原子任务们对应的层次树生成过程如下图所示：</p>
<p><img src="https://i.loli.net/2021/05/27/6suQJanpBrbPUxH.png" alt="image-20210527143832471"></p>
<p>具体来说，就是从根节点出发，在第一层找对应的技能节点，接着找对应的时间和空间节点，最后把这个任务放到对应的叶节点上。这中间如果没查到节点，就直接新建。</p>
<h4 id="3-2-2-Creation-methods-of-the-task-hierarchy-tree"><a href="#3-2-2-Creation-methods-of-the-task-hierarchy-tree" class="headerlink" title="3.2.2 Creation methods of the task hierarchy tree"></a>3.2.2 Creation methods of the task hierarchy tree</h4><p>层次树两种建立方式：空间优先和时间优先。具体来说如下图所示：</p>
<p><img src="https://i.loli.net/2021/05/27/kKPF9WLUujsOrSM.png" alt="image-20210527144407143"></p>
<h4 id="3-2-3-Computing-pattern-of-task-allocation"><a href="#3-2-3-Computing-pattern-of-task-allocation" class="headerlink" title="3.2.3 Computing pattern of task allocation"></a>3.2.3 Computing pattern of task allocation</h4><p>两种计算方式：串行和并行，串行效率低，并行要考虑任务分配的互斥锁。</p>
<p>通过多核处理器实现并行：按技能将分层树分成多个子树，这样多个参与者可以遍历不同的子树，实现并行计算。</p>
<p>具体来说，选参与者的时候会避免技能重复，比如选好第一参与者之后，第二个参与者若有相同的技能，就会跳过去看第三个参与者。这样最后选出来的参与者就都是技能不重复的，每人得到一颗子树及其原子任务们。</p>
<p>分给同一个参与者的多个子树要进行合并，即：把相同的时间和空间节点合并成一个节点。具体如下图：</p>
<p><img src="https://i.loli.net/2021/05/27/Fy4rhoamwisuq2P.png" alt="image-20210527150457291"></p>
<h3 id="3-3-Participant-time-series-queue"><a href="#3-3-Participant-time-series-queue" class="headerlink" title="3.3 Participant time-series queue"></a>3.3 Participant time-series queue</h3><p>参与者有7个属性：参与者ID、当前时间、当前位置、目的地、到达目的地的容忍时间、移动速度、技能向量。</p>
<p>根据当前时间将参与者依次加入到时间序列队列中。更新时间序列的过程如下图：</p>
<p><img src="https://i.loli.net/2021/06/01/vUGhYEMTJwiqNCr.png" alt="image-20210601103602834"></p>
<p>具体来说，就是根据<code>current time</code>把参与者排成队列，新来的插进去，分配好任务后把<code>current time</code>改成执行任务结束后的时间，无任务的节点从序列中删去。对于点推荐的任务，就把它分给任务要求时间与<code>current time</code>完全一致的参与者；而对于轨迹推荐的任务，就把它分给时间序列队列中的所有参与者，直到队列空了。</p>
<p>这个图和论文里的文字描述看起来没对应上，主要存在以下问题：</p>
<ol>
<li>对这个图的文字描述里写的是参与者$tf_6$和$tf_7$，而图里出现的是$tf_6$和$tf_5$，这肯定有一个错了；</li>
<li>文字描述里是先把$tf_6$的<code>current time</code>调到<code>10:08</code>，然后再因为$tf_1$没有任务而删除它，图里这俩过程反过来了；</li>
<li>图中第4行和第6行出现了$U_6$和$U_7$两个符号是什么含义，与其他参与者有什么区别？这需要在文字说明部分加以解释。</li>
</ol>
<h3 id="3-4-Task-allocation-algorithm"><a href="#3-4-Task-allocation-algorithm" class="headerlink" title="3.4 Task allocation algorithm"></a>3.4 Task allocation algorithm</h3><p>任务分配约束：</p>
<ol>
<li>参与者技能是否满足任务对技能的需求；</li>
<li>参与者是否能及时赶到任务执行地点；</li>
<li>执行任务是否会导致参与者无法准时到达自己的目的地；</li>
<li>任务地点是否会让参与者离自己的目的地越来越远。</li>
</ol>
<p>任务分配四步：技能匹配、时空匹配、分配策略、参与者更新。这四步如图所示：</p>
<p><img src="https://i.loli.net/2021/06/01/WQcLDaMinhOsIk9.png" alt="image-20210601104812332"></p>
<p>具体来说，首先判定一番，发现$l_4$会让参与者无法按时到目的地，所以排除；$l_1$会让参与者离目的地更远（从5变成5.4），所以排除；$l_2$和$l_3$都可，且此时这俩位置都只有1个任务，在短距离优先的情况下就分配$l_2$了。</p>
<p>任务树采用深度优先遍历的方式。</p>
<h3 id="3-5-Method-summary"><a href="#3-5-Method-summary" class="headerlink" title="3.5 Method summary"></a>3.5 Method summary</h3><p>这部分总结了一下，没啥能说的。</p>
<h2 id="4-Evaluation"><a href="#4-Evaluation" class="headerlink" title="4. Evaluation"></a>4. Evaluation</h2><h3 id="4-1-Data-set"><a href="#4-1-Data-set" class="headerlink" title="4.1 Data set"></a>4.1 Data set</h3><p>两个前提：</p>
<ol>
<li>参与者随时能离线，即便他接了任务没做（这种情况下平台进行任务再分配）；</li>
<li>任务仅能由发布者删除，任务一旦被分配则不能被删除。</li>
</ol>
<p>任务描述：<code>Task={task content, required skill, execution area, execution time period, upload time, deletion time}</code></p>
<p>参与者描述：<code>Participant={participant ID, current time, current location, destination, tolerable time to reach the destination, moving speed, skill vector, and offline time}</code></p>
<p>数据集：将<code>10KM*10KM</code>区域均匀划分为<code>100*100</code>的方格，将<code>60min</code>均匀分为<code>60</code>个时刻，即：时空最小单位是$0.01KM^2/min$</p>
<p>所有参与者和任务根据以下要求随机生成：</p>
<ol>
<li>任务执行区域是具有任何形状的连续区域，其大小不超过$1KM^2$;</li>
<li>任务执行时间是任意长度的连续时间段，长度不超过5分钟；</li>
<li>任务删除时间比任务刷新时间长；</li>
<li>参与者能容忍的到达目的地时间会根据从当前位置到目的地位置的最短时间而随机增加；</li>
<li>参与者最高移动速度不超过<code>1KM/min</code>，最低速度不低于<code>0.5KM/min</code>；（这个速度设置不太合理，没考虑不同交通工具等）</li>
<li>参与者至少1个技能，至多5个技能；</li>
<li>参与者离线时间比当前时间晚；</li>
<li>假设有3种参与者分布：均匀分布、高斯分布（均值50，标准差18）、Check-in分布。任务分布采用均匀分布。</li>
</ol>
<p>由此得到7组数据。（这里的check-in分布没查到，不知道是什么含义）</p>
<h3 id="4-2-Comparison-aspects-and-evaluation-indicators"><a href="#4-2-Comparison-aspects-and-evaluation-indicators" class="headerlink" title="4.2 Comparison aspects and evaluation indicators"></a>4.2 Comparison aspects and evaluation indicators</h3><p>比较3方面：</p>
<ol>
<li>计算模式：串行和并行</li>
<li>任务树建立方式：空间优先和时间优先</li>
<li>任务分配策略：无策略和短距离优先原则</li>
</ol>
<p>关注4个评价指标：</p>
<ol>
<li>算法执行时间</li>
<li>任务和参与者匹配率</li>
<li>参与者行动距离</li>
<li>冗余任务移除</li>
</ol>
<h3 id="4-3-Experiment-Results"><a href="#4-3-Experiment-Results" class="headerlink" title="4.3 Experiment Results"></a>4.3 Experiment Results</h3><p>比较了：</p>
<ol>
<li>不同任务数、参与者数、任务内容、技能类型条件下的效果</li>
<li>参与感知和机会感知、点推荐和轨迹推荐的效果</li>
<li>不同参与者分布下的效果</li>
</ol>
<p>实验图表数据就不列了，都是进行数据对比分析。</p>
<p>总结如下：</p>
<ol>
<li>并行计算能节省算法运行时间；</li>
<li>时间优先的层次树建立方法比空间优先的要更能增加任务和参与者的匹配率；</li>
<li>增加短距离优先原则能减少参与者的行动距离；</li>
<li>任务内容重复率越高，冗余任务去除越多（这不是废话吗）。</li>
</ol>
<h3 id="4-4-Analysis-and-Discussion"><a href="#4-4-Analysis-and-Discussion" class="headerlink" title="4.4 Analysis and Discussion"></a>4.4 Analysis and Discussion</h3><p>前面所说的1和3都很显然，这里分析2的原因。</p>
<p>时间优先的层次树在时间节点那一层是单调增排序的，也就是说时间较早的会先被检索到进而匹配，这样参与者在匹配完该任务后还能继续匹配时间更晚一些的任务；而在空间优先的层次树中，参与者可能会先被匹配到时间较晚的任务，接着其<code>current time</code>就被刷新到更晚，从而无法匹配时间较早的任务了。</p>
<h2 id="5-Conclusion-and-future-work"><a href="#5-Conclusion-and-future-work" class="headerlink" title="5. Conclusion and future work"></a>5. Conclusion and future work</h2><p>在线收集大规模异构任务和多技能参与者可以使任务和参与者实时共享。然而，这将使任务分配非常困难。我们总结了在线收集对任务分配平台的七个要求。它们包括丰富的技能类型、任务的不规则时空要求、多任务的时空重叠、任务和参与者的动力学、多技能参与者、参与式感知和机会主义感知、点推荐和轨迹推荐。为了满足这七个要求，我们设计了一种基于层次树的任务组织方法和一种基于时间序列队列的参与组织方法。基于任务层次树和参与时间序列队列，从计算模式、树生成方法和任务分配策略三个方面研究了任务分配问题。在计算模式上，我们比较了串行计算和并行计算。在树的创建方法中，我们首先比较空间和时间。在任务分配策略中，我们增加了短距离优先原则。最后，对算法运行时间、任务参与者匹配率、参与者行程距离和去除冗余任务四个指标进行了详细的实验评价。实验结果表明，基于任务层次树和参与时间序列队列的任务分配算法能够有效地满足这七个要求。在实验环境中，与串行计算相比，并行计算可以平均减少算法运行时间66.00% 以上。与空间优先相比，时间优先平均可使任务参与者匹配率提高13.00% 以上。增加短距离优先原则可以平均减少参与者出行距离4.00%  以上。</p>
<p>今后还有许多问题需要解决。首先，在进行时空匹配时，我们假设参与者的旅行时间可以被精确估计。然而，即使使用最好的商业地图，也不能准确地估计旅行时间。在这种情况下，如何实现任务分配？我们的想法是，我们可以返回任务的一个周期时间和一个区域，而不是一个时空点。其次，当前树的划分仅根据技能层进行。是否有可能在时间和空间层进一步划分树？我们认为这是可行的。在计算资源充足的情况下，应进一步减少算法运行时间，但效果可能不明显。因为在技能层分割后，树的尺寸并不大。第三，任务不仅具有技能、时间、空间三个属性，而且还具有主题属性，这三个属性对应着参与者的偏好。任务层次树是否可以添加主题属性并考虑参与者的首选项？我们认为这是可行的。在添加了主题属性之后，树的层数从4层改为5层。此外，考虑参与者的偏好会导致任务与参与者之间的概率匹配问题。任务分配问题的复杂性将进一步增加。</p>
<h2 id="审稿意见部分"><a href="#审稿意见部分" class="headerlink" title="审稿意见部分"></a>审稿意见部分</h2><p>本文认为当前针对在线多任务分配问题的诸多解决方案无法同时解决不同的问题，其原因在于它们采用的数据结构过于简单，针对这一点本文提出了基于层次树的任务组织模式和基于时间序列队列的参与者组织模式，并在此基础上设计了任务分配算法。针对不同的计算模式、任务树建立方式和任务分配策略，本文采用随机生成的数据集进行了仿真实验分析，根据算法运行时间、任务参与者匹配率、参与者行程距离和去除冗余任务这四个指标对算法性能进行评估，从而得出结论：并行计算能够减少算法运行时间；时间优先的层次树能提高任务和参与者的匹配率；增加短距离优先原则可以减少参与者出行距离。</p>
<p>strength:</p>
<ol>
<li>作者清晰地阐述了本文的主要思想，完成了研究工作，包括详细的性能分析；</li>
<li>本文从数据结构的角度入手分析在线多任务分配问题，并提出了基于层次树和时间序列队列的任务分配算法，有一定创新性；</li>
<li>本文对算法思想的描述十分详细，图表清晰地解释了算法过程和实验数据，有利于读者阅读论文；</li>
<li>本文考虑了点推荐和轨迹推荐的任务分配模式以及参与感知和机会感知的参与者行为模式，更贴近真实场景。</li>
</ol>
<p>weakness:</p>
<ol>
<li>图10中存在下列问题：<ol>
<li>对这个图的文字描述里写的是参与者$tf_6$和$tf_7$，而图里出现的是$tf_6$和$tf_5$，这两处表达需要统一；</li>
<li>文字描述里是先把$tf_6$的<code>current time</code>调到<code>10:08</code>，然后再因为$tf_1$没有任务而删除它，图里这俩过程反过来了；</li>
<li>图中第4行和第6行出现了$U_6$和$U_7$两个符号是什么含义，与其他参与者有什么区别？这需要在文字说明部分加以解释。</li>
</ol>
</li>
<li>实验部分中提到的check-in分布是否可以增加具体的介绍？</li>
<li>本文实验部分假设参与者最高移动速度不超过<code>1KM/min</code>，最低速度不低于<code>0.5KM/min</code>，这个速度设置主要是汽车的速度范围，没有考虑其他交通方式如步行、骑行等，如果可以放宽速度限制范围，会更合理一些；</li>
<li>本文实验部分如果可以增加与现有算法的性能简要对比，会更有说服力。</li>
</ol>
<p>英文版本：</p>
<p>This paper argues that many current solutions to online multi-task  assignment problems can not solve different problems at the same time.  And the reason is that the data structures they used are too simple to solve these problems. This paper proposes a task organization model based  on hierarchical tree and a participant organization model based on time series queue, and designs a task allocation algorithm. According to  different computing patterns, tree creation methods and task allocation strategy, this paper uses randomly generated data set to carry out  simulation experiment analysis. The performance of the algorithm is evaluated according to four indexes: algorithm running time, task participant matching rate, participant travel distance and redundant tasks removed.  It is concluded that  parallel computing can reduce the running time of the algorithm;  time-first hierarchical tree can improve the matching rate of tasks and  participants, and short-distance-first principle can reduce the travel  distance of participants.</p>
<p>strength:</p>
<ol>
<li>The main idea of this paper is described clearly and the research work is complete, containing detailed performance analysis.</li>
<li>This paper analyzes the problem of online multi-task assignment from the perspective of data structure, and proposes a task assignment algorithm based on hierarchical tree and time series queue, which is innovative to some extent.</li>
<li>In this paper, the algorithm idea is described in detail, and the figures clearly explain the algorithm process and experimental data, which are very helpful for readers to understand this paper.</li>
<li>This paper considers different participant distributions, different sensing methods(i.e. participatory sensing and opportunistic sensing), and different recommendation methods(i.e. point recommendation and trajectory recommendation), which is closer to the real scene.</li>
</ol>
<p>weakness:</p>
<ol>
<li>In Fig. 10,  participants tf_6 and ​tf_7 are written in the corresponding text description(Page 8, line 54, right column), while ​tf_6 and tf_5 appear in the figure. These two  expressions need to be unified.</li>
<li>In the text  description, change the current time of tf_6 to 10:08 first, then delete tf_1  from time-series queue. But the two processes are reversed in Fig.10. Picture content and text description should be unified.</li>
<li>What do the u_6 and u_7  in Fig. 10 mean and how are they different from the other participants? This needs to be explained in the paper.</li>
<li>What is the specific form of the check-in distribution mentioned in Section 4?</li>
<li>The experimental part of this paper assumes that “The maximum moving speed of participants does not exceed 1KM/min, and the minimum moving speed is not lower than 0.5KM/min.” This speed limit is  mainly the speed range of cars, did not consider other modes of  transport such as walking, cycling. If the speed limit can be relaxed,  it will be more reasonable.</li>
<li>The evaluation part will be more convincing if it can be compared with the performance of existing algorithms.</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>审稿意见</tag>
        <tag>crowdsourcing</tag>
      </tags>
  </entry>
  <entry>
    <title>Github项目数据统计</title>
    <url>/2021/04/30/Github%E9%A1%B9%E7%9B%AE%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="Github项目数据统计"><a href="#Github项目数据统计" class="headerlink" title="Github项目数据统计"></a>Github项目数据统计</h1><p>​      由于需要统计Dapp项目的发展历程数据，在查资料时看到了<a href="https://zhuanlan.zhihu.com/p/32759663" target="_blank" rel="noopener">以太坊 Dapp 调研</a>，这份统计只包含了2017年12月20日及之前的数据，而现在已经是2021年了，因此我模仿这个进行了新的统计。</p>
<a id="more"></a>
<h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p>经过一系列学习，我终于掌握了GitHub api的基础使用。简单来说，我们可以通过访问api接口进行查询并获取数据。通过关键字dapp进行查询的api是<code>https://api.github.com/search/repositories?q=dapp</code>，用浏览器直接打开这个链接可以看到如下图的内容：</p>
<p><img src="https://i.loli.net/2021/04/30/nXQsavbDH98PJxc.png" alt="image-20210430103142883"></p>
<p>第一行的<code>total_count</code>是所有结果的总数，接下来有30个<code>items</code>，每一个都是对应的项目，点开第一个可以看到其数据格式为：</p>
<p><img src="https://i.loli.net/2021/04/30/qNL3xuYcrlByVbW.png" alt="image-20210430103308097"></p>
<p>图中显示的内容并不完整，还有很多信息比如stars数量等都可以直接获取。</p>
<p>但是总共有19930个项目，却只获取到30个，这显然是不够的，想获取更多项目就需要修改api的内容，改成<code>https://api.github.com/search/repositories?q=dapp&amp;page=1&amp;per_page=100</code>，修改后就可以获取到100条项目信息了，这是每页项目数的上限，将api中的<code>page=1</code>改成<code>page=2</code>即可得到新的100条信息，然而由于api限制，通过这样的方法最多可以获取1000条（即<code>page=10</code>），超过1000条后会有报错信息。为了能获取到更多项目，我们需要对访问查询作出限制，使得每次查询结果都不超过1000条，然后将多次查询结果合并起来得到完整结果，例如仅查找创建于2021年1月至2月的项目数，这样就可以得到1000条以内的结果，再逐页访问即可。限制时间的api为：<code>https://api.github.com/search/repositories?q=dapp+created:2021-04-01T00:00:00..2021-05-01&amp;page=1&amp;per_page=100</code>，这个api可以获取创建时间在2021年4月1日至5月1日的所有项目数据，如果要获取其他时间范围，对api中的时间进行修改即可，可以精确到秒；如果时间限制是早于或晚于某个时间点，则写成<code>created:&gt;=2021-04-01T00:00:00</code>，大于等于符号可以改成小于等于或者大于或者小于。如果想限制其他字段，比如更新时间，则把created修改为updated即可。</p>
<p>具体到写python代码时，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> github3 <span class="keyword">import</span> login, GitHub</span><br><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    result = requests.get(<span class="string">"https://api.github.com/search/repositories?q=dapp+created:2021-04-01T00:00:00..2021-05-01&amp;page=6&amp;per_page=100"</span>)</span><br><span class="line">    response_dict = result.json()</span><br><span class="line">    repo_dicts = response_dict[<span class="string">'items'</span>]</span><br><span class="line">    print(<span class="string">"Toal repositories:"</span>, response_dict[<span class="string">'total_count'</span>])</span><br><span class="line">    print(<span class="string">"Repositories returned:"</span>, len(repo_dicts))</span><br><span class="line">    keys = &#123;<span class="string">'id'</span>,<span class="string">'full_name'</span>,<span class="string">'html_url'</span>,<span class="string">'commits_url'</span>,<span class="string">'language'</span>,<span class="string">'description'</span>,<span class="string">'forks_count'</span>,<span class="string">'stargazers_count'</span>,<span class="string">'watchers_count'</span>,<span class="string">'created_at'</span>,<span class="string">'pushed_at'</span>,<span class="string">'updated_at'</span>&#125;</span><br><span class="line">    save_dicts = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> repo_dicts:</span><br><span class="line">        j = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> i.items() <span class="keyword">if</span> key <span class="keyword">in</span> keys&#125;</span><br><span class="line">        save_dicts.append(j)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'test.csv'</span>, <span class="string">'a+'</span>, newline=<span class="string">''</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f: </span><br><span class="line">        fieldnames = [<span class="string">'id'</span>,<span class="string">'full_name'</span>,<span class="string">'html_url'</span>,<span class="string">'commits_url'</span>,<span class="string">'language'</span>,<span class="string">'description'</span>,<span class="string">'forks_count'</span>,<span class="string">'stargazers_count'</span>,<span class="string">'watchers_count'</span>,<span class="string">'created_at'</span>,<span class="string">'pushed_at'</span>,<span class="string">'updated_at'</span>]</span><br><span class="line">        writer = csv.DictWriter(f,fieldnames=fieldnames)</span><br><span class="line">        <span class="comment">#writer.writeheader()</span></span><br><span class="line">        writer.writerows(save_dicts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>这段代码<code>import</code>的一些包其实没有用到，是最初学着写的时候都引入了，之后没删。</p>
<p>代码第9行使用<code>requests.get()</code>获取api的数据，接着使用<code>.json()</code>将它转为字典。这个字典的<code>total_count</code>项就是前面图中显示的项目总数，这里我们没有用到；字典的<code>items</code>项则是我们需要的项目列表，将它单独存到<code>repo_dicts</code>，显然获取的项目列表数并不等于项目总数。</p>
<p>接下来把这次数据处理所需要的字段写到<code>keys</code>中，从<code>repo_dicts</code>中提取这些列的内容存到新列表<code>save_dicts</code>中，再将这些数据保存到csv文件里。这个提取数据并保存的过程应该有更简练的代码写法，我懒得改了就这样吧。</p>
<p>最终得到的csv文件如下图所示：</p>
<p><img src="https://i.loli.net/2021/04/30/YIcsFzMrN1Cb93l.png" alt="image-20210430105338111"></p>
<p>这个数据总量比api那里的总量要多一些，显然是有重复的，因此要进行去重，我们选择把相同id的条目删了，只保留一个。excel本身就有去重的功能，在python里用pandas也可以，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    frame=pd.read_csv(<span class="string">'test.csv'</span>,engine=<span class="string">'python'</span>)</span><br><span class="line">    data = frame.drop_duplicates(subset=[<span class="string">'id'</span>], keep=<span class="string">'first'</span>, inplace=<span class="literal">False</span>)</span><br><span class="line">    data.to_csv(<span class="string">'newtest.csv'</span>, encoding=<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>这样就得到了一份到目前为止所有和dapp相关的项目表。</p>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>接下来要对所有数据进行分析统计。我们要做的图表如下：</p>
<ol>
<li>每月新Dapp项目数量分布</li>
<li>项目创建及更新时间分布</li>
<li>项目语言分布</li>
</ol>
<p>第3个最简单，我们先看它。</p>
<h3 id="项目语言分布"><a href="#项目语言分布" class="headerlink" title="项目语言分布"></a>项目语言分布</h3><p>从csv文件读入数据后，按<code>language</code>列进行数量统计即可，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import csv</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">pd.set_option(&#39;display.max_rows&#39;,None)</span><br><span class="line">pd.set_option(&#39;display.max_columns&#39;, None)</span><br><span class="line">pd.set_option(&#39;display.width&#39;, 1000)</span><br><span class="line">pd.set_option(&#39;display.max_colwidth&#39;, 1000)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    frame&#x3D;pd.read_csv(&#39;newtest.csv&#39;,engine&#x3D;&#39;python&#39;)</span><br><span class="line">    df1 &#x3D; frame.language.value_counts()</span><br><span class="line">    print(df1)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">JavaScript           <span class="number">10018</span></span><br><span class="line">C<span class="comment">#                    2087</span></span><br><span class="line">HTML                  <span class="number">1019</span></span><br><span class="line">TypeScript             <span class="number">806</span></span><br><span class="line">CSS                    <span class="number">376</span></span><br><span class="line">Solidity               <span class="number">336</span></span><br><span class="line">Vue                    <span class="number">335</span></span><br><span class="line">Java                   <span class="number">295</span></span><br><span class="line">Python                 <span class="number">256</span></span><br><span class="line">Shell                  <span class="number">139</span></span><br><span class="line">Go                     <span class="number">133</span></span><br><span class="line">C++                    <span class="number">120</span></span><br><span class="line">Dockerfile              <span class="number">72</span></span><br><span class="line">PHP                     <span class="number">65</span></span><br><span class="line">Kotlin                  <span class="number">54</span></span><br><span class="line">Ruby                    <span class="number">52</span></span><br><span class="line">Swift                   <span class="number">49</span></span><br><span class="line">Dart                    <span class="number">37</span></span><br><span class="line">Rust                    <span class="number">34</span></span><br><span class="line">Objective-C             <span class="number">30</span></span><br><span class="line">Jupyter Notebook        <span class="number">30</span></span><br><span class="line">C                       <span class="number">25</span></span><br><span class="line">Makefile                <span class="number">24</span></span><br><span class="line">WebAssembly             <span class="number">22</span></span><br><span class="line">TSQL                    <span class="number">19</span></span><br><span class="line">SCSS                    <span class="number">17</span></span><br><span class="line">PowerShell              <span class="number">10</span></span><br><span class="line">F<span class="comment">#                      10</span></span><br><span class="line">TeX                      <span class="number">9</span></span><br><span class="line">Perl                     <span class="number">8</span></span><br><span class="line">Clojure                  <span class="number">8</span></span><br><span class="line">Haskell                  <span class="number">7</span></span><br><span class="line">R                        <span class="number">7</span></span><br><span class="line">Svelte                   <span class="number">6</span></span><br><span class="line">CoffeeScript             <span class="number">6</span></span><br><span class="line">Scala                    <span class="number">6</span></span><br><span class="line">Nix                      <span class="number">5</span></span><br><span class="line">Visual Basic             <span class="number">5</span></span><br><span class="line">Visual Basic .NET        <span class="number">5</span></span><br><span class="line">D                        <span class="number">4</span></span><br><span class="line">Elm                      <span class="number">4</span></span><br><span class="line">Smarty                   <span class="number">3</span></span><br><span class="line">Elixir                   <span class="number">3</span></span><br><span class="line">GLSL                     <span class="number">3</span></span><br><span class="line">ASP                      <span class="number">3</span></span><br><span class="line">HCL                      <span class="number">3</span></span><br><span class="line">PLpgSQL                  <span class="number">2</span></span><br><span class="line">ShaderLab                <span class="number">2</span></span><br><span class="line">OCaml                    <span class="number">2</span></span><br><span class="line">Logos                    <span class="number">2</span></span><br><span class="line">Blade                    <span class="number">2</span></span><br><span class="line">Roff                     <span class="number">2</span></span><br><span class="line">LiveScript               <span class="number">2</span></span><br><span class="line">Hack                     <span class="number">2</span></span><br><span class="line">PLSQL                    <span class="number">2</span></span><br><span class="line">Sass                     <span class="number">1</span></span><br><span class="line">ECL                      <span class="number">1</span></span><br><span class="line">GDScript                 <span class="number">1</span></span><br><span class="line">NSIS                     <span class="number">1</span></span><br><span class="line">Stata                    <span class="number">1</span></span><br><span class="line">CMake                    <span class="number">1</span></span><br><span class="line">MATLAB                   <span class="number">1</span></span><br><span class="line">EJS                      <span class="number">1</span></span><br><span class="line">Twig                     <span class="number">1</span></span><br><span class="line">QML                      <span class="number">1</span></span><br><span class="line">XML                      <span class="number">1</span></span><br><span class="line">Batchfile                <span class="number">1</span></span><br><span class="line">Crystal                  <span class="number">1</span></span><br><span class="line">Apex                     <span class="number">1</span></span><br><span class="line">Emacs Lisp               <span class="number">1</span></span><br><span class="line">Lua                      <span class="number">1</span></span><br><span class="line">Racket                   <span class="number">1</span></span><br><span class="line">VimL                     <span class="number">1</span></span><br><span class="line">Handlebars               <span class="number">1</span></span><br><span class="line"><span class="number">4</span>D                       <span class="number">1</span></span><br><span class="line">PureScript               <span class="number">1</span></span><br><span class="line">Pascal                   <span class="number">1</span></span><br><span class="line">Io                       <span class="number">1</span></span><br><span class="line">Assembly                 <span class="number">1</span></span><br><span class="line">Name: language, dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="每月新增Dapp项目数量分布"><a href="#每月新增Dapp项目数量分布" class="headerlink" title="每月新增Dapp项目数量分布"></a>每月新增Dapp项目数量分布</h3><p>从csv文件读入数据后，访问<code>created_at</code>这一列并截取其前7位，即可得到每个项目的创建年月，统计每个月创建的项目数量即可得到数据结果，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">pd.set_option(<span class="string">'display.max_rows'</span>,<span class="literal">None</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.max_columns'</span>, <span class="literal">None</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.width'</span>, <span class="number">1000</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.max_colwidth'</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    frame=pd.read_csv(<span class="string">'newtest.csv'</span>,engine=<span class="string">'python'</span>)</span><br><span class="line">    frame[<span class="string">'created'</span>] = frame[<span class="string">'created_at'</span>].str[<span class="number">0</span>:<span class="number">7</span>]</span><br><span class="line">    df1 = frame.created.value_counts()</span><br><span class="line">    print(df1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>这份数据内容很多，因此就不列出了。</p>
<h3 id="项目创建及更新时间分布"><a href="#项目创建及更新时间分布" class="headerlink" title="项目创建及更新时间分布"></a>项目创建及更新时间分布</h3><p>由于数据很多，因此这里并不逐月统计，对于创建时间，统计每半年的项目数；对于更新时间，统计每一年的项目数，例如创建于2009年10月至2010年4月且最后一次更新于2014年4月至2015年4月的项目有1个，则这一对时间所对应的值就是1。以此类推，可以得到一份完整表格。</p>
<p>我们首先读入csv文件，截取创建和更新的年月数据，并依次分组并统计每组的项目数，这样就可以得到每组年月对所对应的项目数，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">pd.set_option(<span class="string">'display.max_rows'</span>,<span class="literal">None</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.max_columns'</span>, <span class="literal">None</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.width'</span>, <span class="number">1000</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.max_colwidth'</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    frame=pd.read_csv(<span class="string">'newtest.csv'</span>,engine=<span class="string">'python'</span>)</span><br><span class="line">    frame[<span class="string">'created'</span>] = frame[<span class="string">'created_at'</span>].str[<span class="number">0</span>:<span class="number">7</span>]</span><br><span class="line">    frame[<span class="string">'updated'</span>] = frame[<span class="string">'updated_at'</span>].str[<span class="number">0</span>:<span class="number">7</span>]</span><br><span class="line">    group = frame.groupby([<span class="string">'created'</span>,<span class="string">'updated'</span>])</span><br><span class="line">    dict_tmp = dict(group.size())</span><br><span class="line">    print(dict_tmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>得到的结果是<code>... (&#39;2021-03&#39;, &#39;2021-03&#39;): 473, (&#39;2021-03&#39;, &#39;2021-04&#39;): 151,...</code>这样的格式，将这些放到excel里并进行分列、去除无效数据等处理，最终可以得到如下图所示的表格：</p>
<p><img src="https://i.loli.net/2021/04/30/tS9wECnmoiONprB.png" alt="image-20210430122233349"></p>
<p>接下来筛选出created列中2014-11~2015-04之间的数据，将筛选后的updated和num这两列复制到新区域（比如sheet4），按升序排列，如下图，选中2015-04之前的数据，就可以在右下角看到这个时间段内的项目数总和。</p>
<p><img src="https://i.loli.net/2021/04/30/Eq83h4BrRxLd5z6.png" alt="image-20210430122713555"></p>
<p>用类似的方法进行多次筛选、排序、求和，最终可以得到如下数据表：</p>
<p><img src="https://i.loli.net/2021/04/30/1Qok6Z9U2r5RtvO.png" alt="image-20210430124738534"></p>
<p>行表示创建时间，列表示更新时间。</p>
<h2 id="图像生成"><a href="#图像生成" class="headerlink" title="图像生成"></a>图像生成</h2><p>使用<code>Echarts</code>生成图表，因为没学过前端，所以就直接用了<a href="https://zhuanlan.zhihu.com/p/32759663" target="_blank" rel="noopener">以太坊 Dapp 调研</a>给出的js代码，链接为 <a href="https://github.com/heeeeeng/my_docs/tree/master/ethereum_dapp/data_viewer" target="_blank" rel="noopener">Github</a> 。</p>
<p>所有数据是直接在<code>web.js</code>中写好的，并不是从其他文件读取，且文件开头的<code>var scatter_origin_data</code>其实可以删了。此外，这份文件中的个人和组织项目散点图我并不需要，因此也直接删了。</p>
<p>接下来将<code>web.js</code>中的数据修改成前面统计好的数据，打开<code>web.html</code>就可以看到图表了。</p>
<p>由于hexo博客也可以显示echarts，因此我就把图表放这里了。</p>
<div id="echarts2296" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts2296'));
        // 指定图表的配置项和数据
        var option = {
title: {
            text: '每月新Dapp项目数量分布',
            x:'center'
        },
        tooltip: {
            trigger: 'axis'
        },
        toolbox: {
            show: true,
            feature: {
                dataZoom: {
                    yAxisIndex: 'none'
                },
                dataView: {readOnly: false},
                magicType: {type: ['line', 'bar']},
                restore: {},
                saveAsImage: {}
            }
        },
        xAxis:  {
            name: "创建时间",
            type: 'category',
            boundaryGap: false,
            data: ["2009-01","2009-02","2009-03","2009-04","2009-05","2009-06","2009-07","2009-08","2009-09","2009-10","2009-11","2009-12","2010-01","2010-02","2010-03","2010-04","2010-05","2010-06","2010-07","2010-08","2010-09","2010-10","2010-11","2010-12","2011-01","2011-02","2011-03","2011-04","2011-05","2011-06","2011-07","2011-08","2011-09","2011-10","2011-11","2011-12","2012-01","2012-02","2012-03","2012-04","2012-05","2012-06","2012-07","2012-08","2012-09","2012-10","2012-11","2012-12","2013-01","2013-02","2013-03","2013-04","2013-05","2013-06","2013-07","2013-08","2013-09","2013-10","2013-11","2013-12","2014-01","2014-02","2014-03","2014-04","2014-05","2014-06","2014-07","2014-08","2014-09","2014-10","2014-11","2014-12","2015-01","2015-02","2015-03","2015-04","2015-05","2015-06","2015-07","2015-08","2015-09","2015-10","2015-11","2015-12","2016-01","2016-02","2016-03","2016-04","2016-05","2016-06","2016-07","2016-08","2016-09","2016-10","2016-11","2016-12","2017-01","2017-02","2017-03","2017-04","2017-05","2017-06","2017-07","2017-08","2017-09","2017-10","2017-11","2017-12","2018-01","2018-02","2018-03","2018-04","2018-05","2018-06","2018-07","2018-08","2018-09","2018-10","2018-11","2018-12","2019-01","2019-02","2019-03","2019-04","2019-05","2019-06","2019-07","2019-08","2019-09","2019-10","2019-11","2019-12","2020-01","2020-02","2020-03","2020-04","2020-05","2020-06","2020-07","2020-08","2020-09","2020-10","2020-11","2020-12","2021-01","2021-02","2021-03","2021-04"]
        },
        yAxis: {
            name: '新项目数量',
            type: 'value',
            axisLabel: {
                formatter: '{value}'
            }
        },
        series: [
            {
                name:'新项目数量',
                type:'line',
                data: [1,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,2,0,1,2,1,3,2,1,2,2,2,0,1,5,2,3,5,2,1,1,5,4,4,3,3,8,8,8,5,7,5,8,11,16,9,9,5,6,6,12,19,5,12,16,10,14,21,29,29,26,18,29,34,34,32,34,52,42,49,63,56,50,58,66,64,66,60,41,37,69,60,75,109,128,118,148,203,193,217,223,229,339,353,455,425,625,506,526,596,488,490,432,456,441,341,433,391,385,387,383,379,278,303,313,288,320,288,291,407,479,348,381,316,339,411,448,392,492,456,633,581],
                markPoint: {
                    data: [
                        {type: 'max', name: '最大值'}
                    ]
                },
                markLine: {
                    data: [
                        {type: 'average', name: '平均值'}
                    ]
                }
            }
        ]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>
<div id="echarts443" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts443'));
        // 指定图表的配置项和数据
        var option = {
        title : {
            text: '项目语言分布',
            x:'center'
        },
        tooltip : {
            trigger: 'item',
            formatter: "{b} <br/> 项目数量: {c} ({d}%) "
        },
        legend: {
            orient: 'vertical',
            left: 'left',
            data: ['JavaScript','HTML', 'TypeScript', 'CSS', 'Others']
        },
        series : [
            {
                name: '项目语言分布',
                type: 'pie',
                radius : '55%',
                center: ['50%', '60%'],
                data:[
                    {value:10018, name:'JavaScript'},
                    {value:2087, name:'C#'},
                    {value:1019,name:"HTML"},
                    {value:806,name:"TypeScript"},
                    {value:376,name:"CSS"},
                    {value:336,name:"Solidity"},
                    {value:335,name:"Vue"},
                    {value:295,name:"Java"},
                    {value:256,name:"Python"},
                    {value:139,name:"Shell"},
                    {value:133,name:"Go"},
                    {value:120,name:"C++"},
                    {value:687, name:'Others'}
                ],
                itemStyle: {
                    emphasis: {
                        shadowBlur: 10,
                        shadowOffsetX: 0,
                        shadowColor: 'rgba(0, 0, 0, 0.5)'
                    }
                }
            }
        ]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>
<div id="echarts5486" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts5486'));
        // 指定图表的配置项和数据
        var option = {
        title : {
            text: '剩余语言分布',
            x:'center'
        },
        tooltip : {
            trigger: 'item',
            formatter: "{b} <br/> 项目数量: {c} ({d}%) "
        },
        series : [
            {
                name: '编程语言数量分布',
                type: 'pie',
                radius : '55%',
                center: ['50%', '60%'],
                data:[                    
                    {value:72,name:"Dockerfile"},
                    {value:65,name:"PHP"},
                    {value:54,name:"Kotlin"},
                    {value:52,name:"Ruby"},
                    {value:49,name:"Swift"},
                    {value:37,name:"Dart"},
                    {value:34,name:"Rust"},
                    {value:30,name:"Jupyter Notebook"},
                    {value:30,name:"Objective-C"},
                    {value:25,name:"C"},
                    {value:24,name:"Makefile"},
                    {value:22,name:"WebAssembly"},
                    {value:19,name:"TSQL"},
                    {value:17,name:"SCSS"},
                    {value:10,name:"PowerShell"},
                    {value:10,name:"F#"},
                    {value:137,name:"Others"},
                ],
                itemStyle: {
                    emphasis: {
                        shadowBlur: 10,
                        shadowOffsetX: 0,
                        shadowColor: 'rgba(0, 0, 0, 0.5)'
                    }
                }
            }
        ]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>
<p><img src="https://i.loli.net/2021/04/30/UC8DSlosXBIu5Mv.png" alt="fe0b04c74a9bae3058a8c53ba973f4e"></p>
<p>热力图不知道为什么始终没法在这里显示，所以就放个截图了……</p>
]]></content>
      <categories>
        <category>无分类项</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>Echarts</tag>
        <tag>Github</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Eliciting Information from Heterogeneous Mobile Crowdsourced Workers Without Verification</title>
    <url>/2021/04/15/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Eliciting%20Information%20from%20Heterogeneous%20Mobile%20Crowdsourced%20Workers%20Without%20Verification/</url>
    <content><![CDATA[<h1 id="Eliciting-Information-from-Heterogeneous-Mobile-Crowdsourced-Workers-Without-Verification"><a href="#Eliciting-Information-from-Heterogeneous-Mobile-Crowdsourced-Workers-Without-Verification" class="headerlink" title="Eliciting Information from Heterogeneous Mobile Crowdsourced Workers Without Verification"></a>Eliciting Information from Heterogeneous Mobile Crowdsourced Workers Without Verification</h1><p>这篇和Strategic Information Revelation in Crowdsourcing Systems Without Verification是同一批作者的，针对的问题一样，内容方法看着也差不多，希望别一模一样……</p>
<a id="more"></a>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>问题：无验证的信息提取（IEWV）</p>
<p>思路：激励workers高质量和如实报告</p>
<p>常规方法：多数投票——符合多数解决方案的workers获得报酬</p>
<p>存在问题：未考虑workers的异构性</p>
<p>本文方法：两阶段Stackelberg博弈</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>本文场景：</p>
<ol>
<li>workers求解准确率异构（即，不同workers以不同概率生成高质量数据）</li>
<li>考虑数据质量与平台成本之间的平衡</li>
</ol>
<p>本文方法：多数投票机制</p>
<p>需要解决的问题：</p>
<ol>
<li>给定奖励，多数投票机制下，异构workers会如何行动；</li>
<li>workers的异构性如何影响平台的最优奖励设计和均衡；</li>
<li>在提升平台均衡方面，知道workers异构方案准确性有什么价值。</li>
</ol>
<p>本文的两阶段博弈：</p>
<ol>
<li>平台决定多数投票机制的奖励等级，目标是最大化收益，该收益考虑了workers解决方案质量和平台总支出之间的均衡；</li>
<li>每个worker选择自己的努力等级和报告策略，目标是最大化自己收益。</li>
</ol>
<p>本文考虑两种情况：</p>
<ol>
<li>不完全信息博弈（平台不知道workers的准确率）</li>
<li>完全信息博弈（平台知道workers的准确率）</li>
</ol>
<h3 id="Key-Contributions"><a href="#Key-Contributions" class="headerlink" title="Key Contributions"></a>Key Contributions</h3><ol>
<li>分析了IEWV问题中异构workers场景下的平台均衡</li>
<li>分析了多均衡共存的场景</li>
<li>刻画了workers的最优策略</li>
<li>刻画了workers异构性对平台均衡的影响</li>
<li>刻画了得知workers异构性的价值</li>
</ol>
<h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><h3 id="Information-Elicitation"><a href="#Information-Elicitation" class="headerlink" title="Information Elicitation"></a>Information Elicitation</h3><p>略</p>
<h3 id="Information-Aggregation"><a href="#Information-Aggregation" class="headerlink" title="Information Aggregation"></a>Information Aggregation</h3><p>略</p>
<h2 id="3-Model"><a href="#3-Model" class="headerlink" title="3. Model"></a>3. Model</h2><h3 id="Workers’-Decision-Problem"><a href="#Workers’-Decision-Problem" class="headerlink" title="Workers’ Decision Problem"></a>Workers’ Decision Problem</h3><h4 id="Workers-and-Task"><a href="#Workers-and-Task" class="headerlink" title="Workers and Task"></a>Workers and Task</h4><p>集合：$N=\{1,2,…,N\}$表示到达平台的workers</p>
<p>待求解问题的答案是二选一，记作$X=\{-1,1\}$</p>
<p>$x\in X$表示该任务的正确答案</p>
<p>$x_i^{estimate}\in X$表示第$i$个worker对任务答案的估计值</p>
<p>$x_i^{estimate}\in X$表示第$i$个worker向平台上报的任务答案</p>
<h4 id="Worker-Effort-Exertion-and-Reporting-Strategy"><a href="#Worker-Effort-Exertion-and-Reporting-Strategy" class="headerlink" title="Worker Effort Exertion and Reporting Strategy"></a>Worker Effort Exertion and Reporting Strategy</h4><p>workers的任务质量依赖于努力程度，记作$e_i\in \{0,1\}$</p>
<p>workers可通过付出一定代价来努力从而提高任务质量（即准确率）</p>
<p>第$i$个worker的求解方案准确率记作$p_i\in (0.5,1])$</p>
<script type="math/tex; mode=display">
P(x_i^{estimate}=x)=\left\{
\begin{matrix}
p_i,\ \ &if\ \ e_i=1\ \ with\ \ a\ \ cost\ \ c_i\geq 0, \\
0.5,\ \ &if\ \ e_i=0.
\end{matrix}
\right.</script><p>workers异构性的体现：$N$个workers中有$k$个高质量的求解准确率为$p_h$，和$N-k$个低质量的求解准确率为$p_l$，$0.5&lt;p_l&lt;p_h\leq 1$</p>
<p>workers的上报策略：$v_i=\{1,-1,rd\}$，其中，努力的workers可以选择$\{1,-1\}$分别表示如实报告和谎报；而不努力的workers可以选择$rd$表示以0.5的概率随机上报</p>
<script type="math/tex; mode=display">
x_i^{report}=
\left\{
\begin{matrix}
x_i^{estimate},\ \ &if\ \  v_i=1\\
-x_i^{estimate},\ \ &if\ \  v_i=-1\\
1\ \  or\ \  -1\ \  with\ \  an\ \  equal\ \  probability,\ \ &if\ \  v_i=rd.
\end{matrix}
\right.</script><p>本文不考虑多个workers共谋等情况。</p>
<p>workers的策略记作$s_i=(e_i,v_i)$，属于集合$S_i=\{(0,rd),(1,1),(1,-1)\}$</p>
<h4 id="Internal-Reward-for-Truthful-Reports"><a href="#Internal-Reward-for-Truthful-Reports" class="headerlink" title="Internal Reward for Truthful Reports"></a>Internal Reward for Truthful Reports</h4><p>第$i$个worker如果努力且如实上报，则会得到内在奖励$l_i\geq 0$</p>
<p>反之，谎报会得到内在惩罚$-l_i$</p>
<p>不努力的worker会随机上报，他的内在奖励为0</p>
<h4 id="Consistency-Reward-for-Output-Agreement"><a href="#Consistency-Reward-for-Output-Agreement" class="headerlink" title="Consistency Reward for Output Agreement"></a>Consistency Reward for Output Agreement</h4><p>一致性奖励记作$R\geq 0$</p>
<p>除了第$i$个worker以外，其余workers的多数投票方案记作$x_{-i}^{majority}$</p>
<p>从第$i$个worker的角度来看，多数投票方案是：</p>
<script type="math/tex; mode=display">
x_{-i}^{majority}=
\left \{
\begin{matrix}
1,\ \ if\ \ \sum_{j\in N,j\neq i}x_j^{report}>0,\\
-1,\ \ if\ \ \sum_{j\in N,j\neq i}x_j^{report}<0,\\
tie,\ \ if\ \ \sum_{j\in N,j\neq i}x_j^{report}=0.
\end{matrix}
\right.</script><p>第$i$个worker的上报值与多数投票方案一致或者多数投票方案是tie的情况下，该worker会得到奖励；反之则不会。</p>
<p>第$i$个worker得到奖励R的概率记作$P_i(R,p,s)$，$p=(p_j,\forall j\in N)$，$s=(e,v)$，$e=(e_j,\forall j \in N)$，$v=(v_j,\forall j \in N)$</p>
<h4 id="Worker-Payoff-Maximization-Problem"><a href="#Worker-Payoff-Maximization-Problem" class="headerlink" title="Worker Payoff Maximization Problem"></a>Worker Payoff Maximization Problem</h4><p>worker的收益函数：$u_i(R,s)=R*P_i(R,p,s)+v_il_i-e_ic_i$</p>
<p><strong>博弈1：</strong>$\Omega_1=(N,S,u)$，其中：</p>
<ol>
<li><p>$N$：N个workers的集合</p>
</li>
<li><p>$S$：第$i$个worker的策略空间为$s_i\in S_i=\{(0,rd),(1,1),(1,-1)\}$。所有workers的策略记作$s=(s_i,\forall i\in N)$，所有workers的可行策略集合记作$S=\prod_{i\in N}S_i$。</p>
<p><em>这里应该是集合的笛卡尔积，不过这个表达不太确定是否正确。</em></p>
</li>
<li><p>$u$：向量$u=(u_i,\forall i \in N)$包含了所有workers的收益</p>
</li>
</ol>
<p>该博弈中，给定报酬$R$和其他workers的决策$s_{-i}=(e_{-i},v_{-i})=((e_j,v_j),\forall j \neq i)$，第$i$个worker需要求解下述优化问题。</p>
<p><strong>问题1：</strong> 第$i$个worker的收益最大化</p>
<p>$max\ \ u_i(R,s,s_{-i})$</p>
<p>$var.\ \ s_i\in\{(0,rd),(1,1),(1,-1)\}.$</p>
<p><strong>定义1：</strong> 纳什均衡：在给定$R$的情况下，如果对于所有$s_i’\in S_i$，和所有$i\in N$，都有$u_i(R,s_i^<em>,s_{-i}^</em>)\geq u_i(R,s_i’,s_{-i}^<em>)$，则认为策略$s^</em>=\prod_{i\in N}s_i^*$构成了博弈$\Omega_1$的一个纳什均衡。</p>
<p>注意：第$i$个worker的策略选择是前面<strong>问题1</strong>的优化解决方案，是与平台支付报酬$R$和其他worker策略$s_{-i}$相关的函数。</p>
<h3 id="Platform’s-Reward-Design-Problem"><a href="#Platform’s-Reward-Design-Problem" class="headerlink" title="Platform’s Reward Design Problem"></a>Platform’s Reward Design Problem</h3><h4 id="Accuracy-of-Aggregated-Estimate"><a href="#Accuracy-of-Aggregated-Estimate" class="headerlink" title="Accuracy of Aggregated Estimate"></a>Accuracy of Aggregated Estimate</h4><p>平台根据所有workers的上报值进行多数投票猜测最终的值</p>
<script type="math/tex; mode=display">
x_p^{estimate}=
\left \{
\begin{matrix}
1,\ &if\ \sum_{i=1}^Nx_i^{report}>0,\\
-1,\ &if\ \sum_{i=1}^Nx_i^{report}<0,\\
1\ or\ -1\ with\ an\ equal\ probability,\ &if\ \sum_{i=1}^Nx_i^{report}=0.
\end{matrix}
\right.</script><p>$P_a(R,p,N)$表示上述公式得到的聚合解决方案是正确的概率</p>
<p>假设：N是基数且$N\geq 4$</p>
<h4 id="Expected-Consistency-Rewards"><a href="#Expected-Consistency-Rewards" class="headerlink" title="Expected Consistency Rewards."></a>Expected Consistency Rewards.</h4><p>workers总一致性奖励期望记作$E[R^T]$</p>
<h4 id="Platform’s-Payoff-Maximization-Problem"><a href="#Platform’s-Payoff-Maximization-Problem" class="headerlink" title="Platform’s Payoff Maximization Problem"></a>Platform’s Payoff Maximization Problem</h4><p>平台收益函数：</p>
<script type="math/tex; mode=display">
\prod(R)=\beta P_a(R,p,N)-E[R^T]</script><p>$\beta&gt;0$表示平台对准确率分配的权重</p>
<p><strong>问题2：</strong> 平台的收益最大化：</p>
<p>$max \prod(R)$</p>
<p>$var. R\geq0$</p>
<h3 id="Two-Stage-Game"><a href="#Two-Stage-Game" class="headerlink" title="Two-Stage Game"></a>Two-Stage Game</h3><p>阶段1：平台决定R</p>
<p>阶段2：workers选择努力和上报策略</p>
<p>博弈求解方法：逆向归纳</p>
<p>符号表达：</p>
<p>$X$：任务类型空间</p>
<p>$x$：任务真实类型</p>
<p>$x_i^{estimate}$：第$i$个worker的估计值</p>
<p>$x_i^{report}$：第$i$个worker的上报值</p>
<p>$x_{-i}^{majority}$：除了第$i$个worker以外，剩下workers的多数投票方案</p>
<p>$x_p^{estimate}$：平台的聚合估计值</p>
<p>$s_i\triangleq(e_i,v_i)$：第$i$个worker的策略（努力策略和上报策略）</p>
<p>$c_i$：第$i$个worker的努力成本</p>
<p>$l_i$：第$i$个worker的内部奖励</p>
<p>$p_i$：第$i$个worker努力时的准确率</p>
<p>$R$：平台的一致性奖励</p>
<p>$\beta$：平台对聚合准确率的权重</p>
<p>$E[R^T]$：所有workers一致性奖励的期望</p>
<h2 id="4-Incomplete-Information"><a href="#4-Incomplete-Information" class="headerlink" title="4. Incomplete Information"></a>4. Incomplete Information</h2><p>每个worker的准确率只有自己知道，其他workers和平台都不知道。</p>
<h3 id="Workers’-Decisions-at-Stage-II"><a href="#Workers’-Decisions-at-Stage-II" class="headerlink" title="Workers’ Decisions at Stage II"></a>Workers’ Decisions at Stage II</h3><h4 id="Workers’-Heterogeneity"><a href="#Workers’-Heterogeneity" class="headerlink" title="Workers’ Heterogeneity"></a>Workers’ Heterogeneity</h4><p>workers异构性的体现：</p>
<ol>
<li>准确率异构——&gt;$k$个高准确率$p_h$workers，用集合$N_h$表示，$N-k$个低准确率$p_l$，用集合$N_l$表示，$1\leq k\leq N-1,0.5&lt;p_l&lt;p_h\leq 1$，这些参数的数值是公开信息。</li>
<li>努力时的成本和内在奖励/惩罚相同——&gt;$c_i=c,l_i=l,l&lt;c$</li>
</ol>
<h4 id="Workers’-Equilibrium-Behaviors"><a href="#Workers’-Equilibrium-Behaviors" class="headerlink" title="Workers’ Equilibrium Behaviors"></a>Workers’ Equilibrium Behaviors</h4><p>假设：同类型worker（准确率相同）会选择相同的策略</p>
<p><strong>定义2：</strong> 对称纳什均衡（SNE）</p>
<ol>
<li>n-SNE：所有workers都不努力和如实报告</li>
<li>f-SNE：所有workers都努力和如实报告</li>
<li>p-SNE：高质量workers努力和如实报告，低质量workers则相反</li>
</ol>
<p><strong>命题1：</strong> workers之间的SNE</p>
<ol>
<li>当$R\geq 0$时一定存在一个n-SNE</li>
<li>存在一个阈值$R_f\geq 0$，当$R\geq R_f$时，一定存在一个f-SNE</li>
<li>当$k\geq k_1$时，存在两个阈值$0&lt;R_p^l\leq R_p^h$，使得在$R_p^l\leq R \leq R_p^h$时，一定存在一个p-SNE</li>
</ol>
<p>阈值之间的关系取决于$k$的大小：当$k$较小时，$R_f\leq R_p^l$；当$k$较大时，$R_f&gt;R_p^l$。</p>
<p>由命题1可得：</p>
<ol>
<li>对于任意非负一致性奖励$R$，一定存在一个n-SNE，所有workers都没有动机努力和如实报告；努力worker的收益是$\frac{R}{2}+l-c$，不努力worker的收益是$\frac{R}{2}$，由于$l&lt;c$，显然不努力更好。</li>
<li>当一致性奖励足够大时，存在f-SNE，所有workers都会努力和如实报告。</li>
<li>workers准确率的异构性允许我们通过机制来使不同准确率的workers采取不同策略，当一致性准确率在合适范围内时，存在p-SNE使得高准确率workers努力且如实报告，而低准确率workers不努力并随机报告。</li>
</ol>
<p>各均衡解存在性与参数的关系：</p>
<ol>
<li>$k&lt;k_1:$ 高准确率workers很少时，不存在p-SNE。</li>
<li>$k_1\leq k\leq k_2:$ 高准确率workers人数适量时，存在p-SNE，但平台报酬$R$的下限很高（$R_p^l&gt;R_f$）。</li>
<li>$k\geq k_2:$ 高准确率workers足够多时，存在p-SNE，且$R_p^l&lt;R_f$。当k很大时，高质量workers在p-SNE得到报酬的概率与在f-SNE得到报酬的概率相近，低质量workers也会被激励选择(1,1)策略。</li>
</ol>
<p>帕累托最优均衡解：</p>
<p><strong>命题2：</strong> 给定一致性奖励$R$，一定存在一个帕累托最优均衡解。</p>
<p>这意味着可以通过调整一致性奖励来引导worker的努力策略和上报策略。</p>
<p><strong>命题3：</strong> 策略空间（$s_i^*=(0,rd),\forall i\in N_h,s_j=(1,1),\forall i\in N_l$）不存在均衡解。</p>
<p>这意味着不会出现低质量workers努力而高质量workers随机的场面。对于给定的R，高质量workers有更高的概率拿到奖励。在努力成本不变的前提下，高准确率workers更愿意选择(1,1)的策略。换言之，多数投票方案更能吸引高准确率workers。然而，在完全信息的场景下这一条并不成立。</p>
<h3 id="Platform’s-Reward-Design-at-Stage-I"><a href="#Platform’s-Reward-Design-at-Stage-I" class="headerlink" title="Platform’s Reward Design at Stage I"></a>Platform’s Reward Design at Stage I</h3><p>$P_f,P_p,P_n:$ workers在三种均衡下的聚合准确率</p>
<p>$E[R_f^T],E[R_p^T],E[R_n^T]:$ 三种均衡下的总期望一致性奖励</p>
<p>$\eta_f,\eta_p,\eta_n:$ 三种均衡下的效率（是指一致性奖励的效率）</p>
<p>效率计算方式：</p>
<p>$\eta_f=\frac{P_f-P_n}{E[R_f^T]}$</p>
<p>$\eta_p=\frac{P_p-P_n}{E[R_p^T]}$</p>
<p>$\eta_n=\frac{P_n-P_n}{E[R_n^T]}=0$</p>
<p>上面这个计算式反过来（也就是$\frac{1}{\eta_f}$）的含义是：对于单位准确率而言，从均衡n-SNE提高到f-SNE所需要支出的平均一致性奖励。$\eta_p$也是类似的含义。</p>
<p>平台的最优决策R：</p>
<p><strong>定理1：</strong> 给定任意参数$(\beta,N,c,l,p_l,p_h,k)$，平台可以引导workers达到f-SNE和对应的效率$\eta_f$</p>
<ol>
<li><p>如果p-SNE存在，且$\eta_p\geq \eta_f$，平台的最优一致性奖励为：</p>
<script type="math/tex; mode=display">
R^* = 
\left\{
\begin{matrix}
0,\ &if\ \beta<\frac{1}{\eta_p}, \\
R_p^l,\  &if\ \frac{1}{\eta_p}\leq\beta<\frac{E[R_f^T]-E[R_p^T]}{P_f-P_p}\\
R_f,\  &if\ \beta \geq \frac{E[R_f^T]-E[R_p^T]}{P_f-P_p};\\
\end{matrix}
\right.</script></li>
<li><p>其他情况下的平台最优一致性奖励为：</p>
<script type="math/tex; mode=display">
R^*=
\left \{
\begin{matrix}
0,&\ if\ \beta<1/\eta_f,\\
R_f,&\ if\ \beta\geq1/\eta_f.
\end{matrix}
\right.</script></li>
</ol>
<p><img src="https://i.loli.net/2021/05/07/E2af8LhbsgiKpUC.png" alt="image-20210507094050695"></p>
<p><img src="https://i.loli.net/2021/05/07/2PdRjKWyF7prVfT.png" alt="image-20210507094124550"></p>
<p>分析<strong>定理1</strong>可得：</p>
<ol>
<li>当p-SNE存在，且效率高于f-SNE，对应图4中的$k&gt;k^{THR}$区域，平台会根据$\beta$来引导均衡从而最大化收益。当$\beta$较小时，由于较低的准确率评价，平台不会提供任何激励，R=0，从而n-SNE是帕累托最优，对应图3中$k&gt;k^{THR}$区域中下面的白色部分。当$\beta$合适时，即图3中的蓝色区域，平台会选择$R=R_p^l$从而得到p-SNE。当$\beta$很大时，即图3中的灰色区域，平台会选择$R=R_f$，得到f-SNE，同时在一致性奖励方面支出很大。</li>
<li>当p-SNE不存在，或其效率低于f-SNE，对应图4中的$k&lt;k^{THR}$区域，类似前面的分析，$\beta$较小时，是n-SNE；反之则是p-SNE。</li>
</ol>
<h2 id="5-Complete-Information-Weighted-Aggregation"><a href="#5-Complete-Information-Weighted-Aggregation" class="headerlink" title="5. Complete Information: Weighted Aggregation"></a>5. Complete Information: Weighted Aggregation</h2><p>每个worker的准确率$p_i$是公开信息</p>
<h3 id="Workers’-Decisions"><a href="#Workers’-Decisions" class="headerlink" title="Workers’ Decisions"></a>Workers’ Decisions</h3><p>这一步和前面的<strong>博弈1</strong>、<strong>命题1</strong>一样。</p>
<h3 id="Platform’s-Reward-Design"><a href="#Platform’s-Reward-Design" class="headerlink" title="Platform’s Reward Design"></a>Platform’s Reward Design</h3><p>平台使用加权多数规则（weighted majority rule）来决定最终的聚合准确率：</p>
<script type="math/tex; mode=display">
x_p^{estimate}=
\left\{
\begin{matrix}
1,\ &if\ \sum_{i=1}^Nw_i(p_i,s_i)x_i^{report}>0\\
-1,\ &if\ \sum_{i=1}^Nw_i(p_i,s_i)x_i^{report}<0\\
1\ or\ -1\ with\ equal\ prob.,\ &if\ \sum_{i=1}^Nw_i(p_i,s_i)x_i^{report}=0
\end{matrix}
\right.</script><p>其中，</p>
<script type="math/tex; mode=display">
w_i(p_i,s_i)=log\frac{\rho(p_i,s_i)}{1-\rho(p_i,s_i)}, \\
\rho(p_i,s_i)=
\left\{
\begin{matrix}
0.5,\ &if\ s_i=(0,rd), \\
p_i,\ &if\ s_i=(1,1), \\
1-p_i,\ &if\ s_i=(1,-1).
\end{matrix}
\right.</script><p>权重公式既能提高聚合准确率，又会显著影响平台决定的报酬。</p>
<p>第$i$个worker的权重$w_i(p_i,s_i)$由其准确率和策略共同决定，因此：</p>
<ol>
<li>在f-SNE时（所有workers都选择<code>(1,1)</code>策略），高质量workers有更高权重，高低质量的权重都是正数；</li>
<li>在p-SNE时（高质量workers采取<code>(1,1)</code>而低质量workers采取<code>(0,rd)</code>），高质量workers权重为正数，低质量workers权重为0；</li>
<li>在n-SNE时（所有workers都选择<code>(0,rd)</code>策略），大家权重都是0，平台随机得到最终答案。</li>
</ol>
<p>数字符号定义如下：</p>
<ol>
<li>$P_f^{wm},P_p^{wm},P_n^{wm}$分别表示在加权多数规则情况下，f-SNE、p-SNE和f-SNE对应的聚合准确率；</li>
<li>$\eta_f^{wm},\eta_p^{wm},\eta_n^{wm}$分别表示在加权多数规则情况下，f-SNE、p-SNE和f-SNE对应的效率。</li>
</ol>
<p>计算方式：</p>
<p>$\eta_f^{wm}=(P_f^{wm}-P_n^{wm})/E[R_f^T]$</p>
<p>$\eta_p^{wm}=(P_p^{wm}-P_n^{wm})/E[R_p^T]$</p>
<p>$\eta_n^{wm}=(P_n^{wm}-P_n^{wm})/E[R_n^T]=0$</p>
<p>workers的均衡解行为和不完全信息一致，每种均衡对应的总一致性奖励（$E[R_f^T],E[R_p^T],E[R_n^T]$）也一致。</p>
<p><strong>命题4：</strong> 给定参数$(\beta,N,c,l,p_l,p_h,k)$，如果f-SNE和p-SNE共存，则$P_f^{wm}\geq P_p^{wm}$</p>
<p><strong>证明：</strong> 在p-SNE，低准确率workers采取<code>(0,rd)</code>，高准确率workers采取<code>(1,1)</code>，根据计算权重的公式，低质量workers权重为0，高质量workers权重为正数，基于此可计算得到$P_p^{wm}$。在f-SNE，所有workers采取<code>(1,1)</code>，按照p-SNE分配权重是可行的，此时$P_f^{wm}= P_p^{wm}$。由于权重计算公式是最优的，因此可得$P_f^{wm}\geq P_p^{wm}$。</p>
<p><em>补充：这个证明没看懂，个人对命题4的理解是说，两个均衡解共存时，f-SNE是所有workers都努力并如实报告，p-SNE是只有高质量workers努力并如实报告，显然f-SNE多了低质量workers努力贡献的准确率，因此总的准确率会更高。</em></p>
<p>由此，可以刻画平台的最优决策，和<strong>定理1</strong>一样，只有符号表达替换了。</p>
<p><img src="https://i.loli.net/2021/05/18/1Rf8TAgeHwkzsEn.png" alt="image-20210518162745417"></p>
<p>图5是新的均衡图解。蓝色区域更大了，也就是说在完全信息的场景下，平台更可能只让高质量workers努力和正确上报。</p>
<p><strong>定理2</strong>： 令$\prod^{inc<em>}$和$\prod^{com</em>}$表示平台在不完全信息和完全信息情况下对应的最优收益。给定参数$(\beta,N,c,l,p_l,p_h,k)$，可得：$\prod^{com<em>}\geq \prod^{inc</em>}$。</p>
<h2 id="6-Complete-Information-Discriminatory-Reward-Policy"><a href="#6-Complete-Information-Discriminatory-Reward-Policy" class="headerlink" title="6. Complete Information: Discriminatory Reward Policy"></a>6. Complete Information: Discriminatory Reward Policy</h2><p>第5章中，平台给不同准确率的workers相同的奖励；本章中则采取有差别的奖励策略，即便是和多数一致方案相同，也会因为准确率不同而得到不同的奖励：低准确率得到的奖励是$R_{low}$，高准确率得到的奖励是$R_{high}$。</p>
<h3 id="Workers’-Decisions-1"><a href="#Workers’-Decisions-1" class="headerlink" title="Workers’ Decisions"></a>Workers’ Decisions</h3><p><strong>命题5</strong>：workers的SNE是</p>
<ol>
<li>$R_{low}$和$R_{high}$都大于等于0时，$s_i^*=(0,rd),\forall i$是一个SNE；</li>
<li>存在两个阈值$R_f^l$和$R_f^h$均大于0，使得当$R_{low}\geq R_f^l$且$R_{high}\geq R_f^h$时，$s_i^*=(1,1),\forall i$是一个SNE；</li>
<li>存在两个阈值$R_p^l$和$R_p^h$均大于0，使得当$R_{low}\leq R_p^l$且$R_{high}\geq R_p^h$时，高质量workers采取$(1,1)$而低质量workers采取$(0,rd)$是SNE；</li>
<li>存在两个阈值$R_{pl}^l$和$R_{pl}^h$均大于0，使得当$R_{low}\geq R_{pl}^l$且$R_{high}\leq R_{ph}^h$时，低质量workers采取$(1,1)$而高质量workers采取$(0,rd)$是SNE。</li>
</ol>
<h3 id="Platform’s-Optimal-Reward-Design"><a href="#Platform’s-Optimal-Reward-Design" class="headerlink" title="Platform’s Optimal Reward Design"></a>Platform’s Optimal Reward Design</h3><p><strong>定理3：</strong></p>
<ol>
<li>使用$\prod_{UP}^{com<em>}$和$\prod_{DP}^{com</em>}$表示平台在均等奖励和差分奖励的情况下的最优支出，则有：$\prod_{DP}^{com<em>}\geq\prod_{UP}^{com</em>}$</li>
<li>存在阈值$\bar{\beta}$，使得当$\beta\geq \bar{\beta}$时，如果UP的最优SNE是n-SNE，且DP的最优SNE不是f-SNE、p-SNE或者pl-SNE，则DP的社会财富比UP高。</li>
</ol>
<p>定理3说明从平台来看，采取差分奖励策略会带来不比均等奖励策略糟糕的支出和社会财富。DP并不一定会损害社会财富，反而会带来双赢的场面。</p>
<h2 id="7-Numerical-Results"><a href="#7-Numerical-Results" class="headerlink" title="7. Numerical Results"></a>7. Numerical Results</h2><p>分析高质量workers的数量$k$和高质量workers准确率$p_h$对平台与workers收益的影响。</p>
<h3 id="Incomplete-Information"><a href="#Incomplete-Information" class="headerlink" title="Incomplete Information"></a>Incomplete Information</h3><h3 id="Complete-Information"><a href="#Complete-Information" class="headerlink" title="Complete Information"></a>Complete Information</h3><h2 id="8-Conclusion"><a href="#8-Conclusion" class="headerlink" title="8. Conclusion"></a>8. Conclusion</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>crowdsourcing</tag>
        <tag>stackelberg game</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链行业总结</title>
    <url>/2021/04/10/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A1%8C%E4%B8%9A%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="区块链行业总结"><a href="#区块链行业总结" class="headerlink" title="区块链行业总结"></a>区块链行业总结</h1>]]></content>
      <categories>
        <category>slides</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-A Novel Paradigm for Disaster-Response Networks: Framework, Strategy and Solution</title>
    <url>/2021/03/06/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-A%20Novel%20Paradigm%20for%20Disaster-Response%20Networks%20Framework,%20Strategy%20and%20Solution/</url>
    <content><![CDATA[<h1 id="灾害应对网络的新范式：框架、策略与解决方案"><a href="#灾害应对网络的新范式：框架、策略与解决方案" class="headerlink" title="灾害应对网络的新范式：框架、策略与解决方案"></a>灾害应对网络的新范式：框架、策略与解决方案</h1><p>这篇是投稿到IEEE Wireless Communications Magazine的论文，现在要写审稿意见。</p>
<p>作者：</p>
<p>中国电力科学研究院</p>
<p>西安电子科技大学</p>
<p>华中科技大学</p>
<p>西北工业大学</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ol>
<li>起因：自然灾害频发、恐怖势力猖獗</li>
<li>特性：DRN（disaster-response network灾害应对网络）更看重网络的灵活性和应急救援能力，对网络框架和资源配置策略提出了新的要求</li>
<li>技术基础：卫星通信和无人机（UAV）动态中继</li>
<li>本文：提出了DRN建设和资源配置的新范式，通过卫星和无人机构建动态可扩展的DRN；提出了新的网络资源配置视角；在DRN框架下设计了资源调度计划。</li>
</ol>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="DRN的结构"><a href="#DRN的结构" class="headerlink" title="DRN的结构"></a>DRN的结构</h3><ol>
<li>需求：快速恢复通信，为救灾提供前提，提高救援效率</li>
<li>关键问题：个人安全</li>
<li>传统DRN：在快速部署和网络灵活性方面不好</li>
<li>新技术DRN：根据是否使用其他基础设施分为两类，基础设施包括可移动和可部署的ICT资源单元（MDRU）、卫星、无人机；总的来说使用其他基础设施的这一类更好</li>
<li>大多数现有网络的问题：只重视容量或覆盖性能，忽视救灾需求，尤其是用户的人身安全</li>
</ol>
<h3 id="DRN中的资源分配"><a href="#DRN中的资源分配" class="headerlink" title="DRN中的资源分配"></a>DRN中的资源分配</h3><ol>
<li>受灾用户的实时需求通常远远大于 DRN 的能力。因此，资源配置策略成为决定系统效率的关键因素。传统网络中的资源配置策略通常涉及容量、延迟或吞吐量，并相应地进行优化。</li>
<li>救灾的特殊性，即及时性和任务导向性，加上DRN之间的建筑差异，使得现有的资源配置策略不适应。由于时间和任务导向，主要考虑如何提高受灾用户的救援能力。因此，DRN 中的资源分配策略需要更多地考虑应用层的要求，而不是物理层的性能。</li>
</ol>
<h3 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h3><ol>
<li>针对时效性和任务导向，提出了一种新范式</li>
<li>采用卫星、无人机</li>
<li>快速部署、动态覆盖、灵活中继</li>
<li>第二部分：DRN的框架；第三部分：跨层资源优化和资源分配方案的开发；第四部分：性能评估；第五部分：总结</li>
</ol>
<h2 id="Disaster-response-network"><a href="#Disaster-response-network" class="headerlink" title="Disaster response network"></a>Disaster response network</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ol>
<li>由空间层、空气层和地面层组成：用户在地面层，需要发射信号；无人机在空气层收集信号传递给空间层的卫星；卫星和卫星基站通信。</li>
<li>空间层：使用低轨道卫星、中心化网络控制器</li>
<li>空气层：无人机作为中继来弥补卫星欠缺的灵活性等；假设无人机数量大于卫星容量，配备移动充电设施，可动态规划工作路径；简化卫星信道受大气变化的影响问题，重点关注资源分配策略</li>
<li>地面层：遇险用户发射求救信号成功则被视为成功救援；用户分为三类：成功发出信号的被救援用户（R-user）、有足够电量试图发求救信号的活跃用户（A-user）、用完电池无能为力的沉默用户（S-user）</li>
<li>本文框架中的A-user通过无人机中继器向卫星发信号，无人机分配完成后网络拓扑保持不变，每个用户只涉及一个无人机中继，使用译码转发和波束形成技术，用户与无人机中继之间的链路采用Nakagami衰落信道模型</li>
</ol>
<h3 id="资源分配策略"><a href="#资源分配策略" class="headerlink" title="资源分配策略"></a>资源分配策略</h3><ol>
<li>控制层和数据层通过卫星上的中心化网络解耦</li>
<li>控制层：网络控制器制定通信请求接收率（CRAR），接收用户、无人机报告的信道状态信息，收集用户设备的剩余工作时间</li>
<li>资源分配问题：用户的剩余电量不同，卫星要在电量耗尽前接收用户的遇险通信请求；通信请求的数量可能超过网络容量，要综合考虑用户设备的剩余工作时间和卫星、无人机可以处理的通信请求。</li>
</ol>
<h2 id="Resource-allocation"><a href="#Resource-allocation" class="headerlink" title="Resource allocation"></a>Resource allocation</h2><ol>
<li>用CRAR作为系统效率指标，即优化目标是提高CRAR</li>
<li>t时刻的CRAR指当前CRAR和未来CRAR的总和<ol>
<li>当前CRAR：s(t)</li>
<li>未来CRAR：$\sum_{\tau=t+1}^{\infty}P_{\tau}(B, C_{v-u}, C_{u-s})$</li>
<li>$B, C_{u-s},C_{v-u}$分别表示用户电量、空间层频道和空气层频道</li>
<li>电量越多用户等待救援的时间越久</li>
</ol>
</li>
<li>无人机算力有限，因此需要降低资源分配算法的复杂度——本文资源分配分为两阶段：空间层和空气层各一阶段</li>
<li>第一阶段中，对于每个无人机中继，网络控制器都会收集 CSI（频道状态信息） 并保持空气层链路的信道增益，这是成功传输的最关键因素之一。卫星根据卫星接入能力以更大的信道增益访问无人机中继</li>
<li>第二阶段中，t时刻的空气层链路资源分配方案：用矩阵表示卫星到无人机的分配方案、无人机到用户的分配方案和根据信道容错率判断的信道可用性（1或者0），用户电量不同会有不同的权重（低电量高延迟的优先级高），计算上述矩阵卷积相乘的F范数来作为目标函数</li>
<li>优化算法：贪婪的迭代匹配过程</li>
</ol>
<h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><ol>
<li>仿真模拟实验：用户由泊松点过程建模，使用二进制相移键控发送信号，位错误概率阈值$\epsilon=10^3$，进行20轮实验</li>
</ol>
<h3 id="CRAR"><a href="#CRAR" class="headerlink" title="CRAR"></a>CRAR</h3><ol>
<li>不同信噪比下，无人机数量和CRAR之间的关系</li>
</ol>
<h3 id="传输功率"><a href="#传输功率" class="headerlink" title="传输功率"></a>传输功率</h3><ol>
<li>不同无人机数量下，CRAR和传输功率之间的关系</li>
</ol>
<h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>提出了灾害应对系统中的资源分配方案，可改善CRAR</p>
<h2 id="审稿意见"><a href="#审稿意见" class="headerlink" title="审稿意见"></a>审稿意见</h2><h3 id="Strength"><a href="#Strength" class="headerlink" title="Strength"></a>Strength</h3><ul>
<li></li>
<li></li>
</ul>
<h3 id="Weakness"><a href="#Weakness" class="headerlink" title="Weakness"></a>Weakness</h3><ul>
<li>创新性较差，实质就提出了一个基于电量和延迟的资源分配方案</li>
<li>灾害应对系统的通信恢复过程除了考虑用户电量和延迟，也应当考虑用户本身的生命体征等；第一部分中提到的其他DRN存在的问题，本文中的DRN同样也有</li>
<li>公式1中的P函数具体形式没有介绍，且后文中的资源分配方案是否能得到最优的R(t)也需要进行分析</li>
<li>没有具体介绍空间层（卫星和无人机）的分配方案，“卫星以较大的信道增益访问无人机”是否会和卫星本身的容量和传输能力发生冲突，如果发生冲突（即资源不够分配）时，应当如何向不同的无人机分配资源？</li>
<li><del>网络控制器是卫星和无人机上都有吗？是否可以把无人机的资源分配计算工作放到卫星上，无人机仅进行通信中继？</del></li>
<li>在用户设备与无人机建立通信连接后，如果因为意外导致连接断开如何判断和处理？</li>
<li>在灾害应对系统中，直接将信息发送成功视作救援成功合适吗？是否还需要考虑周期性确认用户状态等后续操作带来的能量消耗？</li>
<li>实验中用作对比的传统方案具体是指哪种方案？</li>
<li>实验是数值仿真还是小规模的无人机仿真？如果是前者，无人机和卫星在实际使用场景的差异很大，数值仿真无法有效说明方案的效率；如果进行了无人机实验，则型号等相关参数应该在实验部分进行说明。</li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>灾害应对网络</tag>
        <tag>审稿意见</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-中世纪历史与文化</title>
    <url>/2021/03/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%AD%E4%B8%96%E7%BA%AA%E5%8E%86%E5%8F%B2%E4%B8%8E%E6%96%87%E5%8C%96/</url>
    <content><![CDATA[<h1 id="中世纪历史与文化"><a href="#中世纪历史与文化" class="headerlink" title="中世纪历史与文化"></a>中世纪历史与文化</h1><h2 id="第一章-波埃修斯与欧洲的崛起"><a href="#第一章-波埃修斯与欧洲的崛起" class="headerlink" title="第一章 波埃修斯与欧洲的崛起"></a>第一章 波埃修斯与欧洲的崛起</h2><h3 id="波埃修斯：新柏拉图主义者"><a href="#波埃修斯：新柏拉图主义者" class="headerlink" title="波埃修斯：新柏拉图主义者"></a>波埃修斯：新柏拉图主义者</h3><ol>
<li>波埃修斯的成就：<ol>
<li>翻译《工具论》by亚里士多德的前三篇，介绍了一种思维方式；</li>
<li>著作《分类之书》、论算术的论文、对音乐的说明、《哲学的慰藉》等；</li>
<li>将“原理”“主体”“本质”等基础概念引入欧洲学术话语；</li>
<li>“知识并不来自所认知的事物，而是进行思考与认识的主题的认知能力所固有的”；</li>
<li>“四艺”的概念</li>
</ol>
</li>
<li>对后世的影响：<ol>
<li>《哲学的慰藉》：见证了古典文化在最终熄灭前发出最后的火光；</li>
<li>但丁、豪斯费霍尔等作者深受影响；</li>
<li>”哲学“与”命运“的讨论支撑着基督教，对自由意志的探讨意义深远；</li>
<li>推进神学与哲学之辩——&gt;中世纪理性与信仰日趋严重分化与对立</li>
</ol>
</li>
<li>在这之后：学术与知识逐渐随古代的结束而沉默，许多学派被取缔，艺术停滞在圣像的形式主义上，留下的只有基督教、教会和异端。中世纪的教育体系不再关注传统教育内容——科学研究与实验，而更多地体现为护教、阐释、劝勉、布道和虔敬。</li>
</ol>
<h3 id="传承到中世纪的知识"><a href="#传承到中世纪的知识" class="headerlink" title="传承到中世纪的知识"></a>传承到中世纪的知识</h3><ol>
<li>《论基督教教义》by圣奥古斯丁：符号学——事物通过符号被认识</li>
<li>《指南》by卡西奥多鲁斯：基督教的教育规划</li>
<li>《语文学与墨丘利的婚约》by马蒂安努斯$\cdot$卡佩拉：寓言式的有关技艺的基础教程</li>
</ol>
<h3 id="罗马与外族的融合"><a href="#罗马与外族的融合" class="headerlink" title="罗马与外族的融合"></a>罗马与外族的融合</h3><ol>
<li>来到罗马帝国的土地上的外族人一方面想要战胜先进文明，同时另一方面又效仿着先进文明，典型的例子：哥特人</li>
</ol>
<h4 id="哥特人"><a href="#哥特人" class="headerlink" title="哥特人"></a>哥特人</h4><ol>
<li>”没有法律任何国家都不能长存“</li>
<li>”复兴罗马“成为接下来数百年乃至整个中世纪的标语，在历史的不同阶段以不同面貌出现，也以不同方式被付诸实践</li>
<li>最初（4世纪初以来）罗马人向哥特人派遣基督教传教士，而这也受到了异教徒的抵抗，由此发生了哥特人的罗马化。在这一阶段，乌尔菲拉主教将《圣经》翻译为哥特方言，尽管翻译存在很多问题，但这仍然推进了哥特人向地中海高等文化的转变。</li>
<li>到5世纪左右，哥特人分为西哥特和东哥特两部分</li>
<li>5世纪后期，西哥特国王们编撰了一系列法令集，这些成文法一直沿用至中世纪盛期，它们将”罗马人“从”哥特人“中分离出来，并形成”成文法区域“</li>
<li>在与法兰克人打仗并战败后，哥特人被迫来到赛蒂马尼亚和西班牙，并建立新的哥特王国。在此之后原本信奉阿里乌教派的哥特人皈依了天主教，修订了教会法。</li>
<li>尽管哥特人认可天主教会的合法性，但事实上哥特人与罗马教会、教宗之间并未建立法律上的联系，哥特-西班牙的天主教徒更多地保持了自身的独立性</li>
<li>11世纪教会改革，西班牙被纳入罗马教宗的普世主教区（指世俗君主放弃神职叙任权）</li>
</ol>
<h4 id="法兰克人"><a href="#法兰克人" class="headerlink" title="法兰克人"></a>法兰克人</h4><ol>
<li>在哥特人发展的同时，法兰克人也在发展；法兰克人的起源混沌不清，没有详细记载，更多的是各种神话</li>
<li>法兰克的整个发展过程中都得到了罗马帝国的帮助，尤其是经济扶持；相应地，墨洛温王朝将罗马遗留的军事、民政管理系统作为自身的统治基础。</li>
<li>古典文化在墨洛温王朝经历了转型、退化，并没有像在哥特王国那样突然消亡。</li>
<li>法兰克王国的创立者克洛维死后，按其意愿，法兰克王国分给了他的四个儿子，这一分裂的继承法由此传承下去，直到9、10世纪随加洛林王朝的结束而结束。</li>
<li>法兰克王国的由于分裂的继承法没能形成稳定的证券，但同时诞生了一系列下属王国</li>
</ol>
<h4 id="东罗马帝国（拜占庭）"><a href="#东罗马帝国（拜占庭）" class="headerlink" title="东罗马帝国（拜占庭）"></a>东罗马帝国（拜占庭）</h4><ol>
<li>在波埃修斯的时代，东罗马统治者是查士丁尼大帝，他实行了一系列复兴政策：<ol>
<li>收复落入蛮族统治的西部省份——战争同时带来巨大的负担，以君士坦丁堡为中心建立的政治经济集权体制绑架了被收复省份的发展机会，削弱了其生产和抵抗的力量，反而加快了罗马帝国的衰落</li>
<li>编撰罗马法法典《民法大全》（又被称为《查士丁尼法典》）——11世纪末，引发了西方以大学为基础的学术勃兴</li>
<li>关闭雅典学园——科学发展逐渐停滞，不再有根本上的创新</li>
</ol>
</li>
<li>陆陆续续的外敌入侵：<ol>
<li>来自中亚的匈人入侵</li>
<li>南面皈依伊斯兰教的阿拉伯人</li>
<li>各类蛮族：斯拉夫人、阿瓦尔人、佩切涅格人、保加利亚人</li>
<li>伦巴第人入侵意大利</li>
</ol>
</li>
<li>11世纪诺曼人的到来终结了拜占庭势力对伦巴第和意大利南部的影响</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>罗马象征着先进的物质、社会和文化发展水平，”朝向罗马“（Romorientierung）这一确凿的、潜意识上的进程从未消解。与之对应的，在罗马彼岸居住着古代意义上的”野蛮人“，他们相对于罗马而言处于低等文化，只拥有少数铁器；没有城市和铺设的道路；只有纯粹的口头文化而没有文字，很长一段时间内用凿刻的符文作为咒语或简单的名字；没有科学也没有持久的历史传统；宗教崇拜鲜为人知。</p>
<p>西方世界的不同地域对接受和继承高等书写文化有着完全不同的启动环境，离地中海高等文明越远的地方，高等文明遭到的拒绝和限制就越明显，其童话效应也更为迟缓和微弱。</p>
<p>不过爱尔兰与众不同，西方学术的复兴从那里受益，尽管波埃修斯的作品并未在爱尔兰产生任何影响。</p>
<h2 id="第二章-大格里高利和法兰克人的新兴权力"><a href="#第二章-大格里高利和法兰克人的新兴权力" class="headerlink" title="第二章 大格里高利和法兰克人的新兴权力"></a>第二章 大格里高利和法兰克人的新兴权力</h2><h2 id="第三章-查理曼与第一次“罗马帝国的复兴”"><a href="#第三章-查理曼与第一次“罗马帝国的复兴”" class="headerlink" title="第三章 查理曼与第一次“罗马帝国的复兴”"></a>第三章 查理曼与第一次“罗马帝国的复兴”</h2><h2 id="第四章-王国的巩固与罗马帝国的第二次复兴"><a href="#第四章-王国的巩固与罗马帝国的第二次复兴" class="headerlink" title="第四章 王国的巩固与罗马帝国的第二次复兴"></a>第四章 王国的巩固与罗马帝国的第二次复兴</h2><h2 id="第五章-末世危险地临近了"><a href="#第五章-末世危险地临近了" class="headerlink" title="第五章 末世危险地临近了"></a>第五章 末世危险地临近了</h2><h2 id="第六章-“真正的皇帝是教宗”"><a href="#第六章-“真正的皇帝是教宗”" class="headerlink" title="第六章 “真正的皇帝是教宗”"></a>第六章 “真正的皇帝是教宗”</h2><h2 id="第七章-教宗分立的漫长世纪"><a href="#第七章-教宗分立的漫长世纪" class="headerlink" title="第七章 教宗分立的漫长世纪"></a>第七章 教宗分立的漫长世纪</h2><h2 id="第八章-天主的代理人"><a href="#第八章-天主的代理人" class="headerlink" title="第八章 天主的代理人"></a>第八章 天主的代理人</h2><h2 id="第九章-法理高奏凯歌"><a href="#第九章-法理高奏凯歌" class="headerlink" title="第九章 法理高奏凯歌"></a>第九章 法理高奏凯歌</h2><h2 id="第十章-理性之光"><a href="#第十章-理性之光" class="headerlink" title="第十章 理性之光"></a>第十章 理性之光</h2><h2 id="第十一章-君主制"><a href="#第十一章-君主制" class="headerlink" title="第十一章 君主制"></a>第十一章 君主制</h2><h2 id="第十二章-对最后的审判与重生的期待"><a href="#第十二章-对最后的审判与重生的期待" class="headerlink" title="第十二章 对最后的审判与重生的期待"></a>第十二章 对最后的审判与重生的期待</h2>]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>中世纪历史与文化</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+reveal实现slide</title>
    <url>/2021/03/02/hexo+reveal%E5%AE%9E%E7%8E%B0slide/</url>
    <content><![CDATA[<h1 id="hexo-reveal"><a href="#hexo-reveal" class="headerlink" title="hexo+reveal"></a>hexo+reveal</h1><h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p>今天终于搞成了用<code>reveal.js</code>在博客里显示ppt的效果。感谢做模块的大佬，以至于安装过程还挺简单的。步骤如下：</p>
<ol>
<li><p>安装：命令行进入博客目录，输入<code>npm i hexo-generator-slidehtml</code></p>
</li>
<li><p>安装好以后，一个按格式（格式见后文）写好的markdown文件就会被渲染成slide格式的html网页了，需要访问的时候，在博客的链接后面加<code>slide.html</code>即可，比如某个博客的链接是<code>http://www.clo5de.info/hexo-generator-slidehtml/2019/04/03/nonTitleMerge/</code>，那么它对应的slide链接就是<code>http://www.clo5de.info/hexo-generator-slidehtml/2019/04/03/nonTitleMerge/slide.html</code>。</p>
</li>
<li><p>但是这样安装好的没法渲染公式，因此要进入<code>\blog\node_modules\hexo-generator-slidehtml\layout</code>目录，打开<code>post-slide.ejs</code>文件，添加<code>&lt;script src=&quot;https://cdn.bootcss.com/reveal.js/3.4.1/plugin/math/math.js&quot;&gt;&lt;/script&gt;</code>（和其他script放一起就行），并在<code>Reveal.initialize</code> 代码块中添加一行<code>plugins: [ RevealMath ],</code>注意这一行最后有个逗号不要忘了。</p>
</li>
<li><p>关于math的设置也还有其他可选项，可以参考<a href="https://revealjs.com/math/" target="_blank" rel="noopener">官网</a></p>
</li>
<li><p>此外我在官网还下载了<code>reveal.js</code>的完整内容，并把其中的<code>plugin</code>文件夹整个复制到了<code>\blog\node_modules\hexo-generator-slidehtml\layout</code>目录下；而刚才那个<code>post-slide.ejs</code>的<code>Reveal.initialize</code> 代码块中的<code>dependencies</code>也增加了以下两行：</p>
<p><code>{ src: &#39;https://cdn.bootcss.com/reveal.js/3.4.1/plugin/math/math.esm.js&#39; },</code></p>
<p><code>{ src: &#39;https://cdn.bootcss.com/reveal.js/3.4.1/plugin/math/math.js&#39; },</code></p>
<p>不过这一步的操作按理说是不需要的，只是我一开始怎么也没法刷新出公式，猜测可能和网页缓存等有关。</p>
</li>
<li><p>按官网的说法，如果要写markdown行内公式，就需要把内容放到如下代码所示的符号中间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;$$公式内容$$&#96;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>If you want to include math inside of a presentation written in Markdown you need to wrap the formula in backticks. This prevents syntax conflicts between LaTeX and Markdown</p>
</blockquote>
</li>
<li><p>不过根据我自己的使用，markdown语法的公式就可以正常显示了，不需要按上面的格式来写。</p>
</li>
<li><p>如果写latex公式，就放到<code>&lt;section&gt;&lt;/section&gt;</code>中间，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">  &lt;h2&gt;The Lorenz Equations&lt;&#x2F;h2&gt;</span><br><span class="line">  \[\begin&#123;aligned&#125;</span><br><span class="line">  \dot&#123;x&#125; &amp; &#x3D; \sigma(y-x) \\</span><br><span class="line">  \dot&#123;y&#125; &amp; &#x3D; \rho x - y - xz \\</span><br><span class="line">  \dot&#123;z&#125; &amp; &#x3D; -\beta z + xy</span><br><span class="line">  \end&#123;aligned&#125; \]</span><br><span class="line">&lt;&#x2F;section&gt;</span><br></pre></td></tr></table></figure>
<p>这个公式的展示效果在官网上可以看到。</p>
</li>
<li><p>在搞了各种配置之后公式如果还没渲染，就等一等，可能和缓存有关。</p>
</li>
<li><p>对于需要制作成slide的markdown文件，只需要在原先写标题日期分类和tags等内容的那个地方增加一个字段：<code>slidehtml: true</code>，这个也可以写进<code>hexo new</code>的模板，这样方便一些。markdown文件中要有一行<code>&lt;!-- #Slide Start# --&gt;</code>（去掉#，这里加#是为了避免接下来直接渲染slide），整个文件内容会以此分为两部分，在这一行前面的，就会展示在博客内容中，而这一行后面的，则会出现在对应的slide中。例如本篇博客的内容就到此结束了，而如果在网址后面添加<code>slide.html</code>，则会看到我复制别人的slide内容。</p>
</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://github.com/jackey8616/hexo-generator-slidehtml" target="_blank" rel="noopener">https://github.com/jackey8616/hexo-generator-slidehtml</a></li>
<li><a href="https://revealjs.com/math/" target="_blank" rel="noopener">https://revealjs.com/math/</a></li>
<li><a href="https://www.lfhacks.com/assets/revealjs.html" target="_blank" rel="noopener">https://www.lfhacks.com/assets/revealjs.html</a></li>
<li><a href="http://vishalgupta.me/md-slides/" target="_blank" rel="noopener">http://vishalgupta.me/md-slides/</a></li>
</ol>
]]></content>
      <categories>
        <category>slides</category>
      </categories>
      <tags>
        <tag>博客配置</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Closed-Form Expression for the Poisson-Binomial Probability Density Function</title>
    <url>/2021/02/12/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Closed-Form%20Expression%20for%20the%20Poisson-Binomial%20Probability%20Density%20Function/</url>
    <content><![CDATA[<h1 id="Closed-Form-Expression-for-the-Poisson-Binomial-Probability-Density-Function"><a href="#Closed-Form-Expression-for-the-Poisson-Binomial-Probability-Density-Function" class="headerlink" title="Closed-Form Expression for the Poisson-Binomial Probability Density Function"></a>Closed-Form Expression for the Poisson-Binomial Probability Density Function</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>二项分布概率密度函数描述了当单个成功概率在试验中保持不变时 N 次独立试验中的成功数。而当这个成功概率会改变时，概率密度函数就转变为泊松-二项分布。</p>
<p>例子：</p>
<ol>
<li>可靠性理论/容错：当N个子进程中有至少M个失败时，我们认为该进程失败。第n个子进程的失败概率为$p_n$，计算整个进程的失败概率。</li>
<li>目标追踪：当传感器在N次连续独立查找中至少检测到M次时，目标追踪会被启动。给定可能会改变的每次查找检测概率$p_n$，确定追踪启动的概率。</li>
<li>模式识别/决策理论：如果第n个专家在诊断某特殊情况是否发生时，有$p_n$的概率得到正确的判断，那么为了实现超过某一百分数的正确率，需要多少位独立专家的重合判定。</li>
<li>教育考试设计：标准化考试中有N个等权重问题，给定至少正确解答其中n个问题的学生百分数，据此推算每个问题正确回答学生的百分数，从而确定问题是否表现出所需的难度扩散。（这是一个逆向泊松二项分布的问题）</li>
<li>多传感器融合：给定一个由N个传感器组成的网络，其检测/无检测输出将通过投票结果进行组合，为了实现指定的M-out-N”融合”误报概率，每个传感器的误报率应该是多少。</li>
<li>项目管理/资源分配：有K个工作站，每个工作站分配到$r_k$个资源，每个工作站达到其各自生产配额的概率为$p_k=f(r_k)$。给定L个附加工作站的可用性，并假设函数$f()$可逆，应向新工作站分配多少资源，以便K+L个工作站中至少 M 个工作站能达到其生产配额的概率为P。</li>
</ol>
<p>本文组织结构：</p>
<ol>
<li>单独每次事件成功率与泊松-二项分布概率密度函数之间的关系</li>
<li>数值技术（多项式插值和离散傅里叶变换）</li>
<li>通过获取二项系数、二项式 cdf 和泊松-二项性时刻（Poisson-binomial moments，这个翻译不知道是否正确）的新表示来演示这些表达式的使用</li>
<li>解决前面的第6个例子作为应用展示</li>
<li>使用多项式技术和矩阵理论技术解决逆向泊松-二项分布的问题</li>
<li>总结</li>
</ol>
<h2 id="GROUNDWORK"><a href="#GROUNDWORK" class="headerlink" title="GROUNDWORK"></a>GROUNDWORK</h2><p>在N次独立实验中，第k次的成功率为$p_k$，失败率为$1-p_k$。成功的次数Y可以被写作$Y=X_1+X_2+…+X_N$，这N个相互独立的随机变量$X_k$，分布向量为$[Pr\{X_k=0\}\ \ Pr\{X_k=1\}]=[1-p_k\ \ p_k]$，其中$Pr\{u\}$表示$u$的概率。而这些随机变量的和式Y的分布就是泊松二项概率密度函数，其表达式通过线性卷积可以得到：</p>
<script type="math/tex; mode=display">
[Pr\{Y=0\}\ \ Pr\{Y=1\}...Pr\{Y=N\}]\\
= [1-p_1\ \ p_1]*[1-p_2\ \ p_2]*...*[1-p_N\ \ p_N] \tag{1}</script><p>对公式1两边使用Z变换，可得泊松二项概率密度函数的两种生成函数：</p>
<script type="math/tex; mode=display">
P_0+P_1z+P_2z^2+...+P_Nz^N\\
=(1-p_1+p_1z)(1-p_2+p2_z)...(1-p_N+p_Nz) \tag{2}</script><p>其中$P_n$表示$Pr\{Y=n\}$</p>
<p>公式(2)的右边稍微改动一下可得：</p>
<script type="math/tex; mode=display">
P_0+P_1z+P_2z^2+...+P_Nz^N\\
=\alpha(z-s_1)(z-s_2)...(z-s_N) \tag{3a}</script><p>其中</p>
<script type="math/tex; mode=display">
\alpha = \prod_{k=1}^N P_k \tag{3b}</script><script type="math/tex; mode=display">
s_k = -(1-p_k)/p_k \tag{3c}</script><p>上述过程用matlab可以写成：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[P,Q]</span>=<span class="title">ProbMofN</span><span class="params">(p)</span></span></span><br><span class="line"><span class="comment">% 给定N个元素的向量p，它表示N个独立重复实验的成功概率，该函数的返回值包括：</span></span><br><span class="line"><span class="comment">% P：N+1个元素，表示0次成功、1次成功、2次成功...N次成功（泊松-二项式的pdf）</span></span><br><span class="line"><span class="comment">% Q：N+1个元素，表示至少0次成功、至少1次成功、...、至少N次成功的概率（泊松-二项式的cdf）</span></span><br><span class="line">p(p==<span class="number">0</span>)=[];    <span class="comment">% 消除等于0的元素</span></span><br><span class="line">n=<span class="built_in">length</span>(p);</span><br><span class="line">alpha=prob(p);</span><br><span class="line">s=-(<span class="number">1</span>-p)./p;</span><br><span class="line">S=poly(s); <span class="comment">% S就是根为向量s的多项式的N+1个系数的向量，也就是说，S(1)*x^N+...+S(N)*x+S(N+1)</span></span><br><span class="line"></span><br><span class="line">temp_P=alpha*S;</span><br><span class="line">temp_Q=cumsum(temp_P);</span><br><span class="line"></span><br><span class="line">P=temp_P[N+<span class="number">1</span>:<span class="number">-1</span>:<span class="number">1</span>];</span><br><span class="line">Q=temp_Q[N+<span class="number">1</span>:<span class="number">-1</span>:<span class="number">1</span>];</span><br><span class="line"><span class="comment">%================================</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span>=<span class="title">invProbMofN</span><span class="params">(P)</span></span></span><br><span class="line"><span class="comment">% 给定N个元素的向量P，它表示N次实验后，0次成功、1次成功、...、N次成功的概率，该函数的返回值为：</span></span><br><span class="line"><span class="comment">% p：N个元素的向量，表示每次实验的成功率</span></span><br><span class="line">N1=<span class="built_in">length</span>(P); <span class="comment">% N1=N+1</span></span><br><span class="line">S=P[N1:<span class="number">-1</span>:<span class="number">1</span>]; </span><br><span class="line">s=roots(S); <span class="comment">% s是N个元素的向量，表示生成函数的根</span></span><br><span class="line">p=<span class="number">1.</span>/(<span class="number">1</span>-s); <span class="comment">% p是N个元素的向量，表示每次事件的成功率</span></span><br></pre></td></tr></table></figure>
<p>这样的计算过程虽然很好用，但是在对泊松-二项式pdf进行进一步分析或推导新结论时不太方便。于是本文提出了近似表达式。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>泊松分布</tag>
      </tags>
  </entry>
  <entry>
    <title>Ren&#39;py引擎的使用</title>
    <url>/2021/02/11/Ren-py%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Ren’py引擎的使用"><a href="#Ren’py引擎的使用" class="headerlink" title="Ren’py引擎的使用"></a>Ren’py引擎的使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>Renpy可以在<a href="https://www.renpy.org/" target="_blank" rel="noopener">官方网站</a>下载；</li>
<li>除了安装引擎本身以外，还需要准备python2和python3；</li>
<li>解包游戏文件需要使用python3安装unrpa，命令行中的安装命令为<code>py -3 -m pip install unrpa</code>；</li>
</ol>
<h2 id="制作游戏"><a href="#制作游戏" class="headerlink" title="制作游戏"></a>制作游戏</h2><h2 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h2><ol>
<li><code>unrpa -mp 目标路径 rpa文件路径</code>即可将rpa文件解包成rpy文件和rpyc文件</li>
</ol>
]]></content>
      <categories>
        <category>Renpy</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>Renpy</tag>
      </tags>
  </entry>
  <entry>
    <title>仙境之夜攻略记录</title>
    <url>/2021/02/11/%E4%BB%99%E5%A2%83%E4%B9%8B%E5%A4%9C%E6%94%BB%E7%95%A5%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="仙境之夜攻略记录"><a href="#仙境之夜攻略记录" class="headerlink" title="仙境之夜攻略记录"></a>仙境之夜攻略记录</h1><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><div class="table-container">
<table>
<thead>
<tr>
<th>中文</th>
<th>英文</th>
<th>编号</th>
</tr>
</thead>
<tbody>
<tr>
<td>白兔</td>
<td>White Rabbit</td>
<td>WR</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>King Claudius of Clubs</td>
<td>KC</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>Queen Catherine of Clubs</td>
<td>QC</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>Countess Jamala of Clubs</td>
<td>JC</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>King David of Diamonds</td>
<td>KD</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>Queen Diana of Diamonds</td>
<td>QD</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>Princess Julie of Diamonds</td>
<td>JD</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>King Harry of Hearts</td>
<td>KH</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>Queen Hera of Hearts</td>
<td>QH</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>Duke Jorge of Hearts</td>
<td>JH</td>
</tr>
<tr>
<td>黑桃国王所罗门</td>
<td>King Solomon of Spades</td>
<td>KS</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>Queen Sarah of Spades</td>
<td>QS</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>Prince John of Spades</td>
<td>JS</td>
</tr>
<tr>
<td>小丑 柴郡猫</td>
<td>Cheshire Cat, The Joker</td>
<td>JK</td>
</tr>
<tr>
<td>外来者 爱丽丝</td>
<td>Alice, The Outsider</td>
<td>A</td>
</tr>
</tbody>
</table>
</div>
<h3 id="活动喜好"><a href="#活动喜好" class="headerlink" title="活动喜好"></a>活动喜好</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>槌球</th>
<th>驯鹰</th>
<th>音乐</th>
<th>马术</th>
<th>下午茶</th>
<th>网球</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>无感</td>
<td>厌恶</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
<td>喜欢</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>厌恶</td>
<td>无感</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
<td>喜欢</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>厌恶</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
<td>无感</td>
<td>喜欢</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
<td>喜欢</td>
<td>厌恶</td>
<td>无感</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>喜欢</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
<td>无感</td>
<td>厌恶</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
<td>喜欢</td>
<td>无感</td>
<td>厌恶</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
<td>无感</td>
<td>厌恶</td>
<td>喜欢</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>无感</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>无感</td>
<td>厌恶</td>
<td>喜欢</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>喜欢</td>
<td>无感</td>
<td>厌恶</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>喜欢</td>
<td>厌恶</td>
<td>无感</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>喜欢</td>
<td>喜欢</td>
<td>厌恶</td>
<td>无感</td>
<td>厌恶</td>
<td>无感</td>
</tr>
</tbody>
</table>
</div>
<h3 id="初始立场"><a href="#初始立场" class="headerlink" title="初始立场"></a>初始立场</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>战争</th>
<th>魔法</th>
<th>贸易</th>
<th>边境</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>反对</td>
<td>支持</td>
<td>征税</td>
<td>有些反对</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>支持</td>
<td>支持</td>
<td>征税</td>
<td>闭关</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>支持</td>
<td>反对</td>
<td>没有主见</td>
<td>开放</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>支持</td>
<td>反对</td>
<td>自由</td>
<td>闭关</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>反对</td>
<td>支持</td>
<td>征税</td>
<td>开放</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>皆可</td>
<td>皆可</td>
<td>自由（强烈）</td>
<td>皆可</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>反对</td>
<td>反对</td>
<td>自由</td>
<td>开放</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>反对</td>
<td>支持</td>
<td>自由</td>
<td>开放</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>反对</td>
<td>支持</td>
<td>自由</td>
<td>开放</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>反对</td>
<td>支持</td>
<td>征税</td>
<td>开放</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>反对</td>
<td>支持</td>
<td>征税</td>
<td>开放</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>支持</td>
<td>反对</td>
<td>自由</td>
<td>闭关</td>
</tr>
</tbody>
</table>
</div>
<h3 id="秘密和对他人的看法"><a href="#秘密和对他人的看法" class="headerlink" title="秘密和对他人的看法"></a>秘密和对他人的看法</h3><p><strong>列人物</strong>对<strong>行人物</strong>的看法，例如第二行第三列“被其支配”表示所罗门对莎拉的看法。行列相同的格子表示这个角色的秘密。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>被妻子的魔法控制了</td>
<td>被其支配</td>
<td>可爱的儿子</td>
<td>不待见对方</td>
<td>友好</td>
<td>互相怀疑</td>
<td>敌对</td>
<td>友好</td>
<td>对我来说也像自己的女儿一样</td>
<td>友好</td>
<td>友好</td>
<td>可疑</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>受控的丈夫</td>
<td>对黑桃蘑菇上瘾</td>
<td>受控的儿子</td>
<td>若意见相同，可以友好相处</td>
<td>无感</td>
<td>互相怀疑</td>
<td>敌对</td>
<td>无感</td>
<td>无感</td>
<td>无感</td>
<td>敌对（姐妹关系）</td>
<td>无感</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>亲爱的父亲</td>
<td>独裁的母亲</td>
<td>和方片公主相爱</td>
<td>很容易操纵我</td>
<td>友好</td>
<td>友好</td>
<td>仰慕</td>
<td>友好</td>
<td>坠入爱河！</td>
<td>有意思的姨丈</td>
<td>有点怕她，但是是个有意思的人</td>
<td>很容易操纵我</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>令人厌恶的蠢蛋</td>
<td>若意见相同，可以友好相处</td>
<td>易操纵</td>
<td>是炸脖龙！</td>
<td>糟糕的婚姻</td>
<td>值得信任</td>
<td>勒索对象</td>
<td>若意见相同，可以友好相处</td>
<td>我想得到她</td>
<td>敌对</td>
<td>敌对</td>
<td>不为人知的弟弟！</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>友好</td>
<td>糟糕的悍妇</td>
<td>可爱的小伙子</td>
<td>可怕的怪物！</td>
<td>不是仙境世界的本地人</td>
<td>值得信任</td>
<td>被领养后遇到的刻薄哥哥</td>
<td>友好</td>
<td>可爱的小姑娘</td>
<td>被领养后遇到的冷漠哥哥</td>
<td>棘手之人</td>
<td>旧爱</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>高度怀疑</td>
<td>高度怀疑</td>
<td>蠢蛋，没有威胁</td>
<td>独裁者，需要遏制他</td>
<td>我会保护她</td>
<td>前任黑桃女王</td>
<td>高度怀疑</td>
<td>高度怀疑</td>
<td>多愁善感的小姑娘，没有威胁</td>
<td>老蠢蛋，没有威胁</td>
<td>太情绪化，没有威胁</td>
<td>高度怀疑</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>敌对</td>
<td>敌对</td>
<td>敌人之子</td>
<td>勒索我的人</td>
<td>与我无关</td>
<td>…谁啊？</td>
<td>他的身体正长出像怪物一样的肿瘤</td>
<td>轻浮的女人，我要控制她！</td>
<td>和她妈太像了</td>
<td>愚蠢的弟弟</td>
<td>我的弟弟很听她的</td>
<td>这家伙是什么立场？</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>应该是我的敌人</td>
<td>令人厌恶的女人</td>
<td>敌人的可爱儿子</td>
<td>可怕的暴君</td>
<td>可爱而不幸的女人</td>
<td>她让我很不自在…</td>
<td>控制狂！</td>
<td>是一名不为人知的女巫</td>
<td>完美！</td>
<td>亲爱的小叔子</td>
<td>让她高兴就对了！</td>
<td>他让我很不自在…</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>应该是我的敌人</td>
<td>令人厌恶的女人</td>
<td>我爱他！</td>
<td>让我害怕的人</td>
<td>可爱的女人，可惜婚姻不幸福</td>
<td>看起来很友好</td>
<td>父王（有点无趣）</td>
<td>完美的母后</td>
<td>和黑桃王子陷入爱河</td>
<td>亲爱的叔叔</td>
<td>亲爱的婶婶（只要不生气）</td>
<td>很有说服力！</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>友好的妹夫</td>
<td>可恨的小姨子</td>
<td>可爱的小侄子</td>
<td>敌人！</td>
<td>可怜的妹妹…</td>
<td>看起来很有涵养</td>
<td>无聊的哥哥</td>
<td>友好的嫂子</td>
<td>可爱的小侄女</td>
<td>偷了妻子的水果塔！</td>
<td>喜怒无常的妻子</td>
<td>值得信任的顾问</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>友好的妹夫</td>
<td>可恨的妹妹</td>
<td>可爱的小侄子</td>
<td>敌人！</td>
<td>可怜又悲惨的女人</td>
<td>有点无聊</td>
<td>大舅子</td>
<td>友好的嫂子</td>
<td>可爱的小侄女</td>
<td>有点无聊的丈夫</td>
<td>和乔治公爵有外遇</td>
<td>情人</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>蠢蛋</td>
<td>糟糕的女人</td>
<td>缺心眼，容易受骗</td>
<td>我的哥哥</td>
<td>我对她还有感情…</td>
<td>她是从哪来的？</td>
<td>试试操纵他</td>
<td>试试操纵她</td>
<td>缺心眼，容易受骗</td>
<td>我的情敌</td>
<td>我爱她！</td>
<td>梅花王国培养他来暗中破坏红心王国</td>
</tr>
</tbody>
</table>
</div>
<h2 id="给自己的提醒"><a href="#给自己的提醒" class="headerlink" title="给自己的提醒"></a>给自己的提醒</h2><h3 id="仙境世界的灾难"><a href="#仙境世界的灾难" class="headerlink" title="仙境世界的灾难"></a>仙境世界的灾难</h3><p>如果克劳狄斯王和所罗门王、莎拉王后、戴安娜王后及赫拉女王碰面，会发生什么事？大卫王似乎想深入了解约翰王子</p>
<p>如果克劳狄斯王和所罗门王、莎拉王后、戴安娜王后及赫拉女王碰面，会发生什么事？（大卫王和约翰王子没有谈话过）</p>
<p>克劳狄斯王想见大卫王和朱莉公主。</p>
<h3 id="黑桃王国的命运"><a href="#黑桃王国的命运" class="headerlink" title="黑桃王国的命运"></a>黑桃王国的命运</h3><p>贾马拉女伯爵想见戴安娜王后、大卫王和莎拉王后。其中的一位在压力之下是个脆弱的突破点。</p>
<p>如果贾马拉女伯爵在试探过戴安娜王后、大卫王和莎拉王后之后和所罗门王谈话，会发生什么？</p>
<p>所罗门王和约翰王子需要和对方谈话，并与戴安娜王后和凯瑟琳王后谈话。</p>
<p>如果所罗门王与赫拉女王见面两次后，和莎拉王后进行了谈话，会发生什么…</p>
<h3 id="红心王国的故事"><a href="#红心王国的故事" class="headerlink" title="红心王国的故事"></a>红心王国的故事</h3><p>如果乔治公爵和赫拉女王整个峰会都待在一起会发生什么事？</p>
<p>如果莎拉王后和亨利王谈话，然后然后和赫拉女王见面，并且她们两位都与乔治公爵对话，会发生什么？</p>
<p>赫拉女王托贾马拉女伯爵调查亨利王、约翰王子和乔治公爵。</p>
<p>也许克劳狄斯王、朱莉公主和大卫王会鼓励亨利王做出新的尝试。</p>
<h3 id="梅花王国的阴谋"><a href="#梅花王国的阴谋" class="headerlink" title="梅花王国的阴谋"></a>梅花王国的阴谋</h3><p>如果整个峰会期间，克劳狄斯王和乔治公爵都被安排在一起，会发生什么事？</p>
<p>如果克劳狄斯王和凯瑟琳见面，然后向大卫王或贾马拉女伯爵抱怨对方，会发生什么？对了，必须有另一个步骤…</p>
<p>如果凯瑟琳王后和乔治公爵整个峰会期间都待在一块会发生什么事？</p>
<h3 id="方片王国的审判"><a href="#方片王国的审判" class="headerlink" title="方片王国的审判"></a>方片王国的审判</h3><p>大卫王想同所罗门王和莎拉王后和平谈判，但是他也许需要向乔治公爵寻求帮助。</p>
<p>如果戴安娜王后无法付清乔治公爵索要的钱款，会发生什么？</p>
<h3 id="年轻的人儿"><a href="#年轻的人儿" class="headerlink" title="年轻的人儿"></a>年轻的人儿</h3><p>如果克劳狄斯王和大卫王全程都被安排在一块会发生什么？</p>
<p>为约翰王子和朱莉公主向富有的贵族寻求帮助。</p>
<p>如果乔治公爵和约翰王子及朱莉公主相处时间相同，会发生什么？</p>
<p>约翰王子似乎有个工作机会。他应该与他的母亲和克劳狄斯王对话。所罗门王应该和乔治公爵谈谈。</p>
<p>黑桃王国的国王和王后以及梅花王国的王后和女伯爵似乎对朱莉公主有兴趣。</p>
<h3 id="外来者"><a href="#外来者" class="headerlink" title="外来者"></a>外来者</h3><p>如果整个峰会期间，莎拉王后和凯瑟琳王后都被安排在一块，会发生什么？</p>
<p>凯瑟琳王后与贾马拉女伯爵一道，需要从大卫王那里拿到花园钥匙，并从乔治公爵那里拿到魔法玫瑰。</p>
<p>赫拉女王想见大卫王、亨利王、约翰王子和凯瑟琳王后。</p>
<h2 id="每天开始时的反应"><a href="#每天开始时的反应" class="headerlink" title="每天开始时的反应"></a>每天开始时的反应</h2><h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><ol>
<li>战争没通过，红心女王会表示满意；否则，红心女王会表示不高兴。</li>
<li>满意值大于等于6，红心女王会满意；没过半但大于等于0，红心女王会表现得中性；否则，会生气。</li>
<li>红心女王会对水果塔丢失而感到生气。</li>
</ol>
<h3 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h3><ol>
<li>魔法通过，红心女王满意。</li>
<li>满意值大于等于12，红心女王会满意；大于等于0，中性；反之，生气。</li>
<li>继续生气水果塔。</li>
</ol>
<h3 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h3><ol>
<li>贸易没通过，会满意。</li>
<li>满意值大于等于18，会高兴；大于等于0，中性；反之，生气。</li>
<li>继续生气水果塔。</li>
</ol>
<h2 id="每天活动安排的影响"><a href="#每天活动安排的影响" class="headerlink" title="每天活动安排的影响"></a>每天活动安排的影响</h2><p>满意值（satisfaction）初始为0</p>
<p>投票值初始：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>战争</th>
<th>魔法</th>
<th>贸易</th>
<th>边境</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>接下来每天的表格种：</p>
<ol>
<li><p>表格中空白表示这个组合只有对话，没有满意值和投票值的变化</p>
</li>
<li><p>表格中-表示该值不存在或者有对称组合，比如<code>（所罗门，莎拉）</code>和<code>（莎拉，所罗门）</code>是同一个组合，前者写了影响，后者就是-了</p>
</li>
</ol>
<p>除了这些表格以外，每个人对应的活动项目，如果是喜欢，则满意值+1，厌恶，则满意值-1，无感则无变化</p>
<p>任意两个角色组合的初始值为1，每安排到一起一次，该组合的值+1，第四次不会增加（例如，KCQC表示克劳狄斯和凯瑟琳的组合，在结局判定时，KCQC=1表示没有安排在一起过，KCQC=2表示安排了一次，KCQC=3表示两次，KCQC=4表示三次，KCQC=5表示四次；此外有一些组合，代码里没有在第四次的时候+1，也就是说=4表示3次或4次，不过对于最后判定没有影响。）</p>
<h3 id="人物组合的影响"><a href="#人物组合的影响" class="headerlink" title="人物组合的影响"></a>人物组合的影响</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>-</td>
<td>组合第1次时，所罗门的秘密曝光</td>
<td>组合第1次时，所罗门和戴安娜的秘密曝光</td>
<td></td>
<td></td>
<td>组合第1次时，如果贾马拉和莎拉、大卫、戴安娜都组合过1次，贾马拉的秘密曝光</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>组合第1次时，莎拉的秘密曝光，</td>
<td></td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
<td>组合第2次时，凯瑟琳的秘密曝光</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>组合第1次时，约翰和朱莉的秘密曝光</td>
<td>组合第4次时，亨利的秘密曝光</td>
<td></td>
<td>组合第1次时，约翰和朱莉的秘密曝光</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>组合第4次时，满意值减10</td>
<td>组合第4次时，<code>talkaboutclubs == 1 and kingconvinced == 0</code>不成立时，乔治的秘密曝光</td>
<td>组合第1次时，克劳狄斯的秘密曝光；组合第4次时，大卫的秘密曝光</td>
<td></td>
<td>组合第3次时，乔治的秘密曝光</td>
<td>组合第4次时，亨利的秘密曝光</td>
<td>组合第4次时，满意值减10</td>
<td>组合第1次且魔法没通过时，乔治的秘密曝光</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>组合第1次，凯瑟琳的秘密曝光</td>
<td></td>
<td></td>
<td></td>
<td>组合第4次时，凯瑟琳的秘密曝光</td>
<td></td>
<td></td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td>组合第2次时，贾马拉和戴安娜的秘密都曝光</td>
<td></td>
<td></td>
<td></td>
<td>组合第2次时，乔治的秘密曝光</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td>组合第4次时，如果<code>dianahaspayment!=0</code>，亨利的秘密曝光</td>
<td></td>
<td>组合第1次时，戴安娜的秘密曝光</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>组合第4次时，约翰和朱莉的秘密曝光</td>
<td></td>
<td>组合第1次时，约翰和朱莉的秘密曝光</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第一天（战争）"><a href="#第一天（战争）" class="headerlink" title="第一天（战争）"></a>第一天（战争）</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>-</td>
<td>KS投票值 1 满意值-1</td>
<td>满意值+1</td>
<td>满意值-1</td>
<td>满意值+1</td>
<td>JC投票值 0</td>
<td>KS投票值 1 KD投票值 1 满意值-1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>-</td>
<td>-</td>
<td>JS投票值 1 满意值-1</td>
<td>满意值+1</td>
<td>QC投票值 1 满意值-1</td>
<td>JC投票值 0 满意值-1</td>
<td>满意值-1</td>
<td>空</td>
<td>JD投票值 1 满意值+1</td>
<td>KH投票值 1 满意值+1</td>
<td>满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JS投票值 1 满意值+1</td>
<td>QC投票值 1 满意值+1</td>
<td>JC投票值 1</td>
<td>满意值+1</td>
<td>QD投票值 1 满意值+1</td>
<td>JD投票值 1 满意值+1</td>
<td>KH投票值 1 满意值+1</td>
<td>QH投票值 1 满意值+1</td>
<td>JS投票值 1</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>QC投票值 1; 满意值-1</td>
<td>JC投票值 1 满意值+1</td>
<td>KD投票值 1</td>
<td>QD投票值 1</td>
<td>JD投票值 1</td>
<td>KH投票值 1 满意值-1</td>
<td>满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 0 满意值+1</td>
<td>空</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>空</td>
<td>QC投票值 1 满意值+1</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 1 满意值-1</td>
<td>JC投票值 0</td>
<td>JC投票值 0</td>
<td>JC投票值 0</td>
<td>JC投票值 0</td>
<td>JC投票值 1 满意值-1</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>空</td>
<td>空</td>
<td>满意值+1</td>
<td>JH投票值 0</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>QD投票值 1</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>JD投票值 1</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>满意值+1</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JH投票值 0 满意值+1</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第二天（魔法）"><a href="#第二天（魔法）" class="headerlink" title="第二天（魔法）"></a>第二天（魔法）</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>-</td>
<td>满意值-1</td>
<td>JS投票值 0 满意值+1</td>
<td>满意值-1</td>
<td>满意值+1</td>
<td>JC投票值 1</td>
<td>满意值-1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>-</td>
<td>-</td>
<td>JS投票值 0 满意值-1</td>
<td>空</td>
<td>满意值-1</td>
<td>JC投票值 0 满意值-1</td>
<td>满意值-1</td>
<td>空</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值-1</td>
<td>JH投票值 1</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>QC投票值 0 满意值+1</td>
<td>JC投票值 0</td>
<td>私奔flag+1 满意值+1</td>
<td>QD投票值 0 满意值+1</td>
<td>JD投票值 0 满意值+1</td>
<td>JS投票值 0 满意值+1</td>
<td>QH投票值 0 满意值+1</td>
<td></td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>QC投票值 0 满意值-1</td>
<td>JC投票值 0 满意值+1</td>
<td>空</td>
<td>QD投票值 0</td>
<td>JD投票值 0</td>
<td>满意值-1</td>
<td>QH投票值 0 满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 1 满意值+1</td>
<td>QC投票值 0</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>空</td>
<td>JH投票值 1 满意值+1</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 1 满意值-1</td>
<td>JC投票值 0 JD投票值 0（这里看对话应该是JC投票值 1 QD投票值 0，怀疑是写错了）</td>
<td>JC投票值 0 JD投票值 0</td>
<td>JC投票值 1</td>
<td>JC投票值 1</td>
<td>JC投票值 0</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>QD投票值 0</td>
<td>JD投票值 0</td>
<td>KH投票值 0</td>
<td>QH投票值 0</td>
<td>空</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>QD投票值 0</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>QH投票值 0 JD投票值 0 满意值+1</td>
<td>JD投票值 0</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>满意值+1</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JH投票值 0 QH投票值 0 满意值+1</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第三天（贸易）"><a href="#第三天（贸易）" class="headerlink" title="第三天（贸易）"></a>第三天（贸易）</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>-</td>
<td>满意值-1</td>
<td>JS投票值 0 满意值+1</td>
<td>KC投票值 0 满意值-1</td>
<td>满意值+1</td>
<td>JC投票值 0</td>
<td>KD投票值 0 满意值-1</td>
<td>满意值+1</td>
<td>JD投票值 0 满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>-</td>
<td>-</td>
<td>JS投票值 0 满意值-1</td>
<td>KC投票值 0</td>
<td>满意值-1</td>
<td>JC投票值 1 满意值-1</td>
<td>KD投票值 0 满意值-1</td>
<td>空</td>
<td>JD投票值 0 满意值+1</td>
<td>满意值+1</td>
<td>满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JS投票值 1 满意值+1</td>
<td>JS投票值 0 满意值+1</td>
<td>JS投票值 1</td>
<td>私奔flag+1 满意值+1 JS投票值 1</td>
<td>JS投票值 1 满意值+1</td>
<td>JS投票值 1 满意值+1</td>
<td>JS投票值 0 满意值+1</td>
<td>JS投票值 0 满意值+1</td>
<td>JS投票值 1</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>QC投票值 1 满意值-1</td>
<td>满意值+1</td>
<td>空</td>
<td>空</td>
<td>空</td>
<td>KC投票值 0 满意值-1</td>
<td>KC投票值 0 满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>QC投票值 1 满意值+1</td>
<td>空</td>
<td>QC投票值 1 满意值+1</td>
<td>JD投票值 0 满意值+1</td>
<td>空</td>
<td>空</td>
<td>JH投票值 0 满意值+1</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值-1</td>
<td>JC投票值 1</td>
<td>JC投票值 1</td>
<td>KH投票值 1</td>
<td>JC投票值 1</td>
<td>JC投票值 1 满意值-1</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>空</td>
<td>KH投票值 1</td>
<td>KD投票值 0</td>
<td></td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>QD投票值 0 满意值+1</td>
<td>空</td>
<td>JH投票值 1</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JD投票值 0 满意值+1</td>
<td>JD投票值 0  满意值+1</td>
<td>JD投票值 1</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>KH投票值 1 满意值+1</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第四天（边境）"><a href="#第四天（边境）" class="headerlink" title="第四天（边境）"></a>第四天（边境）</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>-</td>
<td>KS投票值 0 满意值-1</td>
<td>KS投票值 0 JS投票值 0 满意值+1</td>
<td>KS投票值 0 满意值-1</td>
<td>满意值+1</td>
<td>JC投票值 0 KS投票值 0 满意值-1</td>
<td>KS投票值 0 KD投票值 0 满意值-1</td>
<td>KS投票值 0 QD投票值 0  满意值+1</td>
<td>满意值+1</td>
<td>KH投票值 0 KS投票值 0 满意值+1</td>
<td>满意值+1</td>
<td>KS投票值 0</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>-</td>
<td>-</td>
<td>JS投票值 0 满意值-1</td>
<td>满意值+1</td>
<td>满意值-1</td>
<td>JC投票值 1 满意值-1</td>
<td>KD投票值 0 满意值-1</td>
<td>QD投票值 0</td>
<td>满意值+1</td>
<td>KH投票值 0 满意值+1</td>
<td>满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JS投票值 0 满意值+1</td>
<td>私奔flag+1 满意值+1</td>
<td>JS投票值 0</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>JS投票值 0</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值-1</td>
<td>满意值+1</td>
<td>KD投票值 0</td>
<td>QD投票值 0</td>
<td>空</td>
<td>KH投票值 0 满意值-1</td>
<td>满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 1 满意值+1</td>
<td>空</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>空</td>
<td>满意值+1</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 0 满意值-1</td>
<td>QD投票值 0</td>
<td>JC投票值 1</td>
<td>JC投票值 0 KH投票值 0</td>
<td>JC投票值 1</td>
<td>满意值-1</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>空</td>
<td>空</td>
<td>满意值+1</td>
<td>空</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>QD投票值 0</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>KH投票值 0 满意值+1</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h2 id="每晚投票"><a href="#每晚投票" class="headerlink" title="每晚投票"></a>每晚投票</h2><p>如果大于等于7票，就通过；小于等于5票，就不通过；恰好是6票，柴郡猫投票。</p>
<p>柴郡猫投票的结果：战争不通过；魔法通过；贸易自由；开放边境通过。</p>
<h2 id="最终结局"><a href="#最终结局" class="headerlink" title="最终结局"></a>最终结局</h2><p>”皇室成员聚集在一起，这是他们最后一个可以互相交流的晚上了。“</p>
<p>以下结局在条件不冲突的情况下可同时达成。</p>
<h3 id="炸脖龙结局"><a href="#炸脖龙结局" class="headerlink" title="炸脖龙结局"></a>炸脖龙结局</h3><p>结局1：克劳狄斯与所罗门、莎拉、戴安娜、赫拉各组合过一次</p>
<p>分支1：约翰和大卫组合过两次及以上</p>
<p>约翰王子杀了龙，然后大卫王提议约翰继位当梅花的国王。</p>
<p>分支2：不满足分支1的条件</p>
<p>大卫王杀了龙，但是龙死前划破他的衣服，他自己被龙诅咒的事实也被发现了，于是只能放弃王位，朱莉继位。</p>
<p>结局2：克劳狄斯与大卫组合过两次、与朱莉组合过两次</p>
<p>克劳狄斯变成龙，抢走朱莉，约翰王子和他父亲一起去营救。</p>
<h3 id="贾马拉结局"><a href="#贾马拉结局" class="headerlink" title="贾马拉结局"></a>贾马拉结局</h3><p>结局1：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成）炸脖龙结局1的分支2没有达成（朱莉没继位）</p>
<p>要求：贾马拉与戴安娜、大卫各组合过1次，与莎拉组合过2次</p>
<p>戴安娜坦白她当初参与刺杀贾马拉的事情，贾马拉在其的帮助下找到了另外两个当初刺杀她的人（大卫和莎拉），并把他们用魔法锁起来了。</p>
<p>结局2：贾马拉与所罗门第一次组合时，已经与戴安娜、大卫、莎拉各组合过1次</p>
<p>要求：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 炸脖龙结局1的分支2没有达成（朱莉没继位）</p>
<p>贾马拉在所罗门的帮助下找到当初刺杀自己的三个人，并把他们用魔法锁起来了。同时为了感谢和补偿所罗门，他俩结婚了。</p>
<h3 id="黑桃结局"><a href="#黑桃结局" class="headerlink" title="黑桃结局"></a>黑桃结局</h3><p>结局1：所罗门逃离了莎拉的控制</p>
<p>炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算） 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王）</p>
<p>要求：这个条件实在太复杂了我不想思考了…</p>
<p>结局2：所罗门和莎拉相互洗脑（他发现了她对蘑菇上瘾）</p>
<p>要求：所罗门和莎拉第2次组合时，所罗门和赫拉已经组合2次了。</p>
<h3 id="约翰和朱莉的结局"><a href="#约翰和朱莉的结局" class="headerlink" title="约翰和朱莉的结局"></a>约翰和朱莉的结局</h3><p>结局1：朱莉与克劳迪斯订婚，凯瑟琳离婚了</p>
<p>要求：克劳狄斯与大卫组合4次，炸脖龙结局1的分支2没有达成（朱莉没继位） 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王） 且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算）</p>
<p>结局2：俩人私奔</p>
<p>要求：这个条件很多种组合懒得写了（是要约翰和朱莉凑够至少4份钱，给钱的一共有9种情况） 或 炸脖龙结局1的分支2达成（朱莉继位） 或 炸脖龙结局1的分支1达成（约翰继位），且 炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 克劳狄斯与大卫组合少于4次</p>
<p>该结局三个分支：</p>
<ol>
<li>炸脖龙结局1的分支2达成（朱莉继位）</li>
<li>炸脖龙结局1的分支1达成（约翰继位）</li>
<li>不符合前两条</li>
</ol>
<p>结局3：俩人相爱</p>
<p>要求：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成）, 炸脖龙结局1的分支1没有达成（约翰没继位）,炸脖龙结局1的分支2没有达成（朱莉没继位）, 约翰与乔治组合2次， 且 朱莉与乔治组合2次， 且 这个条件很多种组合懒得写了（是要约翰和朱莉没凑够4份钱，给钱的一共有9种情况）</p>
<h3 id="红心结局"><a href="#红心结局" class="headerlink" title="红心结局"></a>红心结局</h3><p>结局1：亨利被谋杀， 赫拉和乔治私奔</p>
<p>要求：赫拉与乔治组合4次</p>
<p>结局2：赫拉和乔治的私情曝光，触发女王死亡结局（见下文）</p>
<p>要求：<code>affairrevealed == 2</code> 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王）且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算）</p>
<p>结局3：亨利偷水果塔的事情曝光</p>
<p>要求：<code>investigatedJCJS == 1 and investigatedJCKH == 1 and investigatedJCJH == 1</code></p>
<h3 id="其他结局"><a href="#其他结局" class="headerlink" title="其他结局"></a>其他结局</h3><p>结局1：乔治和克劳狄斯政变，触发女王死亡结局（见下文）</p>
<p>要求：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 炸脖龙结局1的分支2没有达成（朱莉没继位） 且 炸脖龙结局1的分支1没有达成（约翰没继位）, 且 克劳狄斯与乔治组合4次， 且 魔法没通过</p>
<p>结局2：戴安娜被赶走</p>
<p>要求：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 炸脖龙结局1的分支2没有达成（朱莉没继位） 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王） 且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算）, 且<code>dianablackmail != 0</code></p>
<p>结局3：约翰去梅花王国居住</p>
<p>要求：克劳狄斯没有与所罗门、莎拉、戴安娜、赫拉各组合过一次 且 炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 克劳狄斯与大卫组合不到4次，且 这个条件很多种组合懒得写了（是要约翰和朱莉没凑够4份钱，给钱的一共有9种情况）,且 所罗门与乔治组合至少1次， 且莎拉与约翰组合至少1次， 且克劳狄斯与约翰组合至少1次</p>
<p>结局4：朱莉被训练为先知</p>
<p>要求：克劳狄斯没有与所罗门、莎拉、戴安娜、赫拉各组合过一次 且 炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且克劳狄斯与大卫组合不到4次 且 这个条件很多种组合懒得写了（是要约翰和朱莉没凑够4份钱，给钱的一共有9种情况） 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王） 且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算）, 且 朱莉与凯瑟琳、贾马拉、所罗门、莎拉各组合1次</p>
<p>结局5：黑桃和方片休战</p>
<p>要求：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成）且 炸脖龙结局1的分支2没有达成（朱莉没继位） 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王） 且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算，且 大卫与所罗门、莎拉、乔治 都至少组合1次</p>
<p>结局6：克劳狄斯和凯瑟琳婚姻咨询</p>
<p>要求：<code>johnarmed == 0</code> 且 炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） and 炸脖龙结局1的分支2没有达成（朱莉没继位）且克劳狄斯与大卫组合不到4次, <code>kingconvinced == 1 and queenconvinced == 1</code></p>
<p>结局7：红心王国开公共图书馆</p>
<p>要求：赫拉与乔治没有组合4次，且克劳狄斯与亨利组合至少1次，且大卫与亨利组合至少1次，且约翰与亨利组合至少1次，且 <code>investigatedJCKH == 0</code></p>
<h3 id="外来者结局"><a href="#外来者结局" class="headerlink" title="外来者结局"></a>外来者结局</h3><p>结局1：凯瑟琳和乔治一起跑了</p>
<p>要求：凯瑟琳与乔治组合4次</p>
<p>结局2：凯瑟琳和爱丽丝出现，赫拉心脏病发作，触发女王死亡结局（见下文）</p>
<p>要求：凯瑟琳和莎拉组合4次 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王）且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算）</p>
<p>结局3：凯瑟琳和爱丽丝跑了</p>
<p>要求：<code>therapy == 0</code>，<code>solomonthief == 2 and magicrose == 1</code></p>
<p>结局4：赫拉发现了爱丽丝，爱丽丝被杀了</p>
<p>要求：<code>solomonthief != 2 and magicrose != 1</code>,大卫与赫拉组合1次 且 亨利与赫拉组合1次 且 约翰与赫拉组合1次 且 凯瑟琳与赫拉组合1次</p>
<h3 id="兔子结局"><a href="#兔子结局" class="headerlink" title="兔子结局"></a>兔子结局</h3><p>满意值&gt;=48:</p>
<p>分支1：战争和自由贸易没通过，魔法和开放边境通过了</p>
<p>分支2：战争和自由贸易通过了，魔法和开放边境没通过</p>
<p>分支3：不满足前面两个</p>
<p>满意值&gt;=-19，且&lt;=47：</p>
<p>分支1：战争和自由贸易没通过，魔法和开放边境通过了</p>
<p>分支2：战争和自由贸易通过了，魔法和开放边境没通过</p>
<p>分支3：不满足前面两个</p>
<p>满意值&lt;=-20</p>
<p>分支1：战争和自由贸易没通过，魔法和开放边境通过了</p>
<p>分支2：不满足上面那个</p>
<h3 id="女王死亡结局"><a href="#女王死亡结局" class="headerlink" title="女王死亡结局"></a>女王死亡结局</h3><p>根据满意值不同，兔子可能会失业。</p>
<h3 id="世界结局"><a href="#世界结局" class="headerlink" title="世界结局"></a>世界结局</h3><p><code>war == 0 and magic == 0 and trade == 0 and borders == 0</code></p>
<p>“四个议题都被否定了，因此，那年仙境世界什么都没发生。”</p>
<p>“没有战争，人民生活还算太平。但是禁止魔法，贸易不自由，边境封锁，导致许多物资匮乏。”</p>
<p>“这是生活艰苦的一年。”</p>
<p><code>war == 1 and magic == 0 and trade == 0 and borders == 0</code></p>
<p>“这一年，只有战争通过了。对于仙境世界较为弱小的国家来说，生活艰难。”</p>
<p>“你必须大量学习，才能找到在这个全新的世界里生存的办法。”</p>
<p>“未来的走向应该会很有意思…”</p>
<p><code>war == 0 and magic == 1 and trade == 0 and borders == 0</code></p>
<p>“这一年，只有魔法通过了，仙境世界到处都是神奇的动物和植物。”</p>
<p>“这会是奇妙的一年…”</p>
<p><code>war == 0 and magic == 0 and trade == 1 and borders == 0</code></p>
<p>“这一年，只有自由贸易通过了，仙境世界的市场情况像坐过山车紧张刺激。”</p>
<p>“幸运的是，这一年你似乎赚得盆钵体满。”</p>
<p><code>war == 0 and magic == 0 and trade == 0 and borders == 1</code></p>
<p>“这一年，只有边境允许开放，除了四处旅行，没有什么可以打发时间的事可以做。”</p>
<p>“趁着边境开放，你和许多仙境世界的游客一样，四处旅行，欣赏美景。”</p>
<p>“这会是马不停蹄的一年！”</p>
<p><code>war == 1 and magic == 1 and trade == 0 and borders == 0</code></p>
<p>“由于通过了战争和魔法，黑桃王国逐渐站上巅峰地位。”</p>
<p>“你和许多民众都移民到了这处于胜利地位的国家。”</p>
<p>“明年还会不会举行峰会呢？没人说得准。”</p>
<p><code>war == 1 and magic == 0 and trade == 1 and borders == 0</code></p>
<p>“由于通过了战争和自由贸易，梅花王国逐渐站上巅峰地位。”</p>
<p>“红心王国被占领后，你成了胜利国接纳的难民。”</p>
<p>“如果其他国家都被征服了，也许就不会再举办任何峰会了…”</p>
<p><code>war == 1 and magic == 0 and trade == 0 and borders == 1</code></p>
<p>“随着战争和边境的开放，生活发生了翻天覆地的变化。”</p>
<p>“你不得不适应暗无天日的生活，与一群衣衫褴褛的宫殿侍卫和仆人待在一起。”</p>
<p>“明年还有可能再次召开峰会吗？”</p>
<p><code>war == 0 and magic == 1 and trade == 1 and borders == 0</code></p>
<p>“随着魔法和自由贸易的开放，蘑菇交易欣欣向荣。”</p>
<p>“有些蘑菇能让你变大，有些蘑菇能让你变小，还有一些能够增强魔法，似乎每个人都在吃蘑菇。”</p>
<p>“明年还会有人理智犹存，担起组织峰会的大任吗？”</p>
<p><code>war == 0 and magic == 1 and trade == 0 and borders == 1</code></p>
<p>“随着魔法和边界的开放，红心王国的生活顺风顺水。”</p>
<p>“每个人都对你很满意，你也成了茶会必不可少的点心师。”</p>
<p>“希望明年你还能把事情安排得这么好。”</p>
<p><code>war == 0 and magic == 0 and trade == 1 and borders == 1</code></p>
<p>“随着自由贸易和边境的开放，方片王国正在崛起。”</p>
<p>“由于你出色的组织能力，方片王国把你挖走了。”</p>
<p>“也许明年的峰会可以在这里的寒冬宫殿举行。”</p>
<p><code>war == 1 and magic == 1 and trade == 1 and borders == 0</code></p>
<p>“除了边境，其他议题都通过了。四个国家都对国家边境地区格外警戒。”</p>
<p>“对于仙境世界的所有人来说，这是个孤立贫穷的时代。围墙四起，大陆被割据成四个部分。”</p>
<p>“明年，国家之间是否还会有足够的信任，来举行峰会？”</p>
<p><code>war == 1 and magic == 1 and trade == 0 and borders == 1</code></p>
<p>“除了自由贸易，其他议题都通过了。王国陷入一片混乱。”</p>
<p>“没有一处安全之处能够落脚！”</p>
<p>“今年你能不能生存下来都是个问题。”</p>
<p><code>war == 1 and magic == 0 and trade == 1 and borders == 1</code></p>
<p>“除了魔法，其他议题都通过了，日子似乎少了点什么…”</p>
<p>“这一整年，你都躲在地洞里。”</p>
<p>“明年还会有峰会吗？峰会是什么？沟通又是什么？蛤？…”</p>
<p><code>war == 0 and magic == 1 and trade == 1 and borders == 1</code></p>
<p>“除了战争，其他议题都通过了，仙境世界的人民大多誉你为英雄。”</p>
<p>“你成为最知名的人物，久负盛誉，礼物纷至沓来。”</p>
<p>“希望将来的峰会也能进行得像今年这么顺利。”</p>
<p><code>war == 1 and magic == 1 and trade == 1 and borders == 1</code></p>
<p>“所有议题都通过了，仙境世界顿时变得忙碌了起来。”</p>
<p>“由于你的组织能力，你被推上一个举足轻重的职位——红心王国国防部长。”</p>
<p>“虽然已经能看到今年会有多艰难，但是也会很有意思。”</p>
]]></content>
      <categories>
        <category>Renpy</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>仙境之夜</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-8</title>
    <url>/2021/01/06/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-8/</url>
    <content><![CDATA[<h1 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h1><ol>
<li><p><code>flag</code>的作用是对人物或者事件进行标记，可以用在<code>if</code>或<code>trigger</code>或其他类似的地方，而其中人物对应的<code>flag</code>就是<code>character_flag</code>。</p>
</li>
<li><p>我们使用<code>add_character_flag</code>来添加一个人物标记，用<code>remove_character_flag</code>移除一个人物标记。</p>
</li>
<li><p>接下来看一个例子：有两个事件，其中事件1001有2个选项，选项a和b分别会给人物添加两个不同的<code>flag</code>，2个选项都会触发事件1002；而事件1002则有1个选项，根据事件1中的两个<code>flag</code>，该选项会显示不同的内容。那么代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace &#x3D; adventure</span><br><span class="line">adventure.1001 &#x3D; &#123;</span><br><span class="line">    type &#x3D; character_event</span><br><span class="line">	title &#x3D; adventure.1001.t1</span><br><span class="line">	desc &#x3D; adventure.1001.desc</span><br><span class="line">	theme &#x3D; adventure</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; adventure.1001.option.a</span><br><span class="line">		add_character_flag &#x3D; flag_adventure_random_1</span><br><span class="line">		trigger_event &#x3D; adventure.1002</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; adventure.1001.option.b</span><br><span class="line">		add_character_flag &#x3D; flag_adventure_random_2</span><br><span class="line">		trigger_event &#x3D; adventure.1002</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">adventure.1002 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; adventure.1002.t1</span><br><span class="line">	desc &#x3D; adventure.1002.desc1</span><br><span class="line">	theme &#x3D; adventure</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; &#123;</span><br><span class="line">			trigger &#x3D; &#123;has_character_flag &#x3D;flag_adventure_random_1&#125;</span><br><span class="line">			text &#x3D; adventure.1002.option.a</span><br><span class="line">		&#125;</span><br><span class="line">		name &#x3D; &#123;</span><br><span class="line">			trigger &#x3D; &#123;has_character_flag &#x3D; flag_adventure_random_2&#125;</span><br><span class="line">			text &#x3D; adventure.1002.option.b</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>flag</code>的基础用法大致就是这样，除了<code>character_flag</code>也还有其他类型的<code>flag</code>。</p>
</li>
</ol>
<h1 id="modifier"><a href="#modifier" class="headerlink" title="modifier"></a>modifier</h1><ol>
<li><p><code>modifier</code>可以理解为对数值的修正，和特质有点像，但结构和功能简单一些。</p>
</li>
<li><p><code>modifier</code>的基础结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modifer_key &#x3D; &#123;</span><br><span class="line">	icon &#x3D; icon_name	</span><br><span class="line">	# Effects, such as</span><br><span class="line">	# tax_mult &#x3D; 0.25</span><br><span class="line">	# county_opinion_add &#x3D; -30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>icon</code> 的文件名如果以<code>positive</code>或<code>negative</code>结尾，则该<code>modifier</code>的颜色会有相应的变化（指游戏里那行字的颜色），例如<code>diplomacy_positive</code>和<code>diplomacy_negative</code>。</p>
</li>
<li><p>在写好一个<code>modifier</code>之后，我们可以使用<code>add_character_modifier = XXX</code>来给角色添加<code>modifier</code>，使用<code>has_character_modifier = XXX</code>来判断角色是否有该<code>modifier</code>，使用<code>remove_character_character_modifier = XXX</code>来移除一个角色的某个<code>modifier</code>。在添加的时候，可以加时间字段来限制该<code>modifier</code>的持续时间，前面部分中的<code>flag</code>也是同样的用法。</p>
</li>
<li><p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># modifier file</span><br><span class="line">adventure_diplomacy_add_modifier &#x3D; &#123;</span><br><span class="line">	icon &#x3D; diplomacy_positive</span><br><span class="line">	diplomacy &#x3D; 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># event file</span><br><span class="line">trigger &#x3D; &#123;</span><br><span class="line">	has_character_flag &#x3D; flag_adventure_diplomacy</span><br><span class="line">	NOT &#x3D; &#123; has_character_modifier &#x3D; adventure_diplomacy_add_modifier &#125;</span><br><span class="line">&#125;</span><br><span class="line">send_interface_message &#x3D; &#123;</span><br><span class="line">	type &#x3D; adventure_success_type</span><br><span class="line">	add_character_modifier &#x3D; &#123;</span><br><span class="line">		modifier &#x3D; adventure_diplomacy_add_modifier</span><br><span class="line">		years &#x3D; 20</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>modifier</code>的作用是让角色外交+2，在事件中，判断该角色有相应的<code>flag</code>且没有该<code>modifier</code>时，就给角色增加该<code>modifier</code>，且持续20年。</p>
</li>
<li><p>需要注意的是，我们无法在mod中直接修改角色的健康，只能通过<code>trait</code>或者<code>modifier</code>这样的方式来修改；类似地，角色的五个属性值也不能直接通过<code>diplomacy = 1</code>或者<code>add_diplomacy = 1</code>这样的方式来改，而是要通过<code>trait</code>或<code>modifier</code>修正（实际上，一定要改角色的属性值时，可以使用<code>add_diplomacy_skill = 1</code>这样的代码，但是一般不建议这么做，因为这样改完全看不出来数值是因为什么事件发生了变化，也不利于后续取消这个改变）。</p>
</li>
</ol>
<h1 id="customizable-localization"><a href="#customizable-localization" class="headerlink" title="customizable_localization"></a>customizable_localization</h1><ol>
<li><p>起因是想了解如何随机显示出现的文字，例如某事件的标题随机显示。试图使用<code>random_list</code>等方式都没用，在论坛提问以后大佬告诉我可以用<code>customizable_localization</code>来实现。学习了一下大致写法如下。</p>
</li>
<li><p>首先，文件夹路径是<code>Crusader Kings III\game\common\customizable_localization</code>，该文件夹中有很多已经写好的文件。</p>
</li>
<li><p>其次，相关的本地化文件夹路径是<code>Crusader Kings III\game\localization\simp_chinese\custom_localization</code>。</p>
</li>
<li><p>一个普通的<code>customizable_localization</code>文件格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YourCustomLoc &#x3D; &#123;</span><br><span class="line">    type &#x3D; character </span><br><span class="line">    random_valid &#x3D; yes</span><br><span class="line">    text &#x3D; &#123;</span><br><span class="line">        trigger &#x3D; &#123;  </span><br><span class="line">            your_triggers &#x3D; yes</span><br><span class="line">        &#125;</span><br><span class="line">        localization_key &#x3D; title_1</span><br><span class="line">    &#125;</span><br><span class="line">    text &#x3D; &#123;</span><br><span class="line">        trigger &#x3D; &#123;  </span><br><span class="line">            your_triggers &#x3D; no</span><br><span class="line">        &#125;</span><br><span class="line">        localization_key &#x3D; title_2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>type</code>可以有其他选项，具体选项在<code>CUSTOM_LOC_README.txt</code>文件中列出了。</p>
<p><code>random_valid</code>表示随机选，如果去掉这行就不随机了，而是按顺序第一个满足条件的文本。</p>
<p>接下来的<code>text</code>块就是待选的随机文本，其中<code>trigger</code>是该文本的触发条件，如果没有条件则可以不写<code>trigger</code>块。<code>localization_key</code>所对应的文字是在前面第3条提到的路径中。</p>
</li>
<li><p>在使用该随机文本的时候，例如我们要让某事件的标题随机出现，则把该标题所对应的本地化字符串写成<code>&quot;[ROOT.Char.Custom(&#39;YourCustomLoc&#39;)]&quot;</code></p>
</li>
<li><p>具体来看一个例子：</p>
<ol>
<li><p><code>common\customizable_localization\00_test_random_loc.txt</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YourCustomLoc &#x3D; &#123;</span><br><span class="line">    type &#x3D; character</span><br><span class="line">    random_valid &#x3D; yes</span><br><span class="line">    text &#x3D; &#123;</span><br><span class="line">        localization_key &#x3D; title_1</span><br><span class="line">    &#125;</span><br><span class="line">    text &#x3D; &#123;</span><br><span class="line">        localization_key &#x3D; title_2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>localization\simp_chinese\custom_localization\test_random_loc_l_simp_chinese.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> title_1:0 &quot;大胆&quot;</span><br><span class="line"> title_2:0 &quot;善心&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>events\adventure_events\adventure_events.txt</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adventure.1001 &#x3D; &#123;</span><br><span class="line">    type &#x3D; character_event</span><br><span class="line">	title &#x3D; adventure.1001.t1</span><br><span class="line">	desc &#x3D; adventure.1001.desc</span><br><span class="line">	theme &#x3D; adventure</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; adventure.1001.option.a</span><br><span class="line">		add_character_flag &#x3D; flag_adventure_random_1</span><br><span class="line">		trigger_event &#x3D; adventure.1002</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; adventure.1001.option.b</span><br><span class="line">		add_character_flag &#x3D; flag_adventure_random_2</span><br><span class="line">		trigger_event &#x3D; adventure.1002</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; adventure.1001.option.c</span><br><span class="line">		trigger_event &#x3D; adventure.1003</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>localization\simp_chinese\event_localization\adventure\adventure_l_simp_chinese.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> adventure.1001.t1:0 &quot;[ROOT.Char.Custom(&#39;YourCustomLoc&#39;)]&quot;</span><br><span class="line"> adventure.1001.desc:0 &quot;氪金可以获得更好的体验&quot;</span><br><span class="line"> adventure.1001.option.a:0 &quot;我相信上天会为我选择最合适的道路！&quot;</span><br><span class="line"> adventure.1001.option.b:0 &quot;我相信我的能力，命运掌握在我自己手中！&quot;</span><br><span class="line"> adventure.1001.option.c:0 &quot;人的能力是有极限的，我要充钱变强！&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>写好这些文件以后，游戏中通过<code>event adventure.1001</code>触发该事件，可以看到标题会随机显示为<code>大胆</code>或者<code>善心</code>。</p>
</li>
<li><p>类似地，<code>desc</code>部分也可以这样写。此外，除了<code>[ROOT.Char.Custom(&#39;YourCustomLoc&#39;)]</code>这样的写法，也还有其他类型的写法，具体可以参考游戏本体文件中的内容。</p>
</li>
</ol>
</li>
</ol>
<h1 id="message"><a href="#message" class="headerlink" title="message"></a>message</h1><ol>
<li><p><code>message</code>是指游戏右下角弹出的那个信息提示，或者屏幕上半部分的中间弹出的那个横幅。</p>
</li>
<li><p>代码基础结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_message &#x3D; &#123;</span><br><span class="line">	display &#x3D; (feed|toast)		# where to display the message; default: feed</span><br><span class="line">	text &#x3D; some_loc_key			# string to be used in the message; default: same as message key (e.g &quot;my_message&quot; in this example)</span><br><span class="line">	desc &#x3D; some_loc_key			# string that gives more info about what happened</span><br><span class="line">	tooltip &#x3D; some_loc_key		# string to be used for tooltip of type(optional); default: no tooltip</span><br><span class="line">	soundeffect &#x3D; sound_name	# sound effect played when showing the message (optional); default: no sound</span><br><span class="line">	icon &#x3D; &quot;texture.dds&quot;		# icon textures found in gfx\interface\message_icons</span><br><span class="line">	style &#x3D; good&#x2F;bad&#x2F;neutral	# neutral is default, affects the look of message items</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一行的<code>display</code>如果是<code>feed</code>，则信息是右下角的形式；如果是<code>toast</code>，则信息是中间横幅的形式；默认值是<code>feed</code>；</p>
<p>第二行是该信息的标题文本，默认是信息本身的关键字段，例如这里的<code>my_message</code>；</p>
<p>第三行是改信息的描述文本；</p>
<p>接下来是该信息的工具栏提示文本；</p>
<p>最后三行分别是音效、图标和类型，图标的路径在<code>gfx\interface\message_icons</code>，类型的设置会影响信息框的颜色外观。</p>
</li>
<li><p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_message_type &#x3D; &#123;</span><br><span class="line">	display &#x3D; feed</span><br><span class="line">	title &#x3D; &quot;My Title&quot;</span><br><span class="line">	desc &#x3D; &quot;My $EFFECT$&quot;</span><br><span class="line">	tooltip &#x3D; &quot;My Tooltip&quot;</span><br><span class="line">	soundeffect &#x3D; &quot;blah.audio&quot;</span><br><span class="line">	icon &#x3D; &quot;nice.dds&quot;</span><br><span class="line">	style &#x3D; good</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">send_interface_message &#x3D; &#123;</span><br><span class="line">	type &#x3D; my_message_type</span><br><span class="line">	add_gold &#x3D; 50</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<script type="math/tex">EFFECT</script>的写法表示该信息的文本描述是实际造成的效果，比如这里是钱增加50。这样写的一个好处就是，类似的事件可以共用同一个<code>message_type</code>，而不用针对每个事件都写一个新的。上述这个例子所弹出的信息提示如下：</p>
<pre><code>Title = My Title
Description = My Add 50 Gold
Tooltip = My Tooltip
</code></pre></li>
<li><p>第二个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">send_interface_message &#x3D; &#123;</span><br><span class="line">	type &#x3D; my_message_type</span><br><span class="line">	desc &#x3D; &#123;</span><br><span class="line">		desc &#x3D; &quot;My Start Line&quot;</span><br><span class="line">		desc &#x3D; linebreak</span><br><span class="line">		desc &#x3D; &quot;My $EFFECT$&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	title &#x3D; &quot;My Cooler Title&quot;</span><br><span class="line">	tooltip &#x3D; &quot;$DESCRIPTION$&quot;</span><br><span class="line">	add_gold &#x3D; 50</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仍然使用刚才的<code>message_type</code>，但是在调用的时候指定了<code>desc</code>、<code>title</code>和<code>tooltip</code>这3个字段，则输出的信息中的3个字段会替换为指定的内容，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Title &#x3D; My Cooler Title</span><br><span class="line">Description &#x3D; My Start Line \n My Add 50 Gold</span><br><span class="line">Tooltip &#x3D; My Start Line \n My Add 50 Gold</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Strategic Information Revelation in Crowdsourcing Systems Without Verification</title>
    <url>/2020/12/25/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Strategic%20Information%20Revelation%20in%20Crowdsourcing%20Systems%20Without%20Verification/</url>
    <content><![CDATA[<h1 id="Strategic-Information-Revelation-in-Crowdsourcing-Systems-Without-Verification"><a href="#Strategic-Information-Revelation-in-Crowdsourcing-Systems-Without-Verification" class="headerlink" title="Strategic Information Revelation in Crowdsourcing Systems Without Verification"></a>Strategic Information Revelation in Crowdsourcing Systems Without Verification</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ol>
<li>本文研究：无需验证解决方案、激励员工提供高质量解决方案的众包平台</li>
<li>本文假设：信息不对称、平台具有信息优势——平台知道有关workers解决方案的平均准确性的更多信息，可以向workers策略性披露信息。根据平台公开的信息，workers判断自己认真完成任务后所获得的奖励。</li>
<li>workers类型：<ol>
<li>naive workers：完全信任平台公开的信息</li>
<li>strategic workers：基于平台公开信息更新自己的先验信念</li>
</ol>
</li>
<li>本文发现：<ol>
<li>对于naive workers：始终宣布高平均精度</li>
<li>对于strategic workers：有动机宣布低于实际值的平均精度</li>
<li>平台的回报可能减少高精度workers </li>
</ol>
</li>
</ol>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ol>
<li>互联网的发展使得多种在线任务的众包具有可行性。</li>
<li>高质量的众包任务解决方案需要worker付出足够的努力，因此平台需要提供激励；而平台无法获取真实结果验证解决方案时，设计激励方案会很难，进而引出IEWV问题。</li>
<li>IEWV(Information elicitation without verification)：未验证的信息挖掘，大多数研究对称信息场景；而实际上，平台往往有更多信息。</li>
<li>本文采用多数投票方案：如果一个worker与其他workers的大多数解决方案相匹配，他将获得一个一致性奖励。</li>
<li>本文假设平台有一个额外决策：信息披露。该场景中，workers由高精度和低精度的混合构成，平台知道每种类型的数量，而workers不知道。</li>
<li>本文研究：<ol>
<li>平台是否有披露信息的动机</li>
<li>平台是否操纵被披露的信息</li>
<li>平台的最优信息披露策略——&gt;平台如何利用信息不对称</li>
</ol>
</li>
<li>平台与workers之间的交互（三阶段）：<ol>
<li>平台决定信息披露策略</li>
<li>平台决定一致性奖励</li>
<li>workers决定是否努力完成任务以及是否如实报告解决方案</li>
<li>上述三阶段结束后，平台收集workers上报的解决方案并根据三阶段来决定一致性奖励</li>
</ol>
</li>
<li>本文考虑两种类型的workers：<ol>
<li>naive workers：完全相信平台、workers推理平台公开信息是否可靠的能力有限，可以作为基准</li>
<li>strategic workers：不相信平台，有很高推理能力</li>
</ol>
</li>
</ol>
<h3 id="Key-Contributions"><a href="#Key-Contributions" class="headerlink" title="Key Contributions"></a>Key Contributions</h3><ol>
<li>研究IEWV问题的策略性信息披露：非凸问题，但是可以利用特殊结构求最优解</li>
<li>workers的均衡策略：证明workers之间存在多重均衡，在适当的信息披露和报酬设计下，所有workers努力工作并如实报告自己解决方案是其帕累托最优</li>
<li>平台信息披露策略：<ol>
<li>naive workers：始终公布一个与实际值无关的较高的平均准确率</li>
<li>strategic workers：有动机公布一个低于实际值的平均准确率</li>
</ol>
</li>
<li>性能评估：数值实验<ol>
<li>平台报酬增加了workers对高准确率workers数量的先验信念</li>
<li>平台报酬可能会减小高准确率workers的数量</li>
</ol>
</li>
</ol>
<h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><h3 id="Information-Elicitation-Without-Verification-IEWV"><a href="#Information-Elicitation-Without-Verification-IEWV" class="headerlink" title="Information Elicitation Without Verification(IEWV)"></a>Information Elicitation Without Verification(IEWV)</h3><ol>
<li>设计适当的激励</li>
<li>同伴预测</li>
<li>大都假设信息对称</li>
</ol>
<h3 id="Strategic-Information-Revelation"><a href="#Strategic-Information-Revelation" class="headerlink" title="Strategic Information Revelation"></a>Strategic Information Revelation</h3><ol>
<li>不完全信息中的cheap talk问题——假设平台不会说谎</li>
<li>考虑信息获取和揭示代价的劝说博弈——认为信息披露是唯一的决策</li>
</ol>
<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><h3 id="Workers’-Decisions-and-Payoffs"><a href="#Workers’-Decisions-and-Payoffs" class="headerlink" title="Workers’ Decisions and Payoffs"></a>Workers’ Decisions and Payoffs</h3><ol>
<li>任务和workers：<ol>
<li>任务：二值问题，例如判断数学问题求解方案是否正确，解空间<code>{1， -1}</code>，分别表示正确和错误。</li>
<li>workers：$N$个，$x_i^{estimate}$表示第$i$个worker对该任务解的估计值，$x_i^{report}$表示第$i$个worker对该任务解的上报值，这二者可能一样也可能不同。</li>
</ol>
</li>
<li>workers的努力策略：<ol>
<li>worker可以决定是否努力工作，求解准确性和他选择的努力程度有关，努力程度为<code>{0,1}</code>两种。<ol>
<li>努力程度为0时，worker求解准确率为0.5，代价为0，且无法获取关于任务解方案的任何信息（即其估计值为真或假的概率相等）</li>
<li>努力程度为1时，其求解准确率会提高为$p_i$，代价为$c$。</li>
</ol>
</li>
<li>workers的异构：$N$个workers中有$k$个高准确率的worker（准确率为$p_h$）使用集合$N_h$表示；$N-k$个低准确率的worker（准确率为$p_l$），使用集合$N_l$表示。两个准确率值均大于0.5小于1。</li>
</ol>
</li>
<li>worker的上报策略：<ol>
<li>对于不努力的worker：策略唯一，随机上报，用<code>rd</code>表示</li>
<li>对于努力的worker：策略空间<code>{1,-1}</code>，分别表示如实报告和谎报</li>
<li>workers可以共谋，大家都报告1或者-1，但对于在线众包系统，这样的共谋并不现实；平台检测到共谋则会删除该worker，因此认为workers的报告策略是独立的，且只有<code>{rd,1,-1}</code>这三个选项。</li>
<li>$s_i=(e_i,r_i)$表示第$i$个worker的努力策略和报告策略，具体来说$s_i\in S_i=\{(0,rd),(1,1),(1,-1)\}$</li>
</ol>
</li>
<li>一致性奖励：<ol>
<li>报告值和大多数人一样的worker可以得到奖励$R$。</li>
<li>$G_i(s;\epsilon)$表示第$i$个worker收到$R$的概率，其中，$s=(e_i,r_i)$，$\epsilon$是平台策略，在后面进行分析。</li>
</ol>
</li>
<li>worker的收益：$u_i(s;\epsilon,R)=G_i(s;\epsilon)\cdot R-e_i\cdot c$</li>
</ol>
<h3 id="Platform’s-Decisions-and-Payoff"><a href="#Platform’s-Decisions-and-Payoff" class="headerlink" title="Platform’s Decisions and Payoff"></a>Platform’s Decisions and Payoff</h3><ol>
<li><p>平台的信息披露策略：</p>
<ol>
<li><p>平台拥有的信息优势：workers求解准确率的分布，也就是高准确率workers的数量$k$</p>
</li>
<li><p>平台和workers之间非对称信息披露的贝叶斯说服框架：</p>
<ol>
<li><p>平台和workers都不知道$k$，平台需要进行长期信息披露策略：</p>
<ol>
<li><p>平台虽然不知道$k$，但是知道$k$的分布，从而得到先验信念$\mu^{prior}=(\mu_{high}^{prior},\mu_{low}^{prior})$，其中$\mu_{high}^{prior}=Pr(k=k^{high})$，$\mu_{low}^{prior}=Pr(k=k^{low})$。$\mu_{high}^{prior}+\mu_{low}^{prior}=1$，且$k^{high}$和$k^{low}$是$k$的两个可能取值。</p>
</li>
<li><p>这个先验同时也是workers的，大家都一样。</p>
</li>
<li><p>注意，出于简化，上述公式中$k$的分布是两点分布，本方法同样适用于其他分布的情况。</p>
</li>
<li><p>在$k$被发现之前，平台会预定一个信息披露策略（？是否公开——从后文看是公开的，或者说是workers能发现其规律）。</p>
</li>
<li><p>平台可以有多个任务，每个任务有各自对应的$k$，在workers到来之前（也即是在$k$被发现之前），平台会先决定信息披露策略，并承诺会按这个策略执行，从而建立良好信誉。</p>
</li>
<li><p>$\epsilon = (\epsilon^h, \epsilon^l)\in [0,1]^2$：平台的信息披露策略。假设当$k=k^{low}$时，平台宣称$k_p^{anu}=k^{high}$的概率是$\epsilon^h$，而反之，当$k=k^{high}$时，平台宣称$k_p^{anu}=k^{low}$的概率是$\epsilon^l$。</p>
</li>
<li><p>总结一下就是平台会按下列概率决策：</p>
<p>$Pr(k_p^{anu}=k^{high}|k=k^{low})=\epsilon^h$</p>
<p>$Pr(k_p^{anu}=k^{low}|k=k^{low})=1-\epsilon^h$</p>
<p>$Pr(k_p^{anu}=k^{high}|k=k^{high})=1-\epsilon^l$</p>
<p>$Pr(k_p^{anu}=k^{low}|k=k^{high})=\epsilon^l$</p>
<p>即：k有两个取值，一个high，一个low，当真实的k是high时，平台说谎的概率是$\epsilon^l$；当真实的k是low时，平台说谎的概率是$\epsilon^h$。</p>
</li>
</ol>
</li>
<li><p>workers执行任务，平台观察到$k$，workers尚且不知道；</p>
</li>
<li><p>平台依据之前决定的策略公开$k_p^{anu}$，可能和真实$k$不同，平台决定的$\epsilon$会影响workers对$k$的后验信念，从而影响平台的信誉和收益。</p>
</li>
<li><p>workers可以通过重复与平台交互从而了解平台的信息披露策略，也可以通过平台反馈以及信誉系统来了解信息披露策略。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>平台的奖励设计策略：$R$，决定worker均衡收益</p>
</li>
<li><p>平台的收益：准确率和代价之间的均衡</p>
<p>$U_p(\epsilon,R,k;s)=\beta P_a(\epsilon,R,k;s)-E\{R^{tot}(\epsilon,R,k;s)\}$</p>
<ol>
<li>$P_a(\epsilon,R,k;s)$表示workers的任务聚合准确率，使用少数服从多数的规则来计算该概率。</li>
<li>$\beta$表示平台对聚合准确率的估值（从公式上理解感觉更像是说当聚合结果是正确的时候所得到的收益）</li>
<li>$E\{R^{tot}(\epsilon,R,k;s)\}$表示对总的一致性奖励的预期支出（这里的$R^{tot}$是指什么？）</li>
</ol>
</li>
</ol>
<h2 id="SOLVING-THREE-STAGE-MODEL"><a href="#SOLVING-THREE-STAGE-MODEL" class="headerlink" title="SOLVING THREE-STAGE MODEL"></a>SOLVING THREE-STAGE MODEL</h2><p>本章节使用逆向归纳法，仅分析strategic worker。</p>
<h3 id="Worker-Equilibrium-Behaviors-in-Stage-III"><a href="#Worker-Equilibrium-Behaviors-in-Stage-III" class="headerlink" title="Worker Equilibrium Behaviors in Stage III"></a>Worker Equilibrium Behaviors in Stage III</h3><ol>
<li><p>前提：给定平台策略$\epsilon$和$R$，每个worker选择自己的努力程度和报告策略$s_i$来最大化自身收益</p>
</li>
<li><p>worker的信念更新：平台公布$k_p^{anu}$之前，workers有对$k$的先验信念$\mu^{prior}$（是每人一个还是所有worker共用？）</p>
<ol>
<li><p>平台公布$k_p^{anu}$后，workers基于先验信念和平台公布值更新后验信念$\mu_w^{post,str}|k_p^{anu}$，其中$w\in \{high,low\}$。计算如下：</p>
<script type="math/tex; mode=display">
\mu_{high}^{post,str}|k^{high}(\epsilon)=\frac{(1-\epsilon^l)\mu_{high}^{prior}}{(1-\epsilon^l)\mu_{high}^{prior}+\epsilon^h\mu_{low}^{prior}}</script><script type="math/tex; mode=display">
\mu_{low}^{post,str}|k^{high}(\epsilon)=\frac{\epsilon^h\mu_{low}^{prior}}{(1-\epsilon^l)\mu_{high}^{prior}+\epsilon^h\mu_{low}^{prior}}</script><script type="math/tex; mode=display">
\mu_{high}^{post,str}|k^{low}(\epsilon)=\frac{\epsilon^l\mu_{low}^{prior}}{\epsilon^l\mu_{high}^{prior}+(1-\epsilon^h)\mu_{low}^{prior}}</script><script type="math/tex; mode=display">
\mu_{low}^{post,str}|k^{low}(\epsilon)=\frac{(1-\epsilon^h)\mu_{low}^{prior}}{\epsilon^l\mu_{high}^{prior}+(1-\epsilon^h)\mu_{low}^{prior}}</script><p>推导过程用到了<a href="https://zhuanlan.zhihu.com/p/134036707" target="_blank" rel="noopener">贝叶斯公式</a>。</p>
<p>前两行表示平台宣布$k=k^{high}$时，worker对$k$实际值的后验信念；后两行表示平台宣布$k=k^{low}$时，worker对$k$实际值的后验信念。</p>
</li>
<li><p>显然，第一个公式里，随着$\epsilon^h$的增加，workers对k为high的后验信念逐渐减小，也就是说，如果平台在k实际为low时说谎的概率增加，则workers在听到平台说k为high时，会怀疑平台说谎；类似地，在第四个公式中，随着$\epsilon^l$的增加，workers对k为low的后验信念逐渐减小，也就是说，如果平台在k实际为high时说谎的概率增加，则workers在听到平台说k为low时，会怀疑平台，进而减小后验信念。</p>
</li>
</ol>
</li>
<li><p>worker的均衡策略：worker根据后验信念做出是否努力以及是否如实汇报的决策，本文关注对称纳什均衡——相同类型（任务求解准确率）的worker会有相同的决策。</p>
<ol>
<li><p>定义1：</p>
<ol>
<li>$n-SNE$：$(s_i^*=(0,rd), \forall i\in N)$，没有worker会努力和如实报告</li>
<li>$f-SNE$：$(s_i^*=(1,1), \forall i\in N)$， 所有worker都努力和如实报告</li>
<li>$p-SNE$：$(s_i^<em>=(1,1), \forall i\in N_h, s_j^</em>=(0,rd), \forall j\in N_l)$，高准确率的worker会努力和如实报告，低准确率的worker会不努力和随机报告</li>
</ol>
</li>
<li><p>定理1：</p>
<ol>
<li>给定任意$\epsilon\in [0,1]^2$，$R\geq 0$时一定存在一个$n-SNE$.</li>
<li>给定任意$\epsilon\in [0,1]^2$，始终存在阈值$R_f^{str}(\epsilon, k_p^{anu})&gt; 0$，使得当且仅当$R&gt;R_f^{str}(\epsilon,k_p^{anu})$时存在$f-SNE$.</li>
<li>当$\epsilon\in \Phi=\{\epsilon\in [0,1]^2|condition (11) \}$成立时，存在两个阈值$0&lt;R_{pl}^{str}(\epsilon,k_p^{anu})\leq R_{ph}^{str}(\epsilon, k_p^{anu})$，使得当且仅当$R_{pl}^{str}(\epsilon,k_p^{anu})\leq R \leq R_{ph}^{str}(\epsilon, k_p^{anu})$时，存在$p-SNE$. $condition (11)$如下：</li>
</ol>
<script type="math/tex; mode=display">
\frac{2p_h-1}{2p_l-1}(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}-1}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}-1}^{majority})\geq \mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority} \tag{11}</script><p>​        在该公式中，$P_{k^{high}-1}^{majority}$是指：当$k^{high}-1$个高准确率workers决定采取策略$(1,1)$且剩下的其他workers都决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>​        $P_{k^{low}-1}^{majority}$是指：当$k^{low}-1$个高准确率workers决定采取策略$(1,1)$且剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>​        $P_{k^{high}}^{majority}$是指：$k^{high}$个高准确率worker决定采取策略$(1,1)$，剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>​        $P_{k^{low}}^{majority}$是指：$k^{low}$个高准确率worker决定采取策略$(1,1)$，剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>​        这个公式算起来很复杂，它表达的场景是：当选择努力时，高准确率worker相信他们更有可能拿到奖励（而不是低准确率worker），也就是说高准确率worker认为自己是大多数的那部分。反之，当这个公式不满足时，高准确率worker会觉得自己拿到奖励的概率很低，从而使得高准确率worker的期望收益很低。此时，高准确率worker不会努力，而是选择降低成本，进而不存在$p-SNE$。</p>
</li>
</ol>
</li>
<li><p>推论1：</p>
<ol>
<li><p>对于一个固定的$\epsilon^l$，如果$k_p^{anu}=k^{high}$，则定理1中的$R_f^{str}(\epsilon,k_p^{anu})$和$R_{pl}^{str}(\epsilon,k_p^{anu})$随$\epsilon^h$增加而增加；反之，如果$k_p^{anu}=k^{low}$，则这两个都随$\epsilon^h$增加而减小。</p>
<p>说明：如果平台更喜欢把$k_p^{anu}$谎报成$k^{high}$（也就是说在$k^{low}$时说谎），那么为了达成$f-SNE$和$p-SNE$，平台需要提供更高报酬（也就是更大的$R$）。分析原因：这种情况会让workers觉得实际的$k$并不是$k^{high}$而是$k^{low}$，也就是说$\mu_{high}^{post,str}|k^{high}(\epsilon)$会减小，因此通过多数一致获得的奖励会减少，而为了激励workers，平台就需要提高奖励，从而提高workers的期望收益。</p>
</li>
<li><p>对于一个固定的$\epsilon^h$，如果$k_p^{anu}=k^{high}$，则定理1中的$R_f^{str}(\epsilon,k_p^{anu})$和$R_{pl}^{str}(\epsilon,k_p^{anu})$随$\epsilon^l$增加而增加；反之，如果$k_p^{anu}=k^{low}$，则这两个都随$\epsilon^l$增加而减小。</p>
<p>说明：如果平台更喜欢把$k_p^{anu}$谎报成$k^{low}$（也就是说在$k^{high}$时说谎），那么为了达成$f-SNE$和$p-SNE$，平台也一样需要提高报酬来激励。这里的推导可以看前面workers更新后验信念那里的公式来理解。</p>
</li>
<li><p>对于适当的$\epsilon$和$R$，定理1中的几个不同的$SNE$可以共存。</p>
</li>
</ol>
</li>
<li><p>定理2：帕累托最优：对于任意给定$\epsilon$和$R$，workers之间存在一个帕累托最优均衡解。</p>
<p>本文假设当多个均衡解共存时，workers会选择帕累托最优。</p>
</li>
</ol>
<h3 id="Platform-Reward-Design-in-Stage-II"><a href="#Platform-Reward-Design-in-Stage-II" class="headerlink" title="Platform Reward Design in Stage II"></a>Platform Reward Design in Stage II</h3><p>这一部分分析对于给定的$\epsilon$，平台观察$k$并决定$R$，从而在第三阶段达到帕累托最优。</p>
<ol>
<li><p>定义2：$z\in \{n,f,p\}$表示均衡解索引</p>
<ol>
<li><p>$P_z(k)$：均衡$z-SNE$的任务聚合准确率</p>
</li>
<li><p>$E\{R_z^{tot}(\epsilon,k,k_p^{anu})\}$：均衡$z-SNE$的总期望一致性奖励</p>
</li>
<li><p>$B_z(\epsilon,k,k_p^{anu})$：对于每单位$R$，均衡解从$n-SNE$提升到$z-SNE$所带来的平均准确率的提升，计算方式如下：</p>
<script type="math/tex; mode=display">
B_z(\epsilon,k,k_p^{anu})=\frac{P_z(k)-P_n(k)}{E\{R_z^{tot}(\epsilon,k,k_p^{anu})\}}</script></li>
</ol>
</li>
<li><p>定理3：</p>
<ol>
<li><p>如果$(11)$成立且$B_p(\epsilon,k,k_p^{anu})&gt;B_f(\epsilon,k,k_p^{anu})$，则平台的最优奖励为：</p>
<script type="math/tex; mode=display">
R^*=\left\{
\begin{aligned}
&0, &if \ \ \beta<\frac{1}{B_p(\epsilon,k,k_p^{anu})}\\
&R_{pl}^{str}(\epsilon,k_p^{anu}), &if\ \ \frac{1}{B_p(\epsilon,k,k_p^{anu})} \leq \beta<\widetilde\beta(\epsilon,k,k_p^{anu}) \\
&R_{f}^{str}(\epsilon,k_p^{anu}), &if\ \ \beta\geq \widetilde\beta(\epsilon,k,k_p^{anu})
\end{aligned}
\right.</script><p>其中，$\widetilde\beta(\epsilon,k,k_p^{anu})=\frac{E\{R_f^{tot}(\epsilon,k,k_p^{anu})-E\{R_p^{tot}(\epsilon,k,k_p^{anu})}{P_f(k)-P_p(k)}$</p>
</li>
<li><p>如果$(11)$不成立或者$B_p(\epsilon,k,k_p^{anu})&lt;B_f(\epsilon,k,k_p^{anu})$，则平台的最优奖励为：</p>
<script type="math/tex; mode=display">
R^*=\left\{
\begin{aligned}
&0, &if \ \ \beta<\frac{1}{B_f(\epsilon,k,k_p^{anu})}\\
&R_{f}^{str}(\epsilon,k_p^{anu}), &if\ \ \beta\geq \frac{1}{B_f(\epsilon,k,k_p^{anu})}
\end{aligned}
\right.</script><p>注意，$(11)$是达到$p-SNE$所必须的条件。</p>
</li>
</ol>
</li>
<li><p>定理3说明了：</p>
<ol>
<li>如果$p-SNE$存在，且它比$f-SNE$的单位收益准确率提升更高，且平台的估值$\beta$是温和的，平台会通过选择$R^*=R_{pl}^{str}(\epsilon,k_p^{anu})$引出$p-SNE$作为第三阶段的帕累托均衡来最大化自己的收益。</li>
<li>如果$p-SNE$不存在，或者它比$f-SNE$的单位收益准确率提升低，那么$p-SNE$对平台而言就不是最好的均衡解。当$\beta$很大时，平台会通过选择$R^*=R_f^{str}(\epsilon,k_p^{anu})$引出$f-SNE$作为第三阶段的帕累托最优。</li>
</ol>
</li>
</ol>
<h3 id="Platform-Information-Revelation-in-Stage-I"><a href="#Platform-Information-Revelation-in-Stage-I" class="headerlink" title="Platform Information Revelation in Stage I"></a>Platform Information Revelation in Stage I</h3><p>这一部分讨论平台的信息披露策略。在该阶段中，平台决定自己的信息披露策略$\epsilon = (\epsilon^h,\epsilon^l)\in[0,1]^2$，并预测自己在第二阶段中的$R$和workers在第三阶段中的帕累托均衡。</p>
<p>重复一下前文的符号表示：</p>
<blockquote>
<p>$\epsilon = (\epsilon^h, \epsilon^l)\in [0,1]^2$：平台的信息披露策略。假设当$k=k^{low}$时，平台宣称$k_p^{anu}=k^{high}$的概率是$\epsilon^h$，而反之，当$k=k^{high}$时，平台宣称$k_p^{anu}=k^{low}$的概率是$\epsilon^l$。</p>
<p>总结一下就是平台会按下列概率决策：</p>
<p>$Pr(k_p^{anu}=k^{high}|k=k^{low})=\epsilon^h$</p>
<p>$Pr(k_p^{anu}=k^{low}|k=k^{low})=1-\epsilon^h$</p>
<p>$Pr(k_p^{anu}=k^{high}|k=k^{high})=1-\epsilon^l$</p>
<p>$Pr(k_p^{anu}=k^{low}|k=k^{high})=\epsilon^l$</p>
<p>即：k有两个取值，一个high，一个low，当真实的k是high时，平台说谎的概率是$\epsilon^l$；当真实的k是low时，平台说谎的概率是$\epsilon^h$。</p>
</blockquote>
<ol>
<li><p>定理4：对平台而言，设置为$\epsilon^h=1,\epsilon^l=0$并不总是最优解。</p>
<p>换言之，宣称$k_p^{anu}=k^{high}$并不总是最好的，具体分析如下：</p>
<p>首先，复习内容：$k$的真实值影响第2阶段中的奖励设计，而平台对$k$的宣称值$k_p^{anu}$影响第3阶段中workers的行为。考虑一下4种情况：</p>
<ol>
<li>Case $(h,h)$: $k=k^{high}$ 且 $k_p^{anu}=k^{high}$，出现概率$Q_{h,h}(\epsilon)=\mu_{high}^{prior}(1-\epsilon^l)$</li>
<li>Case $(h,l)$: $k=k^{high}$ 且 $k_p^{anu}=k^{low}$，出现概率$Q_{h,l}(\epsilon)=\mu_{high}^{prior}\epsilon^l$</li>
<li>Case $(l,h)$: $k=k^{low}$ 且 $k_p^{anu}=k^{high}$，出现概率$Q_{l,h}(\epsilon)=\mu_{low}^{prior}\epsilon^h$</li>
<li>Case $(l,l)$: $k=k^{low}$ 且 $k_p^{anu}=k^{low}$，出现概率$Q_{l,l}(\epsilon)=\mu_{low}^{prior}(1-\epsilon^h)$</li>
</ol>
<p>固定$\epsilon^l$，平台的期望收益为：</p>
<script type="math/tex; mode=display">
E\{U_p(\epsilon^h)\}=Q_{h,h}(\epsilon^h)U_{h,h}(\epsilon^h)+Q_{h,l}(\epsilon^h)U_{h,l}(\epsilon^h)+Q_{l,h}(\epsilon^h)U_{l,h}(\epsilon^h)+Q_{l,l}(\epsilon^h)U_{l,l}(\epsilon^h)</script><p>$U_{h,h}$表示在Case $(h,h)$的情况下，平台在第2阶段最优化奖励值后的最大收益。其他几个U也是类似的含义。</p>
<p>接下来分析期望收益随披露策略的变化趋势。</p>
</li>
<li><p>引理1：</p>
<ol>
<li>$U_{h,h}(\epsilon^h),U_{l,h}(\epsilon^h),Q_{l,l}(\epsilon^h)$随$\epsilon^h$增加而减小。</li>
<li>$U_{h,l}(\epsilon^h),U_{l,l}(\epsilon^h),Q_{l,h}(\epsilon^h)$随$\epsilon^h$增加而增加。</li>
</ol>
<p>分析：$Q_{l,l}(\epsilon^h)$和$Q_{l,h}(\epsilon^h)$随$\epsilon^h$的变化从定义即可看出。接下来用Case $(h,h)$ 中的 $U_{h,h}(\epsilon^h)$作为例子来分析。在推论1中可知，随$\epsilon^h$增加，平台需要支付更大的奖励$R$来激励workers，而这会减小平台的收益。其他几个U也是类似的分析思路。</p>
<p>而由于$E\{U_p(\epsilon^h)\}$的几部分单调性不同，因此无法直接分析出平台收益随$\epsilon^h$的变化趋势。同样的，$E\{U_p(\epsilon^l)\}$也无法分析变化趋势。从而得出定理4的结论。</p>
</li>
</ol>
<p>具体的平台披露策略因为太复杂了，所以没法分析，在实验部分进行了数值实验。</p>
<h2 id="NUMERICAL-RESULTS"><a href="#NUMERICAL-RESULTS" class="headerlink" title="NUMERICAL RESULTS"></a>NUMERICAL RESULTS</h2><p>这一部分进行数值实验，研究两类workers：策略型和天真型，天真型的符号表达沿用前文中策略型的，只是把str改成了nai，具体如下：</p>
<script type="math/tex; mode=display">
\left\{
\begin{aligned}
\mu_{high}^{post,nai}|k^{high}=\mu_{low}^{post,nai}|k^{low}=1\\
\mu_{high}^{post,nai}|k^{low}=\mu_{low}^{post,nai}|k^{high}=0\\
\end{aligned}
\right.</script><p>接下来的实验结果说明：平台始终向天真的工人宣布高平均工人准确率是最佳的（也就是$k=k^{high}$），但对策略型工人来说并非如此。我们还显示了一个反直觉的结果，表明平台的收益随高准确率workers的准确率提高而提高，随高准确率workers的数量提高而减小。</p>
<h3 id="Impact-of-Worker-Characteristics"><a href="#Impact-of-Worker-Characteristics" class="headerlink" title="Impact of Worker Characteristics"></a>Impact of Worker Characteristics</h3><p>这一部分研究高准确率workers的准确率$p_h$对平台最优收益、workers总收益（所有workers的收益和）和社会福利（平台收益+workers收益）的影响。</p>
<p>参数：workers数量$N=100$，高准确率workers的准确率$p_h\in(0.7,0.8),step=0.02$，低准确率workers的准确率$p_l=0.6$，对$k$的先验信念$\mu_{high}^{prior}=0.7,\mu_{low}^{prior}=0.3$，$k$的取值$k^{low}=20,k^{high}\in\{50,70\}$，workers努力的成本$c=1$，平台对聚合准确的估值$\beta=1000$。</p>
<p>分析图像：</p>
<ol>
<li>平台收益随$p_h$增加而增加，对于某些$p_h$随$k^{high}$增加（指从50变成70）而减小。</li>
<li>天真的workers给平台带来的收益更高。</li>
<li>workers收益可能随$p_h$增加而减小。</li>
<li>社会财富随$p_h$增加而增加。</li>
</ol>
<h3 id="Impact-of-Worker-Prior-Belief"><a href="#Impact-of-Worker-Prior-Belief" class="headerlink" title="Impact of Worker Prior Belief"></a>Impact of Worker Prior Belief</h3><p>这一部分研究先验信念对平台最优收益、workers总收益和平台披露策略的影响。</p>
<p>参数：workers数量$N=100$，高准确率workers的准确率$p_h=0.75$，低准确率workers的准确率$p_l=0.6$，对$k$的先验信念$\mu_{high}^{prior}\in\{0.01,0.2,0.4,0.6,0.8,0.99\}$，$k$的取值$k^{low}=20,k^{high}\in\{50,70\}$，workers努力的成本$c=1$，平台对聚合准确的估值$\beta=1000$。</p>
<p>分析图像：</p>
<ol>
<li>平台收益随先验$\mu_{high}^{prior}$增加而增加。</li>
<li>策略型workers的聚合收益随先验$\mu_{high}^{prior}$增加而减小，天真型workers的聚合收益与先验$\mu_{high}^{prior}$无关。</li>
<li>面对天真型workers，平台始终宣称$k=k^{high}$是最优的；面对策略型workers则不是这样。</li>
<li>面对策略型workers时，平台的最优$\epsilon^{h}$随先验$\mu_{high}^{prior}$增加而减小，最优$\epsilon^{l}$随先验$\mu_{high}^{prior}$增加而增加。</li>
</ol>
<h2 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h2><ol>
<li>策略性信息披露问题——非凸规划</li>
<li>naive workers：总是公开一个较高的平均准确率</li>
<li>strategic workers：收益和平台信用的平衡，有动机宣布一个低于实际值的平均准确率</li>
<li>平台报酬可能减少高准确率workers的数量</li>
<li>未来工作：<ol>
<li>多维workers异质性</li>
<li>考虑信息披露的代价（获取信息所产生的成本）</li>
</ol>
</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/134036707" target="_blank" rel="noopener">贝叶斯公式</a></li>
</ol>
<h2 id="我的分析"><a href="#我的分析" class="headerlink" title="我的分析"></a>我的分析</h2><h3 id="第三阶段workers均衡解定理1"><a href="#第三阶段workers均衡解定理1" class="headerlink" title="第三阶段workers均衡解定理1"></a>第三阶段workers均衡解定理1</h3><p>要用到的字母表达：</p>
<p>$P_{k^{high}-1}^{majority}$是指：当$k^{high}-1$个高准确率workers决定采取策略$(1,1)$且剩下的其他workers都决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>$P_{k^{low}-1}^{majority}$是指：当$k^{low}-1$个高准确率workers决定采取策略$(1,1)$且剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>$P_{k^{high}}^{majority}$是指：$k^{high}$个高准确率worker决定采取策略$(1,1)$，剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>$P_{k^{low}}^{majority}$是指：$k^{low}$个高准确率worker决定采取策略$(1,1)$，剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)$和$\mu_{low}^{post,str}|k_p^{anu}(\epsilon)$是高质量workers的数量的后验概率</p>
<p>我增加的字母表达：$P^{00}$表示高低质量都采取$(0,rd)$时多数一致方案是正确的概率，$P^{01}$表示高质量采取$(0,rd)$低质量采取$(1,-1)$…类似的，可以把workers策略组合的所有概率表达都写出来，上标左边的数字表示高质量workers的策略，右边的数字表示低质量workers的策略，数字012分别表示策略$(0,rd),(1,-1),(1,1)$。</p>
<p>显然，$P^{00}=0.5$，$P^{20}=\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority}$</p>
<p>本文假设相同质量的workers会采取相同的策略，也就是说，高低质量的workers的策略组合一共有9种，我们列出收益矩阵：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>(0,rd)</th>
<th>(1,-1)</th>
<th>(1,1)</th>
</tr>
</thead>
<tbody>
<tr>
<td>(0,rd)</td>
<td>$(0.5R, 0.5R)$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(1,-1)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(1,1)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h4 id="低质量workers选-0-rd"><a href="#低质量workers选-0-rd" class="headerlink" title="低质量workers选$(0,rd)$"></a>低质量workers选$(0,rd)$</h4><ol>
<li>高质量workers选$(0,rd)$，所有workers的答案是正确和错误的概率都是0.5，因此大家的收益都是$0.5R$，没有支出。</li>
<li>高质量workers选$(1,1)$，高质量workers正确的概率是$p_h$，低质量workers正确的概率是0.5，多数一致方案正确的概率是$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority}$，</li>
<li>高质量workers选$(1,-1)$，高质量workers正确的概率是$1-p_h$，低质量workers正确的概率是0.5，多数一致方案正确的概率是$P^{10}$。</li>
</ol>
<h4 id="低质量workers选-1-1"><a href="#低质量workers选-1-1" class="headerlink" title="低质量workers选$(1,-1)$"></a>低质量workers选$(1,-1)$</h4><ol>
<li>高质量workers选$(0,rd)$，高质量workers正确的概率是0.5，低质量workers正确的概率是$1-p_l$，多数一致方案正确的概率是$P^{01}$。</li>
<li>高质量workers选$(1,1)$，高质量workers正确的概率是$p_h$，低质量workers正确的概率是$1-p_l$，多数一致方案正确的概率是$P^{21}$。</li>
<li>高质量workers选$(1,-1)$，高质量workers正确的概率是$1-p_h$，低质量workers正确的概率是$1-p_l$，多数一致方案正确的概率是$P^{11}$。</li>
</ol>
<h4 id="低质量workders选-1-1"><a href="#低质量workders选-1-1" class="headerlink" title="低质量workders选$(1,1)$"></a>低质量workders选$(1,1)$</h4><ol>
<li>高质量workers选$(0,rd)$，高质量workers正确的概率是0.5，低质量workers正确的概率是$p_l$，多数一致方案正确的概率是$P^{02}$。</li>
<li>高质量workers选$(1,1)$，高质量workers正确的概率是$p_h$，低质量workers正确的概率是$p_l$，多数一致方案正确的概率是$P^{22}$。</li>
<li>高质量workers选$(1,-1)$，高质量workers正确的概率是$1-p_h$，低质量workers正确的概率是$p_l$，多数一致方案正确的概率是$P^{12}$。</li>
</ol>
<p>这里看起来是把每一个都列出来，然后比较大小找均衡解。</p>
<h4 id="Condition-11-的推导"><a href="#Condition-11-的推导" class="headerlink" title="$Condition(11)$的推导"></a>$Condition(11)$的推导</h4><p>在$p-SNE$的情况下，高准确率的worker采取策略$(1,1)$，低准确率的worker采取策略$(0,rd)$。</p>
<p>对于一个高质量worker，该workers努力时得到正确答案概率：$p_h$，得到错误答案概率：$1-p_h$。</p>
<p>其他workers中，高质量workers的数量$k$为$k^{high}-1$或者$k^{low}-1$，且对应的概率分别是两个后验概率$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)$和$\mu_{low}^{post,str}|k_p^{anu}(\epsilon)$，而这两种情况下其他workers的多数一致方案是正确和错误的概率分别是$P_{k^{high}-1}^{majority}$和$P_{k^{low}-1}^{majority}$，即可得：</p>
<p>其他workers的多数一致方案是正确的概率：$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}-1}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}-1}^{majority}$，</p>
<p>其他workers的多数一致方案是错误的概率：$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{high}-1}^{majority})+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{low}-1}^{majority})$</p>
<p>一个努力且如实报告的高质量worker得到收益的概率为：</p>
<script type="math/tex; mode=display">
p_h(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}-1}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}-1}^{majority})+(1-p_h)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{high}-1}^{majority})+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{low}-1}^{majority})) \tag{1}</script><p>对于一个低质量worker而言，该workers努力时得到正确答案概率：$p_l$，得到错误答案概率：$1-p_l$，其他workers中，高质量workers的数量$k$为$k^{high}$或者$k^{low}$，且对应的概率分别是两个后验概率$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)$和$\mu_{low}^{post,str}|k_p^{anu}(\epsilon)$，而这两种情况下其他workers的多数一致方案是正确和错误的概率分别是$P_{k^{high}}^{majority}$和$P_{k^{low}}^{majority}$，即可得：</p>
<p>其他workers的多数一致方案是正确的概率：$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority}$，</p>
<p>其他workers的多数一致方案是错误的概率：$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{high}}^{majority})+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{low}}^{majority})$</p>
<p>一个努力且如实报告的低质量worker得到收益的概率为：</p>
<script type="math/tex; mode=display">
p_l(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority})+(1-p_l)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{high}}^{majority})+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{low}}^{majority})) \tag{2}</script><p>公式(1)大于公式(2)所推导出的公式和论文中的$condition(11)$不一样，暂时没想到其他的思路。</p>
<p>这里推导出的是：</p>
<script type="math/tex; mode=display">
(1-p_h)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)+\mu_{low}^{post,str}|k_p^{anu}(\epsilon))+(2p_h-1)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}-1}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}-1}^{majority})\geq \\
(1-p_l)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)+\mu_{low}^{post,str}|k_p^{anu}(\epsilon))+(2p_l-1)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority})</script><p>论文里的11是：</p>
<script type="math/tex; mode=display">
\frac{2p_h-1}{2p_l-1}(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}-1}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}-1}^{majority})\geq \mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority} \tag{11}</script><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><ol>
<li>均衡解和阈值是怎么算出来的完全不懂</li>
<li>实验部分是怎么算最优平台披露策略$\epsilon^h,\epsilon^l$</li>
<li>图2(b)中增加的那段没有解释</li>
<li>$k^{high}=50$和$k^{high}=70$只有两个值是否能充分说明变化趋势（这个不重要）</li>
<li>社会财富的增加是否与平台数值过大有关（这个也不重要）</li>
<li>多数一致投票的时候，如果两边一样怎么处理（这个还不重要）</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>crowdsourcing</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-7</title>
    <url>/2020/12/24/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-7/</url>
    <content><![CDATA[<h1 id="On-Action"><a href="#On-Action" class="headerlink" title="On_Action"></a>On_Action</h1><p>在前面学习到的事件是由玩家在游戏中通过决议而触发的，但有时候我们会希望实现一些自动触发的事件，比如一年触发一次、五年触发一次等，这个时候就需要使用<code>on_action</code>了。</p>
<p>在<a href="https://likun1208.github.io/2020/11/08/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-4/">ck3mod制作笔记-4</a>中，我们提到过这个东西。它可以理解成一种编码，当游戏中有对应编码的事件发生时，就会执行<code>on_action</code>代码块中的内容，比如当角色结婚时，<code>on_marriage</code>部分的内容就会被触发。游戏本体的相关代码存放在<code>Crusader Kings III\game\common\on_action</code>文件夹中，可以看到有很多很多选项。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><code>_on_actions.info</code>文件中说明了一个<code>on_action</code>代码块的写法，这里简要翻译和介绍一下。</p>
<p>首先，一个<code>on_action</code>的基础结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">on_action_name &#x3D; &#123;</span><br><span class="line">	trigger &#x3D; &#123;</span><br><span class="line">		trigger_conditions &#x3D; yes</span><br><span class="line">	&#125;</span><br><span class="line">	weight_multiplier &#x3D; &#123;</span><br><span class="line">		base &#x3D; 1</span><br><span class="line">		modifier &#x3D; &#123;</span><br><span class="line">			add &#x3D; 1</span><br><span class="line">			trigger_conditions &#x3D; yes</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	events &#x3D; &#123;</span><br><span class="line">		event_id_1</span><br><span class="line">		delay &#x3D; &#123; days &#x3D; 365 &#125;</span><br><span class="line">		event_id_2</span><br><span class="line">		delay &#x3D; &#123; months &#x3D; &#123; 6 12 &#125; &#125;</span><br><span class="line">		event_id_3</span><br><span class="line">	&#125;</span><br><span class="line">	random_events &#x3D; &#123;</span><br><span class="line">		chance_to_happen &#x3D; 25</span><br><span class="line">		chance_of_no_event &#x3D; &#123;</span><br><span class="line">			value &#x3D; 0</span><br><span class="line">			if &#x3D; &#123;</span><br><span class="line">				limit &#x3D; &#123; trigger_conditions &#x3D; yes &#125;</span><br><span class="line">				add &#x3D; 10</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		100 &#x3D; event_id_1</span><br><span class="line">		200 &#x3D; event_id_2</span><br><span class="line">		100 &#x3D; 0</span><br><span class="line">	&#125;</span><br><span class="line">	first_valid &#x3D; &#123;</span><br><span class="line">		event_id_1</span><br><span class="line">		event_id_2</span><br><span class="line">		fallback_event_without_trigger</span><br><span class="line">	&#125;</span><br><span class="line">	on_actions &#x3D; &#123;</span><br><span class="line">		on_action_1</span><br><span class="line">		on_action_2</span><br><span class="line">		on_action_3</span><br><span class="line">	&#125;</span><br><span class="line">	random_on_actions &#x3D; &#123;</span><br><span class="line">		100 &#x3D; on_action_1</span><br><span class="line">		200 &#x3D; on_action_2</span><br><span class="line">		100 &#x3D; 0</span><br><span class="line">	&#125;</span><br><span class="line">	first_valid_on_action &#x3D; &#123;</span><br><span class="line">		on_action_1</span><br><span class="line">		on_action_2</span><br><span class="line">	&#125;</span><br><span class="line">	effect &#x3D; &#123;</span><br><span class="line">		effects &#x3D; yes</span><br><span class="line">	&#125;</span><br><span class="line">	fallback &#x3D; another_on_action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>第一部分<code>trigger</code>是这个<code>on_action</code>的触发条件，如果一个<code>on_action</code>被游戏中的事件触发，而该<code>on_action</code>的<code>trigger</code>条件不满足，则无事发生。例如我们写一个<code>on_action</code>设定角色结婚后立刻获得1000金币，但是在<code>trigger</code>中限制该角色需要年龄低于30，则一个60岁角色的结婚事件触发该<code>on_action</code>后，不会获得金币。</li>
<li>第二部分是对该<code>on_action</code>权重的修正，这个权重是用于其他<code>on_action</code>的随机<code>on_action</code>列表（这个列表会在下面介绍），比如我们有3个<code>on_action</code>，分别是<code>on_action_1, on_action_2, on_action_3</code>，其中后两个在第一个的随机<code>on_action</code>列表中，这意味着当<code>on_action_1</code>触发时，<code>on_action_2</code>和<code>on_action_3</code>会以一定概率触发，概率由它们在列表中的权重决定，权重的计算方式在前面介绍过，而这里的<code>weight_multiplier</code>就是对该权重值的修正。</li>
<li>第三部分表示该<code>on_action</code>触发时会发生的事件列表，事件们在满足自身触发条件（<code>trigger</code>）的情况下，会从上到下按顺序逐一发生。这一部分中可以使用<code>delay</code>来控制事件之间的间隔，表示上一个事件发生多久后再继续进行下一个事件。<code>delay</code>可以是<code>days</code>，也可以是<code>months</code>和<code>years</code>，且这3者的值可以是形如<code>{6 12}</code>这样的随机列表，具体到游戏中会从大括号的值里挑一个，注意这两个数字之间没有逗号。上述代码中的这段例子就是当<code>on_action</code>触发时，先立刻发生<code>event_id_1</code>，等365天后会发生<code>event_id_2</code>，接着等6个月或12个月会发生<code>event_id_3</code>。</li>
<li>第四部分<code>random_events</code>是随机事件列表，<code>on_action</code>发生时，会从该列表中根据权值随机挑选事件发生，会且只会挑一个。其中的<code>chance_to_happen</code>是基础权值，比如这里是25。<code>chance_of_no_event</code>是可以格式化为脚本值的条目，出于性能原因独立于<code>chance_to_happen</code>，只有当<code>chance_to_happen</code>为真时，该值会被考虑。接下来的列表就是会被挑选的事件列表，其中形如<code>100 = 0</code>这样的条目，是指有一定概率没有任何事件发生，这个设置是为了避免玩家通过让随即列表中的其他事件都不满足触发条件，从而触发稀有事件。</li>
<li>第五部分<code>first_valid</code>选取触发器返回 true 的第一个事件。</li>
<li><code>on_action</code>除了规定发生什么事件以外，也可以规定触发哪些<code>on_action</code>，接下来的第六、第七和第八部分和前面的<code>events, random_events, first_valid</code>很像，它们分别是该<code>on_action</code>会触发的其他<code>on_action</code>列表、随机<code>on_action</code>列表和<code>first_valid on_action</code>列表，前面第二部分的权重就是在这里用的。</li>
<li>接着的<code>effect</code>这里先不说明，因为我还没学。</li>
<li>最后<code>fallback</code>有点类似于编程语言中的函数返回值，它表示该<code>on_action</code>定义的返回<code>on_action</code>。如果没有事件/on_actions由该<code>on_action</code>触发，则该返回<code>on_action</code>会被调用。注意，要避免创建无限的返回循环，否则游戏可能会被阻止推进时间。</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在这一部分中，我们写一个很基础朴素的<code>on_action</code>，来略微了解一下。</p>
<ol>
<li><p>首先我们要完成一个如下<code>on_action</code>：当角色结婚时，弹出第一个事件，1天后弹出第2个事件，10天或15天后弹出第3个事件，3个事件就很随意了。</p>
</li>
<li><p>那么首先，我们先写3个事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace &#x3D; test_action</span><br><span class="line">test_action.1001 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; test_action.1001.t</span><br><span class="line">	desc &#x3D; test_action.1001.desc</span><br><span class="line">	theme &#x3D; stewardship</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; test_action.1001.option.a</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; test_action.1001.option.b</span><br><span class="line">		trigger_event &#x3D; give_money.1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_action.1002 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; test_action.1002.t</span><br><span class="line">	desc &#x3D; test_action.1002.desc</span><br><span class="line">	theme &#x3D; stewardship</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; test_action.1002.option.a</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_action.1003 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; test_action.1003.t</span><br><span class="line">	desc &#x3D; test_action.1003.desc</span><br><span class="line">	theme &#x3D; stewardship</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; test_action.1003.option.a</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意，<code>namespace</code>一定要写对（也就是数字id前面的字符串），不能写成别的，不然就找不到这些事件了。</p>
<p>一个反例就是一开始我没注意，namespace写成了test，于是无论怎么搞都只会触发这个文件中的最后一个事件（test_action.1003）。</p>
<p>事件对应的文本文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> test_action.1001.t:0 &quot;测试&quot;</span><br><span class="line"> test_action.1001.desc:0 &quot;测试一下action。&quot;</span><br><span class="line"> test_action.1001.option.a:0 &quot;好耶！&quot;</span><br><span class="line"> test_action.1001.option.b:0 &quot;来点钱呗！&quot;</span><br><span class="line"></span><br><span class="line"> test_action.1002.t:0 &quot;测试2&quot;</span><br><span class="line"> test_action.1002.desc:0 &quot;测试一下多个事件。&quot;</span><br><span class="line"> test_action.1002.option.a:0 &quot;嗯嗯！&quot;</span><br><span class="line"></span><br><span class="line">  test_action.1003.t:0 &quot;测试3&quot;</span><br><span class="line">  test_action.1003.desc:0 &quot;测试一下delay。&quot;</span><br><span class="line">  test_action.1003.option.a:0 &quot;加油！&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备好事件以后，就可以开始写<code>on_action</code>文件了。根据需求，我们的<code>on_action</code>应该是<code>on_marriage</code>，其中只包含<code>events</code>块。内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">on_marriage &#x3D; &#123;</span><br><span class="line">	events &#x3D; &#123;</span><br><span class="line">		test_action.1001</span><br><span class="line">		delay &#x3D; &#123; days &#x3D; 1 &#125;</span><br><span class="line">		test_action.1002</span><br><span class="line">		delay &#x3D; &#123; days &#x3D; &#123; 10 15 &#125; &#125;</span><br><span class="line">		test_action.1003</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来检查一下代码结构，看每个文件是否都在其对应的地方，我的代码结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- common</span><br><span class="line">	- on_action</span><br><span class="line">		test_on_action.txt</span><br><span class="line">- events</span><br><span class="line">	test_action_events.txt</span><br><span class="line">- localization</span><br><span class="line">	-simp_chinese</span><br><span class="line">		-event_localization</span><br><span class="line">			test_action_l_simp_chinses.yml</span><br></pre></td></tr></table></figure>
<p>实际上文件名并不严格要求按这个来，文件层级也不是特别严格，比如events里再套一层文件夹也没关系。</p>
<p>此外，<code>test_action_events</code>事件中某个选项会触发之前写过的<code>give_money_events</code>，这个事件和其相关文件在此就不列出了。</p>
</li>
<li><p>接下来进游戏加载mod，可以看到如下效果：</p>
<p>结婚当天（9月23日）触发第一个事件</p>
<p><img src="https://i.loli.net/2020/12/25/24QNcT3LekhHtpA.png" alt="image-20201225205736201"></p>
</li>
</ol>
<p>一天后（9月24日）触发第二个事件</p>
<p><img src="https://i.loli.net/2020/12/25/yA7d2Hzn9tMolkp.png" alt="image-20201225205913496"></p>
<p>15天后（10月8日）触发第3个事件</p>
<p><img src="https://i.loli.net/2020/12/25/PeXHlhZViFoK5zM.png" alt="image-20201225210107079"></p>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><p>除了一些游戏本身已经写好的<code>on_action</code>以外，我们也可以自己写<code>on_action</code>，并在决议、事件或其他会触发<code>on_action</code>的时候调用，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">trigger_event &#x3D; &#123;</span><br><span class="line">	on_action &#x3D; on_action_name</span><br><span class="line">	days&#x2F;months&#x2F;years &#x3D; X  	# 可选项，可以没有</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="现有的on-action"><a href="#现有的on-action" class="headerlink" title="现有的on_action"></a>现有的<code>on_action</code></h2><p>在这一部分中我整理列出了游戏本体中的一系列<code>on_action</code>的名称和触发条件（其实是根据名称猜的，所以可能有错），具体效果就不说明了。（实在是太多了……）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类别（文件名）</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">结盟（alliance_on_actions）</td>
<td style="text-align:center">on_alliance_added</td>
<td style="text-align:center">结成同盟</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_alliance_removed</td>
<td style="text-align:center">同盟到期移除</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_alliance_broken</td>
<td style="text-align:center">同盟破裂</td>
</tr>
<tr>
<td style="text-align:center">军队（army_on_actions）</td>
<td style="text-align:center">on_army_monthly</td>
<td style="text-align:center">玩家拥有的军队每30天自动触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_county_occupied</td>
<td style="text-align:center">当一个county完全被占领时触发，如果是被province owner重新占领则不触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_siege_completion</td>
<td style="text-align:center">当围攻完成时触发，如果是被province owner重新占领则不触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_siege_looting</td>
<td style="text-align:center">当围攻掠夺某一土地时触发（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_army_enter_province</td>
<td style="text-align:center">军队进入一个province时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_raid_action_start</td>
<td style="text-align:center">突袭发生时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_raid_action_completion</td>
<td style="text-align:center">突袭结束时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_raid_action_weekly</td>
<td style="text-align:center">突袭过程中每7天触发一次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_raid_loot_delivered</td>
<td style="text-align:center">当袭击者返回自己的领土并存入战利品时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_defeat_raid_army</td>
<td style="text-align:center">当突袭失败且战利品被盗时触发（？）</td>
</tr>
<tr>
<td style="text-align:center">战争（battle_on_actions）</td>
<td style="text-align:center">on_battle_owner_battle_end</td>
<td style="text-align:center">战争结束时，对战争双方触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_commander_battle_end</td>
<td style="text-align:center">战争结束时，对战争双方指挥官触发</td>
</tr>
<tr>
<td style="text-align:center">生日（birthday）</td>
<td style="text-align:center">on_birthday</td>
<td style="text-align:center">每个生日触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_specific_birthday</td>
<td style="text-align:center">几个特殊年龄的生日触发（3、6、10、15、16）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_birthday_childhood</td>
<td style="text-align:center">未成年且可以受教育的年龄触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_graceful_aging_birthday</td>
<td style="text-align:center">这个没注释，我也没看懂</td>
</tr>
<tr>
<td style="text-align:center">人物等级（character_levels）</td>
<td style="text-align:center">on_piety_level_gain</td>
<td style="text-align:center">信仰等级提升时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_piety_level_loss</td>
<td style="text-align:center">信仰等级降低时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_prestige_level_gain</td>
<td style="text-align:center">声望等级提升时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_prestige_level_loss</td>
<td style="text-align:center">声望等级降低时触发</td>
</tr>
<tr>
<td style="text-align:center">孩子出生（child_birth_on_actions）</td>
<td style="text-align:center">on_birth_mother</td>
<td style="text-align:center">生娃时对孩他妈触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_birth_father</td>
<td style="text-align:center">生娃时对孩他爸触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_birth_real_father</td>
<td style="text-align:center">生娃时对亲生父亲触发（只在亲生父亲和法理父亲不一样时触发）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_birth_child</td>
<td style="text-align:center">对新生儿触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_pregnancy_mother</td>
<td style="text-align:center">对怀孕状态的母亲触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_pregnancy_father</td>
<td style="text-align:center">对怀孕状态的父亲触发（<strong>这不是指男性怀孕</strong>）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_pregnancy_ended_mother</td>
<td style="text-align:center">怀孕结束时对母亲触发</td>
</tr>
<tr>
<td style="text-align:center">儿童时期（childhood_on_actions）</td>
<td style="text-align:center">child_personality_gain</td>
<td style="text-align:center">儿童性格特质等的获得</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">childhood_ongoing</td>
<td style="text-align:center">儿童时期触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_3rd_birthday</td>
<td style="text-align:center">3岁触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_6th_birthday</td>
<td style="text-align:center">6岁触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_10th_birthday</td>
<td style="text-align:center">10岁触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_15th_birthday</td>
<td style="text-align:center">15岁触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_16th_birthday</td>
<td style="text-align:center">16岁触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_action_add_sexuality</td>
<td style="text-align:center">获得性取向后触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_birthday_education_events</td>
<td style="text-align:center">教育事件触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">childhood_education_boost</td>
<td style="text-align:center">检查儿童是否需要教育</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">childhood_education</td>
<td style="text-align:center">教育事件的触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">childhood_education_patronage</td>
<td style="text-align:center">patronage-forcused或者scholarly 配偶会给儿童教育加分，这个赞助我没理解是什么意思，scholarly应该是指学识属性高</td>
</tr>
<tr>
<td style="text-align:center">战斗（combat_on_actions）</td>
<td style="text-align:center">on_combat_end_winner</td>
<td style="text-align:center">对打赢了的一方触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_combat_end_loser</td>
<td style="text-align:center">对打输了的一方触发</td>
</tr>
<tr>
<td style="text-align:center">内阁（councillor_on_actions）</td>
<td style="text-align:center">on_leave_council</td>
<td style="text-align:center">内阁成员辞职时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_fired_from_council</td>
<td style="text-align:center">领主从内阁解雇该角色时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">organize_the_levies_marshal_task_side_effects</td>
<td style="text-align:center">军事统帅任务事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">train_commanders_success_effect</td>
<td style="text-align:center">训练指挥官成功事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">train_commanders_marshal_task_side_effects</td>
<td style="text-align:center">训练指挥官军事统帅事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_increase_control_side_effects</td>
<td style="text-align:center">增强控制力任务事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_foreign_affairs_side_effects</td>
<td style="text-align:center">外交事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_domestic_affairs_side_effects</td>
<td style="text-align:center">国内事务列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_integrate_title_side_effects</td>
<td style="text-align:center">合并头衔事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_fabricate_claim_success_effect</td>
<td style="text-align:center">伪造宣称成功事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_collect_taxes_side_effects</td>
<td style="text-align:center">收税事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_develop_county_side_effects</td>
<td style="text-align:center">发展事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_promote_culture_side_effects</td>
<td style="text-align:center">文化事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_religious_relations_side_effects</td>
<td style="text-align:center">宗教关系事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_convert_side_effects</td>
<td style="text-align:center">转变文化事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_fabricate_claim_side_effects</td>
<td style="text-align:center">伪造宣称事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_support_schemes_side_effects</td>
<td style="text-align:center">支持密谋事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_disrupt_schemes_side_effects</td>
<td style="text-align:center">打断密谋事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_find_secrets_outcome</td>
<td style="text-align:center">寻找秘密的结果</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_find_secrets_reveal_selection</td>
<td style="text-align:center">揭示秘密选择列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_find_secrets_side_effects</td>
<td style="text-align:center">寻找秘密事件列表</td>
</tr>
<tr>
<td style="text-align:center">伯爵领（county_on_actions）</td>
<td style="text-align:center">on_county_faith_change</td>
<td style="text-align:center">伯爵领改信时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_county_culture_change</td>
<td style="text-align:center">伯爵领改文化时触发</td>
</tr>
<tr>
<td style="text-align:center">宫廷（court_maintenance_on_actions）</td>
<td style="text-align:center">on_join_court</td>
<td style="text-align:center">角色加入宫廷时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_leave_court</td>
<td style="text-align:center">角色离开宫廷时触发</td>
</tr>
<tr>
<td style="text-align:center">廷臣宾客（courtier_guest_management_on_actions）</td>
<td style="text-align:center">on_courtier_decided_to_move_to_pool</td>
<td style="text-align:center">廷臣打算离开时针对该廷臣触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_courtier_ready_to_move_to_pool</td>
<td style="text-align:center">廷臣准备好离开时针对该廷臣触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_guest_arrived_from_pool</td>
<td style="text-align:center">宾客到达时针对该宾客触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_guest_ready_to_move_to_pool</td>
<td style="text-align:center">宾客准备好离开时针对宾客触发</td>
</tr>
<tr>
<td style="text-align:center">文化（culture_on_actions）</td>
<td style="text-align:center">on_culture_era_changed</td>
<td style="text-align:center">文化区域改变时对该文化触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_character_culture_change</td>
<td style="text-align:center">角色改文化时对该角色触发</td>
</tr>
<tr>
<td style="text-align:center">死亡（death）</td>
<td style="text-align:center">on_death</td>
<td style="text-align:center">死亡时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_natural_death_second_chance</td>
<td style="text-align:center">角色即将自然死亡，但通过脚本获得第二次生命时触发</td>
</tr>
<tr>
<td style="text-align:center">宗族（dynasty_on_actions）</td>
<td style="text-align:center">on_dynasty_created</td>
<td style="text-align:center">建立宗族时触发</td>
</tr>
<tr>
<td style="text-align:center">游戏开始（game_start）</td>
<td style="text-align:center">on_game_start</td>
<td style="text-align:center">游戏开局一系列历史信息生成后触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_game_start_after_lobby</td>
<td style="text-align:center">进入游戏后触发，主要是和游戏规则相关的内容</td>
</tr>
<tr>
<td style="text-align:center">健康（health_on_actions）</td>
<td style="text-align:center">yearly_health_pulse</td>
<td style="text-align:center">每年的健康事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">disease_outbreak_pulse</td>
<td style="text-align:center">随机生病触发事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wounded_recovery_pulse</td>
<td style="text-align:center">伤口恢复触发事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit_suicide</td>
<td style="text-align:center">决议自杀触发</td>
</tr>
<tr>
<td style="text-align:center">骑士团（holy_order_on_actions）</td>
<td style="text-align:center">on_holy_order_new_lease</td>
<td style="text-align:center">骑士团获得领地（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_holy_order_hired</td>
<td style="text-align:center">骑士团被雇佣</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_holy_order_destroyed</td>
<td style="text-align:center">骑士团被解散</td>
</tr>
<tr>
<td style="text-align:center">骑士（knight_on_actions）</td>
<td style="text-align:center">on_knight_combat_pulse</td>
<td style="text-align:center">战争中每天针对骑士触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_commander_combat_pulse</td>
<td style="text-align:center">战争中每天对指挥官触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_commander_combat_finished</td>
<td style="text-align:center">战争后对指挥官触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_army_combat_finished</td>
<td style="text-align:center">战争后对每个参战军队触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">varangian_ongoing</td>
<td style="text-align:center">针对Varangian guard触发</td>
</tr>
<tr>
<td style="text-align:center">婚姻（marriage_concubinage）</td>
<td style="text-align:center">on_marriage</td>
<td style="text-align:center">结婚时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_divorce</td>
<td style="text-align:center">离婚时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_concubinage</td>
<td style="text-align:center">角色成为他人侧室时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_concubinage_end</td>
<td style="text-align:center">角色不当侧室时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_betrothal_broken</td>
<td style="text-align:center">婚约破裂时触发</td>
</tr>
<tr>
<td style="text-align:center">监狱（prison_on_actions）</td>
<td style="text-align:center">on_imprison</td>
<td style="text-align:center">被抓时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_release_from_prison</td>
<td style="text-align:center">被放时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">quarterly_prison_maintenance_pulse</td>
<td style="text-align:center">住监狱过程中触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">dungeon_ongoing</td>
<td style="text-align:center">关地牢过程中触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">house_arrest_ongoing</td>
<td style="text-align:center">软禁时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">escape_from_prison</td>
<td style="text-align:center">试图逃出监狱时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">escape_from_prison_success</td>
<td style="text-align:center">成功逃出监狱时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">escape_from_prison_failure</td>
<td style="text-align:center">逃跑失败触发</td>
</tr>
<tr>
<td style="text-align:center">领地（realm_maintenance_on_actions）</td>
<td style="text-align:center">realm_maintenance_quarterly_pulse</td>
<td style="text-align:center">当领主的过程中随机触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">in_debt_county_corruption_pulse</td>
<td style="text-align:center">负债时增加腐败</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">low_control_pulse</td>
<td style="text-align:center">控制力较低时触发（会增加腐败）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">high_countrol_pulse</td>
<td style="text-align:center">高控制力时触发（移除腐败）（这里的countrol真的没问题吗…）</td>
</tr>
<tr>
<td style="text-align:center">宗教（religion_on_actions）</td>
<td style="text-align:center">on_faith_created</td>
<td style="text-align:center">创建信仰时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_faith_conversion</td>
<td style="text-align:center">转变信仰时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_character_faith_change</td>
<td style="text-align:center">人物改信时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_faith_monthly</td>
<td style="text-align:center">每种信仰每个月触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">faith_holy_order_land_acquisition_pulse</td>
<td style="text-align:center">骑士团信仰</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">faith_heresy_events_pulse</td>
<td style="text-align:center">异端事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">faith_fervor_events_pulse</td>
<td style="text-align:center">宗教热情事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pagan_conversion_pulse</td>
<td style="text-align:center">异教徒转变事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_potential_great_holy_war_invalidation</td>
<td style="text-align:center">圣战目标无效时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_great_holy_war_invalidation</td>
<td style="text-align:center">上一个没找到新目标时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_great_holy_war_countdown_end</td>
<td style="text-align:center">圣战开始的倒计时为0时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_great_holy_war_participant_replaced</td>
<td style="text-align:center">圣战中角色被替换时触发</td>
</tr>
<tr>
<td style="text-align:center">规则（ruler_designer）</td>
<td style="text-align:center">on_ruler_designer_finished</td>
<td style="text-align:center">新人物设计好后触发（应该是指那个自定义统治者属性的玩法）</td>
</tr>
<tr>
<td style="text-align:center">秘密（secret_on_actions）</td>
<td style="text-align:center">secrets_ongoing</td>
<td style="text-align:center">处理秘密事件时触发</td>
</tr>
<tr>
<td style="text-align:center">压力应对决策（主要是不同特质会有特殊事件）（stress_coping_decisions_on_actions）</td>
<td style="text-align:center">stress_loss_drunkard</td>
<td style="text-align:center">酒鬼减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_hashishiyah</td>
<td style="text-align:center">瘾君子减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_rakish</td>
<td style="text-align:center">放荡者减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_reclusive</td>
<td style="text-align:center">隐居减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_irritable</td>
<td style="text-align:center">烦躁减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_flagellant</td>
<td style="text-align:center">自鞭笞者减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_profligate</td>
<td style="text-align:center">挥霍减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_improvident</td>
<td style="text-align:center">缺乏远见者减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_contrite</td>
<td style="text-align:center">懊悔减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_comfort_eater</td>
<td style="text-align:center">食以慰藉减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_inappetetic</td>
<td style="text-align:center">没有食欲减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_journaller</td>
<td style="text-align:center">写日记者减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_confider</td>
<td style="text-align:center">倾诉者减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_athletic</td>
<td style="text-align:center">健身减压时触发</td>
</tr>
<tr>
<td style="text-align:center">压力（stress_on_actions）</td>
<td style="text-align:center">stress_pulse</td>
<td style="text-align:center">暂时忽略，注释说这个块可能会被删</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_stress_level_reduced</td>
<td style="text-align:center">压力等级降低时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_stress_level_1</td>
<td style="text-align:center">压力等级变为1时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_stress_level_2</td>
<td style="text-align:center">压力等级变为2时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_stress_level_3</td>
<td style="text-align:center">压力等级变为3时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_stress_level_4</td>
<td style="text-align:center">压力等级变为4时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_1_event</td>
<td style="text-align:center">压力达到1级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_2_event</td>
<td style="text-align:center">压力达到2级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_3_event</td>
<td style="text-align:center">压力达到3级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_1_event_prison</td>
<td style="text-align:center">角色在监狱中，压力达到1级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_2_event_prison</td>
<td style="text-align:center">角色在监狱中，压力达到2级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_3_event_prison</td>
<td style="text-align:center">角色在监狱中，压力达到3级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center">头衔（title_on_actions）</td>
<td style="text-align:center">on_title_destroyed</td>
<td style="text-align:center">头衔被销毁时对头衔持有者触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_title_gain</td>
<td style="text-align:center">头衔获得时对该头衔的新持有者触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_title_gain_inheritance</td>
<td style="text-align:center">继承头衔时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_title_gain_usurpation</td>
<td style="text-align:center">篡夺头衔时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_title_lost</td>
<td style="text-align:center">失去头衔时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_explicit_claim_gain</td>
<td style="text-align:center">获得宣称时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_explicit_claim_lost</td>
<td style="text-align:center">失去宣称时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_rank_up</td>
<td style="text-align:center">头衔改变使角色升级时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_rank_down</td>
<td style="text-align:center">头衔改变使角色降级时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_vassal_gained</td>
<td style="text-align:center">得到封臣时触发</td>
</tr>
<tr>
<td style="text-align:center">特质（traits_on_actions）</td>
<td style="text-align:center">assign_trait_events</td>
<td style="text-align:center">到新压力等级时获取特质</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">assign_trait_ai_on_action</td>
<td style="text-align:center">AI随机获取特质的触发系统</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">assign_trait_on_action</td>
<td style="text-align:center">获取特殊特质</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ongoing_trait_events</td>
<td style="text-align:center">持有特殊特质时触发</td>
</tr>
<tr>
<td style="text-align:center">教程（tutorial）</td>
<td style="text-align:center">on_game_start_with_tutorial</td>
<td style="text-align:center">用教程开局时触发</td>
</tr>
<tr>
<td style="text-align:center">战争（war_on_actions）</td>
<td style="text-align:center">on_war_transferred</td>
<td style="text-align:center">战争中防御者改变时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_join_war_as_secondary</td>
<td style="text-align:center">角色作为战争的次要攻击者/次要防御者时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_war_started</td>
<td style="text-align:center">战争开始时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_war_won_attacker</td>
<td style="text-align:center">攻方赢得战争时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_war_won_defender</td>
<td style="text-align:center">守方赢得战争时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_war_white_peace</td>
<td style="text-align:center">战争无条件和平时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_war_invalidated</td>
<td style="text-align:center">战争无效时触发</td>
</tr>
<tr>
<td style="text-align:center">体重（weight_on_actions）</td>
<td style="text-align:center">on_weight_changed</td>
<td style="text-align:center">体重改变时触发（会触发一系列前面健康中的on_action）</td>
</tr>
<tr>
<td style="text-align:center">巫师（witch_on_actions）</td>
<td style="text-align:center">convert_to_witchcraft_failure_outcome</td>
<td style="text-align:center">转巫师失败时触发</td>
</tr>
<tr>
<td style="text-align:center">年度（yearly_on_actions）</td>
<td style="text-align:center">yearly_global_pulse</td>
<td style="text-align:center">每年1月1日触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">yearly_playable_pulse</td>
<td style="text-align:center">每年固定时间对可玩角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">three_year_playable_pulse</td>
<td style="text-align:center">每3年对可玩角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">five_year_playable_pulse</td>
<td style="text-align:center">每5年对可玩角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">quarterly_playable_pulse</td>
<td style="text-align:center">每季度对可玩角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">random_yearly_playable_pulse</td>
<td style="text-align:center">每年随机日期对可玩角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">random_yearly_everyone_pulse</td>
<td style="text-align:center">每年随机日期对所有角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">five_year_everyone_pulse</td>
<td style="text-align:center">每5年对所有角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">three_year_pool_pulse</td>
<td style="text-align:center">每3年对穷人触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">prison_maintenance_pulse</td>
<td style="text-align:center">角色监狱里关着人时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ai_character_pulse</td>
<td style="text-align:center">对AI触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_yearly_events</td>
<td style="text-align:center">每年随机日期触发</td>
</tr>
<tr>
<td style="text-align:center">活动-宴会（activities/feast_on_actions）</td>
<td style="text-align:center">feast_main_event_selection</td>
<td style="text-align:center">选择宴会主事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">feast_start_events</td>
<td style="text-align:center">宴会开始触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">feast_default_event_selection</td>
<td style="text-align:center">默认宴会主事件中对参与者触发的事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">feast_default_host_event_selection</td>
<td style="text-align:center">默认宴会主事件中对举办者触发的事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">feast_default_fallback</td>
<td style="text-align:center">宴会默认的返回事件</td>
</tr>
<tr>
<td style="text-align:center">活动-打猎（activities/hunt_on_actions）</td>
<td style="text-align:center">hunt_start_events</td>
<td style="text-align:center">打猎开始时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">hunt_random_pulse</td>
<td style="text-align:center">打猎过程中随机触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">hunt_end_pulse</td>
<td style="text-align:center">打猎结束触发</td>
</tr>
<tr>
<td style="text-align:center">活动-朝圣（activities/pilgrimage_on_actions）</td>
<td style="text-align:center">pilgrimage_setup</td>
<td style="text-align:center">朝圣开始</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pilgrimage_journey_events</td>
<td style="text-align:center">朝圣过程中触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">hajj_journey_events</td>
<td style="text-align:center">伊斯兰朝圣过程中触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pilgrimage_journey_event_fallback</td>
<td style="text-align:center">朝圣默认的返回事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pilgrimage_destination_events</td>
<td style="text-align:center">朝圣目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">hajj_destination_events</td>
<td style="text-align:center">伊斯兰目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">christian_destination_events</td>
<td style="text-align:center">基督徒目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">jewish_destination_events</td>
<td style="text-align:center">犹太人目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">muslim_destination_events</td>
<td style="text-align:center">穆斯林目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">hindu_destination_events</td>
<td style="text-align:center">印度教目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">buddhist_destination_events</td>
<td style="text-align:center">佛教徒目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">jain_destination_events</td>
<td style="text-align:center">耆那教目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">zoroastrian_destination_events</td>
<td style="text-align:center">拜火教目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">norse_destination_events</td>
<td style="text-align:center">挪威人目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">tengri_destination_events</td>
<td style="text-align:center">腾格里目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pagan_destination_events</td>
<td style="text-align:center">无信仰者目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pilgrimage_generic_destination_events</td>
<td style="text-align:center">普通目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pilgrimage_return_events</td>
<td style="text-align:center">朝圣后返回事件</td>
</tr>
<tr>
<td style="text-align:center">生活方式-外交（lifestyles/diplomacy_lifestyle_on_actions）</td>
<td style="text-align:center">diplomacy_lifestyle_progress_pulse</td>
<td style="text-align:center">外交生活事件，一年触发4次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_lifestyle_ongoing_events</td>
<td style="text-align:center">外交生活中的事件（包括了下面几个）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_lifestyle_common_events</td>
<td style="text-align:center">外交生活中的普通事件（2年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_lifestyle_uncommon_events</td>
<td style="text-align:center">外交生活中的不普通事件（10年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_lifestyle_rare_events</td>
<td style="text-align:center">外交生活中的稀有事件（30年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_lifestyle_unavailable_events</td>
<td style="text-align:center">外交生活中的不可能事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_foreign_special_1010_court_visit_events</td>
<td style="text-align:center">外交事件链1</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_foreign_special_1010_court_visit_interesting_relation_spy_outcome_events</td>
<td style="text-align:center">外交事件链2</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commission_epic_ongoing</td>
<td style="text-align:center">制作家族史诗事件</td>
</tr>
<tr>
<td style="text-align:center">生活方式-普通（lifestyles/general_lifestyle_on_actions）</td>
<td style="text-align:center">on_perks_refunded</td>
<td style="text-align:center">玩家改生活方式时退还技能触发</td>
</tr>
<tr>
<td style="text-align:center">生活方式-谋略（lifestyles/intrigue_lifestyle_on_actions）</td>
<td style="text-align:center">intrigue_lifestyle_progress_pulse</td>
<td style="text-align:center">谋略生活事件，一年触发4次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">intrigue_lifestyle_ongoing_events</td>
<td style="text-align:center">谋略生活中的事件（包括了下面几个）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">intrigue_lifestyle_common_events</td>
<td style="text-align:center">谋略生活中的普通事件（2年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">intrigue_lifestyle_uncommon_events</td>
<td style="text-align:center">谋略生活中的不普通事件（10年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">intrigue_lifestyle_rare_events</td>
<td style="text-align:center">谋略生活中的稀有事件（30年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">intrigue_lifestyle_unavailable_events</td>
<td style="text-align:center">谋略生活中的不可能事件</td>
</tr>
<tr>
<td style="text-align:center">生活方式-学识（lifestyles/learning_lifestyle_on_actions）</td>
<td style="text-align:center">learning_lifestyle_progress_pulse</td>
<td style="text-align:center">学识生活事件，一年触发4次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learning_lifestyle_ongoing_events</td>
<td style="text-align:center">学识生活中的事件（包括了下面几个）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learning_lifestyle_common_events</td>
<td style="text-align:center">学识生活中的普通事件（2年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learning_lifestyle_uncommon_events</td>
<td style="text-align:center">学识生活中的不普通事件（10年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learning_lifestyle_rare_events</td>
<td style="text-align:center">学识生活中的稀有事件（30年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learning_lifestyle_unavailable_events</td>
<td style="text-align:center">学识生活中的不可能事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">book_translation_story_events</td>
<td style="text-align:center">翻译书事件（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">mystic_communion_side_effect_events</td>
<td style="text-align:center">神秘圣餐事件（？不确定）</td>
</tr>
<tr>
<td style="text-align:center">生活方式-军事（lifestyles/martial_lifestyle_on_actions）</td>
<td style="text-align:center">martial_lifestyle_progress_pulse</td>
<td style="text-align:center">军事生活事件，一年触发4次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">martial_lifestyle_ongoing_events</td>
<td style="text-align:center">军事生活中的事件（包括了下面几个）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">martial_lifestyle_common_events</td>
<td style="text-align:center">军事生活中的普通事件（2年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">martial_lifestyle_uncommon_events</td>
<td style="text-align:center">军事生活中的不普通事件（10年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">martial_lifestyle_rare_events</td>
<td style="text-align:center">军事生活中的稀有事件（30年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">martial_lifestyle_unavailable_events</td>
<td style="text-align:center">军事生活中的不可能事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">horse_riding_accident_outcome</td>
<td style="text-align:center">骑马意外事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">search_for_troops_event_selection</td>
<td style="text-align:center">搜索部队事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learn_commander_trait_offer</td>
<td style="text-align:center">获得指挥官特质的机会</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learn_commander_trait_test</td>
<td style="text-align:center">获得指挥官特质的测试</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learn_commander_trait_success</td>
<td style="text-align:center">成功获得指挥官特质</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learn_commander_trait_failure</td>
<td style="text-align:center">未能获得指挥官特质</td>
</tr>
<tr>
<td style="text-align:center">生活方式-管理（lifestyles/stewardship_lifestyle_on_actions）</td>
<td style="text-align:center">stewardship_lifestyle_progress_pulse</td>
<td style="text-align:center">管理生活事件，一年触发4次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_ongoing_events</td>
<td style="text-align:center">管理生活中的事件（包括了下面几个）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_common_events</td>
<td style="text-align:center">管理生活中的普通事件（2年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_uncommon_events</td>
<td style="text-align:center">管理生活中的不普通事件（10年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_rare_events</td>
<td style="text-align:center">管理生活中的稀有事件（30年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_unavailable_events</td>
<td style="text-align:center">管理生活中的不可能事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">map_painting_event_selection</td>
<td style="text-align:center">绘制地图选项</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">map_painting_outcome</td>
<td style="text-align:center">绘制地图结果</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_road_building_chain</td>
<td style="text-align:center">修路事件链</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_road_building_events</td>
<td style="text-align:center">修路事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_domesday</td>
<td style="text-align:center">末日审判事件（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_domesday_end</td>
<td style="text-align:center">默认审判结束事件（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_duty_special_2000_mediation_stage_1</td>
<td style="text-align:center">调解事件阶段1（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_duty_special_2000_mediation_stage_2</td>
<td style="text-align:center">调解事件阶段2（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_duty_special_2000_mediation_background_events</td>
<td style="text-align:center">调解背景事件（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">sell_titles_side_effect_events</td>
<td style="text-align:center">买卖头衔副作用事件</td>
</tr>
<tr>
<td style="text-align:center">关系-主教（relations/bishop_on_actions）</td>
<td style="text-align:center">bishop_ongoing</td>
<td style="text-align:center">有主教时随机触发</td>
</tr>
<tr>
<td style="text-align:center">关系-父母（relations/parent_on_actions）</td>
<td style="text-align:center">parent_ongoing</td>
<td style="text-align:center">有父母时随机触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">parent_meddling_outcome</td>
<td style="text-align:center">父母干涉的结果</td>
</tr>
<tr>
<td style="text-align:center">关系-关系（relations/relation_on_actions）</td>
<td style="text-align:center">relation_upgrade_quarterly_pulse</td>
<td style="text-align:center">关系升级事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_quarterly_pulse</td>
<td style="text-align:center">恋人事件（一季度一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_ongoing</td>
<td style="text-align:center">恋人事件（一年一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_ongoing_fallback</td>
<td style="text-align:center">恋人事件的返回</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_ongoing_distance</td>
<td style="text-align:center">异地恋事件（一年一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_ongoing_distance_fallback</td>
<td style="text-align:center">异地恋事件返回</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_status_changes</td>
<td style="text-align:center">恋爱状态改变</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_set_relation_lover</td>
<td style="text-align:center">有恋人时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_remove_relation_lover</td>
<td style="text-align:center">失去恋人时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">friendship_quarterly_pulse</td>
<td style="text-align:center">朋友事件（一季度一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">friendship_status_changes</td>
<td style="text-align:center">朋友状态改变</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">friendship_ongoing</td>
<td style="text-align:center">朋友事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_set_relation_friend</td>
<td style="text-align:center">得到朋友</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_remove_relation_friend</td>
<td style="text-align:center">失去朋友（只和关系破裂有关，不会因为朋友凉了而触发）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_death_relation_friend</td>
<td style="text-align:center">朋友去世</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">rival_quarterly_pulse</td>
<td style="text-align:center">仇敌事件（一季度一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">rival_relation_changes</td>
<td style="text-align:center">仇敌改变事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">rivalry_ongoing</td>
<td style="text-align:center">仇敌事件（一年一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">rivalry_ongoing_fallback</td>
<td style="text-align:center">仇敌事件返回</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_set_relation_rival</td>
<td style="text-align:center">得到仇敌</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_remove_relation_rival</td>
<td style="text-align:center">失去仇敌</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">mentor_student_quarterly_pulse</td>
<td style="text-align:center">师生事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">mentor_student_relation_changes</td>
<td style="text-align:center">师生关系改变</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_remove_relation_guardian</td>
<td style="text-align:center">解除监护人时对被监护人触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_death_relation_guardian</td>
<td style="text-align:center">有监护人的被监护人死亡时，对被监护人触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_remove_relation_ward</td>
<td style="text-align:center">解除监护人时对监护人触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_death_relation_ward</td>
<td style="text-align:center">有被监护人的监护人死亡时，对监护人触发</td>
</tr>
<tr>
<td style="text-align:center">关系-兄弟（relations/sibling_on_actions）</td>
<td style="text-align:center">sibling_quarterly_pulse</td>
<td style="text-align:center">兄弟事件（一季度一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">sibling_statuses</td>
<td style="text-align:center">兄弟状态</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ongoing_sibling</td>
<td style="text-align:center">兄弟事件</td>
</tr>
<tr>
<td style="text-align:center">关系-配偶（relations/spouse_on_actions）</td>
<td style="text-align:center">spouse_ongoing</td>
<td style="text-align:center">配偶事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">spouse_councillor_default_on_action</td>
<td style="text-align:center">配偶内阁事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">court_politics_setup</td>
<td style="text-align:center">接下来的几个应该都是指配偶和内阁其他人的互动事件，不太确定，因此不写了。</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">court_politics_task_on_action</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">chivalry_setup</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">chivalry_task_on_action</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">court_intrigue_setup</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">court_intrigue_task_on_action</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">manage_domain_setup</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">manage_domain_task_on_action</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">patronage_setup</td>
<td style="text-align:center">配偶赞助开始</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">patronage_task_on_action</td>
<td style="text-align:center">配偶赞助任务</td>
</tr>
<tr>
<td style="text-align:center">关系-封臣（relations/vassal_on_actions）</td>
<td style="text-align:center">on_vassal_become_powerful</td>
<td style="text-align:center">封臣变强力时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">vassal_ongoing</td>
<td style="text-align:center">有封臣时触发</td>
</tr>
<tr>
<td style="text-align:center">计谋-绑架（schemes/abduct_on_actions）</td>
<td style="text-align:center">abduct_setup</td>
<td style="text-align:center">绑架开始</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">standard_abduct_method_setup</td>
<td style="text-align:center">绑架方式（？没绑架过，不清楚流程）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">abduct_succeeded</td>
<td style="text-align:center">绑架成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">abduct_failed</td>
<td style="text-align:center">绑架失败</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">abduct_ongoing</td>
<td style="text-align:center">绑架进行中</td>
</tr>
<tr>
<td style="text-align:center">计谋-拉拢（schemes/befriend_on_actions）</td>
<td style="text-align:center">befriend_ongoing</td>
<td style="text-align:center">交友进行中</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_dislike_ongoing</td>
<td style="text-align:center">和不喜欢的人交友</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_rival_ongoing</td>
<td style="text-align:center">和仇敌交友</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_critical_success</td>
<td style="text-align:center">交友成功关键点（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_success</td>
<td style="text-align:center">交友成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_failure</td>
<td style="text-align:center">交友失败</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_critical_failure</td>
<td style="text-align:center">交友失败关键点（？不确定）</td>
</tr>
<tr>
<td style="text-align:center">计谋-宣称权位（schemes/claim_throne_on_actions）</td>
<td style="text-align:center">claim_throne_setup</td>
<td style="text-align:center">宣称开始</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">standard_claim_throne_method_setup</td>
<td style="text-align:center">宣称方法</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">claim_throne_succeeded</td>
<td style="text-align:center">宣称成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">claim_throne_failed</td>
<td style="text-align:center">宣称失败</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">claim_throne_ongoing</td>
<td style="text-align:center">宣称进行中</td>
</tr>
<tr>
<td style="text-align:center">计谋-廷臣（schemes/court_on_actions）</td>
<td style="text-align:center">court_ongoing</td>
<td style="text-align:center">廷臣事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">court_outcome</td>
<td style="text-align:center">廷臣事件结果</td>
</tr>
<tr>
<td style="text-align:center">计谋-私奔（schemes/elope_on_actions）</td>
<td style="text-align:center">elope_ongoing</td>
<td style="text-align:center">私奔进行时</td>
</tr>
<tr>
<td style="text-align:center">计谋-牵制（schemes/fabricate_hook_on_actions）</td>
<td style="text-align:center">abricate_hook_method_success_outcome</td>
<td style="text-align:center">伪造牵制成功结果</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">fabricate_hook_ongoing</td>
<td style="text-align:center">伪造牵制进行中</td>
</tr>
<tr>
<td style="text-align:center">计谋-谋杀（schemes/murder_on_actions）</td>
<td style="text-align:center">murder_method_selection</td>
<td style="text-align:center">（dbq这部分我懒得写了…）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">infant_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">child_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">incapable_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">dungeon_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">house_arrest_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">standard_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_setup</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_save_roll</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_save_response</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_succeeded</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_failed</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_ongoing</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">计谋-勾引（schemes/seduce_on_actions）</td>
<td style="text-align:center">seduce_ongoing_milestone_1</td>
<td style="text-align:center">勾引阶段1</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">seduce_ongoing_milestone_2</td>
<td style="text-align:center">勾引阶段2</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">seduce_success</td>
<td style="text-align:center">勾引成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">seduce_generic_success</td>
<td style="text-align:center">勾引成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">seduce_failure</td>
<td style="text-align:center">勾引失败</td>
</tr>
<tr>
<td style="text-align:center">计谋-拉拢（schemes/sway_on_actions）</td>
<td style="text-align:center">sway_success</td>
<td style="text-align:center">拉拢成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">sway_failure</td>
<td style="text-align:center">拉拢失败</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">sway_ongoing</td>
<td style="text-align:center">拉拢进行时</td>
</tr>
<tr>
<td style="text-align:center">周期故事-猫（story_cycles/story_cycle_cat_on_actions）</td>
<td style="text-align:center">ongoing_cat_events</td>
<td style="text-align:center">有猫时触发的事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">story_cycle_cat_pet_decision_on_actions</td>
<td style="text-align:center">决议养猫</td>
</tr>
<tr>
<td style="text-align:center">周期故事-狗（story_cycles/story_cycle_dog_on_actions）</td>
<td style="text-align:center">ongoing_dog_events</td>
<td style="text-align:center">有狗时触发事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">story_cycle_dog_pet_decision_on_actions</td>
<td style="text-align:center">决议养狗</td>
</tr>
<tr>
<td style="text-align:center">周期故事-打猎神秘动物（story_cycle_hunt_mystical_animal_on_actions）</td>
<td style="text-align:center">ongoing_hunt_mystical_animal_events</td>
<td style="text-align:center">打猎时的神秘动物</td>
</tr>
<tr>
<td style="text-align:center">周期故事-谋杀系列（story_cycles/story_cycle_murders_at_court_on_actions）</td>
<td style="text-align:center">murders_at_court_events</td>
<td style="text-align:center">谋杀系列事件（就是那个很奇怪可怕的发现尸体等等一系列事件）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murders_at_court_confrontation</td>
<td style="text-align:center">最终结果</td>
</tr>
<tr>
<td style="text-align:center">周期故事-宴会？（story_cycles/story_cycle_party_baron_on_actions）</td>
<td style="text-align:center">party_baron_events</td>
<td style="text-align:center">看本地化文件是宴会上的事情，不知道这个要怎么解释</td>
</tr>
<tr>
<td style="text-align:center">周期故事-农民（story_cycles/story_cycle_peasant_affair_on_actions）</td>
<td style="text-align:center">peasant_affair_shows_up_at_court</td>
<td style="text-align:center">农民来时触发（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">peasant_affair_looking_for_peasant</td>
<td style="text-align:center">寻找农民</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">peasant_affair_peasant_at_court</td>
<td style="text-align:center">农民来找你时触发（比如想让你认个儿子）</td>
</tr>
<tr>
<td style="text-align:center">周期故事-重建罗马（story_cycles/story_cycle_roman_restoration_on_actions）</td>
<td style="text-align:center">on_action_roman_restoration_pulse</td>
<td style="text-align:center">重建罗马触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_action_orthodox_pentarchy_pulse</td>
<td style="text-align:center">拜占庭恢复五大牧首区</td>
</tr>
<tr>
<td style="text-align:center">周期故事-受尊敬的领主（story_cycles/story_cycle_statecraft_lifestyle_respected_liege_on_actions）</td>
<td style="text-align:center">ongoing_respected_liege_events</td>
<td style="text-align:center">受尊敬的领主（这块代码还没写，是空的）</td>
</tr>
<tr>
<td style="text-align:center">周期故事-战马（story_cycles/story_cycle_warhorse_on_actions）</td>
<td style="text-align:center">ongoing_warhorse_events</td>
<td style="text-align:center">有战马时随机触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">breed_warhorse</td>
<td style="text-align:center">战马繁殖事件</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode记录-1</title>
    <url>/2020/12/21/Leetcode%E8%AE%B0%E5%BD%95-1/</url>
    <content><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">链接</a></p>
<p>给定一个整数数组<code>nums</code>和一个整数目标值<code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,3], target &#x3D; 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>2 &lt;= <code>nums.length</code> &lt;= 103</li>
<li>-109 &lt;= <code>nums[i]</code> &lt;= 109</li>
<li>-109 &lt;= <code>target</code> &lt;= 109</li>
<li>只会存在一个有效答案</li>
</ol>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    * returnSize=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> result[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numsSize<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;numsSize; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[j]==target)&#123;</span><br><span class="line">                result[<span class="number">0</span>]=i;</span><br><span class="line">                result[<span class="number">1</span>]=j;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><ol>
<li>指针没学好，所以其实还是没懂为什么一开始要指定<code>* returnSize=2;</code></li>
<li>是最普通的遍历判断是否正确的过程，没有什么复杂算法</li>
<li>第3行如果不用静态数组，则最后返回的时候数组生命周期就结束了，会返回一个空数组</li>
<li>还有一些同样思路的代码写法，但是输出的时候不对，总是输出<code>]</code>，猜测和OJ系统的gcc有关，暂且不管</li>
</ol>
<h2 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h2><p><a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/" target="_blank" rel="noopener">参考链接</a></p>
<ol>
<li><p>哈希表（C语言的哈希表代码略长，所以改用python）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        hashtable = dict()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target - num], i]</span><br><span class="line">            hashtable[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
</li>
<li><p>首尾递进查找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sorted_id = sorted(range(len(nums)), key=<span class="keyword">lambda</span> k: nums[k])</span><br><span class="line">        head = <span class="number">0</span></span><br><span class="line">        tail = len(nums) - <span class="number">1</span></span><br><span class="line">        sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]]</span><br><span class="line">        <span class="keyword">while</span> sum_result != target:</span><br><span class="line">            <span class="keyword">if</span> sum_result &gt; target:</span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> sum_result &lt; target:</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">            sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]]</span><br><span class="line">        <span class="keyword">return</span> [sorted_id[head], sorted_id[tail]]</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-6</title>
    <url>/2020/12/16/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-6/</url>
    <content><![CDATA[<h1 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h1><h2 id="基础格式"><a href="#基础格式" class="headerlink" title="基础格式"></a>基础格式</h2><ol>
<li><p>特质相关的文件有两个，第一个是对特质的说明，存放在文件夹<code>Crusader Kings III\game\common\traits</code>中，文件名为<code>00_traits.txt</code>，同目录下有一个<code>_traits.info</code>是说明怎么写特质；第二个是本地化文本文件，<code>Crusader Kings III\game\localization\simp_chinese\traits_l_simp_chinese.yml</code>，其他语言的也是类似路径。</p>
</li>
<li><p>目前游戏里有277个特质，在<a href="https://ck3.parawikis.com/wiki/%E7%89%B9%E8%B4%A8" target="_blank" rel="noopener">wiki</a>中已经有人整理过特质的分类和效果等信息。</p>
</li>
<li><p>从<code>_traits.info</code>中我们可以看到，一个特质<code>trait_&lt;key&gt;</code>对应的描述在本地化文本中应该是<code>trait_&lt;key&gt;_desc</code>，而默认图标是<code>gfx/interface/icons/traits/&lt;trait&gt;.dds</code>文件。</p>
</li>
<li><p>特质默认加给玩家角色，也就是<code>root</code>。</p>
</li>
<li><p>显然，一个最基础的特质<code>test_trait</code>由3部分组成：</p>
<ol>
<li><p>特质图标：<code>gfx/interface/icons/traits/test_trait.dds</code></p>
</li>
<li><p>特质内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test_trait &#x3D; &#123;</span><br><span class="line">	index &#x3D; 278</span><br><span class="line">	desc &#x3D; &#123;</span><br><span class="line">		first_valid &#x3D; &#123;</span><br><span class="line">			triggered_desc &#x3D; &#123;</span><br><span class="line">				trigger &#x3D; &#123;</span><br><span class="line">					NOT &#x3D; &#123; exists &#x3D; this &#125;</span><br><span class="line">				&#125;</span><br><span class="line">				desc &#x3D; trait_test_trait_desc</span><br><span class="line">			&#125;</span><br><span class="line">			desc &#x3D; trait_test_trait_character_desc</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特质文本描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> # test traits</span><br><span class="line"> trait_test_trait:0 &quot;XXX&quot;</span><br><span class="line"> trait_test_trait_desc:0 &quot;XXX&quot;</span><br><span class="line"> trait_test_trait_character_desc:0 &quot;XXX&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要注意的是，在特质内容中，为了保证触发特效时该角色是存在的，我们需要进行<code>first_valid</code>来验证<code>Root</code>存在。</p>
</li>
<li><p>文本描述中，如果需要出现角色的名字，可以通过<code>[ROOT.GetCharacter.GetFirstNameNoTooltip]</code>来获取角色名。</p>
</li>
</ol>
</li>
<li><p>当我们按照上一条中，准备好对应的图标，并在mod文件夹中建立了<code>traits</code>文件夹和相应的特质文件，以及本地化内容也新建了文件，就会得到如下文件结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- test</span><br><span class="line">	- common</span><br><span class="line">		- traits</span><br><span class="line">			01_traits.txt</span><br><span class="line">	- gfx</span><br><span class="line">		- interface</span><br><span class="line">			- icons</span><br><span class="line">				- traits</span><br><span class="line">					test_trait.dds</span><br><span class="line">	- localization</span><br><span class="line">		- simp_chinese</span><br><span class="line">			- traits_test_l_simp_chinese.yml</span><br><span class="line">	descriptor.mod</span><br></pre></td></tr></table></figure>
<p>需要注意的是，特质文件和本地化文件的文件名本身并不是很重要，但是如果和CK3官方的那俩文件重名，则需要把那两个文件中的内容也原封不动复制过来，否则本身自带的特质就会都没法用。</p>
</li>
<li><p>准备好一系列文件以后，打开游戏通过<code>add_traits</code>指令增加特质，就可以看到对应的特质了。</p>
</li>
</ol>
<h2 id="一些具体设置"><a href="#一些具体设置" class="headerlink" title="一些具体设置"></a>一些具体设置</h2><ol>
<li>除了上述的文本描述以外，特质还可以增加很多具体设置，例如对角色的影响、获取的触发条件等等。以下内容是对<code>_traits.info</code>文件的翻译。</li>
<li><code>health</code>：表示该特质对健康的修正，例如在特质身心俱悉（<code>whole_of_body</code>）中，有一条<code>health = 0.5</code>，表示有该特质的角色健康+0.5。</li>
<li><code>fertility</code>：表示该特质对生育力的修正百分比，例如还是身心俱悉中，有一条<code>fertility = 0.2</code>表示该角色的生育力+25%。</li>
<li><code>inherit_chance</code>：表示该特质遗传给孩子的概率，例如特质梅毒<code>great_pox</code>中有一条<code>inherit_chance = 10</code>，表示遗传概率是10%。</li>
<li><code>birth</code>：表示有百分之多少的人会带着这个特质出生。</li>
<li><code>random_creation</code>：表示有百分之多少的人会带着这个特质被创造出来。和出生不一样的是，创造是指通过命令行生成和修改人物。不过根据检索，<code>00_traits</code>文件里的<code>birth</code>和<code>random_creation</code>都是一起出现的，且值相等。</li>
<li><code>triggered_opinion</code>：这一条应该是针对角色好感度修正特质的触发器，它包括以下内容：<ol>
<li><code>opinion_modifier</code>：修正的好感度类型</li>
<li><code>parameter</code>：要检查的布尔值参数</li>
<li><code>check_missing</code>：检查参数是否没设置（或设置为 false），而不是设置为 true</li>
<li><code>same_faith</code>：相同信仰</li>
<li><code>same_dynasty</code>：相同宗族</li>
<li><code>ignore_opinion_value_if_same_trait</code>：设置为<code>yes</code>的时候，会对有相同特质的角色不进行好感度修正，但是惩罚理由还在</li>
<li><code>male_only</code>和<code>female_only</code>很显然分别是仅限男性和仅限女性</li>
</ol>
</li>
<li><code>compatibility</code>：这是用于<code>compatibility_modifier</code>和<code>trait_compatibility</code>这两个触发器的，是检查特质持有者与列出的特质的兼容性。感觉是指获取某一特质后，再获取其他特质的概率会受这个列表值的修正。具体怎么用还不太明白，之后补充。</li>
<li><code>parent_inheritance_sex</code>：可以是<code>male/female/all</code>，表示该特质可以从父亲/母亲/双亲继承。</li>
<li><code>child_inheritance_sex</code>：值同上，表示该特质可以遗传给男孩/女孩/所有孩子。</li>
<li><code>genetic</code>：默认是<code>no</code>，如果被设置为<code>yes</code>，则表示特征可以是非活动状态。子级可以从活动和非活动父特征中继承该特征。活动特征继承为 100% 的机会，非活动特征为 50% 的机会。如果从父母两个成功继承该特征，则该特征将变为活动状态。如果仅从一个父级继承，则它是非活动状态。（可以理解成生物学基因的隐性显性）。</li>
<li><code>inherit_from_real_father</code>：是否可以从亲生父亲那里继承，其实不太懂这个和前面<code>parent_inheritance_sex</code>有什么不一样的。</li>
<li><code>enables_inbred</code>：概括来说这个标志为<code>yes</code>时意味着这个特质是近亲繁殖的。</li>
<li><code>good</code>：特质标识为好的（默认值是<code>no</code>，表示坏的）。</li>
<li><code>genetic_constraint_all</code>：这种遗传约束将在获得特征时应用。</li>
<li><code>forced_portrait_age_index</code>：年龄索引，可以设置多个，但是我还不知道年龄索引是什么东西，以后补充。</li>
<li><code>portrait_extremity_shift</code>：这个值是一个表示百分比的小数，角色获得对应特质时，每个变形基因都会按这个百分比向 0 或 1 移动，具体是0还是1看基因本身接近哪个，比如该值为0.25， 基因值为0.4，则0.4将向0偏移0.25，从而变成0.3。</li>
<li><code>ugliness_portrait_extremity_shift</code>：和上一条一样，但是获得此特质时，与角色最极端的单一特征（在公共/基因中定义）相关的每个变形基因都会按此百分比向 0 或 1 移动。关于这里的特征、基因等词还不太了解，以后再补充。</li>
<li><code>immortal</code>：设置为<code>yes</code>后，获得该特质的角色会停止视觉老化，使角色对自然死亡免疫。仍然可以被脚本杀死。生育能力将匹配视觉年龄。可以使用<code>set_immortal_age</code>更改视觉年龄。</li>
<li><code>physical, health_trait, fame</code>：这三个设置为<code>yes</code>则分别表示该特质是和物理、健康、名誉相关。</li>
<li><code>trait_exclusive_if_realm_contains</code>：这个值是<code>{}</code>，大括号里可以填东西，表示随机分配给指挥官时考虑的地形类型列表。只有当指挥官的文化包含具有列表中指定的地形类型之一的省时，才分配/考虑这些特征。</li>
<li><code>blocks_from_claim_inheritance</code>：设置为<code>yes</code>时，有该特质的角色无法继承头衔宣称。</li>
<li><code>blocks_from_claim_inheritance_from_dynasty</code>：同上，设置为<code>yes</code>时，有该特质的角色无法从宗族成员那里继承头衔宣称。</li>
<li><code>shown_in_ruler_designer</code>：默认是<code>yes</code>，设置为<code>yes</code>时，可以在自定义角色的那个地方的特质列表中看到该特质。</li>
<li><code>ruler_designer_cost</code>：默认是0，同上，是指自定义角色时该特质消耗的点数。</li>
<li><code>valid_sex</code>：可以是<code>all/male/female</code>，默认是<code>all</code>，表示该特质可以由什么性别的角色获得。</li>
</ol>
<h2 id="如何使角色得到特质"><a href="#如何使角色得到特质" class="headerlink" title="如何使角色得到特质"></a>如何使角色得到特质</h2><p>和命令行一样，在<code>mod</code>里需要角色获取特质的时候，<code>add_trait = trait_ID</code>即可。</p>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-5</title>
    <url>/2020/11/08/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-5/</url>
    <content><![CDATA[<h1 id="条件式"><a href="#条件式" class="headerlink" title="条件式"></a>条件式</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>条件式的基本结构和CK2里一样，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if &#x3D; &#123;</span><br><span class="line">	limit &#x3D; &#123;</span><br><span class="line">		# 条件</span><br><span class="line">	&#125;</span><br><span class="line">	# 符合条件时执行的指令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实条件式不仅限于if语句，在其他地方也会出现这样<code>limit = ...</code>的句式，用来表示执行指令的条件。</p>
<p>接下来沿用之前的例子，将送钱的事件写一个条件式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace &#x3D; give_money</span><br><span class="line">give_money.1 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; give_money.1.t</span><br><span class="line">	desc &#x3D; give_money.1.desc</span><br><span class="line">	theme &#x3D; stewardship</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.a</span><br><span class="line">		add_gold &#x3D; 1000</span><br><span class="line">		add_prestige &#x3D; -500</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.b</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.c</span><br><span class="line">		if &#x3D; &#123;</span><br><span class="line">			limit &#x3D; &#123;</span><br><span class="line">				gold &gt;1000</span><br><span class="line">			&#125;</span><br><span class="line">			remove_short_term_gold &#x3D; 1000</span><br><span class="line">			add_prestige &#x3D; 500</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，现在第三个选项是有条件执行的，当金币大于1000时，会执行减少金钱增加虔诚的指令，而金币不足则不会执行。具体到游戏中，界面如下图，当右上角金币只有26的时候，第三个选项是没有直接影响；而金币超过1000时，则第三个选项变成了扣钱换虔诚。</p>
<p><img src="https://i.loli.net/2020/12/05/nUe1ExpMmFwiJgr.png" alt="image-20201205211819919"></p>
<p><img src="https://i.loli.net/2020/12/05/EMmug4AC7KRUFrS.png" alt="image-20201205212017719"></p>
<h2 id="增加分支"><a href="#增加分支" class="headerlink" title="增加分支"></a>增加分支</h2><p>在一些情况下，我们需要表达“如果满足条件，则执行A指令；反之，则执行B指令”，这种情况就不能简单地用上面的结构来实现，而是使用else语句，具体结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if &#x3D; &#123;</span><br><span class="line">	limit &#x3D; &#123;</span><br><span class="line">		# 条件</span><br><span class="line">	&#125;</span><br><span class="line">	# 符合条件时执行的指令</span><br><span class="line">&#125;</span><br><span class="line">else &#x3D; &#123;</span><br><span class="line">	# 不符合条件时执行的指令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如我们希望，当金钱不够1000时加200虔诚，不扣钱，那就如下改写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option &#x3D; &#123;</span><br><span class="line">	name &#x3D; give_money.1.option.c</span><br><span class="line">	if &#x3D; &#123;</span><br><span class="line">		limit &#x3D; &#123;</span><br><span class="line">			gold &gt;1000</span><br><span class="line">		&#125;</span><br><span class="line">		remove_short_term_gold &#x3D; 1000</span><br><span class="line">		add_prestige &#x3D; 500</span><br><span class="line">	&#125;</span><br><span class="line">	else &#x3D; &#123;</span><br><span class="line">		add_prestige &#x3D; 200</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体效果如下图，当金币够1000时，和前面一样；而金币不够1000时，则只有加200虔诚。</p>
<p><img src="https://i.loli.net/2020/12/05/42FCzK9NsnlEhZ5.png" alt="image-20201205213507855"></p>
<p><img src="https://i.loli.net/2020/12/05/VbFYSnlX19IqHAp.png" alt="image-20201205213724688"></p>
<ul>
<li>需要补充说明的是，CK2中没有else语句，而是通过增加break来实现分支的；相反，CK3中无法通过break来实现分支。</li>
</ul>
<h1 id="随机性结果"><a href="#随机性结果" class="headerlink" title="随机性结果"></a>随机性结果</h1><p>当我们希望某个选项的结果随机出现的时候，就需要用到<code>Random</code>，它有以下两种用法：</p>
<ol>
<li><p>该选项有一定概率得到某种结果，或者无事发生：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">random &#x3D; &#123;</span><br><span class="line">	chance &#x3D; 概率值</span><br><span class="line">	选项结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，我们将之前的事件中的第二个选项修改成如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option &#x3D; &#123;</span><br><span class="line">	name &#x3D; give_money.1.option.b</span><br><span class="line">	random &#x3D; &#123;</span><br><span class="line">		chance &#x3D; 50</span><br><span class="line">		add_gold &#x3D; 1000</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个选项很容易理解，有50%的概率得到1000金币，游戏中的截图如下：</p>
<p><img src="https://i.loli.net/2020/12/10/GLtuAOkoBDZ4S8h.png" alt="image-20201210193754167"></p>
<p>顺带一提，明明是50%的概率，我却直到第5次才获得1000……</p>
</li>
<li><p>更多情况我们会希望得到多个随机结果，这时就要用<code>Random_list</code>，结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">random_list &#x3D; &#123;</span><br><span class="line">	概率1 &#x3D; &#123;</span><br><span class="line">		第一个结果</span><br><span class="line">	&#125;</span><br><span class="line">	概率2 &#x3D; &#123;</span><br><span class="line">		第二个结果</span><br><span class="line">	&#125;</span><br><span class="line">	概率3 &#x3D; &#123;</span><br><span class="line">		第三个结果</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种结构下，每个情况的触发概率并不是直接的百分比，而是该选项值占所有概率总和的百分比，具体来说，比如（30，30，15）这样的组合中，第一个选项的概率并不是30%，而是30/75，也就是40%。</p>
<p>我们再将刚才的事件进行如下修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option &#x3D; &#123;</span><br><span class="line">	name &#x3D; give_money.1.option.b</span><br><span class="line">	random_list &#x3D; &#123;</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			add_gold &#x3D; 1000</span><br><span class="line">		&#125;</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			add_gold &#x3D; 100</span><br><span class="line">		&#125;</span><br><span class="line">		15 &#x3D; &#123;</span><br><span class="line">			remove_short_term_gold &#x3D; 200</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样修改后，游戏中的截图如下：</p>
<p><img src="https://i.loli.net/2020/12/10/T1wtGmAWIkvqrCo.png" alt="image-20201210194729366"></p>
</li>
</ol>
<h2 id="有触发的随机性条件"><a href="#有触发的随机性条件" class="headerlink" title="有触发的随机性条件"></a>有触发的随机性条件</h2><p>虽然到目前为止还没学触发（Trigger），但大致意思应该能看懂，和前面if语句中的limit有点像。</p>
<p>如果某个随机选项有触发条件，那么当满足条件时，该选项的概率值才会参与计算，例如下面这个事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option &#x3D; &#123;</span><br><span class="line">	name &#x3D; give_money.1.option.b</span><br><span class="line">	random_list &#x3D; &#123;</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			trigger &#x3D; &#123;</span><br><span class="line">				gold &gt; 1000</span><br><span class="line">			&#125;</span><br><span class="line">			add_gold &#x3D; 1000</span><br><span class="line">		&#125;</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			add_gold &#x3D; 100</span><br><span class="line">		&#125;</span><br><span class="line">		15 &#x3D; &#123;</span><br><span class="line">			remove_short_term_gold &#x3D; 200</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当金币不足1000时，可以看到游戏中截图如下：</p>
<p><img src="https://i.loli.net/2020/12/10/EkoGJDMLstROlY5.png" alt="image-20201210195304419"></p>
<p>而当金币够1000时，事件就变成了：</p>
<p><img src="https://i.loli.net/2020/12/10/mp8YdqW7IS1R2vZ.png" alt="image-20201210195404539"></p>
<h2 id="修改随机权重"><a href="#修改随机权重" class="headerlink" title="修改随机权重"></a>修改随机权重</h2><p>有时候我们希望某个随机结果的权重根据不同的条件而发生改变，例如前面的事件中，同样是得到1000金币，我们希望根据不同的管理值会有不同的概率。这样的效果我们可以使用<code>modifier</code>来实现，具体事件代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option &#x3D; &#123;</span><br><span class="line">	name &#x3D; give_money.1.option.b</span><br><span class="line">	random_list &#x3D; &#123;</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			trigger &#x3D; &#123;</span><br><span class="line">				gold &gt; 1000</span><br><span class="line">			&#125;</span><br><span class="line">			modifier &#x3D; &#123;</span><br><span class="line">				add &#x3D; stewardship</span><br><span class="line">			&#125;</span><br><span class="line">			add_gold &#x3D; 1000</span><br><span class="line">		&#125;			</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			add_gold &#x3D; 100</span><br><span class="line">		&#125;</span><br><span class="line">		15 &#x3D; &#123;</span><br><span class="line">			remove_short_term_gold &#x3D; 200</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的含义就是，该选项有3个随机结果，分别是金币+1000，金币+100，金币-200，其概率组合是（30+管理值，30，15）。</p>
<p>那么在游戏中我们可以看到，该角色管理值是8，对应的事件如下：</p>
<p><img src="https://i.loli.net/2020/12/10/htkEOdT9qS3xBQY.png" alt="image-20201210203011631"></p>
<p>需要注意的是，不能直接把类似stewardship这样的词放到概率值那里，如果我们希望直接用stewardship当概率，则应该按下面的形式来写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">random_list &#x3D; &#123;</span><br><span class="line">	0 &#x3D; &#123;</span><br><span class="line">		modifier &#x3D; &#123;</span><br><span class="line">			add &#x3D; stewardship</span><br><span class="line">		&#125;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，我尝试给modifier加trigger或者if语句，都失败了，可能它只能单独出现吧。</p>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-4</title>
    <url>/2020/11/08/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-4/</url>
    <content><![CDATA[<h1 id="事件模组"><a href="#事件模组" class="headerlink" title="事件模组"></a>事件模组</h1><p><a href="https://ck3.paradoxwikis.com/Event_modding" target="_blank" rel="noopener">链接</a></p>
<h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>事件在<code>events</code>文件夹下的<code>.txt</code>文件中。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>整体结构与<a href="https://ck2.paradoxwikis.com/Event_modding" target="_blank" rel="noopener">CK2</a>的事件很相似，但是对语法进行了一些调整，并增加了大量额外的功能，其中许多功能是可选的。此处将介绍每个事件所必须的部分，并在稍后部分中单独介绍其他内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">example.1 &#x3D; &#123;</span><br><span class="line">	desc &#x3D; example.1.desc</span><br><span class="line">	</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; example.1.a</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写好该mod并加载，即可在游戏中的控制台输入<code>event triggers [example.1]</code>来触发该事件。</p>
<h3 id="ID和命名空间"><a href="#ID和命名空间" class="headerlink" title="ID和命名空间"></a>ID和命名空间</h3><p>ID是事件独一无二的标志。</p>
<h3 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h3><p>这些是确定事件种类和外观的顶级变量。它们具有有限的值集。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Flag</th>
<th>Meaning</th>
<th>Possible values</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>事件类型，决定root的范围。</td>
<td>* character_event none (when an event doesn’t use the root scope at all)</td>
</tr>
<tr>
<td>hidden</td>
<td>如果设置为true，则该事件不会显示出来，只会在后台触发。可用于执行与玩家不立即相关的维护事件。</td>
<td>true, false</td>
</tr>
</tbody>
</table>
</div>
<h2 id="画像"><a href="#画像" class="headerlink" title="画像"></a>画像</h2><h3 id="画像位置"><a href="#画像位置" class="headerlink" title="画像位置"></a>画像位置</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Portrait Position</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>left_portrait</td>
<td>出现在事件场景的左边。</td>
</tr>
<tr>
<td>right_portrait</td>
<td>出现在事件场景的右边。</td>
</tr>
<tr>
<td>lower_left_portrait</td>
<td>出现在事件场景的左下方。</td>
</tr>
<tr>
<td>lower_center_portrait</td>
<td>出现在事件场景的中下方。</td>
</tr>
<tr>
<td>lower_right_portrait</td>
<td>出现在事件场景的右下方。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">example_event.1001 &#x3D; &#123;</span><br><span class="line">	left_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; ROOT # 无论是什么角色，都显示在此事件窗口位置，显示所选的动画。</span><br><span class="line">		animation &#x3D; fear # 请注意，具有某些遗传特征（例如，巨人主义、侏儒主义）的角色更改其角色模型具有不同的动画，如果将其中一个动画分配给没有该模型的角色，则可能会发生崩溃。</span><br><span class="line">	&#125;</span><br><span class="line">	right_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; ROOT</span><br><span class="line">		animation &#x3D; scheme</span><br><span class="line">	&#125;</span><br><span class="line">	lower_left_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; ROOT</span><br><span class="line">	&#125;</span><br><span class="line">	lower_center_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; ROOT</span><br><span class="line">	&#125;</span><br><span class="line">	lower_right_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; ROOT</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段mod所对应的事件如下图所示。</p>
<p><img src="https://i.loli.net/2020/11/08/GlaYmiW15KjkUzF.png" alt="img"></p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Animation</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>happiness</td>
<td>dismissal</td>
<td>prison_dungeon</td>
<td>admiration</td>
</tr>
<tr>
<td>disgust</td>
<td>schadenfreude</td>
<td>stress</td>
<td>personality_compassionate</td>
</tr>
<tr>
<td>pain</td>
<td>ecstasy</td>
<td>fear</td>
<td>rage</td>
</tr>
<tr>
<td>anger</td>
<td>flirtation_left</td>
<td>shame</td>
<td>boredom</td>
</tr>
<tr>
<td>shock</td>
<td>worry</td>
<td>scheme</td>
<td>personality_bold</td>
</tr>
<tr>
<td>personality_callous</td>
<td>personality_irrational</td>
<td>personality_content</td>
<td>flirtation</td>
</tr>
<tr>
<td>disbelief</td>
<td>personality_cynical</td>
<td>personality_rational</td>
<td>personality_dishonorable</td>
</tr>
<tr>
<td>idle</td>
<td>paranoia</td>
<td>personality_vengeful</td>
<td>disapproval</td>
</tr>
<tr>
<td>sick</td>
<td>beg</td>
<td>personality_zealous</td>
<td>newborn</td>
</tr>
<tr>
<td>love</td>
<td>sadness</td>
<td>personality_honorable</td>
<td>personality_forgiving</td>
</tr>
<tr>
<td>personality_greedy</td>
<td>personality_coward</td>
<td>severelyinjured</td>
<td>severelywounded</td>
</tr>
<tr>
<td>war_attacker</td>
<td>war_defender</td>
<td>war_over_win</td>
<td>grief</td>
</tr>
</tbody>
</table>
</div>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Theme</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>abduct_scheme</td>
<td>alliance</td>
<td>bastardy</td>
<td>battle</td>
</tr>
<tr>
<td>befriend_scheme</td>
<td>claim_throne_scheme</td>
<td>corruption</td>
<td>crown</td>
</tr>
<tr>
<td>culture_change</td>
<td>death</td>
<td>default</td>
<td>diplomacy</td>
</tr>
<tr>
<td>diplomacy_family_focus</td>
<td>diplomacy_foreign_affairs_focus</td>
<td>diplomacy_majesty_focus</td>
<td>dread</td>
</tr>
<tr>
<td>dungeon</td>
<td>dynasty</td>
<td>education</td>
<td>fabricate_hook_scheme</td>
</tr>
<tr>
<td>faith</td>
<td>family</td>
<td>feast_activity</td>
<td>friend_relation</td>
</tr>
<tr>
<td>friendly</td>
<td>generic_intrigue_scheme</td>
<td>healthcare</td>
<td>hunt_activity</td>
</tr>
<tr>
<td>hunting</td>
<td>intrigue</td>
<td>intrigue_intimidation_focus</td>
<td>intrigue_skulduggery_focus</td>
</tr>
<tr>
<td>intrigue_temptation_focus</td>
<td>learning</td>
<td>learning_medicine_focus</td>
<td>learning_scholarship_focus</td>
</tr>
<tr>
<td>learning_theology_focus</td>
<td>love</td>
<td>lover_relation</td>
<td>marriage</td>
</tr>
<tr>
<td>martial</td>
<td>martial_authority_focus</td>
<td>martial_chivalry_focus</td>
<td>martial_strategy_focus</td>
</tr>
<tr>
<td>medicine</td>
<td>mental_break</td>
<td>mental_health</td>
<td>murder_scheme</td>
</tr>
<tr>
<td>party</td>
<td>pet</td>
<td>physical_health</td>
<td>pilgrimage_activity</td>
</tr>
<tr>
<td>pregnancy</td>
<td>prison</td>
<td>realm</td>
<td>recovery</td>
</tr>
<tr>
<td>rival_relation</td>
<td>romance_scheme</td>
<td>secret</td>
<td>seduce_scheme</td>
</tr>
<tr>
<td>seduction</td>
<td>skull</td>
<td>stewardship</td>
<td>stewardship_domain_focus</td>
</tr>
<tr>
<td>stewardship_duty_focus</td>
<td>stewardship_wealth_focus</td>
<td>sway_scheme</td>
<td>unfriendly</td>
</tr>
<tr>
<td>vassal</td>
<td>war</td>
<td>witchcraft</td>
</tr>
</tbody>
</table>
</div>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Background</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>alley_day</td>
<td>alley_night</td>
<td>armory</td>
<td>army_camp</td>
</tr>
<tr>
<td>battlefield</td>
<td>bedchamber</td>
<td>burning_building</td>
<td>corridor_day</td>
</tr>
<tr>
<td>corridor_night</td>
<td>council_chamber</td>
<td>courtyard</td>
<td>docks</td>
</tr>
<tr>
<td>dungeon</td>
<td>farmland</td>
<td>feast</td>
<td>gallows</td>
</tr>
<tr>
<td>garden</td>
<td>market</td>
<td>market_east</td>
<td>market_india</td>
</tr>
<tr>
<td>market_tribal</td>
<td>market_west</td>
<td>physicians_study</td>
<td>sitting_room</td>
</tr>
<tr>
<td>study</td>
<td>tavern</td>
<td>temple</td>
<td>temple_church</td>
</tr>
<tr>
<td>temple_generic</td>
<td>temple_mosque</td>
<td>temple_scope</td>
<td>terrain</td>
</tr>
<tr>
<td>terrain_activity</td>
<td>terrain_scope</td>
<td>throne_room</td>
<td>throne_room_east</td>
</tr>
<tr>
<td>throne_room_india</td>
<td>throne_room_mediterranean</td>
<td>throne_room_scope</td>
<td>throne_room_tribal</td>
</tr>
<tr>
<td>throne_room_west</td>
<td>wilderness</td>
<td>wilderness_desert</td>
<td>wilderness_forest</td>
</tr>
<tr>
<td>wilderness_forest_pine</td>
<td>wilderness_mountains</td>
<td>wilderness_scope</td>
<td>wilderness_steppe</td>
</tr>
</tbody>
</table>
</div>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>当选择好背景后，对应的环境也会被自动选择，但如果有必要可以自行指定覆盖。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Environment</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>environment_body</td>
<td>environment_council</td>
<td>environment_cw_east_main</td>
</tr>
<tr>
<td>environment_cw_east_spouse</td>
<td>environment_cw_east_throneroom_main</td>
<td>environment_cw_east_throneroom_spouse</td>
</tr>
<tr>
<td>environment_cw_india_main</td>
<td>environment_cw_india_spouse</td>
<td>environment_cw_india_throneroom_main</td>
</tr>
<tr>
<td>environment_cw_india_throneroom_spouse</td>
<td>environment_cw_mediterranean_main</td>
<td>environment_cw_mediterranean_spouse</td>
</tr>
<tr>
<td>environment_cw_mediterranean_throneroom_main</td>
<td>environment_cw_mediterranean_throneroom_spouse</td>
<td>environment_cw_tavern</td>
</tr>
<tr>
<td>environment_cw_tavern_spouse</td>
<td>environment_cw_tribal_main</td>
<td>environment_cw_tribal_spouse</td>
</tr>
<tr>
<td>environment_cw_west</td>
<td>environment_cw_west_spouse</td>
<td>environment_event_alley</td>
</tr>
<tr>
<td>environment_event_alley_day</td>
<td>environment_event_armory</td>
<td>environment_event_battlefield</td>
</tr>
<tr>
<td>environment_event_bedchamber</td>
<td>environment_event_church</td>
<td>environment_event_corridor_day</td>
</tr>
<tr>
<td>environment_event_courtyard</td>
<td>environment_event_desert</td>
<td>environment_event_docks</td>
</tr>
<tr>
<td>environment_event_dungeon</td>
<td>environment_event_farms</td>
<td>environment_event_feast</td>
</tr>
<tr>
<td>environment_event_forest</td>
<td>environment_event_forest_pine</td>
<td>environment_event_gallows</td>
</tr>
<tr>
<td>environment_event_garden</td>
<td>environment_event_genericcamp</td>
<td>environment_event_market_east</td>
</tr>
<tr>
<td>environment_event_market_tribal</td>
<td>environment_event_market_west</td>
<td>environment_event_mosque</td>
</tr>
<tr>
<td>environment_event_mountains</td>
<td>environment_event_sittingroom</td>
<td>environment_event_standard</td>
</tr>
<tr>
<td>environment_event_steppe</td>
<td>environment_event_study</td>
<td>environment_event_study_physician</td>
</tr>
<tr>
<td>environment_event_tavern</td>
<td>environment_event_temple</td>
<td>environment_event_throne_room_west</td>
</tr>
<tr>
<td>environment_frontend_east_heir</td>
<td>environment_frontend_east_main</td>
<td>environment_frontend_east_secondary</td>
</tr>
<tr>
<td>environment_frontend_india_heir</td>
<td>environment_frontend_india_main</td>
<td>environment_frontend_india_secondary</td>
</tr>
<tr>
<td>environment_frontend_mediterranean_heir</td>
<td>environment_frontend_mediterranean_main</td>
<td>environment_frontend_mediterranean_secondary</td>
</tr>
<tr>
<td>environment_frontend_tribal_heir</td>
<td>environment_frontend_tribal_main</td>
<td>environment_frontend_tribal_secondary</td>
</tr>
<tr>
<td>environment_frontend_west_heir</td>
<td>environment_frontend_west_main</td>
<td>environment_frontend_west_secondary</td>
</tr>
<tr>
<td>environment_head</td>
<td>environment_hud</td>
<td>environment_portrait_editor</td>
</tr>
<tr>
<td>environment_shoulders</td>
<td>environment_standard</td>
<td>environment_torso</td>
</tr>
<tr>
<td>environment_war_overview</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>是使事件工作的附加内容。</p>
<h3 id="on-trigger-fail"><a href="#on-trigger-fail" class="headerlink" title="on_trigger_fail"></a>on_trigger_fail</h3><p>当触发器失败时运行该项。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>解释一个描述如何由多个字符串组成，例如<code>first_valid</code>和所有其他选项。</p>
<h3 id="即时模块"><a href="#即时模块" class="headerlink" title="即时模块"></a>即时模块</h3><p>该代码块中的内容会在事件触发时立即执行，甚至早于标题、描述和画像的渲染等等。一般用于设置变量和保存范围，或想要实现无玩家控制的功能影响。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>事件中的选项可以由用户选择。每个事件可以有任意数量的选项，包括无选项（一个典型的例子就是隐藏事件）。每个选项在主事件中如下定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">example.1 &#x3D; &#123;</span><br><span class="line">	[...]</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		# option info</span><br><span class="line">	&#125;</span><br><span class="line">	[...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下列表格介绍了<code>option</code>块中的可选关键字：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Key</th>
<th>Required</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>Yes</td>
<td>Points to a localization key for the event option button text.</td>
<td>name=example.1.a</td>
</tr>
<tr>
<td>(effects)</td>
<td>No</td>
<td>Any <a href="https://ck3.paradoxwikis.com/Effect" target="_blank" rel="noopener">effects</a> that the option may have can be written directly in the <code>option</code> block.</td>
<td>play_music_cue = mx_cue_banquet</td>
</tr>
<tr>
<td>trigger</td>
<td>No</td>
<td>Defines a <a href="https://ck3.paradoxwikis.com/Trigger" target="_blank" rel="noopener">trigger</a> that has to be fulfilled for the option to be valid and thus available to the user. Not to be confused with the <a href="https://ck3.paradoxwikis.com/Event_modding#Trigger" target="_blank" rel="noopener">main event trigger</a>.</td>
<td><code>trigger = { has_trait = shy }</code></td>
</tr>
<tr>
<td>show_as_unavailable</td>
<td>No</td>
<td>If the option is invalid, but this trigger is, the option will be  shown, but disabled. This behavior is also influenced by the  EVENT_OPTIONS_SHOWN_HIDE_UNAVAILABLE define.</td>
<td><code>show_as_unavailable = { short_term_gold &lt; medium_gold_value }</code></td>
</tr>
<tr>
<td>highlight_portrait</td>
<td>No</td>
<td>Highlights the event portrait of this character while this option is hovered. This is in addition to the automatic highlighting when  hovering an event option that has an effect that affects portrait  characters.</td>
<td>highlight_portrait = scope:custom</td>
</tr>
</tbody>
</table>
</div>
<h3 id="结束后"><a href="#结束后" class="headerlink" title="结束后"></a>结束后</h3><p>该代码块描述了事件发生后运行的内容。</p>
<h3 id="部件"><a href="#部件" class="headerlink" title="部件"></a>部件</h3><p>有什么类型的小部件。</p>
<h2 id="On-actions"><a href="#On-actions" class="headerlink" title="On_actions"></a>On_actions</h2><p>这部分wiki上是不完整的，先不详细写了。</p>
<p>该部分分为两类：On_actions from Code和On_actions Not from Code（即from script）</p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>这部分wiki也不完整，以后有了在写。</p>
<p>分为两部分：触发事件 和 技术与设计模式。</p>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>Echarts的配置</title>
    <url>/2020/10/31/Echarts%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>今天发现了一个可以用在markdown的前端画图js，<a href="https://echarts.apache.org/zh/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts" target="_blank" rel="noopener">ECharts</a>。在hexo的next主题中使用它需要进行一些配置。</p>
<a id="more"></a>
<p>首先需要说明的是，hexo的网页渲染方式有ejs和swig两种。</p>
<p>对于ejs方式的主题，直接在主题目录下的<code>layout\_partial\head.ejs</code>中加入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://echarts.baidu.com/dist/echarts.common.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>在博客站点文件的命令行中执行<code>npm install hexo-tag-echarts --save</code>即可。</p>
<p>而对于swig方式的主题要复杂一些。</p>
<ol>
<li><p>下载ECharts的js文件：<a href="https://echarts.apache.org/zh/download.html" target="_blank" rel="noopener">下载链接</a></p>
</li>
<li><p>然后在<code>next\layout\</code>文件夹下，找到<code>_layout.swig</code>文件，并用文本查看器打开，在下面代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;main id=<span class="string">"main"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main-inner"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content-wrap"</span>&gt;</span><br><span class="line">      &lt;div id=<span class="string">"content"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">        &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;% include '_third-party/</span>duoshuo-hot-articles.swig<span class="string">' %&#125;</span></span><br><span class="line"><span class="string">      &#123;% include '</span>_partials/comments.swig<span class="string">' %&#125;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &#123;% if theme.sidebar.display !== '</span>remove<span class="string">' %&#125;</span></span><br><span class="line"><span class="string">      &#123;% block sidebar %&#125;&#123;% endblock %&#125;</span></span><br><span class="line"><span class="string">    &#123;% endif %&#125;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/main&gt;</span></span><br></pre></td></tr></table></figure>
<p>的<strong>前面</strong>添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- echarts --&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/echarts.common.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>保存退出。</p>
</li>
<li><p>在博客站点文件的命令行中执行<code>npm install hexo-tag-echarts --save</code>。</p>
</li>
</ol>
<p>到此为止就可以了，新建一个markdown文件，把下列代码放进去就可以看到本页最下面的echarts示例了。（直接复制粘贴，<strong>不要</strong>放代码块里）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% echarts 400 &#39;85%&#39; %&#125;</span><br><span class="line">&#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">        text: &quot;某站点用户访问来源&quot;,</span><br><span class="line">        subtext: &quot;ECharts示例&quot;,</span><br><span class="line">        x: &quot;center&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">        trigger: &quot;item&quot;,</span><br><span class="line">        formatter: &quot;&#123;a&#125; &lt;br&#x2F;&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    legend: &#123;</span><br><span class="line">        orient: &quot;vertical&quot;,</span><br><span class="line">        x: &quot;left&quot;,</span><br><span class="line">        data: [&quot;直接访问&quot;, &quot;邮件营销&quot;, &quot;联盟广告&quot;, &quot;视频广告&quot;, &quot;搜索引擎&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    toolbox: &#123;</span><br><span class="line">        show: true,</span><br><span class="line">        feature: &#123;</span><br><span class="line">            mark: &#123;</span><br><span class="line">                show: true</span><br><span class="line">            &#125;,</span><br><span class="line">            dataView: &#123;</span><br><span class="line">                show: true,</span><br><span class="line">                readOnly: true</span><br><span class="line">            &#125;,</span><br><span class="line">            restore: &#123;</span><br><span class="line">                show: true</span><br><span class="line">            &#125;,</span><br><span class="line">            saveAsImage: &#123;</span><br><span class="line">                show: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    calculable: true,</span><br><span class="line">    series: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: &quot;访问来源&quot;,</span><br><span class="line">            type: &quot;pie&quot;,</span><br><span class="line">            radius: &quot;55%&quot;,</span><br><span class="line">            center: [&quot;50%&quot;, &quot;60%&quot;],</span><br><span class="line">            data: [</span><br><span class="line">                &#123;</span><br><span class="line">                    value: 335,</span><br><span class="line">                    name: &quot;直接访问&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    value: 310,</span><br><span class="line">                    name: &quot;邮件营销&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    value: 234,</span><br><span class="line">                    name: &quot;联盟广告&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    value: 135,</span><br><span class="line">                    name: &quot;视频广告&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    value: 1548,</span><br><span class="line">                    name: &quot;搜索引擎&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endecharts %&#125;</span><br></pre></td></tr></table></figure>
<div id="echarts7074" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts7074'));
        // 指定图表的配置项和数据
        var option = {
    title: {
        text: "某站点用户访问来源",
        subtext: "ECharts示例",
        x: "center"
    },
    tooltip: {
        trigger: "item",
        formatter: "{a} <br/>{b} : {c} ({d}%)"
    },
    legend: {
        orient: "vertical",
        x: "left",
        data: ["直接访问", "邮件营销", "联盟广告", "视频广告", "搜索引擎"]
    },
    toolbox: {
        show: true,
        feature: {
            mark: {
                show: true
            },
            dataView: {
                show: true,
                readOnly: true
            },
            restore: {
                show: true
            },
            saveAsImage: {
                show: true
            }
        }
    },
    calculable: true,
    series: [
        {
            name: "访问来源",
            type: "pie",
            radius: "55%",
            center: ["50%", "60%"],
            data: [
                {
                    value: 335,
                    name: "直接访问"
                },
                {
                    value: 310,
                    name: "邮件营销"
                },
                {
                    value: 234,
                    name: "联盟广告"
                },
                {
                    value: 135,
                    name: "视频广告"
                },
                {
                    value: 1548,
                    name: "搜索引擎"
                }
            ]
        }
    ]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-3</title>
    <url>/2020/10/05/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-3/</url>
    <content><![CDATA[<p>接下来是事件和决议的简单写法。</p>
<a id="more"></a>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="一些文件说明"><a href="#一些文件说明" class="headerlink" title="一些文件说明"></a>一些文件说明</h2><ol>
<li><p>首先在<code>...\Crusader Kings III\game\common\event_themes</code>文件夹中，可以看到<code>00_event_themes.txt</code>文件，里面记录了游戏中的事件主题，不同的主题会有不同的图标、音乐和背景。</p>
</li>
<li><p>其次在<code>...\Crusader Kings III\game\common\event_backgrounds</code>文件夹中，可以看到<code>01_event_backgrounds.txt</code>文件，里面记录了上一条提到的背景对应的信息，包括图片、环境和氛围，例如对于<code>event_background = study</code>的事件主题而言，它的背景信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">study &#x3D; &#123;</span><br><span class="line">	background &#x3D; &#123;</span><br><span class="line">		reference &#x3D; &quot;gfx&#x2F;interface&#x2F;illustrations&#x2F;event_scenes&#x2F;study.dds&quot;</span><br><span class="line">		environment &#x3D; &quot;environment_event_study&quot;</span><br><span class="line">		ambience &#x3D; &quot;event:&#x2F;SFX&#x2F;Events&#x2F;Backgrounds&#x2F;office_workplace&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来在<code>...\Crusader Kings III\game\events</code>文件夹中，可以看到大量事件的具体说明，其中的<code>_events.info</code>文件介绍了事件格式。</p>
</li>
</ol>
<h2 id="事件格式"><a href="#事件格式" class="headerlink" title="事件格式"></a>事件格式</h2><ol>
<li><p>以勒索事件为例来分析事件格式，勒索事件一共有3种：勒索被拒绝、勒索某人造成恐惧、被勒索带来压力。</p>
<p>这里分析第一种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blackmail.0001 &#x3D; &#123;</span><br><span class="line">	title &#x3D; blackmail.0001.t</span><br><span class="line">	desc &#x3D; blackmail.0001.desc</span><br><span class="line">	theme &#x3D; intrigue</span><br><span class="line">	left_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; scope:recipient</span><br><span class="line">		animation &#x3D; dismissal</span><br><span class="line">	&#125;</span><br><span class="line">	# TODO_CD: Add a check that the secret has not yet been exposed</span><br><span class="line">	immediate &#x3D; &#123;</span><br><span class="line">		play_music_cue &#x3D; mx_cue_murder</span><br><span class="line">	&#125;</span><br><span class="line">	after &#x3D; &#123; remove_variable &#x3D; currently_blackmailing &#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; blackmail.0001.a</span><br><span class="line">		scope:target &#x3D; &#123;</span><br><span class="line">			expose_secret &#x3D; root</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; blackmail.0001.b</span><br><span class="line">		scope:target &#x3D; &#123;</span><br><span class="line">			disable_exposure_by &#x3D; root</span><br><span class="line">		&#125;</span><br><span class="line">		ai_chance &#x3D; &#123;</span><br><span class="line">			factor &#x3D; 0</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>title</code>和<code>desc</code>两个字段对应的内容可以在文本文件（<code>...\Crusader Kings III\game\localization\simp_chinese\event_localization\blackmail_events_l_simp_chinese.yml</code>）中看到；</p>
<p><code>theme</code>是<code>intrigue</code>，在之前的事件主题中可以找到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">intrigue &#x3D; &#123;</span><br><span class="line">	icon &#x3D; &#123;</span><br><span class="line">		reference &#x3D; &quot;gfx&#x2F;interface&#x2F;icons&#x2F;event_types&#x2F;type_intrigue.dds&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	sound &#x3D; &#123;</span><br><span class="line">		reference &#x3D; &quot;event:&#x2F;SFX&#x2F;Events&#x2F;Themes&#x2F;sfx_event_theme_type_intrigue&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	background &#x3D; &#123;</span><br><span class="line">		event_background &#x3D; corridor_night</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说该事件出现时会有如上图标音乐和背景。</p>
<p>接下来<code>left_portrait</code>是说事件发生时左边的人物形象，这里还可以根据需要设置<code>right_portrait, lower_left_portrait, lower_center_portrait, lower_right_portrait</code>。</p>
<p><code>immediate</code>和<code>after</code>根据字面意思来理解应该是指事件发生时和发生后所触发的效果。</p>
<p>接下来两个<code>option</code>表示这个事件有两个选项，分别对应的文字是<code>blackmail.0001.a</code>和<code>blackmail.0001.b</code>，对应的结果是暴露用来勒索的秘密和放弃勒索。</p>
</li>
<li><p>事件的写法还涉及很多东西，之后再继续看，然后先看看决议。</p>
</li>
</ol>
<h1 id="决议"><a href="#决议" class="headerlink" title="决议"></a>决议</h1><ol>
<li>决议文件存放在<code>...\Crusader Kings III\game\common\decisions</code>中，同样有一个<code>_decisions.info</code>来说明决议的大致格式。</li>
<li>决议的格式和事件其实大同小异，就不记录了。</li>
</ol>
<h1 id="一个基础尝试"><a href="#一个基础尝试" class="headerlink" title="一个基础尝试"></a>一个基础尝试</h1><p>我希望做一个决议，通过决议触发一个事件，而该事件有3个选项，分别是</p>
<ol>
<li>消耗500威望给我1000金钱；</li>
<li>无事发生；</li>
<li>消耗1000金钱给我500威望。</li>
</ol>
<p>那么首先新建一个mod文件夹，它的路径是<code>C:\Users\LiKun\Documents\Paradox Interactive\Crusader Kings III\mod\test</code>，需要注意的是，在<code>C:\Users\LiKun\Documents\Paradox Interactive\Crusader Kings III\mod</code>文件夹里同时会出现一个<code>test.mod</code>，它指向我们mod的路径，内容是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version&#x3D;&quot;0.0&quot;</span><br><span class="line">tags&#x3D;&#123;</span><br><span class="line">	&quot;Historical&quot;</span><br><span class="line">&#125;</span><br><span class="line">name&#x3D;&quot;test&quot;</span><br><span class="line">supported_version&#x3D;&quot;1.1.*&quot;</span><br><span class="line">path&#x3D;&quot;C:&#x2F;Users&#x2F;LiKun&#x2F;Documents&#x2F;Paradox Interactive&#x2F;Crusader Kings III&#x2F;mod&#x2F;test&quot;</span><br></pre></td></tr></table></figure>
<p>接下来，我们在mod文件夹中按照游戏本体那样逐层建立所需要的文件夹，这里一定要严格弄清楚所有路径。建立好的文件夹和文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- test</span><br><span class="line">	- common</span><br><span class="line">		- decisions</span><br><span class="line">			give_money_decision.txt</span><br><span class="line">	- events</span><br><span class="line">		- give_money_events</span><br><span class="line">			give_money_events.txt</span><br><span class="line">	- localization</span><br><span class="line">		- simp_chinese</span><br><span class="line">			- event_localization</span><br><span class="line">				give_money_l_simp_chinese.yml</span><br><span class="line">			decisions_test_l_simp_chinese.yml</span><br><span class="line">	descriptor.mod</span><br></pre></td></tr></table></figure>
<p>我首先写的是事件，也就是<code>give_money_events.txt</code>，该文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace &#x3D; give_money</span><br><span class="line"></span><br><span class="line">give_money.1 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; give_money.1.t</span><br><span class="line">	desc &#x3D; give_money.1.desc</span><br><span class="line">	theme &#x3D; stewardship</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.a</span><br><span class="line">		add_gold &#x3D; 1000</span><br><span class="line">		add_prestige &#x3D; -500</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.b</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.c</span><br><span class="line">		remove_short_term_gold &#x3D; 1000</span><br><span class="line">		add_prestige &#x3D; 500</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是非常简单的格式，一共3个选项，没有任何触发限制。其中<code>title, desc, name</code>等需要替换成文字的地方，之后在文本文件会增加内容。</p>
<p>需要注意的是，这里用<code>add_gold</code>增加金钱，用<code>remove_short_term_gold</code>减少金钱，是因为我发现<code>add_gold = -1000</code>根本不会生效，查了一下现成的和金钱有关的事件文档，发现用的是<code>remove_short_term_gold</code>，但这个句式到底是什么意思目前也不是很确定。</p>
<p>接下来写决议文件<code>give_money_decision.txt</code>，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">give_money_decision &#x3D; &#123;</span><br><span class="line">	picture &#x3D; &quot;gfx&#x2F;interface&#x2F;illustrations&#x2F;decisions&#x2F;decision_personal_religious.dds&quot;</span><br><span class="line">	desc &#x3D; give_money_decision_desc</span><br><span class="line">	is_valid_showing_failures_only &#x3D; &#123;</span><br><span class="line">		is_available_adult &#x3D; yes</span><br><span class="line">	&#125;</span><br><span class="line">	effect &#x3D; &#123;</span><br><span class="line">		custom_tooltip &#x3D; give_money_decision_effect_tooltip</span><br><span class="line">		trigger_event &#x3D; give_money.1</span><br><span class="line">	&#125;</span><br><span class="line">	ai_check_interval &#x3D; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里增加了需要成年人的限制，<code>custom_tooltip = give_money_decision_effect_tooltip</code>是指效果区域会显示<code>give_money_decision_effect_tooltip</code>所对应的文字，而<code>trigger_event = give_money.1</code>表示确认该决议后，会触发事件<code>give_money.1</code>。</p>
<p>事件和决议都写好以后，就开始完成文本内容，首先是决议文本<code>decisions_test_l_simp_chinese.yml</code>，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> give_money_decision:0 &quot;我好穷啊&quot;</span><br><span class="line"> give_money_decision_tooltip:0 &quot;收点钱。&quot;</span><br><span class="line"> give_money_decision_desc:0 &quot;想要钱吗？&quot;</span><br><span class="line"> give_money_decision_effect_tooltip:0 &quot;点击按钮一键收钱。&quot;</span><br><span class="line"> give_money_decision_confirm:0 &quot;当然&quot;</span><br></pre></td></tr></table></figure>
<p>完成这部分内容后，该决议在游戏中的效果就是</p>
<p><img src="https://i.loli.net/2020/10/06/HQoYAK7JVivqI62.png" alt="image-20201006221530141"></p>
<p>相应的，事件文本也是一样的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> give_money.1.t:0 &quot;给我打钱！&quot;</span><br><span class="line"> give_money.1.desc:0 &quot;神说要有钱。&quot;</span><br><span class="line"> give_money.1.option.a:0 &quot;好，我喜欢！&quot;</span><br><span class="line"> give_money.1.option.b:0 &quot;不了不了。&quot;</span><br><span class="line"> give_money.1.option.c:0 &quot;你这是看不起我！&quot;</span><br></pre></td></tr></table></figure>
<p>游戏中的效果是</p>
<p><img src="https://i.loli.net/2020/10/06/MWy7KlRpa1wA4kN.png" alt="image-20201006221637015"></p>
<p>把文件们都保存好，就完成了第一个基础mod了。</p>
<p>补充一个重要说明，文件的编码格式非常重要，统一采用UTF-8-BOM编码，不然会出问题。</p>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-2</title>
    <url>/2020/10/04/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<p>这次了解一下决议和事件的图标相关的事情。</p>
<a id="more"></a>
<h1 id="关于图片"><a href="#关于图片" class="headerlink" title="关于图片"></a>关于图片</h1><ol>
<li>游戏中出现的过场图、背景图、事件图标等等基本存放在<code>...\Crusader Kings III\game\gfx\interface</code>文件夹中，比如<code>...\interface\bookmarks</code>里存着开场选人物时的界面贴图，而<code>...\interface\illustrations</code>文件夹里则存着很多尺寸大一些的图（例如过场图、决议说明界面的图等等）；</li>
<li>这些贴图都是dds格式，不同使用场景的贴图有不同尺寸，可以给PS装dds插件然后打开查看；</li>
<li>以决议为例，代码段落中会有<code>picture</code>这个选项，例如<code>create_cadet_branch_decision</code>中的是<code>picture = &quot;gfx/interface/illustrations/decisions/decision_dynasty_house.dds&quot;</code>，如果要自己写决议，或者想把某个决议的图像修改成其他样式，就在这里进行替换，注意dds文件的尺寸等；</li>
<li>开场<code>bookmarks</code>的贴图和上面的不太一样，经过反复分析我发现，在bookmarks文件（<code>...\Crusader Kings III\game\common\bookmarks\00_bookmarks.txt</code>）中，预设的六个是<code>bm_867_northmen</code>、<code>bm_867_adventurers</code>等等，而在<code>...\Crusader Kings III\game\gfx\interface\bookmarks</code>中存在和这些名字相同的六个dds文件，每个可选的人物也类似，总之是dds文件的名字要和bookmarks文件里设定的选项保持一致，这样游戏里会自动对应起来。</li>
<li>图片暂时就先看到这里。</li>
</ol>
<h1 id="关于文本"><a href="#关于文本" class="headerlink" title="关于文本"></a>关于文本</h1><ol>
<li><p>游戏中出现的文本存放在<code>...\Crusader Kings III\game\localization</code>文件夹中，每个语言有一个文件夹；</p>
</li>
<li><p>每个文本文件是<code>.yml</code>格式的，可以用记事本的编辑器打开修改；</p>
</li>
<li><p>文本内容格式是：<code>文本名称:0 &quot;text&quot;</code>，这其中的0也见过写成1的，目前不知道是什么区别，也许和路径有关吧。文本名称的命名有固定格式，比如bookms的命名方式是<code>bm_year_bookmarkname</code>，而对应的描述则是<code>bm_year_bookmarkname_desc</code>，如下是一个例子；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bm_1066_conqueror:0 &quot;Norman England&quot;</span><br><span class="line">bm_1066_conqueror_desc:0 &quot;William has defeated the Anglo-Saxon king Harold at the Battle of Hastings and is crowned king of England, starting an age of Norman rule over the kingdom.&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用的时候，注意名称的统一即可，例如：</p>
<p>在common文件夹的决议文件中，成立葡萄牙的决议如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">form_portugal_decision &#x3D; &#123;</span><br><span class="line">	picture &#x3D; &quot;gfx&#x2F;interface&#x2F;illustrations&#x2F;decisions&#x2F;decision_dynasty_house.dds&quot;</span><br><span class="line">	major &#x3D; yes</span><br><span class="line">	ai_check_interval &#x3D; 60</span><br><span class="line">	desc &#x3D; form_portugal_decision_desc</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>那么对应的文本内容则是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">form_portugal_decision:0 &quot;成立葡萄牙&quot;</span><br><span class="line">form_portugal_decision_desc:0 &quot;一旦我控制了伊比利亚半岛的西海岸，我就能成立葡萄牙王国，并且建立自己独特的文化。&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>目前先看到这里，还有很多问题之后再说。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-1</title>
    <url>/2020/10/03/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<p>首先新建一个mod文件。</p>
<a id="more"></a>
<h1 id="新建Mod"><a href="#新建Mod" class="headerlink" title="新建Mod"></a>新建Mod</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li>启动器里找到mod新建会自动生成相关文件；</li>
<li>也可以文档里找到<code>...\Paradox Interactive\Crusader Kings III\mod</code>文件夹（如果没有就新建），新建<code>test.mod</code>文件，用随便什么编辑器打开，输入一系列内容并保存。</li>
</ol>
<h2 id="test-mod文件"><a href="#test-mod文件" class="headerlink" title="test.mod文件"></a><code>test.mod</code>文件</h2><ol>
<li><p>启动器生成的该文件基础内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version&#x3D;&quot;0.0&quot;</span><br><span class="line">tags&#x3D;&#123;</span><br><span class="line">	&quot;Historical&quot;</span><br><span class="line">&#125;</span><br><span class="line">name&#x3D;&quot;test&quot;</span><br><span class="line">supported_version&#x3D;&quot;1.0.3&quot;</span><br><span class="line">path&#x3D;&quot;C:&#x2F;Users&#x2F;LiKun&#x2F;Documents&#x2F;Paradox Interactive&#x2F;Crusader Kings III&#x2F;mod&#x2F;test&quot;</span><br></pre></td></tr></table></figure>
<p><code>version</code>和<code>supported_version</code>自己可以看着改。</p>
</li>
<li><p>可以附加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">picture &#x3D; 图像文件名</span><br></pre></td></tr></table></figure>
<p>指定mod开场图片。</p>
</li>
<li><p>ck2可以设定<code>replace_path</code>，覆盖文件夹中的所有内容，ck3是否可以还没试过，之后看看。</p>
</li>
</ol>
<h2 id="common文件夹"><a href="#common文件夹" class="headerlink" title="common文件夹"></a><code>common</code>文件夹</h2><ol>
<li><p>正常来说ck3游戏本体内容不在上面那个文档里，而在其他安装路径，比如<code>C:\Program 1\Steam\steamapps\common\Crusader Kings III</code>，在这个文件夹中的<code>...\game\common</code>文件夹中存放着很多游戏相关文件，接下来试图逐一分析。</p>
</li>
<li><p>文件夹里有很多文件夹和一个<code>achievement_groups.txt</code>，这个txt文件内容看上去是对成就进行分组，分为<code>very_easy_achievements</code>, <code>easy_achievements</code>, <code>medium_achievements</code>, <code>hard_achievements</code>, <code>very_hard_achievements</code>，文件夹中的第一个是<code>achievements</code>，包括<code>standard_achievements.txt</code>和<code>msgrdk_achievements.json</code>。</p>
<ol>
<li><p><code>standard_achievements.txt</code>中的内容格式是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">成就名 &#x3D; &#123;</span><br><span class="line">	possible &#x3D; &#123;</span><br><span class="line">		# 成就起始条件</span><br><span class="line">	&#125;</span><br><span class="line">	happened &#x3D; &#123;</span><br><span class="line">		custom_description &#x3D; &#123;</span><br><span class="line">			# 成就达成要求</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<ol>
<li><p><code>msgrdk_achievements.json</code>看起来是给每个成就映射了一个数字编号，总共55个。</p>
</li>
<li><p>目前对成就这部分很不熟悉，可能有理解错的内容。</p>
</li>
</ol>
<ol>
<li><p><code>activities</code>文件夹，这里看上去是五个主要活动的说明，这五个都是决议里的，但应该不是决议。</p>
<ol>
<li><p><code>_activities.info</code> 说明了具体格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name_of_activity &#x3D; &#123;</span><br><span class="line">	expiration_days &#x3D; X 			# default number of days after an activity is started to it&#39;s expiration</span><br><span class="line">	days_until_auto_start &#x3D; X 		# number of days from an activity is spawned until it&#39;s started (regardless of if participants have arrived or not)</span><br><span class="line">	valid &#x3D; trigger					# checked daily on the activity scope</span><br><span class="line">	on_spawn &#x3D; effect 				# executed on the activity when spawned</span><br><span class="line">	on_activate &#x3D; effect			# executed on the activity when started (all invitations replied to or auto started)</span><br><span class="line">	on_complete &#x3D; effect			# executed on the activity when completed through complete_activity &#x3D; yes (ignored if complete_activity &#x3D; no)</span><br><span class="line">	on_expire &#x3D; effect				# executed on the activity when expiring from timeout</span><br><span class="line">	on_participant_death			# executed on the dying character during death, activity set as scope:activity</span><br><span class="line">	on_invalidated &#x3D; effect			# executed on the activity when failing the valid trigger	</span><br><span class="line">	solo &#x3D; yes						# marks the activity as a solo activity (no guests)</span><br><span class="line">	has_activity_window &#x3D; yes		# determines if a certain activity should show a window or not</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来结合其他几个具体文件来理解。</p>
</li>
<li><p><code>00_activity_feast.txt</code> 宴会：</p>
<ol>
<li><p><code>expiration_days = 300</code> 持续300天</p>
</li>
<li><p><code>has_activity_window = yes</code> 有事件窗口</p>
</li>
<li><p><code>days_until_auto_start = 20</code> 默认20天后开始</p>
</li>
<li><p><code>frame = 2</code></p>
</li>
<li><p><code>color = { 0.853906 0.867188 0.105469 1 }</code></p>
</li>
<li><pre><code>valid = {
        activity_owner = {
            is_alive = yes
            is_imprisoned = no
        }
    }
</code></pre><p>宴会期间每天检查召开宴会的人活着且没被关起来。</p>
</li>
<li><p><code>on_spawn</code>这段很长，大致是宴会事件生成时同时执行的内容，主要是设置潜在宾客列表<code>potential_guests</code>。这段有个<code>if</code>语句，提到条件和配偶有关，没配偶似乎是会随机初始化一个配偶，没太看懂这个设计。</p>
</li>
<li><p><code>on_activate</code> 也很长，大致是宴会事件开始时触发的，如果没人来，就结束这个事件，<code>feast.2003</code>可能就是结束宴会的意思；如果有人来，给召开宴会的人选关键事件，再从宾客里选人参与到这个事件中，这里提到<code>reveler（狂欢者？）</code>会得到两点不知道是生活方式还是生活经验的奖励。而作为客人，<code>reveler（狂欢者？）</code>会得到一点，此外针对所有客人，会移除宴会邀请的拦截器（？这里还得之后再看）。</p>
</li>
<li><p><code>on_complete</code> 宴会结束时，主人和封臣似乎会有什么互动，每个参与者的目标体重（？）会改变。</p>
</li>
<li><p><code>on_expire</code> 宴会到期以后会触发<code>feast.2002</code>。注释说这个不应出现，只是作为异常记录。</p>
</li>
<li><p><code>on_participant_death</code>是空的。</p>
</li>
<li><p><code>on_invalidated</code> 失效的情况？</p>
</li>
</ol>
</li>
<li><p><code>00_activity_hunt.txt</code> 打猎：</p>
<ol>
<li>和刚才的宴会不同，这里有<code>solo = yes</code>，说明可以一个人打猎。</li>
<li><code>frame</code>和<code>color</code>暂时还是不太理解。</li>
<li>这里的很多限制都要求是健康成年人。</li>
</ol>
</li>
<li><p><code>00_activity_meditation.txt</code> 冥想：</p>
<ol>
<li>同样可以一个人进行。</li>
</ol>
</li>
<li><p>看上去冥想是宗教决议中的一个：<code>religious_decision.0211</code></p>
</li>
<li><p><code>00_activity_pilgrimage.txt</code> 朝圣：因为没看懂就没什么能说的。</p>
</li>
<li><p><code>00_activity_witch_ritual.txt</code> 巫术仪式：</p>
<ol>
<li>其实也没看懂，看起来是可以搞巫术仪式的，但是限制有点多。</li>
<li>似乎是有个宴会，参加宴会的可以为所欲为，还会有不一样的音乐（？<code>play_music_cue = &quot;mx_cue_sacredrite&quot;</code>）。</li>
<li>这里提到的事件有<code>witch.3003</code> <code>witch.3010</code> <code>witch.3098</code>。</li>
</ol>
</li>
<li><p>补充一下：从<code>event</code>文件夹的内容来看，官方没搞冥想和巫术仪式，以后可能会有吧。</p>
</li>
</ol>
</li>
<li><p><code>ai_goaltypes</code>文件夹和<code>ai_war_stances</code>，这俩看名字是和AI设定有关的。</p>
<ol>
<li><code>ai_goaltypes</code>文件夹里只有<code>00_testgoals.txt</code>，内容相当于是空的，可能是留着做mod用。</li>
<li><code>ai_war_stances</code>文件夹里有<code>_ai_war_stances.info</code>和<code>00_ai_war_stances.txt</code>：<ol>
<li><code>_ai_war_stances.info</code>说明了战争立场格式，注释说无法添加新的或者删除现有的，但是都能改。</li>
<li>这里设定的是AI战争时的目标优先级，优先级范围是1-1000，有一个战争目标列表。</li>
<li>有一个变量<code>enemy_unit_priority</code>，这个值目前设置为100，是指对于战力不到该AI一半的敌军单位，战争优先级数字会增加100，该值的影响似乎会随着敌军单位战力的增长而降低，当敌军战力和该AI战力一样的时候这个值就被看作0。</li>
<li><code>00_ai_war_stances.txt</code>是具体的优先级设定，分为进攻方和防御方：<ol>
<li>作为进攻方的AI，在进攻时作战优先级由高到低：目标省（<code>wargoal_province</code> 500）、敌军所在地（<code>enemy_unit_province</code> 300 这个翻译我猜的，可能不对）、敌军首都（<code>enemy_capital_province</code> 150）、敌军省（<code>enemy_province</code> 100）、敌军盟友省（<code>enemy_ally_province</code> 75）、首都（<code>capital_province</code> 50）、普通省（<code>province</code> 25）、保卫战争目标省（<code>defend_wargoal_province</code> 5）。</li>
<li>作为进攻方的AI，在防御时会优先找敌军所在地（<code>enemy_unit_province</code> 500），其次才是战争目标省（<code>wargoal_province</code> 300），其他和刚才一样。</li>
<li>作为防御方，也有和上面一样的两部分。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><code>bookmark_portraits</code>文件夹看上去是存了游戏命令行里生成的外貌数据。</p>
</li>
<li><p><code>bookmark</code>文件夹中有<code>00_bookmarks.txt</code>，这里存了游戏开局可以选的剧本数据，一共6个时代（3个867和3个1066），设定了起止时间和可选的几个角色以及角色们的相关数据。</p>
</li>
<li><p>后面还有好多好多文件夹，等以后用到了再看吧……</p>
</li>
</ol>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>使用算法和数据结构解决问题-1</title>
    <url>/2020/09/28/%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-1/</url>
    <content><![CDATA[<p>说明：后来发现了已经有不少对这本书的翻译，例如<a href="http://gis4g.pku.edu.cn/course/pythonds/#%E8%AF%BE%E7%A8%8B%E6%95%99%E6%9D%90" target="_blank" rel="noopener">北大课程</a>，因此就不再继续翻译了。</p>
<h1 id="第一章-前言"><a href="#第一章-前言" class="headerlink" title="第一章 前言"></a>第一章 前言</h1><h2 id="1-1-目标"><a href="#1-1-目标" class="headerlink" title="1.1 目标"></a>1.1 目标</h2><ol>
<li><p>回顾计算机科学、编程和解决问题的想法。</p>
</li>
<li><p>理解“抽象”及其在解决问题的过程中发挥的作用。</p>
</li>
<li><p>理解和实现抽象数据类型的概念。</p>
</li>
<li><p>复习 <code>Python</code> 编程语言。</p>
</li>
</ol>
<h2 id="1-2-开始"><a href="#1-2-开始" class="headerlink" title="1.2 开始"></a>1.2 开始</h2><p>自从第一台通过贴片电缆和开关来传达人与机器之间指令的电子计算机问世以来，我们对编程的思考方式已经发生了许多变化。与社会的许多方面一样，计算机技术的变化为计算机科学家提供了越来越多的工具和平台来练习他们的技术，更快的处理器、高速网络和大型内存容量等进步也为计算机科学家带来必须面对的复杂性。在这飞速发展的过程中，仍然有一些基本原则保持不变。计算科学关注于使用计算机来解决问题。</p>
<p>无疑，你花了相当长的时间（真的吗？）学习解决问题的基础知识，并且对读懂问题并开发解决方案充满信心。你还了解到编程通常很难（并不），大规模问题的复杂性和求解方案的复杂性往往会掩盖与求解过程相关的基本思想。</p>
<p>本章强调了其余部分内容的两个重要方面。首先，它回顾了计算机科学以及算法和数据结构研究必须符合的框架，特别是我们需要研究这些主题的原因，以及理解这些主题如何帮助我们更好地解决问题。其次，我们复习一下<code>Python</code>编程语言。虽然我们无法提供详细、详尽的参考，但我们将为将在其余各章中出现的基本构造和想法提供实例和解释。</p>
<h2 id="1-3-什么是计算科学"><a href="#1-3-什么是计算科学" class="headerlink" title="1.3 什么是计算科学"></a>1.3 什么是计算科学</h2><p>可能是由于名称中包含了”计算机“一词，计算科学通常很难定义。如你所知，计算科学并不仅仅是对计算机的研究。尽管计算机作为学科中的工具发挥了重要的支持作用，但它们仅仅是工具。</p>
<p>计算科学是对求解问题过程中的问题、求解过程以及解决方案的研究，针对给定问题，计算科学家的目标是设计算法——这是解决任何可能出现的问题的指令所对应的分布说明列表。算法帮助我们解决问题的有限过程，是解决方案。</p>
<p>我们可以认为计算科学就是研究算法，然而，我们必须注意，一些可能无解的问题也会被包含进来。虽然证明这种说法超出了本文的范围，但一些无解问题对于研究计算科学的人而言很重要。通过包含两种类型的问题，我们可以通过以下方式来定义计算科学：计算科学对问题解决方案的研究，以及对无解问题的研究。</p>
<p>”<strong>可计算</strong>“一词再描述问题和解决方案时也很常见。我们说，如果存在一个算法来解决问题，则该问题是可计算的。计算科学的另一种定义是：对可计算和不可计算的问题的研究、对算法存在性与不存在性的研究。在任何情况下，你都会注意到”计算机“一词没有出现，解决方案与机器是独立的。</p>
<p>因为它涉及到问题求解过程，所以计算科学也是<strong>抽象</strong>的研究。抽象使我们能够以分离逻辑和物理的方式来看代问题和解决方案。我们使用一个常见的例子来熟悉这一基本思想。</p>
<p>想象你今天可能开到学校或公司的汽车（我没车）。作为一个司机、汽车的用户，为了用车实现目的，你与汽车之间发生了一些交互，你进车、插钥匙、启动、换档、刹车、加速和转向以便驾驶。从抽象的角度来看，我们可以说你看到了汽车的逻辑视角。为了将你从一个地方送到另一个地方，你使用了汽车设计者所提供的函数，这些函数有时被称为<strong>接口</strong>。</p>
<p>另一方面，修理汽车的机械师则持有不同的观点。她不仅需要知道如何开车，还需要知道执行所有我们认为理所当然的函数的全部细节。她需要理解发动机的工作原理、变速箱如何换档、如何控制温度等等。这被称为物理视角——”引擎盖下的细节“。</p>
<p>在我们使用计算机时也发生了同样的事情。大多数人在不了解原理的情况下使用计算机来编写文档、发送和接收电子邮件、浏览网页、播放音乐、存储图像和玩游戏，他们从逻辑或者用户的视角来看计算机。而计算科学家、程序员、技术支持人员和系统管理员对计算机的看法则有很大不同，他们必须知道操作系统如何工作、如何配置网络协议以及如何编写控制功能的各种脚本，他们必须能够控制底层细节，而用户则只是简单想象这些。</p>
<p>这两个例子的共同点在于，抽象的用户（有时也被称为客户端）并不需要了解详细信息，而只需要知道接口的工作方式。接口是用户与底层复杂系统的通信方式。我们可以来看另一个抽象的例子：<code>Python</code>中的<code>math</code>模块。当我们导入该模块后，就可以实现如下计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.sqrt(<span class="number">16</span>)</span><br><span class="line"><span class="number">4.0</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这是<strong>过程抽象(procedural abstraction)</strong>的示例。我们不一定知道平方根是如何计算的，但我们知道函数的调用以及如何使用它。如果我们正确执行导入，我们可以假定函数将为我们提供正确的结果。我们知道有人实现了平方根问题的解决方案，但我们并不关心是如何实现的，只需要知道如何使用它。这有时称为进程的”黑盒”视图。我们简单地将接口描述为：函数的名称、需要什么（参数）以及将返回什么，而具体内容则隐藏在接口中，如图1.1。</p>
<center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="https://i.loli.net/2020/11/06/UwFpIlg9mroSa8i.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图1.1 过程抽象</div> </center>

<h3 id="1-3-1-什么是编程"><a href="#1-3-1-什么是编程" class="headerlink" title="1.3.1 什么是编程"></a>1.3.1 什么是编程</h3><p><strong>编程</strong>是将算法编码为符号（编程语言）从而使其可以在计算机上执行的过程。尽管存在许多编程语言和许多不同类型的计算机，但重要的第一步是提出解决方案，没有算法就没有程序。</p>
<p>计算机科学不是编程的研究，然而编程是计算机科学家工作的一个重要部分。编程通常是我们为解决方案创建的表示。因此，这种语言表示和创建过程成为学科的基本部分。</p>
<p>算法根据表示问题实例所需的数据和产生预期结果所需的步骤集来描述问题的解决方案。编程语言必须提供一种符号方式来表示进程和数据。为此，语言提供了控件构造和数据类型。</p>
<p>控件构造允许以方便而明确的方式表示算法步骤。算法至少需要执行顺序处理、决策选择和重复控制迭代的构造（注：简单来说就是顺序、选择、循环）。只要编程语言提供这些基本语句，它就可以用于算法表示。</p>
<p>计算机中的所有数据项都表示为二进制数字字符串。为了给这些字符串赋予意义，我们需要有<strong>数据类型</strong>。数据类型为此二进制数据提供解释，以便我们可以从与所解决的问题有意义的术语中分析数据。这些低级的内置数据类型（有时称为基元数据类型）为算法开发提供了构建基块。</p>
<p>例如，大多数编程语言为整数提供了数据类型，计算机内存中的二进制数字字符串可以解释为整数，并给出我们通常与整数关联的典型含义（例如 23、654 和 -19）。此外，数据类型还提供数据项可以参与的操作的说明，对于整数，加法、减法和乘法等操作是通用的。我们期望该数字类型的数据可以参与这些算术运算。</p>
<p>我们经常遇到的困难是，问题及其解决方法非常复杂。这些简单的语言所提供的构造和数据类型虽然肯定足以表示复杂的解决方案，但往往会使我们再处理问题的过程中处于不利地位。我们需要控制这种复杂性和协助创建解决方案的方法。</p>
<h3 id="1-3-2-为什么要学习数据结构和抽象数据类型"><a href="#1-3-2-为什么要学习数据结构和抽象数据类型" class="headerlink" title="1.3.2 为什么要学习数据结构和抽象数据类型"></a>1.3.2 为什么要学习数据结构和抽象数据类型</h3><p>为了管理问题的复杂性和解决问题的过程，计算机科学家们使用抽象，使他们能够专注于”大局”，而不会迷失在细节中。通过创建问题域的模型，我们能够利用更好、更高效的问题求解过程。这些模型允许我们以与问题本身更加一致的方式来描述我们的算法将处理的数据。</p>
<p>在前文中，我们提到过程抽象是一个隐藏特定函数的详细信息的过程，以允许用户或客户端在非常高的级别上查看它。现在，我们把注意力转向一个类似的想法，即<strong>数据抽象</strong>。<strong>抽象数据类型</strong>（有时称为<strong>ADT</strong>）是对我们如何查看数据及其允许操作的逻辑描述，我们并不关心如何实现该数据类型。这意味着我们只关心数据所代表的是什么，而不关心数据是如何构造的。通过提供这种抽象级别，我们围绕数据创建封装，其理念是，在用户视图中，通过封装将实现过程的详细信息隐藏起来，这被称为信息隐藏。</p>
<p>图 1.2 显示了抽象数据类型及其操作方式的图片。用户使用抽象数据类型指定的操作与接互。抽象数据类型是用户与之交互的 shell。实现过程被隐藏在更深的一层，而用户并不关心实现过程的详细信息。</p>
<center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="https://i.loli.net/2020/11/12/iqCUNtAdfyQEM16.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图1.2 抽象数据类型</div> </center>

<p>抽象数据类型的实现（通常称为数据结构）要求我们使用一些编程构造和基元数据类型的集合提供数据的物理视图。正如我们前面所讨论的，这两个视图的分离将使我们能够在无需说明模型实际构建的细节的情况下，定义我们问题的复杂数据模型，它提供了<strong>实现独立性</strong>的数据视图。由于实现抽象数据类型通常有很多不同的方法，因此这种实现独立性允许程序员切换实现过程的详细信息，而无需更改数据用户与其交互的方式，用户可以继续专注于解决问题的过程。</p>
<h3 id="1-3-3-为什么要学习算法"><a href="#1-3-3-为什么要学习算法" class="headerlink" title="1.3.3 为什么要学习算法"></a>1.3.3 为什么要学习算法</h3><p>计算机科学家通过经验学习，通过看到别人解决问题和自己解决问题来学习。接触不同的问题解决技术，并了解不同的算法是如何设计的，这有助于我们面对下一个具有挑战性的问题。通过思考许多不同的算法，我们可以开始开发模式识别，以便下次出现类似的问题时，可以更好地解决它。</p>
<p>算法通常彼此大不相同，例如前文中的<code>sqrt</code>示例，完全有可能有许多不同的方法来具体实现计算平方根的函数。某种算法使用的资源可能比另一种算法少很多，而某种算法可能需要10倍的时间才能返回结果。我们希望有一些办法来比较这两种解决方案，即使它们都是有效方案，一种也许会比另一种更好。我们可能会认为一种方法更高效，或者运行得更快或使用更少的内存。当我们研究算法时，我们可以学习分析技术，这些分析技术使我们能够仅根据解决方案自身的特点进行比较和对比，而不是基于用于实现它们的程序或计算机的特性。</p>
<p>在最坏的情况下，我们可能有一个难以解决的棘手问题，这意味着没有算法可以在实际的时间内解决问题。能够区分那些有解决办法的问题、没有解决办法的问题和存在解决方案但需要太多时间或其他资源才能合理工作的问题是很重要的。</p>
<p>我们往往需要确定和决定解决方案之间的权衡，作为计算机科学家，除了解决问题的能力外，我们还需要了解和理解解决方案的评估技术。最后，往往有很多方法可以解决问题。找到一个解决方案，然后决定它是否是好的，是我们将不断重复完成的任务。</p>
<h2 id="1-4-基础Python复习"><a href="#1-4-基础Python复习" class="headerlink" title="1.4 基础Python复习"></a>1.4 基础Python复习</h2><p>在本节中，我们将回顾编程语言 Python，并提供上一节中想法的一些更详细的示例。如果你是 Python 的初学者，或者发现需要有关任何内容的更多信息，我们建议你参考诸如<code>Python Language Reference</code>或<code>Python Tutorial</code>这样的资源。在这里我们的目标是重新认识Python语言，并加强一些后几章中的核心概念。</p>
<p>Python 是一种现代、易于学习、面向对象的编程语言。它有一组强大的内置数据类型和易于使用的控件构造。由于 Python 是一种解释性语言，因此只需查看和描述交互式会话，就可以了解它。你应该记得，解释器在提示<code>&gt;&gt;&gt;</code>时显示操作，然后评估您提供的 Python 构造。例如下面这段代码展示了提示、打印功能、结果和下一个提示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"Algorithms and Data Structures"</span>)</span><br><span class="line">Algorithms <span class="keyword">and</span> Data Structures</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-1-从数据开始"><a href="#1-4-1-从数据开始" class="headerlink" title="1.4.1 从数据开始"></a>1.4.1 从数据开始</h3>]]></content>
      <categories>
        <category>Problem Solving with Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>blender学习记录-4</title>
    <url>/2020/08/13/blender%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-4/</url>
    <content><![CDATA[<p>在这里记录一些学到的技巧。</p>
<a id="more"></a>
<ol>
<li>对边缘倒角（ctrl+B）可以让边缘变得平滑</li>
<li>通过细分线段+连接两个点的方式把一些不合适的平面分成两个合适的四边形</li>
<li>要做一个凹下去或者凸起的圆柱形效果时，先挤出（E）一点，再挤出完整长度，最后再继续挤出一点，这样在表面细分以后的效果就还是圆柱</li>
<li>要在一个平面开一个圆洞时，先找好圆心（两条线十字交叉的点），选中这个点然后倒角（ctrl+B），这里要勾选“仅顶点”，或者用ctrl+shift+B这个快捷键倒角，然后选2段，再把轮廓调小（大概0.2左右的样子），让它形状圆一些，最后球形化（alt+shift+S），把系数调最大（1），这样加个细分修改器就是标准圆形了。需要掏洞或者做圆柱的时候可以参考第3条来挤出。</li>
<li>安装md3插件的情况下，物体模式下直接ctrl+3可以方便地细分。</li>
</ol>
]]></content>
      <categories>
        <category>blender</category>
      </categories>
      <tags>
        <tag>随便学学</tag>
      </tags>
  </entry>
  <entry>
    <title>blender学习记录-3</title>
    <url>/2020/08/11/blender%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-3/</url>
    <content><![CDATA[<p>第二课是建模型相关操作</p>
<p>开始学材质，感觉会比之前的内容有意思。</p>
<a id="more"></a>
<ol>
<li>漫射材质：光照会均匀分布在物体表面，适合粗糙的材质，比如毛发、布料等。</li>
<li>反射材质：会反射周围景观，降低粗糙度就会反射得清楚一些，类似镜子。</li>
<li>透射材质：玻璃水晶等，降低粗糙度会更透明，不同物体有不同折射率，可以查表填对应的数值。</li>
<li>发光材质：就是普通的发光</li>
<li>修改alpha模式可以做玻璃罩的效果</li>
</ol>
]]></content>
      <categories>
        <category>blender</category>
      </categories>
      <tags>
        <tag>随便学学</tag>
      </tags>
  </entry>
  <entry>
    <title>python+sklearn+keras+lstm回归预测问题</title>
    <url>/2020/07/24/python-sklearn-keras-lstm%E5%9B%9E%E5%BD%92%E9%A2%84%E6%B5%8B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>因为接到了股票价格预测的任务，所以开始研究怎么写代码。实际上代码是网上现成的，并不需要自己研究算法和网络结构，复制粘贴再重新组合一下就好，所以难度不大。之前做过sklearn的分类问题，现在做回归，思路是差不多的。</p>
<a id="more"></a>
<p>具体场景是：给定某时间段内的股票价格数据，预测接下来的走势；用同样的算法预测其他股票，看准确率是否有变化；老师的想法是对比国内外市场的差异，看是否在机器学习算法中也有体现。</p>
<h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><p>这里先列一下所有导入的包，可能有一些实际没用上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> style</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing, svm</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime <span class="keyword">as</span> date</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> neighbors</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> ensemble</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> ExtraTreeRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">import</span> quandl</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="comment">#from pandas_datareader import data</span></span><br><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line"><span class="comment"># 下面这几个是lstm用的</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Dense, Dropout, LSTM</span><br></pre></td></tr></table></figure>
<h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><ol>
<li><p>使用quandl获取数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> quandl</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">start = date(<span class="number">2000</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">end = date.today()</span><br><span class="line">quandl.ApiConfig.api_key = <span class="string">"gEyzpvmpXReFE8Z8TEps"</span></span><br><span class="line">stock_df = pd.DataFrame(quandl.get(<span class="string">"WIKI/GOOGL"</span>, start_date=start, end_date=end))</span><br></pre></td></tr></table></figure>
<p>第一行导入包；</p>
<p>第二行第三行设置要获取的数据时间范围</p>
<p>第四行设置api_key，这里是需要到quandl官网注册账户，注册好以后会得到这个key，可以用免费数据。注册的时候分为3步，填名字邮箱密码啥的，第三步的时候会需要点一个人机验证的东西才能注册成功，如果没出现人机验证且无法点注册的按钮，说明需要翻墙。</p>
<p>第五行通过<code>quandl.get()</code>函数可以得到所需数据，转成<code>pandas</code>格式方便后续分析。这里的<code>WIKI/GOOGL</code>是谷歌的股票数据在quandl网站上的代码，不过我看不懂那个网站，不清楚要怎么找其他公司和时间的数据，所以暂时就先只用这个了。</p>
</li>
<li><p>通过tushare和pandas_datareader这两个模块也可以获取数据，此外还有其他相关网站。</p>
</li>
<li><p>发现pandas_datareader实际上不太行，查了一下找到了新的数据，数据来源是雅虎财经：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line">start_date = <span class="string">"2000-01-01"</span></span><br><span class="line">end_date = <span class="string">"2018-12-01"</span></span><br><span class="line">stock_df = yf.download(tickers = <span class="string">"MCD"</span>, start = start_date, end = end_date)</span><br></pre></td></tr></table></figure>
<p>这里<code>start_date</code>和<code>end_date</code>也可以写成前面<code>date(2000,1,1)</code>的样子，<code>tickers</code>的参数是可以百度到的股票代码，如果是上海的就是<code>600673.SS</code>这种代码后面加<code>.SS</code>，深圳是<code>.SZ</code>，香港是<code>.HK</code>，美国就是那串字母本身，此外，香港的代码查到的都是五位数，但是在这里要把最高位的0去掉，只用四位数。</p>
<p><code>yf.download</code>会直接返回<code>pandas</code>的<code>dataframe</code>结构，方便后续处理。</p>
<p>和前面那个<code>quandl</code>的比起来，简单了很多，但是有时候会运行很慢，等十几分钟也不出结果。</p>
</li>
</ol>
<h2 id="sklearn的普通方法"><a href="#sklearn的普通方法" class="headerlink" title="sklearn的普通方法"></a>sklearn的普通方法</h2><ol>
<li><p>把预测要用的数据列提取出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_df = stock_df[[<span class="string">'Open'</span>, <span class="string">'High'</span>, <span class="string">'Low'</span>, <span class="string">'Close'</span>, <span class="string">'Volume'</span>]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里使用过去一天的数据来预测当天的收盘价，因此要新建一列来存下一天的收盘价作为机器学习的目标值<code>y</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_df[<span class="string">'object'</span>] = stock_df[<span class="string">'Close'</span>].shift(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>把除了目标列以外的其他数据单独提出来作为<code>X</code>，并做标准化处理，然后去掉最后一行（因为最后一行没有下一天的目标值，所以没法用）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.array(stock_df.drop([<span class="string">'object'</span>], <span class="number">1</span>))</span><br><span class="line">X = preprocessing.scale(X)</span><br><span class="line">X = X[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>把目标列提出来作为<code>y</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_df.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line">y = np.array(stock_df[<span class="string">'object'</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>划分训练集和测试集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_train, x_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>把要用的模型都准备好</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">models = []</span><br><span class="line">models.append((<span class="string">'DecisionTree'</span>, tree.DecisionTreeRegressor()))</span><br><span class="line">models.append((<span class="string">'LR'</span>, linear_model.LinearRegression()))</span><br><span class="line">models.append((<span class="string">'KNN'</span>, neighbors.KNeighborsRegressor()))</span><br><span class="line">models.append((<span class="string">'RF'</span>, ensemble.RandomForestRegressor(n_estimators=<span class="number">20</span>)))</span><br><span class="line">models.append((<span class="string">'ABR'</span>, ensemble.AdaBoostRegressor(n_estimators=<span class="number">50</span>)))</span><br><span class="line">models.append((<span class="string">'SVM'</span>, svm.SVR(gamma=<span class="string">'auto'</span>)))</span><br><span class="line">models.append((<span class="string">'GBRT'</span>, ensemble.GradientBoostingRegressor(n_estimators=<span class="number">100</span>)))</span><br><span class="line">models.append((<span class="string">'Bagging'</span>, BaggingRegressor()))</span><br><span class="line">models.append((<span class="string">'ExtraTree'</span>, ExtraTreeRegressor()))</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历所有模型，在训练集上10折交叉验证并输出模型评价，在测试集上计算均方根误差</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name, model <span class="keyword">in</span> models:</span><br><span class="line">    scores = cross_val_score(model, x_train, y_train, cv=<span class="number">10</span>, scoring=<span class="literal">None</span>)</span><br><span class="line">    print(<span class="string">'%s: %f (%f)'</span> % (name, scores.mean(), scores.std()))</span><br><span class="line">    model.fit(x_train, y_train)</span><br><span class="line">    <span class="comment">#print(model.score(x_test, y_test))</span></span><br><span class="line">    y_predict = model.predict(x_test)</span><br><span class="line">    print(<span class="string">'RMSE: '</span>, np.sqrt(metrics.mean_squared_error(y_test,y_predict)))</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来要随便选个模型画图看看</p>
<ol>
<li><p>选模型并用训练集训练模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf = ensemble.GradientBoostingRegressor(n_estimators=<span class="number">100</span>)</span><br><span class="line">clf.fit(x_train, y_train)</span><br></pre></td></tr></table></figure>
</li>
<li><p>从所有的X中，选取后30%，用模型预测结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index = len(X)*<span class="number">7</span>//<span class="number">10</span></span><br><span class="line">predict_x = X[index:]</span><br><span class="line">predict_y = clf.predict(predict_x)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在原本的<code>dataframe</code>中新建一列来存这个预测结果，这样后面画图能直接用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_df[<span class="string">'Predict'</span>] = np.nan			<span class="comment">#新建一列并初始化为空值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> predict_y:						<span class="comment">#遍历预测结果</span></span><br><span class="line">    stock_df[<span class="string">'Predict'</span>][index] = i		<span class="comment">#从预测的第一个数开始填值</span></span><br><span class="line">    index += <span class="number">1</span>							<span class="comment">#移动到下一个值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>画图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(stock_df[<span class="string">'Close'</span>], label=<span class="string">'Close'</span>, color=<span class="string">'deepskyblue'</span>)	<span class="comment">#实际值</span></span><br><span class="line">stock_df[<span class="string">'Predict'</span>].plot()										<span class="comment">#预测值</span></span><br><span class="line">plt.legend(loc=<span class="number">4</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Date'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Price'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="lstm"><a href="#lstm" class="headerlink" title="lstm"></a>lstm</h2><ol>
<li><p>预处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_df[<span class="string">'Date'</span>] = stock_df.index</span><br><span class="line">data = stock_df.sort_index(ascending=<span class="literal">True</span>, axis=<span class="number">0</span>)</span><br><span class="line">new_data = pd.DataFrame(index=range(<span class="number">0</span>, len(stock_df)), columns=[<span class="string">'Date'</span>, <span class="string">'Close'</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(data)):</span><br><span class="line">    new_data[<span class="string">'Date'</span>][i] = data[<span class="string">'Date'</span>][i]</span><br><span class="line">    new_data[<span class="string">'Close'</span>][i] = data[<span class="string">'Close'</span>][i]</span><br><span class="line"><span class="comment"># setting index</span></span><br><span class="line">new_data.index = new_data.Date</span><br><span class="line">new_data.drop(<span class="string">'Date'</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>这样的结果就是把日期和收盘价单独提出来了</p>
</li>
<li><p>划分训练集和测试集，是7:3划分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataset = new_data.values</span><br><span class="line">t_len = len(dataset)*<span class="number">7</span>//<span class="number">10</span></span><br><span class="line">train = dataset[<span class="number">0</span>:t_len, :]</span><br><span class="line">valid = dataset[t_len:, :]</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理训练集数据，lstm会利用过去一段时间的数据，这里设置为过去60天</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#标准化处理</span></span><br><span class="line">scaler = MinMaxScaler(feature_range=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">scaled_data = scaler.fit_transform(dataset)</span><br><span class="line"><span class="comment">#定义列表存放数据</span></span><br><span class="line">x_train, y_train = [], []</span><br><span class="line"><span class="comment">#对于每一天的y，x的值都是过去60天的收盘价</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">60</span>, len(train)):</span><br><span class="line">    x_train.append(scaled_data[i - <span class="number">60</span>:i, <span class="number">0</span>])</span><br><span class="line">    y_train.append(scaled_data[i, <span class="number">0</span>])</span><br><span class="line"><span class="comment">#把x的格式改成训练需要的格式</span></span><br><span class="line">x_train, y_train = np.array(x_train), np.array(y_train)</span><br><span class="line">x_train = np.reshape(x_train, (x_train.shape[<span class="number">0</span>], x_train.shape[<span class="number">1</span>], <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立和训练lstm模型，这里训练50轮，实际上感觉100轮和50轮没什么差别；这里用了4层lstm，但实际上感觉一层就够了。在训练时用均方根误差作为指标。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create and fit the LSTM network</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(units=<span class="number">50</span>, return_sequences=<span class="literal">True</span>, input_shape=(x_train.shape[<span class="number">1</span>], <span class="number">1</span>)))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(LSTM(units = <span class="number">50</span>, return_sequences = <span class="literal">True</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(LSTM(units = <span class="number">50</span>, return_sequences = <span class="literal">True</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(LSTM(units=<span class="number">50</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.compile(loss=<span class="string">'mean_squared_error'</span>, optimizer=<span class="string">'adam'</span>)</span><br><span class="line">model.fit(x_train, y_train, epochs=<span class="number">50</span>, batch_size=<span class="number">32</span>, verbose=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这些lstm模型用的激活函数是默认的<code>tanh</code>，然后训练时会有错误信息，据一些人说是可以忽略的，参见<a href="https://github.com/tensorflow/tensorflow/issues/30263" target="_blank" rel="noopener">链接</a>。如果把激活函数改成<code>sigmoid</code>，就没报错了，但是发现训练结果格外不好，不清楚是我操作问题还是这个激活函数就不合适。总之暂且先用<code>tanh</code>。</p>
</li>
<li><p>准备测试集，这里和训练集一样，往前倒60个数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputs = new_data[len(new_data) - len(valid) - <span class="number">60</span>:].values</span><br><span class="line">inputs = inputs.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">inputs = scaler.transform(inputs)</span><br><span class="line">X_test, Y_test = [], []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">60</span>, inputs.shape[<span class="number">0</span>]):</span><br><span class="line">    X_test.append(inputs[i - <span class="number">60</span>:i, <span class="number">0</span>])</span><br><span class="line">X_test = np.array(X_test)</span><br><span class="line">X_test = np.reshape(X_test, (X_test.shape[<span class="number">0</span>], X_test.shape[<span class="number">1</span>], <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>用训练好的lstm模型对测试集进行测试并把值改回标准化前的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">closing_price = model.predict(X_test)</span><br><span class="line">closing_price = scaler.inverse_transform(closing_price)</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出均方根误差</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rms &#x3D; np.sqrt(np.mean(np.power((valid - closing_price), 2)))</span><br><span class="line">print(rms)</span><br></pre></td></tr></table></figure>
</li>
<li><p>和sklearn一样的画图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train = new_data[:t_len]</span><br><span class="line">valid = new_data[t_len:]</span><br><span class="line">valid[<span class="string">'Predictions'</span>] = closing_price</span><br><span class="line">plt.plot(train[<span class="string">'Adj. Close'</span>], color=<span class="string">'deepskyblue'</span>, label = <span class="string">'Adj. Close'</span>)</span><br><span class="line">plt.plot(valid[<span class="string">'Adj. Close'</span>], color=<span class="string">'deepskyblue'</span>)</span><br><span class="line">plt.plot(valid[<span class="string">'Predictions'</span>], label = <span class="string">'Predict'</span>)</span><br><span class="line">plt.legend(loc=<span class="number">4</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Date'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Price'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><ol>
<li>之后有空的时候再增加这些算法的理论介绍</li>
<li>回归和分类的代码结构差不多，只是函数名称和模型评价指标不太一样，关于评价指标可以参考<a href="https://scikit-learn.org/stable/modules/model_evaluation.html#the-scoring-parameter-defining-model-evaluation-rules" target="_blank" rel="noopener">这个</a>。</li>
</ol>
]]></content>
      <categories>
        <category>无分类项</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>sklearn</tag>
        <tag>keras</tag>
        <tag>lstm</tag>
        <tag>回归</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-N-in-One: A Novel Location-Based-Service</title>
    <url>/2020/07/18/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-N-in-One-A-Novel-Location-Based-Service/</url>
    <content><![CDATA[<h1 id="新的LBS系统"><a href="#新的LBS系统" class="headerlink" title="新的LBS系统"></a>新的LBS系统</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ol>
<li>现有LBS基于单一POI，而现实里用户需要多POI的LBS</li>
<li>本文将单一POI的LBS扩展为使用单个查询请求多个POI的LBS</li>
</ol>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ol>
<li>场景：用户希望同时查询某地点附近的多个兴趣点（例如饭店和KTV都需要）</li>
<li>和单兴趣点推荐的差别：要综合考虑多个兴趣点的评价和距离以及用户需求，例如吃完饭去KTV这种场景就需要推荐的饭店和KTV近一些</li>
<li>本文实现的功能：<ol>
<li>Ranking mode（排序模式）：根据每个兴趣点的评价和兴趣点之间的距离，提供一个按评分排序的列表中的前K个兴趣点组合</li>
<li>Service area mode（服务区模式）：找出一个包含了最多兴趣点的矩形区域</li>
</ol>
</li>
<li>挑战性：<ol>
<li>受限于兴趣点之间的距离，实现”N-in-One”与单纯找N个相互独立的兴趣点并不同；</li>
<li>服务区模式可能会有木桶效应问题：返回的聚类结果可能因为有一个或多个热门兴趣点被排除。</li>
</ol>
</li>
<li>本文提出：<ol>
<li>排序模式：基于平面扫描算法，垂直线从右往左扫描兴趣点区域，遇到兴趣点时回溯和已经记录的兴趣点匹配，以查找最优K聚类；为实现回溯过程中的POI匹配，引入“可查看网络”；</li>
<li>服务区模式：引入“瓶颈值”来描述 POI 的重复使用数，使用计算几何来识别给定大小的矩形，该矩形可以覆盖尽可能多的最佳Q群集，同时减少木桶效应。</li>
</ol>
</li>
<li>本文组织结构：<ol>
<li>第二部分、第三部分分别介绍排序模式和服务区模式</li>
<li>第四部分仿真实验</li>
<li>第五部分相关研究</li>
<li>第六部分总结</li>
</ol>
</li>
</ol>
<h2 id="“N-IN-ONE”-LBS-IN-THE-RANKING-MODE"><a href="#“N-IN-ONE”-LBS-IN-THE-RANKING-MODE" class="headerlink" title="“N-IN-ONE” LBS IN THE RANKING MODE"></a>“N-IN-ONE” LBS IN THE RANKING MODE</h2><h3 id="Metric-to-Evaluate-a-POI-Cluster"><a href="#Metric-to-Evaluate-a-POI-Cluster" class="headerlink" title="Metric to Evaluate a POI Cluster"></a>Metric to Evaluate a POI Cluster</h3><p>POI聚类$\Pi=\{p_1,…,p_N\}$，其中$p_j$是第$j$个兴趣点位置</p>
<p><strong>定义1</strong>  POI聚类的直径：覆盖该聚类所有兴趣点的最小圆直径</p>
<p><strong>定义2</strong>  POI聚类的中心：覆盖该聚类所有兴趣点的最小圆圆心</p>
<p>最小圆问题：直径取决于聚类中距离最远的两点之间的距离上限</p>
<p><strong>评估函数</strong>：</p>
<script type="math/tex; mode=display">
R(\Pi)=\sum_{j=1}^{N}\alpha_je_j-\beta D(\Pi)-\gamma d(\Pi,c)</script><p>其中，$e_j$是对该聚类内第$j$个兴趣点的评估值，$\alpha_j$是对应的权重；$D(\Pi)$是聚类的直径，体现了聚类的离散程度，$\beta$是对应的权重；$d(\Pi,c)$是当前位置$c$到聚类中心的距离，$\gamma$是对应权重。所有权重由用户自己决定。</p>
<h3 id="Overview-of-Our-Algorithm-for-the-Ranking-Mode"><a href="#Overview-of-Our-Algorithm-for-the-Ranking-Mode" class="headerlink" title="Overview of Our Algorithm for the Ranking Mode"></a>Overview of Our Algorithm for the Ranking Mode</h3><p>用户兴趣区域内有$n$个POI，集合表示为$\Omega$，$||\Omega||=n$</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>所有POI根据x坐标升序排列（即标号大的POI出现在右边）</li>
<li>垂直线从右向左扫描兴趣区域</li>
<li>当垂直线扫到了某个POI，算法会检查之前找到的POI聚类，并将该POI加到之前的聚类中形成新聚类，聚类中所有元素的POI类型在任何时刻都不同</li>
<li>基于新聚类，更新最优K结果</li>
<li>当兴趣区域内的POI都被扫描过时，上述过程结束，最终的最优K结果被推送给用户</li>
</ol>
<p><strong>关键问题</strong>：扫描到一个POI时，如何从之前的POI集合中高效识别那些需要被回溯的</p>
<p><strong>解决方法</strong>：引入可视网络的概念，$N=(\Omega,E)$，$\Omega$是兴趣点集合，E是可视线集合</p>
<p>可视线：由扫描到的POI及其可视点之一决定。当扫描到某个POI $P_i$时，算法根据其可视线回溯L层邻近POI</p>
<p>L层邻近POI：可视网络中，比$P_i$扫描得早、且从$P_i$出发可通过最多L个可视线到达的POI</p>
<p>采用递归方法，整体分为两步：</p>
<ol>
<li>构建可视网络</li>
<li>移动和回溯</li>
</ol>
<h3 id="Constructing-the-Viewable-Network"><a href="#Constructing-the-Viewable-Network" class="headerlink" title="Constructing the Viewable Network"></a>Constructing the Viewable Network</h3><p>构建可视网络的思路大致是：从右向左扫描点（也就是从最后一个点开始），每扫描到一个点就看它右边是否有没被挡住可以直接相连的点，如果有就连起来，这样一直扫到最左边的点（也就是第一个点），网络就构建好了。</p>
<p>实际上这个网络扫描的方向并不一定要这样，也可以从左往右。</p>
<p>时间复杂度的分析和证明省略。</p>
<p>该算法的具体流程如下：</p>
<p>​    输入：POI集合根据x坐标升序排列</p>
<ol>
<li>扫描线自右向左扫描</li>
<li>当扫描到$P_n$、$P_{n-1}$、$P_{n-2}$的时候：<ol>
<li>$P_n$、$P_{n-1}$、$P_{n-2}$加到集合V里，集合V用来存放已经扫描过的点；</li>
<li>如果$P_i$是集合V的凸包的顶点，就把$P_i$加到集合$C^P(V)$里；</li>
<li>如果$L_i$是集合V的凸包的边，就把$L_i$加到集合$C^E(V)$里；</li>
<li>把集合$C^E(V)$加到集合E里，集合E用来存放可视线；</li>
</ol>
</li>
<li>令$i=n-2$</li>
<li>重复循环一下流程：<ol>
<li>令$i=i-1$</li>
<li>遍历集合$C^P(V)$中的点记作$P_k$，如果点$P_i$、$P_k$之间的连线与集合$C^E(V)$的交集是点$P_k$，则把$P_k$加入集合$A_i$，集合$A_i$用来存放点$P_i$的可视点</li>
<li>遍历集合$A_i$中的所有$P_k$，把点$P_i$、$P_k$之间的连线加入到之前的边集合E中</li>
<li>把$P_i$加入集合V中</li>
<li>按之前的规则更新集合$C^P(V)$和$C^E(V)$</li>
</ol>
</li>
<li>$i=0$时结束循环，集合E就是所有可视边</li>
</ol>
<h3 id="Searching-Heterogeneous-POIs"><a href="#Searching-Heterogeneous-POIs" class="headerlink" title="Searching Heterogeneous POIs"></a>Searching Heterogeneous POIs</h3><ol>
<li>总共有$n$个兴趣点</li>
<li>兴趣点异构，总共有$j$个类型</li>
<li>有$j$个异构兴趣点的聚类的集合记作$G_j$，而$G_1$是有$n$个聚类的集合，其中每个聚类都包含一个兴趣点</li>
<li>垂直线从第$n-j+1$个点开始扫描，L层邻接POI集合最多有$j$个POI，这也是构建包含j-1个异构兴趣点的聚类的最小兴趣点编号</li>
<li>整个算法递归地根据$G_{j-1}$计算$G_j$，具体过程如下：<ol>
<li>每当扫描到一个兴趣点$P_i$时，遍历$G_{j-1}$中的聚类，如果某个聚类属于$P_i$的L层邻接POI集合，则把该聚类加到一个新集合$S_{i,j-1}$中</li>
<li>第一步中的聚类遍历结束后，遍历得到的集合$S_{i,j-1}$中的聚类，如果$P_i$和这个聚类异构，则把$P_i$和这个聚类组成的集合加到集合$G_j$中</li>
<li>继续用同样的思路扫描兴趣点$P_{i-1}$，这样循环直到$P_1$被扫描完</li>
<li>最终得到$G_j$作为异构兴趣点聚类</li>
</ol>
</li>
</ol>
<p>复杂度分析省略。</p>
<h3 id="Searching-the-Best-K-Results-in-the-Ranking-Mode"><a href="#Searching-the-Best-K-Results-in-the-Ranking-Mode" class="headerlink" title="Searching the Best K Results in the Ranking Mode"></a>Searching the Best K Results in the Ranking Mode</h3><p>算法1构建可视网络得到的可视线记作$E$；算法2寻找异构兴趣点聚类的集合记作$G_{N-1}$（它包括所有具有N-1个异构兴趣点的聚类）；兴趣点$P_i$的L层邻接兴趣点记作$L_i$。</p>
<ol>
<li>从第$i=n-N+1$个兴趣点开始，从右向左扫描所有兴趣点</li>
<li>遍历$G_{N-1}$中的聚类，如果聚类属于$L_i$，则把聚类加到一个新集合$S_{i,N-1}$中</li>
<li>遍历新集合$S_{i,N-1}$中的聚类，如果$P_i$和聚类异构，则把$P_i$和这个聚类组成的集合插入到列表B中，插入顺序按聚类的评价降序</li>
<li>如果列表B中的元素个数大于K，则删去最后一个元素</li>
<li>继续扫描第$i-1$个兴趣点，执行相同的操作，直到扫描到$P_1$</li>
</ol>
<p>复杂度分析省略。</p>
<h2 id="“N-IN-ONE”-LBS-IN-THE-SERVICE-AREA-MODE"><a href="#“N-IN-ONE”-LBS-IN-THE-SERVICE-AREA-MODE" class="headerlink" title="“N-IN-ONE” LBS IN THE SERVICE AREA MODE"></a>“N-IN-ONE” LBS IN THE SERVICE AREA MODE</h2><p>服务区：给定长宽的矩形区域，该区域内的兴趣点密度最大，且所有兴趣点都属于最优Q聚类</p>
<p>矩形区域的权重受三个因素影响：</p>
<ol>
<li>矩形覆盖的最优兴趣点聚类个数</li>
<li>矩形内的兴趣点聚类评分</li>
<li>兴趣点聚类的分布</li>
</ol>
<p><strong>定义3.1</strong>  如果一个兴趣点聚类$\Pi$的中心在某区域$\Gamma$内，则称该聚类在该区域内。</p>
<p>就此将聚类视作其中心点，将该问题转变为<code>maximizing range sum</code>（最大子序列？）</p>
<p>当一个兴趣点属于多个聚类时，我们称它被多个聚类复用了。这种情况如果该兴趣点不可用，则会导致区域内大量聚类都不可用，这不好。</p>
<p><strong>定义3.2</strong>  一个矩形区域内聚类集合的瓶颈值$B$是指，该区域内被复用次数最多的兴趣点所对应的复用次数。</p>
<p><strong>定义3.3</strong> 矩形的权重由该区域内聚类的评分和该区域的瓶颈值决定，计算公式如下：</p>
<script type="math/tex; mode=display">
W(C)=\varepsilon\sum_{\Pi\in C}R(\Pi)-\eta B</script><p>其中，$\varepsilon$和$\eta$都是常数系数。</p>
<p>找服务区的算法流程：</p>
<p>复杂度分析省略。</p>
<h2 id="PERFORMANCE-EVALUATION"><a href="#PERFORMANCE-EVALUATION" class="headerlink" title="PERFORMANCE EVALUATION"></a>PERFORMANCE EVALUATION</h2><h3 id="Performance-Evaluation-Based-on-Synthetic-Data"><a href="#Performance-Evaluation-Based-on-Synthetic-Data" class="headerlink" title="Performance Evaluation Based on Synthetic Data"></a>Performance Evaluation Based on Synthetic Data</h3><h3 id="Performance-Evaluation-Based-on-Real-World-Data"><a href="#Performance-Evaluation-Based-on-Real-World-Data" class="headerlink" title="Performance Evaluation Based on Real-World Data"></a>Performance Evaluation Based on Real-World Data</h3><p>实验部分不看了，省略。</p>
<h2 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h2><p>当前LBS领域的热点研究：基于位置信息的推荐系统，尤其是兴趣点推荐</p>
<ol>
<li>潜在Dirichlet分配（LDA）</li>
<li>朴素贝叶斯</li>
<li>地理概率分析框架，策略性地考虑多个因素</li>
<li>动态聚类算法识别运动轨迹</li>
</ol>
<p>路线推荐同样热门</p>
<ol>
<li>分析用户交通路线来得到两地之间最受欢迎的路线</li>
<li>基于集体知识的路线推荐框架</li>
<li>候选-生成-验证策略得到K近邻轨迹</li>
<li>KNN+更多因素的分析</li>
<li>LIT前缀挖掘算法</li>
<li>网络优化问题</li>
<li>轨迹大数据</li>
</ol>
<p>本文和上述内容的共同点：给用户返回多个POI</p>
<p>不同点：本文侧重查询，是LBS的基础服务；上述侧重推荐，是LBS的衍生服务</p>
<p>本文的创新性：现有LBS的基础服务不涉及多POI查询，本文针对基础服务进行了改进</p>
<h2 id="CONCLUSION-AND-FUTURE-WORK"><a href="#CONCLUSION-AND-FUTURE-WORK" class="headerlink" title="CONCLUSION AND FUTURE WORK"></a>CONCLUSION AND FUTURE WORK</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>LBS</tag>
        <tag>POI</tag>
      </tags>
  </entry>
  <entry>
    <title>blender学习记录-2</title>
    <url>/2020/07/07/blender%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-2/</url>
    <content><![CDATA[<p>第二课是建模型相关操作</p>
<a id="more"></a>
<p>我发现了，blender入门教程其实就是教快捷键。</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">进入编辑模式</td>
<td style="text-align:center">TAB</td>
</tr>
<tr>
<td style="text-align:center">切换选择模式</td>
<td style="text-align:center">W</td>
</tr>
<tr>
<td style="text-align:center">环选，例如点竖线会把横着一圈选中，而点横线会把竖着的一圈选中</td>
<td style="text-align:center">alt+左键</td>
</tr>
<tr>
<td style="text-align:center">连选</td>
<td style="text-align:center">ctrl</td>
</tr>
<tr>
<td style="text-align:center">多选（这个和上一个刚好和windows系统的操作相反）</td>
<td style="text-align:center">shift</td>
</tr>
<tr>
<td style="text-align:center">全选</td>
<td style="text-align:center">A</td>
</tr>
<tr>
<td style="text-align:center">取消全选</td>
<td style="text-align:center">双击A</td>
</tr>
<tr>
<td style="text-align:center">挤出</td>
<td style="text-align:center">E</td>
</tr>
<tr>
<td style="text-align:center">环切，环切确认的时候滚动滚轮可以一次切好几个</td>
<td style="text-align:center">ctrl+R</td>
</tr>
<tr>
<td style="text-align:center">倒角</td>
<td style="text-align:center">ctrl+B</td>
</tr>
<tr>
<td style="text-align:center">内插面</td>
<td style="text-align:center">I（进编辑模式，双击I会有不太一样的效果，但是我说不清是什么样的）</td>
</tr>
<tr>
<td style="text-align:center">环切</td>
<td style="text-align:center">ctrl+R</td>
</tr>
<tr>
<td style="text-align:center">偏移环切线</td>
<td style="text-align:center">ctrl+shift+R</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>blender</category>
      </categories>
      <tags>
        <tag>随便学学</tag>
      </tags>
  </entry>
  <entry>
    <title>typora图床功能设置</title>
    <url>/2020/07/07/typora%E5%9B%BE%E5%BA%8A%E5%8A%9F%E8%83%BD%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>终于不用自己上传github然后再复制链接到markdown了！</p>
<a id="more"></a>
<ol>
<li><p>打开typora，文件—&gt;偏好设置—&gt;图像，然后按照下图设置：</p>
<p><img src="https://pic3.zhimg.com/80/v2-2f7c965687ee0689ced4a80a608599be_1440w.jpg" alt="img"></p>
</li>
<li><p>设置好以后点下载或更新，下载更新结束以后，浏览器打开<a href="https://sm.ms/home/apitoken" target="_blank" rel="noopener">smms</a>并注册账号和登录，注册的时候要填用户名和邮箱，登录的时候不是邮箱登录而是用户名登录；</p>
</li>
<li><p>注册并登录以后打开<a href="https://sm.ms/home/apitoken" target="_blank" rel="noopener">新链接</a>，secret token那里是空的，点下面的generate secret token，会得到一串字符，如下图：</p>
<p><img src="https://pic2.zhimg.com/80/v2-f8e838a39e52ef233bca3c190af483f1_1440w.jpg" alt="img"></p>
</li>
<li><p>回到刚才的typora，还是图像那里，打开配置文件，如果要选应用程序就找记事本之类的编辑器；</p>
</li>
<li><p>把下面的代码复制粘贴进去和保存：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"picBed"</span>: &#123;</span><br><span class="line">    <span class="attr">"uploader"</span>: <span class="string">"smms"</span>, <span class="comment">// 代表当前的默认上传图床为 SM.MS,</span></span><br><span class="line">    <span class="attr">"smms"</span>: &#123;</span><br><span class="line">      <span class="attr">"token"</span>: <span class="string">"这里面的token换成你上个页面的申请的token"</span> <span class="comment">//一定要换</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"picgoPlugins"</span>: &#123;&#125; <span class="comment">// 为插件预留</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>到此为止就好了，还是在图像那里，点验证图片上传选项，可以验证一下有没有问题。</p>
</li>
</ol>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/137310314" target="_blank" rel="noopener">知乎链接</a></p>
]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>blender学习记录-1</title>
    <url>/2020/07/06/blender%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-1/</url>
    <content><![CDATA[<p>因为种种原因，我决定培养个兴趣爱好，于是开始学blender。</p>
<a id="more"></a>
<p>第一课是移动旋转缩放的操作。</p>
<h2 id="快捷键记录"><a href="#快捷键记录" class="headerlink" title="快捷键记录"></a>快捷键记录</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">视角旋转</td>
<td style="text-align:center">鼠标中键按着拖动</td>
</tr>
<tr>
<td style="text-align:center">视角缩放</td>
<td style="text-align:center">滚动鼠标滚轮</td>
</tr>
<tr>
<td style="text-align:center">视角平移</td>
<td style="text-align:center">shift+鼠标中键按着拖动</td>
</tr>
<tr>
<td style="text-align:center">物体移动</td>
<td style="text-align:center">G</td>
</tr>
<tr>
<td style="text-align:center">物体缩放</td>
<td style="text-align:center">S</td>
</tr>
<tr>
<td style="text-align:center">物体旋转</td>
<td style="text-align:center">R</td>
</tr>
<tr>
<td style="text-align:center">物体删除</td>
<td style="text-align:center">Delete或者X</td>
</tr>
<tr>
<td style="text-align:center">撤销操作</td>
<td style="text-align:center">Ctrl+Z</td>
</tr>
<tr>
<td style="text-align:center">插入关键帧</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">新建各种物体</td>
<td style="text-align:center">shift+A</td>
</tr>
<tr>
<td style="text-align:center">进入/退出编辑模式</td>
<td style="text-align:center">TAB（需要安装M3工具）</td>
</tr>
<tr>
<td style="text-align:center">新建一条边（存疑）</td>
<td style="text-align:center">Ctrl+R</td>
</tr>
<tr>
<td style="text-align:center">进入面模式</td>
<td style="text-align:center">3（不是小键盘的那个）</td>
</tr>
<tr>
<td style="text-align:center">选中某条竖线所在的横面</td>
<td style="text-align:center">alt+左键点击</td>
</tr>
<tr>
<td style="text-align:center">复制物体</td>
<td style="text-align:center">shift+D</td>
</tr>
<tr>
<td style="text-align:center">平面细分</td>
<td style="text-align:center">Ctrl+3</td>
</tr>
<tr>
<td style="text-align:center">打开切换视图面板，可以插入智能摄像机，还可以锁定视图</td>
<td style="text-align:center">pagedown（需要安装M3工具）</td>
</tr>
<tr>
<td style="text-align:center">进入摄像机视图</td>
<td style="text-align:center">0（小键盘的那个，没小键盘就得改设置或者鼠标点视图按钮）</td>
</tr>
<tr>
<td style="text-align:center">选多个物体</td>
<td style="text-align:center">按住shift左键点物体们</td>
</tr>
<tr>
<td style="text-align:center">物体组合</td>
<td style="text-align:center">Ctrl+P 最后一个被选中的是父物体</td>
</tr>
<tr>
<td style="text-align:center">进入/退出四视图</td>
<td style="text-align:center">Ctrl+alt+Q</td>
</tr>
<tr>
<td style="text-align:center">进入各种视图</td>
<td style="text-align:center">~</td>
</tr>
<tr>
<td style="text-align:center">开/关工具栏</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">快捷键进入移动旋转缩放后在坐标轴操作</td>
<td style="text-align:center">分别按XYZ</td>
</tr>
<tr>
<td style="text-align:center">快捷键进入移动旋转缩放后在某平面操作</td>
<td style="text-align:center">按shift+锁定不变的那个轴</td>
</tr>
<tr>
<td style="text-align:center">物体位置角度缩放归0</td>
<td style="text-align:center">alt+G/R/S</td>
</tr>
<tr>
<td style="text-align:center">打开变换面板</td>
<td style="text-align:center">Ctrl+A</td>
</tr>
</tbody>
</table>
</div>
<h2 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h2><p>学着<a href="https://www.bilibili.com/video/BV1T4411N7GE?p=5" target="_blank" rel="noopener">这个</a>做的</p>
<p>我好困啊懒得写了</p>
]]></content>
      <categories>
        <category>blender</category>
      </categories>
      <tags>
        <tag>随便学学</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Combinatorial Multi-Armed Bandit Based Unknown Worker Recruitment in Heterogeneous Crowdsensing</title>
    <url>/2020/07/05/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Combinatorial%20Multi-Armed%20Bandit%20Based%20Unknown%20Worker%20Recruitment%20in%20Heterogeneous%20Crowdsensing/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ol>
<li>本文研究问题：异构群智感知系统（也就是众包）中对未知worker的招募</li>
<li>本文场景：requester招募workers收集某城市交通路口一段时间内的交通数据，整个收集过程分为多轮，每轮包含一些和地点有关的任务，对应一个交通路口。每个任务有权重，表示重要性。每个worker能做一个或多个任务，且不同worker能做的任务可能不一样。worker会告诉平台自己能做的任务和期望收到的费用。worker完成任务的质量服从未知分布。</li>
<li>本文目的：设计worker招聘方案，在给定预算的情况下，最大限度提高总任务完成质量。</li>
<li>本文面临的挑战：平台不知道worker的质量分布</li>
<li>本文解决挑战的方法：让worker先完成一些任务，然后从任务结果里学习worker的质量，最后从中找最好的worker，简单来说分为exploration和exploitation。本文需要平衡这两个过程，从而实现目标（这么看一开始被完成的那些任务就被牺牲了）。</li>
<li>本文将上述问题概括为组合多臂老虎机模型（ Combinatorial Multi Armed Bandit），并且说和现存的CMAB模型都不一样；然后本文用扩展的上置信界算法（Upper Confidence Bound）。多臂老虎机模型我之前听说过，但是完全不了解，所以要先查一下。</li>
<li>本文贡献：<ol>
<li>介绍了这个场景并把它概括为多臂老虎机</li>
<li>用UCB来解决这个问题</li>
<li>研究了扩展问题：worker质量和期望收费都不知道的场景</li>
<li>做了仿真实验，分析了性能</li>
</ol>
</li>
</ol>
<h2 id="Combinatorial-Multi-Armed-Bandit"><a href="#Combinatorial-Multi-Armed-Bandit" class="headerlink" title="Combinatorial Multi Armed Bandit"></a>Combinatorial Multi Armed Bandit</h2><ol>
<li>实质是未知概率情况下的选择问题，比如赌博</li>
<li>具体来说，重复一个选择过程，每次有k个选项或动作可供选择，每次选择一个动作后会获得相应的奖励。目标是为了最大化k次后的奖励。选项对应的收益服从某种未知概率分布，对于实验者本人而言是黑箱，因此需要采取各种可能的方式来最大化收益。</li>
<li>基础思路：每一轮根据之前的结果更新对收益的期望，期望计算方法为[之前采取该选项所得到的所有收益]/[之前采取过该选项的次数]，也就是平均每次得到的收益；只要时间够长，这个算出来的期望就会接近真实收益。</li>
</ol>
<h2 id="System-model-and-problem"><a href="#System-model-and-problem" class="headerlink" title="System model and problem"></a>System model and problem</h2><ol>
<li>字母符号表示：</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>t</td>
<td>当前轮数，第t轮</td>
</tr>
<tr>
<td>N</td>
<td>N个workers的集合，第i个worker</td>
</tr>
<tr>
<td>M</td>
<td>M个任务的集合，第j个任务</td>
</tr>
<tr>
<td>B</td>
<td>预算</td>
</tr>
<tr>
<td>$w_j$</td>
<td>第j个任务的权重，所有权重加起来的和是1</td>
</tr>
<tr>
<td>L</td>
<td>每个worker会向平台提交L个任务候选</td>
</tr>
<tr>
<td>$p_i^l=\langle M_i^l,c_i^l \rangle$</td>
<td>第i个worker提交的第l个选项，其中$M_i^l$表示该worker的任务候选集合，$c_i^l$表示收费</td>
</tr>
<tr>
<td>$c_i^l=\varepsilon_i f(\vert M_i^l \vert)$</td>
<td>每个worker的收费与该选项包含的任务数正相关，每个worker的收费系数不同</td>
</tr>
<tr>
<td>$P_i=\{p_i^l \vert 1&lt;=l&lt;=L\}$</td>
<td>第i个worker提交的选项集合</td>
</tr>
<tr>
<td>$P=U_{i\in N}P_i $</td>
<td>所有选项集合</td>
</tr>
<tr>
<td>$q_{i,j}^t \vert j\in M_i^l$</td>
<td>第i个worker在第t轮完成第j个任务的质量</td>
</tr>
<tr>
<td>$P^t\subset P$</td>
<td>第t轮中平台对所有workers所选的选项集合</td>
</tr>
<tr>
<td>$p_i^l\in P^t$</td>
<td>第t轮平台对第i个worker选了其第l个选项</td>
</tr>
<tr>
<td>$u^j(P^t)$</td>
<td>第t轮采用方案$P^t$时的第j个任务的最终质量（所有完成任务结果中最好的那个）</td>
</tr>
<tr>
<td>$u(P^t)$</td>
<td>第t轮采用方案$P^t$时所有任务的最终质量和，也就是上一个符号乘权重再加起来</td>
</tr>
<tr>
<td>$n_i^l(t)$</td>
<td>第i个worker的第l个选项被选的次数</td>
</tr>
<tr>
<td>$n_i(t)$</td>
<td>第i个worker被学习过的次数</td>
</tr>
<tr>
<td>$\overline{q}_{i(t)}$</td>
<td>截至到第t轮学习到的第i个worker的质量</td>
</tr>
</tbody>
</table>
</div>
<p>   需要注意：虽然worker可以提交L个任务候选，但是每一轮只能最终完成一个选项，这里假设$c_i^1$到$c_i^L$是从小到大排的，也就是说最后一个的收费最高，且实际中，c的取值一般和M的长度（就是任务数量）正相关。</p>
<ul>
<li><p>这里有个奇怪的问题，我以为每个选项就是单独一个任务，然后c是对应的收费，但是看起来每个选项是任务集合，然后c是收费，也就是说比如有5个任务用abcde表示，某个worker的选项就会是{a,b,收费3}{b,c,d,收费5}{a,c,d,e,收费10}，这样看起来好奇怪。希望后面有解释。</p>
</li>
<li><p>虽然这样的设定有点别扭，不过解释是说：每一轮每个worker完成$|M_i^l|$个任务，也就会学习到到$|M_i^l|$个任务质量，就是说任务质量会被学习$|M_i^l|$次，这和传统CMAB不一样。</p>
</li>
<li><p>每轮每个worker最多定一个选项（也可以不选）</p>
</li>
</ul>
<ol>
<li><p>要研究的问题：给定预算，每轮招募K个workers，使得所有轮中完成的所有任务的权重加起来最大。</p>
</li>
<li><p>数学模型：</p>
<p>目标函数最大化：$E[\sum_{t\geq1}u(P^t) ]$    所有轮下来总期望收益最大</p>
<p>约束：$\sum_{t\geq1}\sum_{p_i^l\in P^t}c_i^l\leq B$    花费不超过预算</p>
<p>​            $|P^t|=K \  for\ \forall t&gt;1$    每一轮都招K个workers，不多不少</p>
<p>​            $\sum_{l=1}^LI\{p_i^l\in P^t\}\leq 1$    每个worker的选项最多一个</p>
</li>
</ol>
<h2 id="Algorithm-Design"><a href="#Algorithm-Design" class="headerlink" title="Algorithm Design"></a>Algorithm Design</h2><ol>
<li><p>本文模型：K臂的组合多臂赌博机</p>
</li>
<li><p>本文方法：</p>
<ol>
<li>扩展的上置信界算法（UCB）学习任务质量</li>
<li>增加了对最大化权重的考虑</li>
<li>每轮用贪心算法招K个workers：最大化任务质量和招募费用的比（单位费用的任务质量最大化）</li>
</ol>
<h3 id="原本的UCB算法"><a href="#原本的UCB算法" class="headerlink" title="原本的UCB算法"></a>原本的UCB算法</h3><ol>
<li>总的来说就是估计置信区间</li>
<li>我们认为真实的那个未知概率或者说收益是p，而根据尝试和计算推断出的概率是$\widetilde{p}$，这两个概率之间存在差值，即：$\widetilde{p}-\Delta \leq p \leq \widetilde{p}+\Delta$，这个范围就是置信区间，算法的目的就是通过一次次尝试缩小置信区间</li>
<li>该算法的流程是在所有臂里找$\widetilde{p}+\Delta$最大的那个，根据一系列完全没看的数学定理，$\Delta=\sqrt{2\ln T /n}$，T是目前进行过的轮数，n是这个臂已经被选过的次数，每一轮执行完会更新数据。具体来说，$\widetilde{p}$最大，选这个选项的收益就越大，而$\Delta$越大，这个选项之前被选中的次数就越小。</li>
<li>总结一下就是会考虑每个臂已经估计过的历史记录，尽可能去探索次数较少和收益较高的臂，兼顾收益和探索。</li>
</ol>
<h3 id="本文的算法"><a href="#本文的算法" class="headerlink" title="本文的算法"></a>本文的算法</h3><ol>
<li>在第t轮中，若第i个worker的第l个选项被选中，则$n_i^l(t)=n_i^l(t-1)+1$（就是比上一轮的多1），反之则保持上一轮的值不变</li>
<li>$n_i(t)$的值是第t轮时的第i个worker每个选项的$n_i^l(t)$和该选项任务数（也就是$|M_i^l|$）相乘，然后所有的加起来，表示第i个worker的质量被学习过的次数</li>
<li>用普通的总值/总次数更新worker的质量（$\overline {q}_i(t)$），用不太一样的UCB平衡探索和收益（$\widehat{q}_i (t)$）</li>
<li>每一轮都是最大化权重*$\widehat{q}_i (t)$，也就是根据之前结果的信息推断出的最大收益</li>
</ol>
<h3 id="本文的流程"><a href="#本文的流程" class="headerlink" title="本文的流程"></a>本文的流程</h3><ol>
<li>最一开始，对于每个worker平台都让他去完成候选列表中的第一个任务（就是最便宜的那个）,由此初始化$n_i^l(t)$、$n_i(t)$、$\overline{q}_i(t)$。</li>
<li>接下来的每一轮中，都以最大化单位费用的收益增长为目的来选择K个worker和它们的任务，也就是说([选择这个任务选项的收益]-[选之前的收益])/[选这个任务的开销]，要找使得这个式子最大的那个任务选项。要注意这一步中，当某个worker已经被选了任务，那他的其他选项都不会再被考虑</li>
<li>第t轮的K个worker选好以后，开始各自完成任务，做完以后平台计算任务质量，由此更新$n_i^l(t)$、$n_i(t)$、$\overline{q}_i(t)$、$\widehat{q}_i (t)$。同时，目前为止的所有轮获得的收益也更新了，平台根据预算还剩多少决定是否进行下一轮。</li>
</ol>
<h3 id="算法性能分析"><a href="#算法性能分析" class="headerlink" title="算法性能分析"></a>算法性能分析</h3><ol>
<li>实质是01背包问题</li>
<li>经过一系列我还没看的计算，该算法复杂度是$O(NLK^3\ln \tau(B))$</li>
</ol>
</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol>
<li><p>扩展问题场景：所有worker的质量和收费都未知，收费未知是指$c_i^l=\varepsilon_i f(|M_i^l|)$这个公式里的参数$\varepsilon_i$未知，公式里的函数$f()$是公开的。具体来说，在第t轮，worker的任务已经选定后，worker根据当前电量、环境、网络等估计一个第t轮的收费参数$\varepsilon_i^t$，该值在0和1之间，且有下限$\varepsilon_{min}$，所有轮的$\varepsilon_i^t$独立同分布，分布未知，期望是$\varepsilon_i$。</p>
</li>
<li><p>每一轮开始时，首先是平台选worker和任务，然后是worker报价，接着平台算一下预算够不够，不够的话就结束，反之就进入做任务的环节，之后的流程和上一部分一样。</p>
</li>
<li><p>问题在于：$\varepsilon_i$也需要学习，而且每一轮会被学习一次，这和之前的任务质量不太一样。</p>
<h3 id="本文方法"><a href="#本文方法" class="headerlink" title="本文方法"></a>本文方法</h3><ol>
<li>新增一个符号表示：$m_i(t)=\sum_{l=1}^Ln_i^l(t)$，表示$\varepsilon_i$目前被学习过的次数（第i个worker的所有选项目前被选过的次数）</li>
<li>新增另一个符号表示：$\overline \varepsilon_i (t) $，计算方法和前面p那个类似，也是[在此之前的值*在此之前的次数+这次的值]/[在此之前的次数+1]</li>
<li>同样也新增了$\widehat  \varepsilon_i (t)$，和前面的一样</li>
<li>把之前那个目标函数里的费用部分用这里新的符号改写然后化简，但是这里化简以后的没看懂（问了一下作者，是从regret部分分析出来的，然后又看了看之前没看的证明，发现是证明部分分析的）</li>
<li>于是整个流程就和之前的一模一样，只是目标函数换了</li>
<li>算法性能分析和前面一样，还没看，感觉不重要</li>
</ol>
</li>
</ol>
<h2 id="Performance-Evaluation"><a href="#Performance-Evaluation" class="headerlink" title="Performance Evaluation"></a>Performance Evaluation</h2><ol>
<li>实验部分对平台的介绍格外简单，用的公开数据集，这部分没什么能说的</li>
<li>实验主要关注：期望质量和期望费用（就是前面计算的俩参数）</li>
<li>实验内容是和另一种常用的CMAB的算法做对比</li>
<li>针对第一个算法：分析了预算的影响（500-1000），招募工人数K的变化（得出K小一些更好，但是意味着要来更多轮），用均匀分布作为例子对比了准确率</li>
<li>针对第二个算法：估计了质量和预算的关系，改变工人数之后的性能（和上一个不太一样了）</li>
</ol>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ol>
<li>没啥总结的，这个论文就这样了</li>
<li>之后有时间就看看性能证明那里，不过个人觉得十有八九是已有证明改编的</li>
<li>看了一点证明，还没完全看懂，大致了解思路了，不过不打算继续看了…..</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>crowdsourcing</tag>
        <tag>Combinatorial Multi Armed Bandit</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程期末作业</title>
    <url>/2020/06/13/python%E8%AF%BE%E7%A8%8B%E6%9C%9F%E6%9C%AB%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<p>实际上在这之前还有两课讲<code>scikit</code>库，不过没作业，就不整理内容了。</p>
<a id="more"></a>
<h1 align = "center">北京师范大学2019～2020学年第二学期期末大作业</h1>
<h1 align = "center">（研究生）</h1>

<p><strong>课程名称：</strong><u>Python编程之美</u>   &nbsp;&emsp;&emsp;&emsp; <strong>任课教师姓名：</strong><u>邓擎琼</u></p>
<p><strong>总分</strong>：<u>40</u>   </p>
<p><strong>院 系：</strong><u>人工智能学院</u> &nbsp;&emsp;&emsp;&emsp; <strong>年级：</strong><u>2019级</u></p>
<p><strong>姓 名：</strong><u>李琨</u>   &nbsp;&emsp;&emsp;&emsp; <strong>学 号：</strong><u>201931210003</u></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">题号</th>
<th style="text-align:center">第一题</th>
<th style="text-align:center">第二题</th>
<th style="text-align:center">第三题</th>
<th style="text-align:center">第四题</th>
<th style="text-align:center">第五题</th>
<th style="text-align:right">总分</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">得分</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p><strong>阅卷教师（签字）：</strong><u> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp;</u></p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><ol>
<li>读入北京历史天气数据（北京天气.xlsx）；  <font color='red'>分值：3</font><br>或者：从<a href="http://www.tianqihoubao.com/lishi/beijing.html" target="_blank" rel="noopener">http://www.tianqihoubao.com/lishi/beijing.html</a><br>网站上通过爬虫把北京2011年-至今的天气数据爬下来，并保存为Excel文件；  <font color='red'>分值：10</font></li>
<li>读入北京空气质量数据（北京空气质量.xlsx），并把该数据和第1步中得到的北京天气数据进行融合，得到一个同时包含天气和空气质量的表格数据，保存为Excel文件；   <font color='red'>分值：5</font></li>
<li>对2011-2019年的每一年，统计这一年中白天为晴、雨、多云、阴、雪、雾霾、扬沙的天数，并绘制成饼图；    <font color='red'>分值：4</font></li>
<li>对2014-2019年的每一年，统计这一年中持续1天污染的次数、持续2天污染的次数、持续3天污染的次数、持续4天污染的次数和持续5天及以上有污染的次数，把所有年份的统计结果绘制成一幅柱状图；    <font color='red'>分值：6</font></li>
<li>在北京历史天气和空气质量数据的基础上，根据当天的天气情况以及前两天的天气及空气质量情况，预测当天的空气质量等级，要求至少比较两种算法，从中选出较优的算法并确定最优超参数（如果算法有超参数的话） 。  <font color='red'>分值：15</font></li>
</ol>
<h2 id="承诺："><a href="#承诺：" class="headerlink" title="承诺："></a>承诺：</h2><p>本人承诺本程序是自己编写的，没有抄袭。</p>
<h3 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h3><p>首先列出所有用到的库，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> requests.compat <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures, StandardScaler</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OrdinalEncoder, OneHotEncoder, LabelEncoder</span><br></pre></td></tr></table></figure>
<ol>
<li>考虑到题目中有画图的要求，而内容有中文，因此先将<code>plt</code>的字体改为中文字体。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><ol>
<li><p>首先分析天气数据的<a href="http://www.tianqihoubao.com/lishi/beijing.html" target="_blank" rel="noopener">网页链接</a>，该页面并不直接包含天气数据，而是包含了指向每个月天气数据的链接，因此需要先从该页面把所有月份的链接提取出来。经过分析可知，该页面所有链接都在<code>class_=&quot;box pcity&quot;</code>的<code>div</code>块中，是<code>a</code>标签，因此可以通过以下函数来获取所有链接，该函数将所有链接存放在一个列表中并返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_href</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：获取所有天气链接</span></span><br><span class="line"><span class="string">    参数：无</span></span><br><span class="line"><span class="string">    返回值：href_list 所有天气链接的列表</span></span><br><span class="line"><span class="string">    使用方式：list = get_href()</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 设置网页链接和head等信息</span></span><br><span class="line">    url = <span class="string">'http://www.tianqihoubao.com/lishi/beijing.html'</span></span><br><span class="line">    head = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36'</span>&#125;</span><br><span class="line">    <span class="comment"># 获取网页文件并分析</span></span><br><span class="line">    html = requests.get(url, headers=head)</span><br><span class="line">    bsObj = BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">    <span class="comment"># 找到所有天气链接所在区块</span></span><br><span class="line">    allLinks = bsObj.find_all(<span class="string">'div'</span>, class_=<span class="string">"box pcity"</span>)</span><br><span class="line">    href_list = []</span><br><span class="line">    <span class="comment"># 提取所有链接并存入列表返回</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> allLinks[:<span class="number">10</span>]:</span><br><span class="line">        aLink = i.find_all(<span class="string">'a'</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> aLink:</span><br><span class="line">            href = urljoin(url, j[<span class="string">'href'</span>])</span><br><span class="line">            href_list.append(href)</span><br><span class="line">    <span class="keyword">return</span> href_list</span><br></pre></td></tr></table></figure>
</li>
<li><p>得到所有链接的列表后，遍历该列表即可访问每个月的天气数据网页，分析这些网页可以发现，天气数据存放在<code>table</code>中，每一行的标签为<code>tr</code>，每一项的标签为<code>td</code>，而一行有四项，分别是日期、天气、温度、风力风向，其中第一行是表格头，因此可以从表格的第二行（第二个<code>tr</code>）开始遍历，获取所有<code>td</code>的内容（是一个长度为4的列表），将内容逐一处理再存放在列表中。遍历完成后即可得到所有天气数据，我将这些数据存放在列表中并返回，函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis_href</span><span class="params">(href_list)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：分析处理天气链接里的数据</span></span><br><span class="line"><span class="string">    参数：href_list 天气链接列表</span></span><br><span class="line"><span class="string">    返回值：lists 所有处理后的天气数据，格式为[日期、天气、温度、风力风向]</span></span><br><span class="line"><span class="string">    使用方式：lists = analysis_href(href_list)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 设置head</span></span><br><span class="line">    head = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36'</span>&#125;</span><br><span class="line">    lists = []</span><br><span class="line">    <span class="comment"># 遍历所有链接</span></span><br><span class="line">    <span class="keyword">for</span> href <span class="keyword">in</span> href_list:</span><br><span class="line">        <span class="comment"># 获取网页文件并分析</span></span><br><span class="line">        html = requests.get(href, headers=head)</span><br><span class="line">        bsObj = BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">        <span class="comment"># 找到天气数据所在的表格</span></span><br><span class="line">        table = bsObj.find(<span class="string">"table"</span>).find_all(<span class="string">"tr"</span>)</span><br><span class="line">        <span class="comment"># 从表格第二行开始提取数据（第一行是表格的head）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> table[<span class="number">1</span>:]:</span><br><span class="line">            content = i.find_all(<span class="string">"td"</span>)</span><br><span class="line">            <span class="comment"># 提取日期并去除多余的空格和换行符等</span></span><br><span class="line">            date = content[<span class="number">0</span>].text.replace(</span><br><span class="line">                <span class="string">" "</span>, <span class="string">""</span>).replace(<span class="string">'\n'</span>, <span class="string">''</span>).replace(<span class="string">'\r'</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="comment"># 提取天气并去除多余的空格和换行符等</span></span><br><span class="line">            weather = content[<span class="number">1</span>].text.replace(<span class="string">" "</span>, <span class="string">""</span>).replace(</span><br><span class="line">                <span class="string">" "</span>, <span class="string">""</span>).replace(<span class="string">'\n'</span>, <span class="string">''</span>).replace(<span class="string">'\r'</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="comment"># 提取温度并去除多余的空格和换行符等</span></span><br><span class="line">            temperature = content[<span class="number">2</span>].text.strip().replace(</span><br><span class="line">                <span class="string">" "</span>, <span class="string">""</span>).replace(<span class="string">'\n'</span>, <span class="string">''</span>).replace(<span class="string">'\r'</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="comment"># 提取风力风向并去除多余的空格和换行符等</span></span><br><span class="line">            wind = content[<span class="number">3</span>].text.strip().replace(</span><br><span class="line">                <span class="string">" "</span>, <span class="string">""</span>).replace(<span class="string">'\n'</span>, <span class="string">''</span>).replace(<span class="string">'\r'</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="comment"># 将提取的数据存入列表</span></span><br><span class="line">            lists.append([date, weather, temperature, wind])</span><br><span class="line">    <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>
</li>
<li><p>在得到天气数据的列表后，需要将该列表数据写入excel文件，我先将列表转为<code>numpy</code>数组，再将该数组转为<code>DataFrame</code>，并把索引设置为<code>日期</code>列，这时就可以用<code>pandas</code>的库函数将所有内容写入<code>excel</code>文件了，函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_excel</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：将数据写入excel文件</span></span><br><span class="line"><span class="string">    参数：filename 文件名</span></span><br><span class="line"><span class="string">    返回值：无</span></span><br><span class="line"><span class="string">    使用方式：write_excel("weather.xlsx")</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 调用分析网页的函数获取所有天气数据所在列表</span></span><br><span class="line">    a = np.array(analysis_href(get_href()))</span><br><span class="line">    <span class="comment"># 将天气数据列表转为DateFrame</span></span><br><span class="line">    DF = pd.DataFrame(a, columns=[<span class="string">'日期'</span>, <span class="string">'天气'</span>, <span class="string">'温度'</span>, <span class="string">'风力风向'</span>])</span><br><span class="line">    <span class="comment"># 将索引设置为日期列，去除原本的索引序号</span></span><br><span class="line">    DF.set_index(<span class="string">'日期'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 将数据写入excel文件</span></span><br><span class="line">    DF.to_excel(filename)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在主函数中通过调用<code>write_excel()</code>即可得到天气数据文件，完成第一题。</p>
</li>
</ol>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><ol>
<li><p>首先读取天气数据和空气质量数据，并将<code>日期</code>列设置为<code>datetime</code>格式的索引，以便后续分析。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">df_weather = pd.read_excel(<span class="string">'weather.xlsx'</span>, <span class="string">'Sheet1'</span>, header=<span class="number">0</span>)</span><br><span class="line">df_air = pd.read_excel(<span class="string">'北京空气质量.xlsx'</span>, <span class="string">'Sheet1'</span>, header=<span class="number">0</span>)</span><br><span class="line">df_weather[<span class="string">'日期'</span>] = pd.to_datetime(df_weather[<span class="string">'日期'</span>], format=<span class="string">"%Y年%m月%d日"</span>)</span><br><span class="line">df_weather.set_index(<span class="string">'日期'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df_air[<span class="string">'日期'</span>] = pd.to_datetime(df_air[<span class="string">'日期'</span>], format=<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">df_air.set_index(<span class="string">'日期'</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来通过<code>pandas</code>的库函数即可将两个<code>DataFrame</code>按日期融合起来，因为两个表格中的日期并没有完全一致，所以去除了不一致的日期。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_merge = pd.merge(df_weather, df_air, on=<span class="string">'日期'</span>)</span><br><span class="line">df_merge.index = df_merge.index.date</span><br></pre></td></tr></table></figure>
</li>
<li><p>将该<code>DataFrame</code>写入<code>excel</code>文件，完成第二题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_merge.to_excel(<span class="string">'merge.xlsx'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><ol>
<li><p>分析天气数据，可以看出白天天气和夜晚天气通过<code>/</code>分隔，因此首先通过<code>split()</code>函数得到白天天气。</p>
</li>
<li><p>由于数据源本身的问题，有个别天气是无效的（是<code>-</code>符号），因此要删去这些数据。</p>
</li>
<li><p>得到白天天气后，还需要将该天气转换为题目中提到的几个类别中的一个，例如“小雨”要转换为“雨”。值得注意的是，”雨夹雪“天气我算作雨天而不是雪天。</p>
</li>
<li><p>上述处理天气数据的函数如下，该函数返回处理好的天气数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_weather_data</span><span class="params">(df_weather)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：处理天气数据以便后续绘图</span></span><br><span class="line"><span class="string">    参数：df_weather 初始天气数据</span></span><br><span class="line"><span class="string">    返回值：df_weather 处理好的天气数据</span></span><br><span class="line"><span class="string">    使用方式：df_weather = process_weather_data(df_weather)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 分离出白天天气</span></span><br><span class="line">    df_weather[<span class="string">'白天天气'</span>] = df_weather[<span class="string">'天气'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'/'</span>)[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 删去无效数据</span></span><br><span class="line">    df_weather = df_weather.drop(df_weather[df_weather[<span class="string">'白天天气'</span>] == <span class="string">'-'</span>].index)</span><br><span class="line">    <span class="comment"># 统一雨天数据</span></span><br><span class="line">    df_weather.loc[(df_weather[<span class="string">'白天天气'</span>] == <span class="string">'小雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'中雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'大雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'暴雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'阵雨'</span>) | ( df_weather[<span class="string">'白天天气'</span>] == <span class="string">'小到中雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'中到大雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'雷阵雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'雨夹雪'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雨'</span></span><br><span class="line">    <span class="comment"># 统一雪天数据</span></span><br><span class="line">    df_weather.loc[(df_weather[<span class="string">'白天天气'</span>] == <span class="string">'小雪'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'中雪'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'大雪'</span>) | ( df_weather[<span class="string">'白天天气'</span>] == <span class="string">'小到中雪'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'中到大雪'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雪'</span></span><br><span class="line">    <span class="comment"># 统一扬沙天气</span></span><br><span class="line">    df_weather.loc[df_weather[<span class="string">'白天天气'</span>] == <span class="string">'浮尘'</span>, <span class="string">'白天天气'</span>] = <span class="string">'扬沙'</span></span><br><span class="line">    <span class="comment"># 统一雾霾天气</span></span><br><span class="line">    df_weather.loc[(df_weather[<span class="string">'白天天气'</span>] == <span class="string">'雾'</span>) | ( df_weather[<span class="string">'白天天气'</span>] == <span class="string">'霾'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雾霾'</span></span><br><span class="line">    <span class="keyword">return</span> df_weather</span><br></pre></td></tr></table></figure>
</li>
<li><p>对处理好的数据按年分组，再遍历分组结果，可以得到每一年的数据，由于题目要求2011年至2019年，因此当遍历到2020年时终止循环。</p>
</li>
<li><p>对每一年的数据按白天天气这一列分组，统计分组的<code>size</code>，即可得到每种天气的天数，在此基础上可以绘制图像。上述分组并统计绘图的函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weather_pie</span><span class="params">(df_weather)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：根据处理好的天气数据画饼状图</span></span><br><span class="line"><span class="string">    参数：df_weather 处理好的天气数据</span></span><br><span class="line"><span class="string">    返回值：无</span></span><br><span class="line"><span class="string">    使用方式：weather_pie(df_weather)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 按年份分组</span></span><br><span class="line">    weather_group_y = df_weather.groupby(df_weather.index.year)</span><br><span class="line">    <span class="comment"># 对每年进行循环</span></span><br><span class="line">    <span class="keyword">for</span> n, g <span class="keyword">in</span> weather_group_y:</span><br><span class="line">        <span class="comment"># 不需要2020的数据</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2020</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 按白天天气分组</span></span><br><span class="line">        weather_group = g.groupby(g[<span class="string">'白天天气'</span>]).size()</span><br><span class="line">        <span class="comment"># 输出分组结果</span></span><br><span class="line">        print(str(n)+<span class="string">'年天气天数统计如下：'</span>)</span><br><span class="line">        print(weather_group)</span><br><span class="line">        <span class="comment"># 画饼图并保存</span></span><br><span class="line">        weather_group.name = <span class="string">''</span></span><br><span class="line">        weather_group.plot.pie(startangle=<span class="number">90</span>)</span><br><span class="line">        plt.title(<span class="string">''</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">        plt.savefig(<span class="string">'weather-pie-of-'</span>+str(n), dpi=<span class="number">300</span>)</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>在主函数中调用<code>weather_pie()</code>，参数为第二题中读取的天气数据，完成第三题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">weather_pie(process_weather_data(df_weather))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><ol>
<li><p>针对每一年的数据，首先根据空气质量等级区分开有污染和无污染，为了方便，我新增一列存储污染情况，将所有无污染的数据设置为0，有污染的设置为1。</p>
</li>
<li><p>同样是数据源的问题，个别数据的空气质量等级是无，属于无效数据，因此我删去这些数据。</p>
</li>
<li><p>接下来统计持续污染天数，这里参考了<a href="https://www.zhihu.com/question/41265794" target="_blank" rel="noopener">知乎</a>。具体方法是首先找到污染情况不同的坐标，该坐标就是持续同一污染状态的终点，而上一次持续的终点也是下一次持续的起点，因此可以得到一个存储了持续污染情况天数的表格，再从该表格中取出污染情况为1的部分，并进行分组统计，即可得到这一年持续<code>n</code>天污染的统计结果。需要注意的是，因为题目要求最高统计5天及以上，这里要把持续天数超过5天的也改为5。</p>
</li>
<li><p>由于这一题并不是每一年画一个图，而是所有数据一起画图，因此这里最后要把得到的统计结果转置，存储为行名是年份、列名是污染持续天数的新<code>DataFrame</code>，并返回。上述处理过程的函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_air_data</span><span class="params">(df, year)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：处理空气污染数据</span></span><br><span class="line"><span class="string">    参数：df 初始空气污染数据</span></span><br><span class="line"><span class="string">    返回值：df3 处理好的空气污染数据</span></span><br><span class="line"><span class="string">    使用方式：df_air = process_air_data(df_air)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 统一污染</span></span><br><span class="line">    df.loc[(df[<span class="string">'质量等级'</span>] == <span class="string">'轻度污染'</span>) | (df[<span class="string">'质量等级'</span>] == <span class="string">'中度污染'</span>) | (</span><br><span class="line">        df[<span class="string">'质量等级'</span>] == <span class="string">'重度污染'</span>) | (df[<span class="string">'质量等级'</span>] == <span class="string">'严重污染'</span>), <span class="string">'污染'</span>] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 统一无污染</span></span><br><span class="line">    df.loc[(df[<span class="string">'质量等级'</span>] == <span class="string">'优'</span>) | (df[<span class="string">'质量等级'</span>] == <span class="string">'良'</span>), <span class="string">'污染'</span>] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 删去无效数据</span></span><br><span class="line">    df = df.drop(df[df[<span class="string">'质量等级'</span>] == <span class="string">'无'</span>].index)</span><br><span class="line">    <span class="comment"># 找污染数字相同的位置</span></span><br><span class="line">    pos, = np.where(np.diff(df[<span class="string">'污染'</span>]))</span><br><span class="line">    <span class="comment"># 定位连续污染和连续无污染的起止点</span></span><br><span class="line">    start, end = np.insert(pos+<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), np.append(pos, len(df)<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># 计算污染状态的持续天数</span></span><br><span class="line">    df2 = pd.DataFrame(&#123;<span class="string">'污染'</span>: df[<span class="string">'污染'</span>][start], <span class="string">'持续天数'</span>: end-start+<span class="number">1</span>&#125;)</span><br><span class="line">    <span class="comment"># 从连续天数的表格中提取是污染的</span></span><br><span class="line">    df3 = df2.loc[df2[<span class="string">'污染'</span>] == <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 连续天数大于5的统一变成5，方便下一步分组统计画图</span></span><br><span class="line">    df3.loc[df3[<span class="string">'持续天数'</span>] &gt; <span class="number">5</span>, <span class="string">'持续天数'</span>] = <span class="number">5</span></span><br><span class="line">    <span class="comment"># 按持续天数分组计数，并将计数结果存为DateFrame</span></span><br><span class="line">    df3 = df3.groupby(df3[<span class="string">'持续天数'</span>]).size().reset_index(name=str(year))</span><br><span class="line">    <span class="comment"># 重置index</span></span><br><span class="line">    df3.set_index(<span class="string">'持续天数'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 转置行列，方便后续合并分组结果和画图</span></span><br><span class="line">    df3 = pd.DataFrame(df3.values.T, index=df3.columns, columns=[<span class="string">'1天'</span>, <span class="string">'2天'</span>, <span class="string">'3天'</span>, <span class="string">'4天'</span>, <span class="string">'5天及以上'</span>])</span><br><span class="line">    <span class="keyword">return</span> df3</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来是画图函数，该函数将合并了所有年份的数据绘制为条形图，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pollution_bar</span><span class="params">(df)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：按处理好的空气污染数据画柱状图</span></span><br><span class="line"><span class="string">    参数：df 处理好的空气污染数据</span></span><br><span class="line"><span class="string">    返回值：无</span></span><br><span class="line"><span class="string">    使用方式：pollution_bar(df_air)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    df.plot.bar()</span><br><span class="line">    plt.title(<span class="string">'2014年至2019年持续污染天数柱状图'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'天数'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'出现次数'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.xticks(rotation=<span class="number">0</span>)</span><br><span class="line">    plt.savefig(<span class="string">'pollution-bar'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后要在主函数中将原始的空气污染数据按年分组，并对分组结果逐一调用<code>process_air_data()</code>，再将得到的持续污染天数的数据合并起来，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">air_group_y = df_air.groupby(df_air.index.year)</span><br><span class="line">df_air_processed = process_air_data(air_group_y.get_group(<span class="number">2014</span>), <span class="number">2014</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2015</span>, <span class="number">2020</span>):</span><br><span class="line">    df_air_processed = pd.concat([df_air_processed, process_air_data(air_group_y.get_group(i), i)])</span><br></pre></td></tr></table></figure>
</li>
<li><p>对处理好的数据调用<code>pollution_bar()</code>绘制条形图，参数是第二题中读取的空气污染数据，完成第四题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pollution_bar(df_air_processed)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><ol>
<li><p>分析题目要求，”<strong>根据当天的天气情况以及前两天的天气及空气质量情况，预测当天的空气质量等级</strong>“，而天气情况包括天气、温度和风力风向，因此需要进行以下处理。</p>
</li>
<li><p>首先将白天和晚上的天气、风力风向和最高最低温度分离出来，这三个数据都是以<code>/</code>为分隔，因此可以用<code>split()</code>来完成。这里要注意，温度数据的最后一位是摄氏度的标记，因此要去掉，只保留前面的数字。</p>
</li>
<li><p>接下来分离风力和风向，这里的规律并不明显，但总体而言可以用<code>风</code>字作为分隔符来提取，并在之后的处理中将相同含义但不同表示的字符串合并起来。</p>
</li>
<li><p>天气、风力和风向的数据都是字符串，而其它数据则是数字，由于<code>scikit</code>处理的数据都是数字，因此这里需要对字符串进行特征提取和编码，最初我尝试用<code>DictVectorizer</code>来做，但是这样出来的矩阵略大，而结果准确率也略低，因此决定在这里直接用字典和<code>mapping()</code>将字符串转数字。需要注意的是，在这里我把<code>西南偏南</code>和<code>西南</code>算作同一类，用相同的数字表示。另一方面，上一步中分离出的风力数据，如<code>向≤3级</code>、<code>&lt;3级</code>、<code>1-2级</code>等这些显然是同一个含义的也算作一类，用相同的数字表示。</p>
</li>
<li><p>由于天气种类很多，而其中有一些属于同一类，如果不合并相同类别的数据，会对之后的模型训练造成影响，因此按第三题的方法将所有天气统一，并转为数字表示。</p>
</li>
<li><p>质量等级也是字符串，因此采用同样的方法进行转换。转换结束后，原本的天气、风力风向等等数据就可以删除了。</p>
</li>
<li><p>由于预测还用到了前两天的天气和空气质量情况，因此要把前两天的数据逐一增加到当天数据中，作为新的一列保存，之后要删除无效数据。</p>
</li>
<li><p>由于预测时并没有用到当天的空气质量情况，因此要把当天的空气质量数据都删除，只保留空气质量等级这一列作为训练模型的<code>target</code>。</p>
</li>
<li><p>至此，所有数据已经转为数字类型，并剔除不需要的数据，接下来需要进行标准化，并返回标准化之后的数组，该数组第一列是<code>target</code>，剩下数据是训练用数据。上述数据处理过程为如下函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_predict_data</span><span class="params">(df)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：处理天气和空气数据，方便后续训练</span></span><br><span class="line"><span class="string">    参数：df 初始合并好的天气+空气数据</span></span><br><span class="line"><span class="string">    返回值：df 处理好的数据</span></span><br><span class="line"><span class="string">    使用方式：predict_array = process_predict_data(df)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 划分天气、风力、风向和温度</span></span><br><span class="line">    df[<span class="string">'白天天气'</span>] = df[<span class="string">'天气'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'/'</span>)[<span class="number">0</span>])</span><br><span class="line">    df[<span class="string">'夜晚天气'</span>] = df[<span class="string">'天气'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'/'</span>)[<span class="number">1</span>])</span><br><span class="line">    df[<span class="string">'白天风力风向'</span>] = df[<span class="string">'风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'/'</span>)[<span class="number">0</span>])</span><br><span class="line">    df[<span class="string">'夜晚风力风向'</span>] = df[<span class="string">'风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'/'</span>)[<span class="number">1</span>])</span><br><span class="line">    df[<span class="string">'最高温度'</span>] = df[<span class="string">'温度'</span>].map(<span class="keyword">lambda</span> x: int(x.split(<span class="string">'/'</span>)[<span class="number">0</span>][:<span class="number">-1</span>]))</span><br><span class="line">    df[<span class="string">'最低温度'</span>] = df[<span class="string">'温度'</span>].map(<span class="keyword">lambda</span> x: int(x.split(<span class="string">'/'</span>)[<span class="number">1</span>][:<span class="number">-1</span>]))</span><br><span class="line">    df[<span class="string">'白天风力'</span>] = df[<span class="string">'白天风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'风'</span>)[<span class="number">0</span>])</span><br><span class="line">    df[<span class="string">'白天风向'</span>] = df[<span class="string">'白天风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'风'</span>)[<span class="number">1</span>])</span><br><span class="line">    df[<span class="string">'夜晚风力'</span>] = df[<span class="string">'夜晚风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'风'</span>)[<span class="number">0</span>])</span><br><span class="line">    df[<span class="string">'夜晚风向'</span>] = df[<span class="string">'夜晚风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'风'</span>)[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 风向转数字</span></span><br><span class="line">    wind_map_1 = &#123;<span class="string">'无持续'</span>: <span class="number">0</span>, <span class="string">'东'</span>: <span class="number">1</span>, <span class="string">'南'</span>: <span class="number">2</span>, <span class="string">'西'</span>: <span class="number">3</span>, <span class="string">'北'</span>: <span class="number">4</span>, <span class="string">'东北'</span>: <span class="number">5</span>, <span class="string">'东南'</span>: <span class="number">6</span>, <span class="string">'西北'</span>: <span class="number">7</span>, <span class="string">'西南'</span>: <span class="number">8</span>, <span class="string">'西南偏南'</span>: <span class="number">8</span>&#125;</span><br><span class="line">    df[<span class="string">'白天风力'</span>] = df[<span class="string">'白天风力'</span>].map(wind_map_1)</span><br><span class="line">    df[<span class="string">'夜晚风力'</span>] = df[<span class="string">'夜晚风力'</span>].map(wind_map_1)</span><br><span class="line">    <span class="comment"># 风力转数字</span></span><br><span class="line">    wind_map_2 = &#123;<span class="string">'向≤3级'</span>: <span class="number">0</span>, <span class="string">'&lt;3级'</span>: <span class="number">0</span>, <span class="string">'1-2级'</span>: <span class="number">0</span>, <span class="string">'≤3级'</span>: <span class="number">0</span>, <span class="string">'向&lt;3级'</span>: <span class="number">0</span>, <span class="string">'向3-4级'</span>: <span class="number">1</span>, <span class="string">'3-4级'</span>: <span class="number">1</span>, <span class="string">'3～4级'</span>: <span class="number">1</span>, <span class="string">'3～4级'</span>: <span class="number">1</span>, <span class="string">'4'</span>: <span class="number">1</span>, <span class="string">'4-5级'</span>: <span class="number">1</span>, <span class="string">'4～5级'</span>: <span class="number">1</span>, <span class="string">'5～6级'</span>: <span class="number">2</span>, <span class="string">'5-6级'</span>: <span class="number">2</span>, <span class="string">'6-7级'</span>: <span class="number">2</span>&#125;</span><br><span class="line">    df[<span class="string">'白天风向'</span>] = df[<span class="string">'白天风向'</span>].map(wind_map_2)</span><br><span class="line">    df[<span class="string">'夜晚风向'</span>] = df[<span class="string">'夜晚风向'</span>].map(wind_map_2)</span><br><span class="line">    <span class="comment"># 删去不需要的列</span></span><br><span class="line">    df = df.drop(<span class="string">'天气'</span>, axis=<span class="number">1</span>).drop(<span class="string">'温度'</span>, axis=<span class="number">1</span>).drop(<span class="string">'风力风向'</span>, axis=<span class="number">1</span>).drop(<span class="string">'白天风力风向'</span>, axis=<span class="number">1</span>).drop(<span class="string">'夜晚风力风向'</span>, axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 删去无效数据</span></span><br><span class="line">    df = df.drop(df[df[<span class="string">'质量等级'</span>] == <span class="string">'无'</span>].index)</span><br><span class="line">    <span class="comment"># 统一雨天数据</span></span><br><span class="line">    df.loc[(df[<span class="string">'白天天气'</span>] == <span class="string">'小雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'中雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'大雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'暴雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'阵雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'小到中雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'中到大雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'雷阵雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'雨夹雪'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雨'</span></span><br><span class="line">    df.loc[(df[<span class="string">'夜晚天气'</span>] == <span class="string">'小雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'中雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'大雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'暴雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'阵雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'小到中雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'中到大雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'大到暴雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'雷阵雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'雨夹雪'</span>), <span class="string">'夜晚天气'</span>] = <span class="string">'雨'</span></span><br><span class="line">    <span class="comment"># 统一雪天数据</span></span><br><span class="line">    df.loc[(df[<span class="string">'白天天气'</span>] == <span class="string">'小雪'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'中雪'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'大雪'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'小到中雪'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'中到大雪'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雪'</span></span><br><span class="line">    df.loc[(df[<span class="string">'夜晚天气'</span>] == <span class="string">'小雪'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'中雪'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'大雪'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'小到中雪'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'中到大雪'</span>), <span class="string">'夜晚天气'</span>] = <span class="string">'雪'</span></span><br><span class="line">    <span class="comment"># 统一扬沙天气</span></span><br><span class="line">    df.loc[df[<span class="string">'白天天气'</span>] == <span class="string">'浮尘'</span>, <span class="string">'白天天气'</span>] = <span class="string">'扬沙'</span></span><br><span class="line">    df.loc[df[<span class="string">'夜晚天气'</span>] == <span class="string">'浮尘'</span>, <span class="string">'夜晚天气'</span>] = <span class="string">'扬沙'</span></span><br><span class="line">    <span class="comment"># 统一雾霾天气</span></span><br><span class="line">    df.loc[(df[<span class="string">'白天天气'</span>] == <span class="string">'雾'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'霾'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雾霾'</span></span><br><span class="line">    df.loc[(df[<span class="string">'夜晚天气'</span>] == <span class="string">'雾'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'霾'</span>), <span class="string">'夜晚天气'</span>] = <span class="string">'雾霾'</span></span><br><span class="line">    <span class="comment"># 质量等级转数字</span></span><br><span class="line">    quality_mapping = &#123;<span class="string">'优'</span>: <span class="number">0</span>, <span class="string">'良'</span>: <span class="number">1</span>, <span class="string">'轻度污染'</span>: <span class="number">2</span>, <span class="string">'中度污染'</span>: <span class="number">3</span>, <span class="string">'重度污染'</span>: <span class="number">4</span>, <span class="string">'严重污染'</span>: <span class="number">5</span>&#125;</span><br><span class="line">    df[<span class="string">'质量等级'</span>] = df[<span class="string">'质量等级'</span>].map(quality_mapping)</span><br><span class="line">    <span class="comment"># 天气转数字</span></span><br><span class="line">    weather_mapping = &#123;<span class="string">'晴'</span>: <span class="number">0</span>, <span class="string">'雨'</span>: <span class="number">1</span>, <span class="string">'阴'</span>: <span class="number">2</span>, <span class="string">'雪'</span>: <span class="number">3</span>, <span class="string">'多云'</span>: <span class="number">4</span>, <span class="string">'雾霾'</span>: <span class="number">5</span>, <span class="string">'扬沙'</span>: <span class="number">6</span>&#125;</span><br><span class="line">    df[<span class="string">'白天天气'</span>] = df[<span class="string">'白天天气'</span>].map(weather_mapping)</span><br><span class="line">    df[<span class="string">'夜晚天气'</span>] = df[<span class="string">'夜晚天气'</span>].map(weather_mapping)</span><br><span class="line">    <span class="comment"># 增加昨天和前天的数据</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(df)<span class="number">-2</span>):</span><br><span class="line">        df.ix[i+<span class="number">2</span>, <span class="string">'昨天AQI'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天质量等级'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天PM2.5'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天PM10'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天SO2'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天CO'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天NO2'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天O3_8h'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天白天天气'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天夜晚天气'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天白天风力'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天夜晚风力'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天白天风向'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天夜晚风向'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天最高温度'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天最低温度'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天AQI'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天质量等级'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天PM2.5'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天PM10'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天SO2'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天CO'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天NO2'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天O3_8h'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天白天天气'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天夜晚天气'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天白天风力'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天夜晚风力'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天白天风向'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天夜晚风向'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天最高温度'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天最低温度'</span>] = df.ix[i+<span class="number">1</span>, <span class="string">'AQI'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'质量等级'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'PM2.5'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'PM10'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'SO2'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'CO'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'NO2'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'O3_8h'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'白天天气'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'夜晚天气'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'白天风力'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'夜晚风力'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'白天风向'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'夜晚风向'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'最高温度'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'最低温度'</span>], df.ix[i, <span class="string">'AQI'</span>], df.ix[i, <span class="string">'质量等级'</span>], df.ix[i, <span class="string">'PM2.5'</span>], df.ix[i, <span class="string">'PM10'</span>], df.ix[i, <span class="string">'SO2'</span>], df.ix[i, <span class="string">'CO'</span>], df.ix[i, <span class="string">'NO2'</span>], df.ix[i, <span class="string">'O3_8h'</span>], df.ix[i, <span class="string">'白天天气'</span>], df.ix[i, <span class="string">'夜晚天气'</span>], df.ix[i, <span class="string">'白天风力'</span>], df.ix[i, <span class="string">'夜晚风力'</span>], df.ix[i, <span class="string">'白天风向'</span>], df.ix[i, <span class="string">'夜晚风向'</span>], df.ix[i, <span class="string">'最高温度'</span>], df.ix[i, <span class="string">'最低温度'</span>]</span><br><span class="line">    <span class="comment"># 删除无效数据</span></span><br><span class="line">    df = df.dropna(how=<span class="string">'any'</span>)</span><br><span class="line">    <span class="comment"># 删除今天空气数据</span></span><br><span class="line">    df = df.drop(<span class="string">'AQI'</span>, axis=<span class="number">1</span>).drop(<span class="string">'PM2.5'</span>, axis=<span class="number">1</span>).drop(<span class="string">'PM10'</span>, axis=<span class="number">1</span>).drop(</span><br><span class="line">        <span class="string">'SO2'</span>, axis=<span class="number">1</span>).drop(<span class="string">'CO'</span>, axis=<span class="number">1</span>).drop(<span class="string">'NO2'</span>, axis=<span class="number">1</span>).drop(<span class="string">'O3_8h'</span>, axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 数据标准化</span></span><br><span class="line">    ss = StandardScaler()</span><br><span class="line">    predict_array = ss.fit_transform(df)</span><br><span class="line">    <span class="keyword">return</span> predict_array</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理好数据后，就可以开始训练模型。首先用<code>train_test_split()</code>划分训练集和测试集。</p>
</li>
<li><p>接下来建立一个算法列表，该列表包含了几个不同的分类器。</p>
</li>
<li><p>对每一个分类器，用K折交叉判断其在训练集的准确率并输出。</p>
</li>
<li><p>根据输出结果选择最优分类器，测试其在测试集上的性能并输出。</p>
</li>
<li><p>在这里经过对比，选择了LDA分类器。整体训练过程如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_air</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：训练和测试模型</span></span><br><span class="line"><span class="string">    参数：array 处理好的数据集</span></span><br><span class="line"><span class="string">    返回值：无</span></span><br><span class="line"><span class="string">    使用方式：predict_air(array)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 划分训练集和测试集</span></span><br><span class="line">    x = array[:, <span class="number">1</span>:]</span><br><span class="line">    y = array[:, <span class="number">0</span>]</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(</span><br><span class="line">        x, y, test_size=<span class="number">0.7</span>, random_state=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 把备选算法放入列表</span></span><br><span class="line">    models = []</span><br><span class="line">    models.append((<span class="string">'LR'</span>, LogisticRegression(</span><br><span class="line">        solver=<span class="string">'liblinear'</span>, multi_class=<span class="string">'ovr'</span>)))</span><br><span class="line">    models.append((<span class="string">'LDA'</span>, LinearDiscriminantAnalysis()))</span><br><span class="line">    models.append((<span class="string">'KNN'</span>, KNeighborsClassifier()))</span><br><span class="line">    models.append((<span class="string">'CART'</span>, DecisionTreeClassifier()))</span><br><span class="line">    models.append((<span class="string">'NB'</span>, GaussianNB()))</span><br><span class="line">    models.append((<span class="string">'SVM'</span>, SVC(gamma=<span class="string">'auto'</span>)))</span><br><span class="line">    <span class="comment"># 用训练集训练每个模型并评价</span></span><br><span class="line">    results = []</span><br><span class="line">    names = []</span><br><span class="line">    <span class="keyword">for</span> name, model <span class="keyword">in</span> models:</span><br><span class="line">        kfold = StratifiedKFold(n_splits=<span class="number">10</span>, random_state=<span class="number">1</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">        cv_results = cross_val_score(model, x_train, y_train.astype(</span><br><span class="line">            <span class="string">'int'</span>), cv=kfold, scoring=<span class="string">'accuracy'</span>)</span><br><span class="line">        results.append(cv_results)</span><br><span class="line">        names.append(name)</span><br><span class="line">        print(<span class="string">'%s: %f (%f)'</span> % (name, cv_results.mean(), cv_results.std()))</span><br><span class="line">    <span class="comment"># 从上面的输出可知lda准确率最高，因此训练lad模型并输出测试集的准确率</span></span><br><span class="line">    lda = LinearDiscriminantAnalysis()</span><br><span class="line">    lda.fit(x_train, y_train.astype(<span class="string">'int'</span>))</span><br><span class="line">    print(lda.score(x_test, y_test.astype(<span class="string">'int'</span>)))</span><br></pre></td></tr></table></figure>
</li>
<li><p>在主函数中先后调用<code>process_predict_data()</code>和<code>predict_air()</code>，在已知某天天气情况和前两天的天气及空气情况时，也可以调用该模型来预测当天空气质量。完成第五题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">predict = process_predict_data(df_merge)</span><br><span class="line">predict_air(predict)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>好了我终于写完了，这个空气质量预测根本就靠不住，一开始只有准确率只有0.3，用很麻烦的方法处理数据之后才达到现在的0.7。啊写实验报告好累，我总算不用再上课了。希望分数能好点。</p>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode的一系列配置</title>
    <url>/2020/06/06/vscode%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>前段时间忽然开始用vscode，今天配置好了C和C++，现在决定整理一下配置过程。</p>
<a id="more"></a>
<h2 id="安装和外观"><a href="#安装和外观" class="headerlink" title="安装和外观"></a>安装和外观</h2><ol>
<li><p><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VSCode官网</a>下载和安装，这部分应该不会有问题，注意最后添加到path的选项要勾选，不然就要自己去配置环境变量；</p>
</li>
<li><p>中文设置：打开扩展（左边那一列按钮最下面的，默认快捷键是<code>ctrl+shift+x</code>，找一个叫Chinese (Simplified) Language Pack for Visual Studio Code的扩展，安装完成以后重启vscode，界面就变成中文了。如果没变，就按<code>ctrl+shift+p</code>，在出现的框里输入configure display language，然后下拉菜单里选zh-cn就可以了。</p>
</li>
<li><p>主题和图标：在扩展里找喜欢的就可以，据推荐vscode-icons比较好看，我也没研究其他图标。</p>
</li>
<li><p>背景：扩展里找background这个插件（名字就是这个单词），安装以后需要设置一下</p>
<ol>
<li><p><code>文件—&gt;首选项—&gt;设置—&gt;扩展—&gt;Plugin background config.background插件配置</code></p>
</li>
<li><p>打开这个界面以后，有一行字<code>在settings.json中编辑</code>，点一下可以打开settings.json（实际上在其他扩展里也能找到这行字，总之打开settings.json就行）</p>
</li>
<li><p>如果之前什么扩展也没装，也没搞别的配置，那这个文件打开以后应该是只有两行花括号(<code>{}</code>)的，如果之前装了别的，那花括号中间可能会有几行内容，接下来在花括号里面输入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;background.enabled&quot;: true,</span><br><span class="line">   &quot;background.useDefault&quot;: false,</span><br><span class="line">   &quot;background.customImages&quot;:[&quot;file:&#x2F;&#x2F;&#x2F;C:&#x2F;Users&#x2F;LiKun&#x2F;Pictures&#x2F;background.png&quot;],</span><br><span class="line">   &quot;background.style&quot;:&#123;</span><br><span class="line">       &quot;content&quot;:&quot;&#39;&#39;&quot;,</span><br><span class="line">       &quot;pointer-events&quot;:&quot;none&quot;,</span><br><span class="line">       &quot;position&quot;:&quot;absolute&quot;,&#x2F;&#x2F;图片位置</span><br><span class="line">       &quot;width&quot;:&quot;99%&quot;,</span><br><span class="line">       &quot;height&quot;:&quot;99%&quot;,</span><br><span class="line">       &quot;z-index&quot;:&quot;99999&quot;,</span><br><span class="line">       &quot;background.repeat&quot;:&quot;no-repeat&quot;,</span><br><span class="line">       &quot;background-size&quot;:&quot;25%,25%&quot;,&#x2F;&#x2F;图片大小</span><br><span class="line">       &quot;opacity&quot;:0.3 &#x2F;&#x2F;透明度</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>
<p>注意：每一行最后的逗号不要忘了，背景图的路径改成自己的图，我这个设置是背景图出现在右下角的位置，如果有其他需求自己改就行。</p>
</li>
</ol>
</li>
</ol>
<h2 id="latex"><a href="#latex" class="headerlink" title="latex"></a>latex</h2><ol>
<li><p>安装texlive，因为我之前安装过texstudio所以就没再装了，这里要记得环境变量的问题，正常来说安装的时候会自动添加，如果没勾选那就要自己配置；</p>
</li>
<li><p>vscode的扩展里找latex workshop安装，据说安装好就能编译tex文件并生成pdf，不过我还搞了乱七八糟的设置才可以；</p>
</li>
<li><p>设置过程还是打开setting.json，直接输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;latex-workshop.latex.recipes&quot;: [</span><br><span class="line">     &#123;</span><br><span class="line">       &quot;name&quot;: &quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;,</span><br><span class="line">       &quot;tools&quot;: [</span><br><span class="line">         &quot;xelatex&quot;,</span><br><span class="line">         &quot;bibtex&quot;,</span><br><span class="line">         &quot;xelatex&quot;,</span><br><span class="line">         &quot;xelatex&quot;</span><br><span class="line">       ]</span><br><span class="line">     &#125;</span><br><span class="line">   ],</span><br><span class="line">   &quot;latex-workshop.latex.tools&quot;: [</span><br><span class="line">     &#123;</span><br><span class="line">       &quot;name&quot;: &quot;xelatex&quot;,</span><br><span class="line">       &quot;command&quot;: &quot;xelatex&quot;,</span><br><span class="line">       &quot;args&quot;: [</span><br><span class="line">         &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">         &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">         &quot;-file-line-error&quot;,</span><br><span class="line">         &quot;%DOC%&quot;</span><br><span class="line">       ]</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       &quot;name&quot;: &quot;latexmk&quot;,</span><br><span class="line">       &quot;command&quot;: &quot;latexmk&quot;,</span><br><span class="line">       &quot;args&quot;: [</span><br><span class="line">         &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">         &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">         &quot;-file-line-error&quot;,</span><br><span class="line">         &quot;%DOC%&quot;</span><br><span class="line">       ]</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       &quot;name&quot;: &quot;pdflatex&quot;,</span><br><span class="line">       &quot;command&quot;: &quot;pdflatex&quot;,</span><br><span class="line">       &quot;args&quot;: [</span><br><span class="line">         &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">         &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">         &quot;-file-line-error&quot;,</span><br><span class="line">         &quot;%DOC%&quot;</span><br><span class="line">       ]</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       &quot;name&quot;: &quot;bibtex&quot;,</span><br><span class="line">       &quot;command&quot;: &quot;bibtex&quot;,</span><br><span class="line">       &quot;args&quot;: [</span><br><span class="line">         &quot;%DOCFILE%&quot;</span><br><span class="line">       ]</span><br><span class="line">     &#125;</span><br><span class="line">   ],</span><br><span class="line">   &quot;latex-workshop.view.pdf.viewer&quot;: &quot;tab&quot;,</span><br><span class="line">   &quot;editor.wordWrap&quot;: &quot;on&quot;,</span><br><span class="line">   &quot;latex-workshop.synctex.afterBuild.enabled&quot;: true,</span><br><span class="line">   &quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;: &quot;double-click&quot;,</span><br><span class="line">   &quot;[latex]&quot;: &#123;</span><br><span class="line">     &quot;editor.defaultFormatter&quot;: &quot;nickfode.latex-formatter&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;latex-workshop.latex.autoClean.run&quot;: &quot;onBuilt&quot;,</span><br></pre></td></tr></table></figure>
<p>注意：这个文件最外层就一组花括号，不管有多少要设置的东西都在里面加；latex的内容里有一些是在那个设置里可以直接选的，而不是通过这种让人看不懂的代码来设置，例如<code>&quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;: &quot;double-click&quot;</code>这一句的作用是在pdf里双击可以跳转到latex源文件对应的位置，本来默认的是ctrl点击，但是我习惯双击，可以在设置里搜synctex:keybinding然后修改，改了会自动在settings.json 里出现那句话；<code>&quot;editor.wordWrap&quot;: &quot;on&quot;</code>是和latex本身无关的设置，是让编辑器可以自动换行；其他各种设置可以自行百度。</p>
</li>
</ol>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><ol>
<li>扩展里搜python，安装跳出来的第一个就行；</li>
<li>可能和我之前已经安装过python、pycharm等等东西有关，安装插件之后就能编译运行python了。</li>
</ol>
<h2 id="C和C"><a href="#C和C" class="headerlink" title="C和C++"></a>C和C++</h2><ol>
<li>安装mingw，如果之前装过就不必重装了，这里要自己添加环境变量，然后检查有没有装好；</li>
<li>vscode里安装C/C++扩展，可能装好要重启；</li>
<li>打开要写代码的那个文件夹，比如C++文件夹，里面新建一个cpp文件随便写几行；</li>
<li><code>Ctrl+Shift+P</code>输入C/C++，选择“Edit Configurations(UI)”进入配置，这里要选编译器：<code>C:/Program Files/mingw-w64/x86_64-8.1.0-posix-seh-rt_v6-rev0/mingw64/bin/g++.exe</code>，路径改成自己的，还要选IntelliSense 模式，要用gcc-x64；</li>
<li>上一步做好以后，可以看到C++文件夹里多出一个.vscode文件夹，里面有c_cpp_properties.json文件，文件内容是写好的，可以看看，不过不需要修改；</li>
<li>再按<code>Ctrl+Shift+P</code>输入tasks，选择“Tasks:Configure Default Build Task”，再选择“C/C++: g++.exe build active file”，然后.vscode文件夹里就会出现tasks.json，也是写好的，不需要改；</li>
<li>接下来点运行—&gt;启动调试，或者直接按F5，选择C++(GDB/LLDB)，会出现一个launch.json，或者左边那列扩展按钮上面的那个按钮里有个创建launch.json也可以；</li>
<li>上一步的launch.json里可以自己根据需求添加一些配置，或者去网上复制别人的配置，总之我这里是什么也没改就能直接运行；</li>
<li>然后再按F5，就可以运行文件了；</li>
<li>在第4步之后，就可以在vscode里找到终端然后gcc编译运行文件；</li>
<li>默认运行输出信息是在下面的终端，在launch.json里找到”externalConsole”然后把它的false改成true,就可以出现独立的命令行界面来显示信息了。</li>
</ol>
<h2 id="KanBan"><a href="#KanBan" class="headerlink" title="KanBan"></a>KanBan</h2><ol>
<li><p>是最近发现的很好用的一个项目管理方式；</p>
</li>
<li><p>在扩展里搜KanBan，出来的第一个就是它，然后安装；</p>
</li>
<li><p>在扩展说明那里能看到很多可以配置的，我的配置如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">"kanban": </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">&lt;!--配置四个列的名称，因为原本的名称不符合我的需求，所以这么改了--&gt;</span></span><br><span class="line">        "columns": &#123;</span><br><span class="line">          "done": "Others",</span><br><span class="line">          "inProgress": "In Progress",</span><br><span class="line">          "testing": "Done",</span><br><span class="line">          "todo": "TODOs"</span><br><span class="line">        &#125;,</span><br><span class="line">        "openOnStartup": true,   <span class="comment">&lt;!--每次打开vscode的时候，自动打开KanBan标签页--&gt;</span></span><br><span class="line">        "trackTime": true    <span class="comment">&lt;!--打开计时功能，如果在干活前后各点一下，就会记录干了多久--&gt;</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>在搞好以后发现，KanBan文件是存放在项目文件夹的<code>.vscode</code>中，名称是<code>vscode-kanban.json</code>，打开可以看到具体内容。打开不同文件夹时，KanBan文件都是新的，如果想保持同步，就得把最新的文件复制到其他文件夹里，这有点麻烦，所以对着说明文档分析了一下，猜测可以改扩展的源代码里的文件。</p>
</li>
<li><p>具体来说，是找到用户目录里的vscode文件夹中的KanBan文件夹，文件夹名字可能和版本号等有关，比如我的是<code>C:\Users\LiKun\.vscode\extensions\mkloubert.vscode-kanban-1.28.0\</code>，里面有一个<code>out</code>文件夹，打开会发现一些<code>js</code>文件，这些文件都可以按需求改，我需要改的是<code>workspace.js</code>。</p>
</li>
<li><p>打开<code>workspace.js</code>，在一开始定义常量的地方有一个<code>const BOARD_FILENAME</code>，把它的值改成我打算固定存KanBan的绝对路径，例如：<code>const BOARD_FILENAME = &#39;C:/code/.vscode/vscode-kanban.json&#39;;</code></p>
</li>
<li><p>改了之后如果直接保存并在vscode里运行，会提示路径不对，看报错信息是因为程序把上面那个路径和项目文件夹的路径直接拼起来了，显然有问题。回到<code>workspace.js</code>，往下没几行就能看到一个<code>get boardFile()</code>函数，函数内容就是把路径拼起来并作为新路径返回，那么在这里，把拼路径的去掉，直接返回<code>BOARD_FILENAME</code>就可以了，修改之后这个函数如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span> boardFile() &#123;</span><br><span class="line">        <span class="keyword">return</span> vscode.Uri.file(Path.resolve(BOARD_FILENAME));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意这个文件夹里其他东西不能乱改。</p>
</li>
<li><p>到此为止就可以实现所有项目文件共享同一个KanBan了，不过每次更新了以后需要重新改js文件。</p>
</li>
<li><p>用了一段时间发现因为css文件里已经写好了每个模块的功能和交互，所以像我那样改每一块的名字用起来效果不太好，想了想还是改回去了，以后研究一下css文件再改。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>编辑器配置</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-13</title>
    <url>/2020/05/26/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-13/</url>
    <content><![CDATA[<p>这一课讲scipy库。</p>
<p><code>from scipy import some_module</code></p>
<p><code>from scipy.some_module import some_function</code></p>
<a id="more"></a>
<h2 id="linalg模块的使用"><a href="#linalg模块的使用" class="headerlink" title="linalg模块的使用"></a>linalg模块的使用</h2><ol>
<li><p>基本线性代数操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="comment"># 计算矩阵的行列式</span></span><br><span class="line">linalg.det(arr)				</span><br><span class="line"><span class="comment"># output: -2.0</span></span><br><span class="line"><span class="comment"># 计算特征值和特征向量</span></span><br><span class="line">linalg.eig(arr)</span><br><span class="line"><span class="comment"># output: (array([-0.37228132+0.j,  5.37228132+0.j]), array([[-0.82456484, -0.41597356], [ 0.56576746, -0.90937671]]))</span></span><br><span class="line"><span class="comment"># 矩阵求逆</span></span><br><span class="line">linalg.inv(arr)</span><br><span class="line"><span class="comment"># output: array([[-2. ,  1. ], [ 1.5, -0.5]])</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解线性方程组：$Ax=b$，其中A是方阵：<code>solve(A, b)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line">m = <span class="number">500</span></span><br><span class="line">A=np.random.rand(m,m)</span><br><span class="line">b=np.random.rand(m)</span><br><span class="line">x1=linalg.solve(A,b)</span><br><span class="line">x2=np.dot(linalg.inv(A),b)</span><br><span class="line">print(np.allclose(x1,x2))</span><br></pre></td></tr></table></figure>
</li>
<li><p>更一般的线性方程组：$Ax=b$，其中A不是方阵：<code>lstsq(A,q)</code>找最小二乘解</p>
<p>例如：给定四个点<code>(1,6) (2,5) (3,7) (4,10)</code>，找拟合直线<code>y=ax+b</code> 这样的问题可以转化为：矩阵<code>A=[[1,2],[2,1],[3,1],[4,1]]</code> ，<code>b=[6, 5, 7, 10]^T</code>，<code>x=[a,b]^T</code>，求解<code>Ax=b</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line">A = np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">1</span>]])</span><br><span class="line">y = np.array([<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10</span>])</span><br><span class="line">c,resid,rank,sigma=linalg.lstsq(A,y)</span><br><span class="line">print(c, resid, rank, sigma)</span><br><span class="line"><span class="comment"># [1.4 3.5] 4.200000000000003 2 [5.77937881 0.77380911]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其他功能：</p>
<ol>
<li>范数求解: <code>linalg.norm</code></li>
<li>广义逆求解: <code>linalg.pinv, linalg.pinv2</code></li>
<li>矩阵分解：<code>linalg.sva, linalg.lu, linalg.qr</code></li>
</ol>
</li>
</ol>
<h2 id="optimize模块的使用"><a href="#optimize模块的使用" class="headerlink" title="optimize模块的使用"></a>optimize模块的使用</h2><ol>
<li><p>求解带约束条件的函数最小值：<code>minimize(fun, x0[,args, method, jac, hess, bounds, constrains])</code></p>
<ol>
<li><p>fun是目标函数 </p>
</li>
<li><p>x0是初始解 </p>
</li>
<li><p>args：需要传递给fun, jac, hess函数的额外的参数 </p>
</li>
<li><p>method是所选方法：Newton-CG、CG、SLSQP、Nelder-Mead…… </p>
</li>
<li><p>jac: Jacobian矩阵，有些方法需要给出 </p>
</li>
<li><p>hess: Hessian矩阵，有些方法需要给出 </p>
</li>
<li><p>bounds是解的约束范围， L-BFGS-B,TNC,SLSQP,trust-constr支持 </p>
</li>
<li><p>constrains是约束条件，COBYLA, SLSQP, trust-constr支持</p>
<p>例如：$min x1+x2+x3$</p>
<p>$s.t. x_1x_2x_3&gt;25$</p>
<p>​      $x_1^2+x_2^2+x_3^2=40$</p>
<p>​     $1&lt;=x_1, x_2&lt;=5$     $x_3&gt;=4$</p>
<p>$x_0=(3,3,4)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">objective</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constr1</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>]*x[<span class="number">1</span>]*x[<span class="number">2</span>]<span class="number">-25</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constr2</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(x**<span class="number">2</span>)<span class="number">-40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jac</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">bnds=((<span class="number">1</span>,<span class="number">5</span>),(<span class="number">1</span>,<span class="number">5</span>),(<span class="number">4</span>,<span class="literal">None</span>))</span><br><span class="line">cons1=&#123;<span class="string">'type'</span>:<span class="string">'ineq'</span>,<span class="string">'fun'</span>:constr1&#125;</span><br><span class="line">cons2=&#123;<span class="string">'type'</span>:<span class="string">'eq'</span>,<span class="string">'fun'</span>:constr2&#125;</span><br><span class="line">cons=[cons1, cons2]</span><br><span class="line">result=minimize(objective,[<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],method=<span class="string">'SLSQP'</span>,jac=jac,bounds=bnds,constraints=cons)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">#     fun: 9.807034491627501</span></span><br><span class="line"><span class="comment">#     jac: array([1., 1., 1.])</span></span><br><span class="line"><span class="comment"># message: 'Optimization terminated successfully.'</span></span><br><span class="line"><span class="comment">#    nfev: 7</span></span><br><span class="line"><span class="comment">#     nit: 7</span></span><br><span class="line"><span class="comment">#    njev: 7</span></span><br><span class="line"><span class="comment">#  status: 0</span></span><br><span class="line"><span class="comment"># success: True</span></span><br><span class="line"><span class="comment">#       x: array([2.11859914, 2.11859914, 5.5698362 ])</span></span><br><span class="line"><span class="comment"># result.fun可输出最小值，result.x可输出对应的x解</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>minimize是局部最优，basinhopping、shgo等可以求解全局最优</p>
</li>
<li><p>求解非线性方程：<code>root(fun, x0[, args, method, jac])</code></p>
<ol>
<li><p>fun是要求根的方程（组） </p>
</li>
<li><p>x0是初始猜测解 </p>
</li>
<li><p>args是fun以及jac中额外的参数 </p>
</li>
<li><p>method是所选方法： hybr, lm, broyden1/2, anderson, linearmixing, krylov, df-sane 等 </p>
</li>
<li><p>jac: Jacobian矩阵</p>
<p>例如：求解 $f(x)=2x^2+3x-10$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> root</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*x**<span class="number">2</span>+<span class="number">3</span>*x<span class="number">-10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jac</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>*x+<span class="number">3</span></span><br><span class="line"></span><br><span class="line">x=np.linspace(<span class="number">-5</span>,<span class="number">3</span>)</span><br><span class="line">plt.plot(x,func(x))</span><br><span class="line">plt.plot(x,np.zeros(len(x)))</span><br><span class="line"></span><br><span class="line">result1=root(func,<span class="number">-3</span>,method=<span class="string">'hybr'</span>,jac=jac)</span><br><span class="line">result2=root(func,<span class="number">1</span>,method=<span class="string">'lm'</span>,jac=jac)</span><br><span class="line"></span><br><span class="line">print(result1.fun,result2.fun)</span><br><span class="line">print(result1.x, result2.x)</span><br><span class="line"><span class="comment"># [-1.77635684e-15] [0.]</span></span><br><span class="line"><span class="comment"># [-3.10849528] [1.60849528]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>求解非线性方程组：和前面一样，把给定的目标函数和雅可比矩阵写成函数然后运算。</p>
</li>
</ol>
<h2 id="integrate模块的使用"><a href="#integrate模块的使用" class="headerlink" title="integrate模块的使用"></a>integrate模块的使用</h2><ol>
<li><p>根据函数求解积分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> integrate</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">half_circle</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>-x**<span class="number">2</span>)**<span class="number">0.5</span></span><br><span class="line">result = integrate.quad(half_circle, <span class="number">-1</span>, <span class="number">1</span>)	<span class="comment">#积分函数和积分上下限</span></span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># quad是一重积分，dblquad()和tplquad()分别是二重和三重积分</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>根据样本求解积分：分布均匀用<code>romb</code>，不均匀用<code>trapz(order 1), simple(order 2)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.integrate <span class="keyword">import</span> simps</span><br><span class="line">x=np.array([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">y=np.array([<span class="number">1</span>,<span class="number">9</span>,<span class="number">16</span>])</span><br><span class="line">result=simps(y1,x)</span><br><span class="line">print(result)	<span class="comment"># 21.0</span></span><br><span class="line"><span class="comment"># 相当于计算x的2次方在1到4的定积分</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>求解常微分方程：<code>odeint(func, y0, t, args=())</code></p>
<ol>
<li><p>func: 计算微分方程组中每个未知函数的一阶导数值</p>
</li>
<li><p>y0：微分方程组中每个未知函数的初始值</p>
</li>
<li><p>t：需要进行数值求解的时间点 （数值解）</p>
</li>
<li><p>args：计算导数时的其他参数</p>
<p>求解方程以后还可以画好看的函数图像。</p>
<p>这个涉及的数学知识略多，暂时也不用，就先不看例子了</p>
</li>
</ol>
</li>
</ol>
<h2 id="interpolate模块的使用"><a href="#interpolate模块的使用" class="headerlink" title="interpolate模块的使用"></a>interpolate模块的使用</h2><ol>
<li><p>插值：</p>
<ol>
<li>一/二维插值：interp1d/interp2d </li>
<li>多维插值：griddata </li>
<li>其他常用插值：Spline样条插值(spl（曲线）, bispl（曲面）等)、Rbf插值</li>
</ol>
</li>
<li><p><code>interp1d(x, y, kind=&#39;linear‘,……)</code></p>
<ol>
<li>x,y：要插值的数据点，注意x是一个递增序列 </li>
<li>kind：插值的方法：‘linear’, ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’, ‘previous’,  ‘next’等</li>
<li>返回值：一个用于插值的函数，调用这个函数时以新的x为参数 ，会得到对应的y值。</li>
</ol>
</li>
<li><p>一维B样条插值：</p>
<ol>
<li>splrep(x,y,k=3,s,……)：获得一维曲线的B样条表示 </li>
<li>splev(x, tck, der=0,……)：根据B样条表示得到对应数值 </li>
</ol>
<p>呜呜呜我不想看B样条了就这样把</p>
</li>
</ol>
<h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><ol>
<li><p>最小二乘拟合： least_squares(fun, x0, bounds=(-inf, inf), method=‘trf’, args,……) </p>
<ol>
<li><p>fun：计算残差向量(residuals)的函数 </p>
</li>
<li><p>x0：猜测的参数值𝑝0 </p>
</li>
<li><p>bounds：参数𝑝的约束范围，2-tuple：((𝑝i的下限),(𝑝i的上限)) </p>
</li>
<li><p>method： ‘trf’, ‘dogbox’, ‘lm’，其中‘lm’不支持bounds </p>
</li>
<li><p>args：计算fun需要的其他参数，例如样本数据x，y</p>
<p>返回值： </p>
</li>
<li><p>x：求解出来使得S最小的参数𝑝 </p>
</li>
<li><p>fun：对应的残差向量</p>
</li>
</ol>
<p>一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x,p)</span>:</span></span><br><span class="line">    A,k,theta = p</span><br><span class="line">    <span class="keyword">return</span> A*np.sin(<span class="number">2</span>*np.pi*k*x+theta)</span><br><span class="line">x=np.linspace(<span class="number">0</span>,<span class="number">2</span>*np.pi,<span class="number">100</span>)</span><br><span class="line">A,k,theta=<span class="number">10</span>,<span class="number">0.34</span>,np.pi/<span class="number">6</span>	<span class="comment"># 真实数据的函数参数</span></span><br><span class="line">y0=func(x,[A,k,theta])		<span class="comment"># 真实数据</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)			<span class="comment"># 噪声种子</span></span><br><span class="line">y=y0+<span class="number">2</span>*np.random.randn(len(x))	<span class="comment"># 添加噪声后的数据</span></span><br><span class="line"></span><br><span class="line">plt.plot(x,y,<span class="string">"o"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">residuals</span><span class="params">(p,y,x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> y-func(x,p)</span><br><span class="line">p0=[<span class="number">7</span>,<span class="number">0.4</span>,<span class="number">0</span>]</span><br><span class="line">plsq=optimize.least_squares(residuals,p0,args=(y,x))</span><br><span class="line">print(<span class="string">"真实参数："</span>,[A,k,theta])</span><br><span class="line">print(<span class="string">"拟合参数："</span>,plsq.x)</span><br><span class="line">plt.plot(x,func(x,plsq.x))</span><br><span class="line"><span class="comment"># 真实参数： [10, 0.34, 0.5235987755982988]</span></span><br><span class="line"><span class="comment"># 拟合参数： [10.25218748  0.3423992   0.50817423]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>scipy.optimize.curve_fit</code>：实质和最小二乘一样</p>
<p>用法上和least_squares稍有点不同：不用定义误差函数，直接 使用目标函数，且目标函数的各个待优化参数𝑝直接作为函数的参 数传入。</p>
</li>
<li><p>多项式拟合polyfit：</p>
<ol>
<li><p>numpy/scipy.polyfit(x, y, deg,……)： </p>
<ol>
<li>x,y：待拟合的数据 </li>
<li>deg：多项式的次数<br>返回值：<br>p：拟合后的多项式的系数，从<strong>高</strong>位到<strong>低</strong>位</li>
</ol>
</li>
<li>numpy/scipy.polyval(p, x)：计算多项式p在x处的值</li>
</ol>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = np.polyfit(x,y,<span class="number">10</span>)</span><br><span class="line">plt.plot(x,np.polyval(p,x),<span class="string">'k-'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>polynomial模块：</p>
<ol>
<li>拟合：和上面的区别在于，返回的多项式系数是从<strong>低</strong>到<strong>高</strong>的</li>
</ol>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.polynomial <span class="keyword">import</span> polymial <span class="keyword">as</span> P</span><br><span class="line">p2=P.polyfit(x,y,<span class="number">10</span>)</span><br><span class="line">plt.plot(x,P.polyfit(x,p2),<span class="string">'m-'</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>四则运算：<code>P.polyadd(), P.polysub(), P.polymul(), P.polydiv()</code></p>
</li>
<li><p>微分：<code>P.polyder()</code>用来求微分以后的多项式参数，默认是一阶导，加参数就是参数对应的导数</p>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)	<span class="comment"># 1+2x+3x**2+4x**3</span></span><br><span class="line">P.polyder(a)	<span class="comment"># (d/dx)(c)=2+6x+12x**2	</span></span><br><span class="line"><span class="comment"># array([ 2., 6., 12.])</span></span><br><span class="line">P.polyder(a,<span class="number">3</span>)	<span class="comment"># (d**3/dx**3)(c)=24</span></span><br><span class="line"><span class="comment"># array([ 24.])</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>积分：<code>P.polyint(c)</code>  和微分类似的用法</p>
</li>
<li><p>求根：<code>P.polyroots(a)</code> 和微分类似，对多项式求根，返回运算之后的参数</p>
</li>
</ol>
<h2 id="随堂练习"><a href="#随堂练习" class="headerlink" title="随堂练习"></a>随堂练习</h2><p>IBM.csv中保存了2014年以来的IBM股票信息，请读入IBM的收盘价，然后选取其中2019年的数据，之后： （1）假设每天的收盘价可以用之前5天的收盘价的线性组合表示出来，由此建立一个线性模型进行收盘价的预测，求解最佳的线性组合系数，并绘制收盘价以及预测的收盘价的曲线图。 </p>
<p>（2）采用多项式对收盘价进行拟合，尝试不同的多项式次数， 选取其中较优的结果，打印该多项式的各项系数，并绘制多项式曲线以及收盘价散点图。进一步，求解该多项式的转折点， 即一阶导数为0的点（只要实数解），并在多项式曲线上以上三角的标记绘制出来。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>首先是读取csv文件并提取2019年收盘价：</li>
<li>接下来，第一问可以看作是求解线性方程组的系数，<code>y=a*x1+b*x2+c*x3+d*x4+e*x5+f</code>，其中<code>abcdef</code>是待求解参数，<code>x1,x2,x3,x4,x5</code>分别是连续5天的收盘价，而<code>y</code>是第六天收盘价。<ol>
<li>建立存放<code>x</code>的列表；</li>
<li>遍历收盘价列表，把每一组收盘价（连续5个）作为一个列表加到x中，注意这里遍历的终点是倒数第5个，因为再往后就无法凑成连续5个了；</li>
<li>每一行<code>x</code>对应的<code>y</code>都是连续5个收盘价的下一个，也就是第6个收盘价开始，即<code>ibm_2019[5:]</code></li>
<li><code>x</code>和<code>y</code>都要转为<code>np.array</code>，然后用<code>lstsq</code>求解系数并绘制图像即可；</li>
</ol>
</li>
<li>第二问则是多项式拟合，这里我把自变量<code>x</code>设置为<code>1,2,3,...</code>，因变量<code>y</code>就是所有收盘价，然后使用<code>polyfit</code>求解并输出和绘图即可。经过尝试和比较，选择了<code>deg=17</code>。</li>
<li>求解一阶导数为0的点，也就是先对之前的多项式求导得到新多项式，再求解新多项式的根，最后在图像中标注即可。</li>
</ol>
<p>整体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line"><span class="keyword">from</span> numpy.polynomial <span class="keyword">import</span> polynomial <span class="keyword">as</span> P</span><br><span class="line">ibm = pd.read_csv(<span class="string">'IBM.csv'</span>, header=<span class="number">0</span>, index_col=<span class="number">0</span>, parse_dates=<span class="literal">True</span>)</span><br><span class="line">ibm_group = ibm.groupby(ibm.index.year)</span><br><span class="line">ibm_2019 = ibm_group.get_group(<span class="number">2019</span>)[<span class="string">'Close'</span>]</span><br><span class="line">x = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(ibm_2019)<span class="number">-5</span>):</span><br><span class="line">    tmp=[ibm_2019[i],ibm_2019[i+<span class="number">1</span>],ibm_2019[i+<span class="number">2</span>],ibm_2019[i+<span class="number">3</span>],ibm_2019[i+<span class="number">4</span>],<span class="number">1</span>]</span><br><span class="line">    x.append(tmp)</span><br><span class="line">x = np.array(x)</span><br><span class="line">y = np.array(ibm_2019[<span class="number">5</span>:])</span><br><span class="line">c,resid,rank,sigma=linalg.lstsq(x,y)</span><br><span class="line">x_1=np.linspace(<span class="number">1</span>,y.size,y.size)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x_1,y,<span class="string">'x'</span>, x_1,x.dot(c))</span><br><span class="line">x_2=np.linspace(<span class="number">1</span>,len(ibm_2019),len(ibm_2019))</span><br><span class="line">p=P.polyfit(x_2,ibm_2019,<span class="number">17</span>)</span><br><span class="line">print(<span class="string">"多项式系数为："</span>,p)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x_2,ibm_2019,<span class="string">'x'</span>,x_2,P.polyval(x_2,p),<span class="string">'k-'</span>)</span><br><span class="line">p2=P.polyder(p)</span><br><span class="line">root=P.polyroots(p2)</span><br><span class="line">plt.plot(root, P.polyval(root,p),<span class="string">'r^'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-FractalNet的ODE建模</title>
    <url>/2020/05/23/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-BEYOND%20FINITE%20LAYER%20NEURAL%20NETWORKS%20BRIDGING%20DEEP%20ARCHITECTURES%20AND%20NUMERICAL%20DIFFERENTIAL%20EQUATIONS/</url>
    <content><![CDATA[<h1 id="FractalNet的ODE建模"><a href="#FractalNet的ODE建模" class="headerlink" title="FractalNet的ODE建模"></a>FractalNet的ODE建模</h1><p>论文1：Beyond Finite Layer Neural Networks: Bridging Deep Architectures And Numerical Differential Equations</p>
<p>论文2：Fractalnet: Ultra-Deep Neural Networks Without Residuals</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>OED</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-12</title>
    <url>/2020/05/19/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-12/</url>
    <content><![CDATA[<p>这一课讲Pandas库。</p>
<p><code>import pandas as pd</code></p>
<a id="more"></a>
<h2 id="Pandas初探"><a href="#Pandas初探" class="headerlink" title="Pandas初探"></a>Pandas初探</h2><ol>
<li>读取文件：<code>data = pd.read_excel(filename, index_col=0)</code></li>
<li>取出数据中的一列或一行：<code>data[&#39;学号&#39;], data.loc[1]</code></li>
</ol>
<h2 id="Pandas数据类型"><a href="#Pandas数据类型" class="headerlink" title="Pandas数据类型"></a>Pandas数据类型</h2><h3 id="Series-一维序列"><a href="#Series-一维序列" class="headerlink" title="Series(一维序列)"></a>Series(一维序列)</h3><ol>
<li><p>由index+value组成</p>
</li>
<li><p>通过列表创建Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = pd.Series([<span class="string">'apple'</span>,<span class="string">'peach'</span>])</span><br><span class="line"><span class="comment"># 0	apple</span></span><br><span class="line"><span class="comment"># 1	peach</span></span><br><span class="line">a.index</span><br><span class="line"><span class="comment"># RangeIndex(start=0,stop=2,step=1)</span></span><br><span class="line">a.values</span><br><span class="line"><span class="comment"># array(['apple','peach'],dtype=object)</span></span><br><span class="line">a[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 'peach'</span></span><br><span class="line">a[<span class="number">1</span>]=<span class="number">100</span></span><br><span class="line"><span class="comment"># 原来是peach的地方改成了100</span></span><br><span class="line">a[<span class="number">0</span>:]</span><br><span class="line"><span class="comment"># 整个输出</span></span><br><span class="line">a[[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># 输出0和1</span></span><br><span class="line">a = pd.Series([<span class="string">'apple'</span>,<span class="string">'peach'</span>],index=[<span class="string">'a'</span>,<span class="string">'p'</span>])</span><br><span class="line"><span class="comment"># a    apple</span></span><br><span class="line"><span class="comment"># p    peach</span></span><br><span class="line">a[<span class="string">'a'</span>]</span><br><span class="line"><span class="comment"># 输出索引a对应的value</span></span><br><span class="line">a[<span class="string">'a'</span>]=<span class="string">'lemon'</span></span><br><span class="line"><span class="comment"># 原来的apple改成lemon</span></span><br><span class="line">a[<span class="string">'a'</span>:]</span><br><span class="line"><span class="comment"># 整个输出</span></span><br><span class="line">a[[<span class="string">'a'</span>,<span class="string">'p'</span>]]</span><br><span class="line"><span class="comment"># 输出a和p对应的value</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过字典创建Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'Japan'</span>:<span class="string">'Tokyo'</span>,<span class="string">'S.Korea'</span>:<span class="string">'Seoul'</span>,<span class="string">'China'</span>:<span class="string">'Beijing'</span>&#125;</span><br><span class="line">a = pd.Series(d)</span><br><span class="line"><span class="comment"># Japan        Tokyo</span></span><br><span class="line"><span class="comment"># S.Korea      Seoul</span></span><br><span class="line"><span class="comment"># China      Beijing</span></span><br><span class="line"></span><br><span class="line">indexL=[<span class="string">'China'</span>,<span class="string">'Japan'</span>,<span class="string">'ingapore'</span>,<span class="string">'S.Korea'</span>]</span><br><span class="line">a = pd.Series(d, index=indexL)</span><br><span class="line"><span class="comment"># China       Beijing</span></span><br><span class="line"><span class="comment"># Japan         Tokyo</span></span><br><span class="line"><span class="comment"># ingapore        NaN</span></span><br><span class="line"><span class="comment"># S.Korea       Seoul</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过标量创建Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = pd.Series(<span class="string">'无'</span>)</span><br><span class="line"><span class="comment"># 0    无</span></span><br><span class="line">a = pd.Series(<span class="string">'无'</span>,index=np.arange(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment"># 1    无</span></span><br><span class="line"><span class="comment"># 2    无</span></span><br><span class="line"><span class="comment"># 3    无</span></span><br><span class="line"><span class="comment"># 4    无</span></span><br><span class="line"><span class="comment"># 5    无</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Series的基本运算：</p>
<ol>
<li>和numpy一样，过滤、广播、ufunc等</li>
<li>对齐：对应索引进行运算</li>
<li>频数统计：value_counts()</li>
</ol>
</li>
</ol>
<h3 id="DataFrame-二维表"><a href="#DataFrame-二维表" class="headerlink" title="DataFrame(二维表)"></a>DataFrame(二维表)</h3><ol>
<li><p>共用index的Series的有序集合</p>
</li>
<li><p>从二维数组创建：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = np.array([(<span class="string">'Japan'</span>,<span class="string">'Tokyo'</span>,<span class="number">4000</span>),(<span class="string">'S.Korea'</span>,<span class="string">'Seoul'</span>,<span class="number">1300</span>),(<span class="string">'China'</span>,<span class="string">'Beijing'</span>,<span class="number">9100</span>)])</span><br><span class="line">DF1 = pd.DataFrame(data, columns=[<span class="string">'nation'</span>,<span class="string">'capital'</span>,<span class="string">'GDP'</span>],index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看索引和数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DF1.index</span><br><span class="line">DF1.columns</span><br><span class="line">DF1.values</span><br></pre></td></tr></table></figure>
</li>
<li><p>从字典创建：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dct = &#123;<span class="string">'nation'</span>:[<span class="string">'Japan'</span>,<span class="string">'S.Korea'</span>,<span class="string">'Japan'</span>],<span class="string">'capital'</span>:pd.Series([<span class="string">'Tokyo'</span>,<span class="string">'Seoul'</span>,<span class="string">'Beijing'</span>],index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]),<span class="string">'GDP'</span>:np.array([<span class="number">4900.1300</span><span class="number">.9100</span>],dtype=int)&#125;</span><br><span class="line">DF2=pd.DataFrame(dct)</span><br></pre></td></tr></table></figure>
</li>
<li><p>把某列数据作为index：<code>DF2.set_index(&#39;nation&#39;)</code></p>
</li>
<li><p>修改index/columns：<code>DF2.reindex(index=[&#39;c&#39;,&#39;a&#39;,&#39;b&#39;,&#39;d&#39;])</code></p>
</li>
<li><p>数据选择：</p>
<ol>
<li>取头尾若干行：<code>df.head(行数), df.tail(行数)</code></li>
<li>选择一列：<code>DF2.nation, DF2[&#39;GDP&#39;]</code></li>
<li>选择一行或多行：<code>DF2[0:2], DF2[&#39;a&#39;:&#39;c&#39;]</code>    序号只能是切片，不能是下标</li>
<li><code>loc[index, columns]</code>根据索引对多个轴进行选取</li>
<li>取单个数据：<code>DF2.loc[&#39;c&#39;,&#39;GDP&#39;]</code>或<code>DF2.at[&#39;c&#39;,&#39;GDP&#39;]</code></li>
<li>布尔索引：<ol>
<li>用某列的值来选取数据：<code>DF2[DF2.GDP&gt;3000]</code></li>
<li><code>isin()</code>方法过滤数据：<code>DF2[DF2.nation.isin([&#39;China&#39;,&#39;S.Korea&#39;])]</code></li>
</ol>
</li>
</ol>
</li>
<li><p>增加一列：<code>DF2[&#39;population&#39;]=[130,55,1600]</code></p>
</li>
<li><p>增加行：<code>append(要添加的行)</code>，序号是添加行的name，如果加入参数ignore_index=True，则序号就是数字</p>
</li>
<li><p>删除行列：<code>drop(序号)</code>，根据索引删除行列，默认删行，axis=1是删列</p>
</li>
<li><p>多个DataFrame对象数据拼接：</p>
<ol>
<li><code>pd.concat([p1,p2])</code>，序号是p1和p2各自的序号直接拼起来，是前几行p1，后几行p2；增加参数ignore_index=True，则序号是0、1、2、3这样；增加参数axis=1，则是前几列p1，后几列p2。</li>
<li><code>pd.merge(p1,p3,on=&#39;name&#39;)</code>，把p1和p3中name列相同的部分融合起来，如果是要把所有name都留下，但是只要一列name，则增加参数<code>how=&#39;outer&#39;</code></li>
</ol>
</li>
<li><p>缺失值处理：</p>
<ol>
<li><code>isnull()</code>和<code>notnull()</code>：是否缺失</li>
<li><code>fillna()</code>：补充缺失值</li>
<li><code>dropna()</code>：删除包含缺失值的行或列</li>
</ol>
</li>
<li><p>基本运算：<code>sub,add,mul,div,sum,min,max,mean,std,describe</code>，默认是竖着运算，加axis=1变成横着运算</p>
</li>
<li><p>分组：<code>groupby()</code>、<code>get_group(列名)</code>，也可以进行上一条的基本运算</p>
</li>
<li><p>排序：<code>sort_value(by=&#39;&#39;, ascending=False)</code> 根据by的取值排序，可以是一个字符串<code>by=&#39;成绩&#39;</code>，也可以是多个字符串的列表，<code>by=[&#39;成绩&#39;,&#39;年级&#39;]</code></p>
</li>
</ol>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="csv"><a href="#csv" class="headerlink" title="csv"></a>csv</h3><ol>
<li><code>read_csv()/to_csv()</code>读写csv和txt</li>
<li>加入参数index_col=0可以没有序号</li>
</ol>
<h3 id="excel"><a href="#excel" class="headerlink" title="excel"></a>excel</h3><ol>
<li><p><code>read_excel()/to_excel()</code>读写excel</p>
</li>
<li><p>把几个dataframe写到一个excel文件里的不同sheet中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">writer=pd.ExcelWriter(<span class="string">'atest.xlsx'</span>)</span><br><span class="line">a.to_excel(writer, sheet_name=<span class="string">'Sheet1'</span>)</span><br><span class="line">b.to_excel(writer, sheet_name=<span class="string">'Sheet2'</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">with</span> pd.ExcelWriter(<span class="string">'atest.xlsx'</span>) <span class="keyword">as</span> writer:</span><br><span class="line">    a.to_excel(writer, sheet_name=<span class="string">'Sheet1'</span>)</span><br><span class="line">	b.to_excel(writer, sheet_name=<span class="string">'Sheet2'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取一个exce里的多个sheet</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reader = pd.ExcelWriter(<span class="string">'atest.xlsx'</span>)</span><br><span class="line">df1 = pd.read_excel(reader, <span class="string">'Sheet1'</span>)</span><br><span class="line">df2 = pd.read_excel(reader, <span class="string">'Sheet2'</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">with</span> pd.ExcelWriter(<span class="string">'atest.xlsx'</span>) <span class="keyword">as</span> reader:</span><br><span class="line">    df1 = pd.read_excel(reader, <span class="string">'Sheet1'</span>)</span><br><span class="line">	df2 = pd.read_excel(reader, <span class="string">'Sheet2'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><ol>
<li>matplotlib中的pyplot模块：<code>b.plot()</code>，表格中的一列代表一条线的数据，行名是横坐标，表格内容值是纵坐标，默认是折线图</li>
<li>柱状图：<code>b.plot(kind=&#39;bar&#39;)      b.plot.bar()</code></li>
</ol>
<h2 id="随堂练习"><a href="#随堂练习" class="headerlink" title="随堂练习"></a>随堂练习</h2><p> 读入第三次作业第一部分爬虫得到的 csv文件，之后：</p>
<ol>
<li>绘制浏览次数曲线图；</li>
<li>根据浏览次数进行降序排序，并打印前10篇报道的日期、标题； </li>
<li>求浏览次数为1的报道的链接并打印结果；</li>
<li>统计每一年的报道数量，以及每一年的总的浏览次数，并分别以 柱状图的形式绘制出来；</li>
<li>统计2019年每个月的报道数量并以饼图的形式绘制出来。</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>首先加载库文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来读取csv文件，考虑到后面的几项要求，把日期作为DatetimeIndex的索引比较好：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reports = pd.read_csv(<span class="string">'reportsInfo.csv'</span>, header=<span class="number">0</span>, index_col=<span class="number">0</span>, parse_dates=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一个要求是绘制浏览次数的折线图，因为原本的csv文件时间是先2020年再2019年然后2018年这样倒着来的，所以先重新排序，再取浏览次数那一列的数值来画图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reports.sort_index()[<span class="string">'浏览次数'</span>].plot(linestyle=<span class="string">'-'</span>, linewidth=<span class="number">2</span>, color=<span class="string">'steelblue'</span>)</span><br><span class="line">plt.title(<span class="string">'浏览次数折线图'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'日期'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'浏览次数'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.savefig(<span class="string">'reports_linechart'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据浏览次数降序排序的操作和上一步索引排序差不多，然后切片取前10，用loc定位到标题那一列，输出即可：</p>
<p><code>print(reports.sort_values(by=&#39;浏览次数&#39;, ascending=False)[0:10].loc[:, [&#39;标题&#39;]])</code></p>
</li>
<li><p>筛选浏览次数为1的链接，用下标的方式找即可：</p>
<p><code>print(reports[reports.浏览次数 == 1].链接)</code></p>
</li>
<li><p>统计每年的报道数量，需要先按年来分组，然后得到分组的size，对size画图即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reports_group = reports.groupby(reports.index.year)</span><br><span class="line">reports_group.size().plot.bar()</span><br><span class="line">plt.title(<span class="string">'年报道数量柱状图'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'年份'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'报道数量'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.xticks(rotation=<span class="number">0</span>)</span><br><span class="line">plt.savefig(<span class="string">'reports_bar_1'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计每年的总浏览次数，在上一条分组的基础上对浏览次数那一列求和，然后画图即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reports_group[<span class="string">'浏览次数'</span>].sum().plot.bar()</span><br><span class="line">plt.title(<span class="string">'年浏览次数柱状图'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'年份'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'浏览次数'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.xticks(rotation=<span class="number">0</span>)</span><br><span class="line">plt.savefig(<span class="string">'reports_bar_2'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计2019年每月的报道数量，在之前的分组中可以得到2019的分组，然后对2019部分再按月来分组，得到size，对size画图即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reports_2019 = reports_group.get_group(<span class="number">2019</span>)</span><br><span class="line">reports_2019_month = reports_2019.groupby(reports_2019.index.month).size()</span><br><span class="line">reports_2019_month.name = <span class="string">''</span></span><br><span class="line">reports_2019_month.plot.pie(startangle=<span class="number">90</span>)</span><br><span class="line">plt.title(<span class="string">'2019年每月报道数量饼状图'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.savefig(<span class="string">'reports_pie'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Dynamic Task Pricing in Multi-Requester Mobile Crowd Sensing with Markov Correlated Equilibrium</title>
    <url>/2020/05/14/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Dynamic-Task-Pricing-in-Multi-Requester-Mobile-Crowd-Sensing-with-Markov-Correlated-Equilibrium/</url>
    <content><![CDATA[<h1 id="基于马尔可夫相关均衡的多发包方移动群体感知中的动态任务定价"><a href="#基于马尔可夫相关均衡的多发包方移动群体感知中的动态任务定价" class="headerlink" title="基于马尔可夫相关均衡的多发包方移动群体感知中的动态任务定价"></a>基于马尔可夫相关均衡的多发包方移动群体感知中的动态任务定价</h1><a id="more"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ol>
<li>场景：移动群智感知，多个发包方公开收集群体感知数据，公开定价来吸引workers</li>
<li>问题：<ol>
<li>requestor之间是不完整信息博弈</li>
<li>动态系统中未来的不确定性：未来会有多少workers</li>
</ol>
</li>
<li>解决方案：动态定价—&gt;Markov博弈，长期累积效用最大化，近似最小社会成本</li>
</ol>
<h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><ol>
<li>K个requestors，每个用$r_i$表示，集合是R</li>
<li>$r_i$发布$N_i$个任务，总共有W种类型，每种类型的任务只能由对应类型的worker来完成</li>
<li>$N_{i,w}$表示第i个requestor发布的w类型的任务数量</li>
<li>$R_w$表示发布了w类型任务的requestors</li>
<li>$N_i$表示所有同一个i的$N_{i,w}$，也就是一个requestor发布的所有任务数量</li>
<li>两种场景：<ol>
<li>所有workers同时到达</li>
<li>workers动态到达</li>
</ol>
</li>
</ol>
<p>这篇暂时先不往后看了，师弟组会讲过了</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>crowd sensing</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-11</title>
    <url>/2020/05/12/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-11/</url>
    <content><![CDATA[<p>这一课是matplotlib画图的介绍。</p>
<p><code>import matplotlib.pyplot as plt</code></p>
<a id="more"></a>
<h2 id="基础绘图"><a href="#基础绘图" class="headerlink" title="基础绘图"></a>基础绘图</h2><ol>
<li><p><code>plt.plot([x坐标],[y坐标])</code>设置图像坐标</p>
<p>x坐标如果是<code>[1,2,3,4]</code>这样连贯的，可以省略。</p>
</li>
<li><p><code>plt.show()</code>显示图像，<code>plt.sacefig(&#39;文件名&#39;, dpi=300)</code>保存图像为png文件。</p>
</li>
<li><p>多条曲线：<code>plt.plot(a,a,a,a*2,a,a**2)</code>，<code>a</code>是numpy数组。</p>
</li>
</ol>
<h2 id="设置图像属性"><a href="#设置图像属性" class="headerlink" title="设置图像属性"></a>设置图像属性</h2><ol>
<li>颜色和线宽：<code>plt.plot(x, y, format_string, **kwargs)</code>，其中<code>format_string</code>设定颜色、风格和标记。</li>
<li>坐标轴范围：<ol>
<li>获取坐标范围：<code>xlim(),ylim(),axis()</code></li>
<li>设置坐标范围：<code>xlim(xmin,xmax), ylim(ymin,ymax), axis([xmin,xmax,ymin,ymax])</code></li>
</ol>
</li>
<li>设置坐标轴刻度：<code>plt.xticks(),plt.yticks(0</code>)</li>
<li>设置坐标轴标签和图的题目：<code>xlabel(), ylabel(),title()</code></li>
<li>添加图例：<code>legend()</code></li>
<li>添加文字注释：<code>text()</code></li>
<li>标注：<code>ax.annotate()</code></li>
<li>网格：<code>plt.grid(True)</code>，可以设置颜色、线型等等</li>
</ol>
<h2 id="中文显示问题"><a href="#中文显示问题" class="headerlink" title="中文显示问题"></a>中文显示问题</h2><ol>
<li><code>rc_params()</code>指定字体：<code>matplotlib.rcParams[&#39;font.family&#39;]=&#39;STSong&#39;</code></li>
<li>在用到的地方指定字体：<code>fontproperties=&#39;Kaiti&#39;</code></li>
</ol>
<h2 id="绘制子图"><a href="#绘制子图" class="headerlink" title="绘制子图"></a>绘制子图</h2><ol>
<li><code>subplot(numRows, numCols, plotNum)</code></li>
<li><code>subplot2grid(shape, loc, rowspan=1, colspan=1)</code></li>
<li><code>gridspec.GridSpec()</code>和<code>subplot()</code>结合</li>
</ol>
<h2 id="绘制多个图"><a href="#绘制多个图" class="headerlink" title="绘制多个图"></a>绘制多个图</h2><p><code>figure()</code></p>
<h2 id="常用图标函数"><a href="#常用图标函数" class="headerlink" title="常用图标函数"></a>常用图标函数</h2><ol>
<li>散点图：<code>plt.scatter()</code></li>
<li>柱状图：<code>plt.bar()</code></li>
<li>直方图：<code>plt.hist()</code></li>
<li>饼图：<code>plt.pie()</code></li>
<li>等值线图：<code>plt.contour()</code></li>
<li>极坐标图：<code>plt.plot()</code></li>
<li>矢量场流线图：<code>plt.streamplot()</code></li>
<li>三维绘图：<code>Axes3D(fig)</code>或者<code>fig.add_subplot()</code></li>
</ol>
<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><p> IBM.csv和BABA.csv分别保存了IBM和阿里巴巴股票信息，请读入它们的日期和收盘价，绘制收盘价曲线图，要求：</p>
<ol>
<li>设置横坐标和纵坐标轴标签、图的题目，另外横坐标轴刻度标签为日期；</li>
<li>对每一支股票求最高收盘价和最低收盘价，并在曲线上对这两个点进行标注。</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>导入所需库文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.ticker <span class="keyword">as</span> ticker</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先是读入csv文件，因为日期是字符串，所以这里先统一用字符串的格式读入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ibm = np.loadtxt(<span class="string">"IBM.csv"</span>, dtype=np.str, delimiter=<span class="string">','</span>)</span><br><span class="line">baba = np.loadtxt(<span class="string">"BABA.csv"</span>, dtype=np.str, delimiter=<span class="string">','</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来提取所需数据：日期、收盘价、最高和最低收盘价，这里使用<code>astype()</code>把收盘价从numpy字符串转为numpy浮点数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># IBM</span></span><br><span class="line">date_ibm = ibm[<span class="number">1</span>:, <span class="number">0</span>]</span><br><span class="line">close_ibm = ibm[<span class="number">1</span>:, <span class="number">4</span>].astype(np.float)</span><br><span class="line">close_ibm_u = close_ibm.max()</span><br><span class="line">date_ibm_u = date_ibm[np.where(close_ibm == close_ibm_u)]</span><br><span class="line">close_ibm_l = close_ibm.min()</span><br><span class="line">date_ibm_l = date_ibm[np.where(close_ibm == close_ibm_l)]</span><br><span class="line"><span class="comment"># BABA</span></span><br><span class="line">date_baba = baba[<span class="number">1</span>:, <span class="number">0</span>]</span><br><span class="line">close_baba = baba[<span class="number">1</span>:, <span class="number">4</span>].astype(np.float)</span><br><span class="line">close_baba_u = close_baba.max()</span><br><span class="line">date_baba_u = date_baba[np.where(close_baba == close_baba_u)]</span><br><span class="line">close_baba_l = close_baba.min()</span><br><span class="line">date_baba_l = date_baba[np.where(close_baba == close_baba_l)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>得到数据以后就开始画图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 画曲线</span></span><br><span class="line">plt.plot(date_ibm, close_ibm, color=<span class="string">"green"</span>, linewidth=<span class="number">0.5</span>, label=<span class="string">'IBM'</span>)</span><br><span class="line">plt.plot(date_baba, close_baba, color=<span class="string">"blue"</span>, linewidth=<span class="number">0.5</span>, label=<span class="string">'BABA'</span>)</span><br><span class="line"><span class="comment"># 设置x轴密度和刻度大小方向</span></span><br><span class="line">plt.gca().xaxis.set_major_locator(ticker.MultipleLocator(<span class="number">80</span>))</span><br><span class="line">plt.xticks(rotation=<span class="number">45</span>, size=<span class="number">6</span>)</span><br><span class="line"><span class="comment"># 设置标题和轴标签内容及字体</span></span><br><span class="line">plt.title(<span class="string">'2014年以来IBM和BABA股票收盘价随日期的变换'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'日期'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'收盘价'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line"><span class="comment"># 设置图例位置</span></span><br><span class="line">plt.legend(loc=<span class="string">'upper center'</span>)</span><br><span class="line"><span class="comment"># 在四个最高最低点加圆圈标记</span></span><br><span class="line">plt.plot(date_ibm_u,close_ibm_u,<span class="string">'ro'</span>,markersize=<span class="number">3</span>)</span><br><span class="line">plt.plot(date_ibm_l,close_ibm_l,<span class="string">'ro'</span>,markersize=<span class="number">3</span>)</span><br><span class="line">plt.plot(date_baba_u,close_baba_u,<span class="string">'ro'</span>,markersize=<span class="number">3</span>)</span><br><span class="line">plt.plot(date_baba_l,close_baba_l,<span class="string">'ro'</span>,markersize=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 给四个最高最低点加文字说明</span></span><br><span class="line">plt.annotate(<span class="string">r'最高'</span>+str(close_ibm_u),color=<span class="string">'r'</span>,xy=(date_ibm_u,close_ibm_u),xytext=(<span class="number">-17</span>,<span class="number">15</span>),textcoords=<span class="string">'offset points'</span>,fontproperties=<span class="string">'Kaiti'</span>,fontsize=<span class="number">5</span>,arrowprops=&#123;<span class="string">'arrowstyle'</span>:<span class="string">'-&gt;'</span>,<span class="string">'color'</span>:<span class="string">'r'</span>&#125;)</span><br><span class="line">plt.annotate(<span class="string">r'最低'</span>+str(close_ibm_l),color=<span class="string">'r'</span>,xy=(date_ibm_l,close_ibm_l),xytext=(<span class="number">-17</span>,<span class="number">-15</span>),textcoords=<span class="string">'offset points'</span>,fontproperties=<span class="string">'Kaiti'</span>,fontsize=<span class="number">5</span>,arrowprops=&#123;<span class="string">'arrowstyle'</span>:<span class="string">'-&gt;'</span>,<span class="string">'color'</span>:<span class="string">'r'</span>&#125;)</span><br><span class="line">plt.annotate(<span class="string">r'最高'</span>+str(close_baba_u),color=<span class="string">'r'</span>,xy=(date_baba_u,close_baba_u),xytext=(<span class="number">-50</span>,<span class="number">6</span>),textcoords=<span class="string">'offset points'</span>,fontproperties=<span class="string">'Kaiti'</span>,fontsize=<span class="number">5</span>,arrowprops=&#123;<span class="string">'arrowstyle'</span>:<span class="string">'-&gt;'</span>,<span class="string">'color'</span>:<span class="string">'r'</span>&#125;)</span><br><span class="line">plt.annotate(<span class="string">r'最低'</span>+str(close_baba_l),color=<span class="string">'r'</span>,xy=(date_baba_l,close_baba_l),xytext=(<span class="number">-50</span>,<span class="number">-6</span>),textcoords=<span class="string">'offset points'</span>,fontproperties=<span class="string">'Kaiti'</span>,fontsize=<span class="number">5</span>,arrowprops=&#123;<span class="string">'arrowstyle'</span>:<span class="string">'-&gt;'</span>,<span class="string">'color'</span>:<span class="string">'r'</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后显示和保存图像：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.tight_layout()</span><br><span class="line">plt.savefig(<span class="string">'homework'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>注意：在一开始的时候可以设置图像尺寸：<code>plt.figure(figsize=(1080/100,520/100),dpi=100)</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-10</title>
    <url>/2020/04/29/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-10/</url>
    <content><![CDATA[<p>这一课是numpy库。</p>
<p><code>import numpy as py</code></p>
<a id="more"></a>
<h2 id="创建数组基本方法："><a href="#创建数组基本方法：" class="headerlink" title="创建数组基本方法："></a>创建数组基本方法：</h2><ol>
<li><p><code>array()</code></p>
<p>python对象转换为数组</p>
</li>
<li><p><code>empty()</code></p>
<p>分配指定大小数组，不初始化</p>
</li>
<li><p><code>zeros()</code>,<code>ones()</code></p>
<p>建立全为0或1的数组</p>
</li>
<li><p><code>eye()</code>,<code>diag()</code></p>
<p>建立对角矩阵</p>
</li>
<li><p><code>arange()</code></p>
<p>初值、终值、步长建立一维数组</p>
</li>
<li><p><code>linspace()</code></p>
<p>初值、终值、元素个数建立一维数组</p>
</li>
<li><p><code>logspace</code></p>
<p>初值、终值、元素个数建立等比数列</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.array((1,2,3,4))</span><br><span class="line">array([1, 2, 3, 4])</span><br><span class="line">b &#x3D; np.array([[1,2,3,4],[4,5,6,7],[7,8,9,10]])</span><br><span class="line">array([[ 1,  2,  3,  4],</span><br><span class="line">       [ 4,  5,  6,  7],</span><br><span class="line">       [ 7,  8,  9, 10]])		</span><br><span class="line">c &#x3D; a.tolist()</span><br><span class="line">[1,2,3,4]</span><br><span class="line">d &#x3D; np.empty((2,2))	#这里数组维数必须是是元组</span><br><span class="line">array([[9.90263869e+067, 9.38159477e-312],</span><br><span class="line">       [0.00000000e+000, 9.38983138e-312]])       </span><br><span class="line">e &#x3D; np.ones((2,2))</span><br><span class="line">array([[1., 1.],</span><br><span class="line">       [1., 1.]])       </span><br><span class="line">f &#x3D; np.diag((2,3,4))</span><br><span class="line">array([[2, 0, 0],</span><br><span class="line">       [0, 3, 0],</span><br><span class="line">       [0, 0, 4]])       </span><br><span class="line">g &#x3D; np.eye(3)</span><br><span class="line">array([[1., 0., 0.],</span><br><span class="line">       [0., 1., 0.],</span><br><span class="line">       [0., 0., 1.]])       </span><br><span class="line">h &#x3D; np.eye(2,3)</span><br><span class="line">array([[1., 0., 0.],</span><br><span class="line">       [0., 1., 0.]])</span><br><span class="line">i &#x3D; np.arange(5,10,1)</span><br><span class="line">array([5, 6, 7, 8, 9])</span><br><span class="line">j &#x3D; np.linspace(5,10,4)</span><br><span class="line">array([ 5.        ,  6.66666667,  8.33333333, 10.        ])</span><br><span class="line">k &#x3D; np.logspace(0,1,5)</span><br><span class="line">array([ 1.        ,  1.77827941,  3.16227766,  5.62341325, 10.        ])</span><br></pre></td></tr></table></figure>
<h2 id="数组的基本属性"><a href="#数组的基本属性" class="headerlink" title="数组的基本属性"></a>数组的基本属性</h2><ol>
<li><code>ndim</code>：数组的维度，也就是有几行</li>
<li><code>shape</code>：数组每维大小，元组形式</li>
<li><code>size</code>：数组里一共多少个元素</li>
<li><code>dtype</code>：数组数据类型</li>
<li><code>itemsize</code>：元素字节数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d1 = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">d2 = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">d3 = np.array([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]],[[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]])</span><br><span class="line">print(d1.ndim, d2.ndim, d3.ndim)		<span class="comment"># 1 2 3</span></span><br><span class="line">print(d1.shape, d2.shape, d3.shape)		<span class="comment"># (6,) (2, 3) (2, 2, 3)</span></span><br></pre></td></tr></table></figure>
<h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><ol>
<li>改变数据类型：astype</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1.7</span>, <span class="number">1.2</span>, <span class="number">1.6</span>])</span><br><span class="line">b = a.astype(int)		<span class="comment"># b = array([1, 1, 1])</span></span><br></pre></td></tr></table></figure>
<h3 id="形状操作"><a href="#形状操作" class="headerlink" title="形状操作"></a>形状操作</h3><ol>
<li><p>reshape</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">b = a.reshape((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># b = array([[1, 2, 3],</span></span><br><span class="line"><span class="comment">#            [4, 5, 6]])</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">10</span></span><br><span class="line"><span class="comment"># a = array([10,  2,  3,  4,  5,  6])</span></span><br><span class="line"><span class="comment"># b = array([[10, 2, 3],</span></span><br><span class="line"><span class="comment">#            [4, 5, 6]])</span></span><br><span class="line">b[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">5</span></span><br><span class="line"><span class="comment"># a = array([5,  2,  3,  4,  5,  6])</span></span><br><span class="line"><span class="comment"># b = array([[5, 2, 3],</span></span><br><span class="line"><span class="comment">#            [4, 5, 6]])</span></span><br><span class="line">c = b.reshape((<span class="number">-1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="comment"># array([[5, 2],</span></span><br><span class="line"><span class="comment">#       [3, 4],</span></span><br><span class="line"><span class="comment">#       [5, 6]])</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>shape：和reshape差不多的用法，<code>a.reshape((-1,2))</code>和<code>a.shape=(-1,2)</code>效果是一样的</p>
</li>
<li><p>resize：同上，<code>a.resize((-1,2))</code>，注意reshape和resize的参数是元组，而shape的参数则不是元组。此外，一般来说reshape有返回值，不对原始多维数组进行修改；resize无返回值，会对原始多维数组进行修改。但其实resize和reshape都可以有返回值，也都可以没有返回值，区别在于，reshape是改变形状而不改变数据量，或者说改变数组维度，如果reshape之后的元素数量和之前的不一致就会报错，但是resize不会，元素多了就去掉，少了就补零。</p>
</li>
<li><p>ravel：扁平化，多维变成一维数组，但是修改ravel之后的元素，<strong>会</strong>导致原始数组的元素跟着变。</p>
</li>
<li><p>flatten：扁平化，多维变成一维数组，修改flatten之后的元素，<strong>不会</strong>导致原始数组的元素跟着变。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">b = a.ravel()	<span class="comment"># b = ([1,2,3,4,5,6])</span></span><br><span class="line">b[<span class="number">0</span>]=<span class="number">99</span></span><br><span class="line"><span class="comment">#a = array([[99,  2,  3],</span></span><br><span class="line"><span class="comment">#           [ 4,  5,  6]])</span></span><br><span class="line">c = a.flatten()  <span class="comment"># c = ([99,  2,  3,  4,  5,  6])</span></span><br><span class="line">c[<span class="number">1</span>]=<span class="number">98</span></span><br><span class="line"><span class="comment">#a = array([[99,  2,  3],</span></span><br><span class="line"><span class="comment">#           [ 4,  5,  6]])</span></span><br></pre></td></tr></table></figure>
<ol>
<li>转置：<code>数组.T</code></li>
</ol>
<h3 id="数组组合"><a href="#数组组合" class="headerlink" title="数组组合"></a>数组组合</h3><ol>
<li><p>hstack：水平</p>
</li>
<li><p>vstack：垂直</p>
</li>
<li><p>concatenate</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">b = np.array([[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]])</span><br><span class="line">c = np.hstack((a,b))</span><br><span class="line"><span class="comment"># [[ 0  1  2  0  2  4]</span></span><br><span class="line"><span class="comment">#  [ 3  4  5  6  8 10]]</span></span><br><span class="line">d = np.vstack((a,b))</span><br><span class="line"><span class="comment"># [[ 0  1  2]</span></span><br><span class="line"><span class="comment">#  [ 3  4  5]</span></span><br><span class="line"><span class="comment">#  [ 0  2  4]</span></span><br><span class="line"><span class="comment">#  [ 6  8 10]]</span></span><br><span class="line">e = np.concatenate((a,b),axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># [[ 0  1  2  0  2  4]</span></span><br><span class="line"><span class="comment">#  [ 3  4  5  6  8 10]]</span></span><br><span class="line">f = np.concatenate((a,b),axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># [[ 0  1  2]</span></span><br><span class="line"><span class="comment">#  [ 3  4  5]</span></span><br><span class="line"><span class="comment">#  [ 0  2  4]</span></span><br><span class="line"><span class="comment">#  [ 6  8 10]]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="数组分割"><a href="#数组分割" class="headerlink" title="数组分割"></a>数组分割</h3><ol>
<li>hsplit：水平</li>
<li>vsplit：垂直</li>
<li>split</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">a1, a2, a3 = np.hsplit(a,<span class="number">3</span>)</span><br><span class="line">b1, b2 = np.vsplit(a,<span class="number">2</span>)</span><br><span class="line">c1, c2 = np.split(a, <span class="number">2</span>, axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># a1 = [[0]</span></span><br><span class="line"><span class="comment">#       [3]]</span></span><br><span class="line"><span class="comment"># a2 = [[1]</span></span><br><span class="line"><span class="comment">#       [4]]</span></span><br><span class="line"><span class="comment"># a3 = [[2]</span></span><br><span class="line"><span class="comment">#       [5]]</span></span><br><span class="line"><span class="comment"># b1 = [[0 1 2]]</span></span><br><span class="line"><span class="comment"># b2 = [[3 4 5]]</span></span><br><span class="line"><span class="comment"># c1 = [[0 1 2]]</span></span><br><span class="line"><span class="comment"># c2 = [[3 4 5]]</span></span><br></pre></td></tr></table></figure>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><ol>
<li><p>切片下标：和列表切片一样，修改切片后的元素会导致原始数组改变</p>
</li>
<li><p>高级下标：</p>
<ol>
<li><p>整数列表/元组作为下标</p>
</li>
<li><p>整数数组作为下标</p>
</li>
<li><p>布尔数组作为下标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">b = a[[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">5</span>,<span class="number">7</span>]]	<span class="comment">#array([10,2,5,3])</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">c = a[np.array([<span class="number">3</span>,<span class="number">3</span>,<span class="number">-3</span>,<span class="number">8</span>])]	<span class="comment">#array([7,7,4,2])</span></span><br><span class="line">d = a[np.array([[<span class="number">3</span>,<span class="number">3</span>,<span class="number">-3</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]])]	<span class="comment">#array([[7,7,4,2],[9,8,7,6]])</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">array([<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line">b = a[np.array([<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">False</span>])]	<span class="comment">#array([5,3])</span></span><br><span class="line">a[np.array([<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">False</span>])] = <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span> </span><br><span class="line"><span class="comment">#array([-1, 4, -2, -3, 1])</span></span><br><span class="line">x = np.random.rand(<span class="number">4</span>)	</span><br><span class="line"><span class="comment"># [0.75217218 0.49197318 0.0754037  0.8145583 ]</span></span><br><span class="line">x &gt; <span class="number">0.5</span></span><br><span class="line"><span class="comment"># [ True False False  True]</span></span><br><span class="line">x[x&gt;<span class="number">0.5</span>]</span><br><span class="line"><span class="comment"># [0.75217218 0.8145583 ]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多维数组：数组不同维数的坐标用<code>,</code>隔开，例如二维数组<code>a</code>，<code>a[0,1]</code>中，0是第一维（行），1是第二维（列），每个维度内可以用切片的方式访问，例如<code>a[0,3:5]</code>和<code>a[:,2]</code>等，也可以用列表或元组下标的方式访问。</p>
<p>下标长度小于数组维数时，剩余的轴对应的下标是<code>:</code> 。</p>
<p> 所有轴的下标形状相同时，得到的数组和下标形状相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组</span></span><br><span class="line"><span class="comment"># 0, 1, 2, 3, 4, 5</span></span><br><span class="line"><span class="comment"># 10,11,12,13,14,15</span></span><br><span class="line"><span class="comment"># 20,21,22,23,24,25</span></span><br><span class="line"><span class="comment"># 30,31,32,33,34,35</span></span><br><span class="line"><span class="comment"># 40,41,42,43,44,45</span></span><br><span class="line"><span class="comment"># 50,51,52,53,54,55</span></span><br><span class="line">a[<span class="number">0</span>, <span class="number">3</span>:<span class="number">5</span>]	<span class="comment"># 第0行第3列和第4列</span></span><br><span class="line"><span class="comment"># array([3,4])</span></span><br><span class="line">a[<span class="number">4</span>:,<span class="number">4</span>:]	<span class="comment"># 第4、5行和第4、5列</span></span><br><span class="line"><span class="comment"># array([[44,45],[54,55]])</span></span><br><span class="line">a[:,<span class="number">2</span>]		<span class="comment"># 第2列</span></span><br><span class="line"><span class="comment"># array([ 2, 12, 22, 32, 42, 52])</span></span><br><span class="line">a[<span class="number">2</span>,:]		<span class="comment"># 第2行</span></span><br><span class="line"><span class="comment"># array([20, 21, 22, 23, 24, 25])</span></span><br><span class="line">a[<span class="number">2</span>::<span class="number">2</span>, ::<span class="number">2</span>]	<span class="comment">#第2行到最后一行，步长2；所有列，步长2</span></span><br><span class="line"><span class="comment"># array([[20, 22, 24], [40, 42, 44]])</span></span><br><span class="line">a[(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)] <span class="comment">#坐标为(0,1)(1,2)(2,3)(3,4)(4,5)的元素</span></span><br><span class="line"><span class="comment"># array([1,12,23,34,45])</span></span><br><span class="line">a[<span class="number">3</span>:,[<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>]]	<span class="comment">#第3行到最后一行，第0、2、5列</span></span><br><span class="line"><span class="comment"># array([[30, 32, 35], [40, 42, 45], [50, 52, 55]]) </span></span><br><span class="line">mask=np.array([<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>], dtype=bool)</span><br><span class="line">a[mask,<span class="number">2</span>]</span><br><span class="line"><span class="comment"># array([2,22,52])</span></span><br><span class="line">a[[<span class="number">1</span>,<span class="number">2</span>]] 	<span class="comment">#相当于a[[1,2],:] </span></span><br><span class="line"><span class="comment"># array([[10, 11, 12, 13, 14, 15], [20, 21, 22, 23, 24, 25]])</span></span><br><span class="line">x=np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">y=np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]]) </span><br><span class="line">a[x]	<span class="comment">#从2维数组变成3维数组</span></span><br><span class="line"><span class="comment"># [[[10 11 12 13 14 15]</span></span><br><span class="line"><span class="comment">#   [20 21 22 23 24 25]]</span></span><br><span class="line"><span class="comment">#  [[30 31 32 33 34 35]</span></span><br><span class="line"><span class="comment">#   [40 41 42 43 44 45]]]</span></span><br><span class="line">a[x,y] 		<span class="comment"># x和y的元素分别作为两个维度的坐标</span></span><br><span class="line"><span class="comment"># x = 1 2</span></span><br><span class="line"><span class="comment">#     3 4</span></span><br><span class="line"><span class="comment"># y = 1 1</span></span><br><span class="line"><span class="comment">#     2 2</span></span><br><span class="line"><span class="comment">#a[x,y]=[a[1][1] a[2][1]</span></span><br><span class="line"><span class="comment">#        a[3][2] a[4][2]]</span></span><br><span class="line"><span class="comment"># = [[11 21]</span></span><br><span class="line"><span class="comment">#    [32 42]]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="ufunc"><a href="#ufunc" class="headerlink" title="ufunc"></a>ufunc</h2><pre><code>  1. 对数组中每个元素进行操作的函数，不需要写for循环
     2. 常用操作：加减乘除取余乘方、比较运算、布尔运算等等
     3. 自定义ufunc： frompyfunc(func, nin, nout)
</code></pre><h3 id="其他函数操作"><a href="#其他函数操作" class="headerlink" title="其他函数操作"></a>其他函数操作</h3><ol>
<li>求和sum</li>
<li>平均值mean/average</li>
<li>方差var</li>
<li>标准差std</li>
<li>中位数median</li>
<li>最值min、max、ptp、argmin、argmax</li>
<li>排序sort、argsort</li>
<li>查找nonzero(a)、where(condition[,x,y])</li>
</ol>
<h3 id="广播（这部分短期内应该用不到，就不写了）"><a href="#广播（这部分短期内应该用不到，就不写了）" class="headerlink" title="广播（这部分短期内应该用不到，就不写了）"></a>广播（这部分短期内应该用不到，就不写了）</h3><ol>
<li>让数组shape相同的操作</li>
<li>orrid对象</li>
<li>mgrid和meshgrid函数</li>
</ol>
<h2 id="文件存取"><a href="#文件存取" class="headerlink" title="文件存取"></a>文件存取</h2><ol>
<li>这部分短期内应该也就读个图像，不看了</li>
</ol>
<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><p>读入图像文件Cat.jpg，并通过numpy的数组操作对图像进行修改，得到下面一系列图像： </p>
<ol>
<li>反色图像：r、g、b为原始像素颜色，则反色后的颜色为255-r、255-g、 255-b </li>
<li>灰度图像： r、g、b为原始像素颜色，变成灰度的公式为： Gray = r<em>0.299 + g</em>0.587 + b*0.114</li>
<li>水平镜像图像：左右交换</li>
<li>垂直镜像图像：上下交换</li>
<li>行和列转置后的图像 </li>
<li>逆时针旋转90°后的图像 </li>
<li>红色/绿色/蓝色通道图像：其余两通道颜色为0, 0</li>
<li>红色通道的颜色替换成红色通道的最大值 </li>
<li>红色/绿色/蓝色通道重新组合，红色变成蓝色，绿色变成红色，蓝色变成绿色 </li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先读入图像：<code>im = np.array(Image.open(&quot;cat.jpg&quot;))</code></p>
<p>其次考虑保存图像，这里写了一个函数，把数组转为图像并按指定名称保存：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveimg</span><span class="params">(img, index)</span>:</span></span><br><span class="line">    img = Image.fromarray(img.astype(<span class="string">'uint8'</span>))</span><br><span class="line">    img.show()</span><br><span class="line">    img.save(<span class="string">'Cat'</span> + index + <span class="string">'.jpg'</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>接下来就是图像处理部分了，考虑到有通道分离的要求，所以先把3个通道的数据提取出来，彩色图像变成数组时，是用三维数组存储的，前两个维度表示行列对应位置的像素值，第三个维度表示颜色通道，这里的通道顺序是rgb（而如果用opencv库的话，就是gbr），也就是说，<code>im[0,0,0]、im[0,0,1]、im[0,0,1]</code>就分别表示左上角那个像素的红色、绿色和蓝色值，这三个值叠加以后的结果就是彩色图像看上去的颜色，因此分离通道后，得到的是3个二维数组，如下：</p>
<p><code>r, g, b = im[:, :, 0], im[:, :, 1], im[:, :, 2]</code></p>
<ol>
<li><p>反色：这里构造一个和<code>im</code>尺寸一致且元素都是255的新数组，用这个新数组减去<code>im</code>即可。</p>
<p><code>im2 = np.ones_like(im) * 255 - im</code></p>
</li>
<li><p>灰度：按照公式对分离出来的r、g、b三个通道进行运算即可。</p>
<p><code>im3 = r * 0.299 + g * 0.587 + b * 0.114</code></p>
</li>
<li><p>水平镜像：每一行的元素逆序</p>
<p>这里是二维数组，也就是说要逆序的是列坐标，所以是第二维逆序</p>
<p><code>im4 = im[:, ::-1]</code></p>
</li>
<li><p>垂直镜像：每一列的元素逆序</p>
<p>同上，第一维逆序</p>
<p><code>im5 = im[::-1]</code></p>
</li>
<li><p>转置：这里的图像是三维数组，所以使用transpose函数来做，简单来说就是原本的第一、二维交换顺序，也就是<code>transpose(0,1,2)—&gt;transpose(1,0,2)</code></p>
<p><code>im6 = im.transpose(1, 0, 2)</code></p>
</li>
<li><p>逆时针90度：矩阵逆时针90度的操作是左乘一个负对角线上均是1、其余都是0的方阵，也就是说，转置矩阵逆序即可</p>
<p><code>im7 = im.transpose(1, 0, 2)[::-1]</code></p>
</li>
<li><p>三通道图像：把其他通道都变成0即可，最后把3个图拼起来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B_im = im.copy()</span><br><span class="line">B_im[:, :, [<span class="number">0</span>, <span class="number">1</span>]] = <span class="number">0</span></span><br><span class="line">G_im = im.copy()</span><br><span class="line">G_im[:, :, [<span class="number">0</span>, <span class="number">2</span>]] = <span class="number">0</span></span><br><span class="line">R_im = im.copy()</span><br><span class="line">R_im[:, :, [<span class="number">2</span>, <span class="number">1</span>]] = <span class="number">0</span></span><br><span class="line">im8 = np.concatenate((R_im, G_im, B_im), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>红色拉满：把红色通道变成255即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">im9 = im.copy()</span><br><span class="line">im9[:, :, <span class="number">0</span>] = <span class="number">255</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通道重组：这里要想明白通道怎么组合，剩下的就很好做了。红色变成蓝色，绿色变成红色，蓝色变成绿色，也就是原本是红色的数值要变成蓝色通道，绿色数值变成红色通道，蓝色数值变成绿色通道，因此通道原本的<code>(0,1,2)</code>变成现在的<code>(1,2,0)</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">im10 = im.copy()</span><br><span class="line">im10 = im10[:, :, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-9</title>
    <url>/2020/04/22/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-9/</url>
    <content><![CDATA[<p>这一课是爬虫。</p>
<a id="more"></a>
<ol>
<li>使用两个库：<ol>
<li>Requests：获取网络数据</li>
<li>BeautifulSoup：分析网络数据</li>
</ol>
</li>
</ol>
<h3 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h3><ol>
<li><p>获取某网址信息：<code>requests.get(url, params=None, **kwargs)</code></p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">html= requests.get(<span class="string">"html://www.bnu.edu.cn"</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'bnu.html'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(html.content)		<span class="comment"># 保存html的内容</span></span><br><span class="line">type(html)		<span class="comment"># requests.models.Response</span></span><br><span class="line">html.url		<span class="comment"># 'https://www.bnu.edu.cn/'</span></span><br><span class="line">html.content	<span class="comment"># 二进制内容</span></span><br><span class="line">html.text		<span class="comment"># 字符串（可能乱码）</span></span><br><span class="line">html.encoding	<span class="comment"># 'ISO-8859-1'</span></span><br><span class="line">html.encoding=<span class="string">'utf-8'</span>  <span class="comment">#修改编码</span></span><br><span class="line">html.request.headers	<span class="comment"># 访问方式： &#123;'User-Agent': 'python-requests/2.22.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive'&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>把访问方式伪装成正常浏览器：</p>
<ol>
<li><p>获取浏览器的访问方式：</p>
<ol>
<li><p>在浏览器中打开链接；</p>
</li>
<li><p>按F12，找到Network；</p>
</li>
<li><p>随便选一个资源点一下（如果一个都没有，就刷新一下网页）；</p>
</li>
<li><p>在Request Headers里找到User-Agent并把整个内容复制出来。</p>
<p><img src="https://github.com/kun-bin/image/blob/master/0422.png?raw=true" alt="示意图"></p>
</li>
</ol>
</li>
<li><p>在代码中做伪装：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">head = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36'</span>&#125;</span><br><span class="line">html = requests.get(<span class="string">"http://www.bnu.edu.cn"</span>, headers=head)</span><br><span class="line">html.request.headers	<span class="comment"># 访问方式变成User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h3><ol>
<li><p>分析页面信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">bsObj = BeautifulSoup(html.content, <span class="string">'lxml'</span>)  <span class="comment">#lxml HTML 解析器：速度快，文档容错能力强</span></span><br><span class="line">type(bsObj)		<span class="comment"># bs4.BeautifulSoup</span></span><br><span class="line">bsObj.title     <span class="comment">#获得html中的title标签: &lt;title&gt;北京师范大学&lt;/title&gt;</span></span><br><span class="line">type(bsObj.title )	<span class="comment"># bs4.element.Tag</span></span><br><span class="line">bsObj.img   <span class="comment">#获得html中的第一个img标签: &lt;img alt="" src="images/logo1.png"/&gt;</span></span><br><span class="line">bsObj.a    <span class="comment">#获得html中的第一个a标签: &lt;a href="https://one.bnu.edu.cn" target="_blank"&gt;信息门户&lt;/a&gt;</span></span><br><span class="line">print(type(bsObj.img), type(bsObj.a ))	<span class="comment"># &lt;class 'bs4.element.Tag'&gt; &lt;class 'bs4.element.Tag'&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取标签信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bsObj.a.get_text()	<span class="comment"># '信息门户'</span></span><br><span class="line">bsObj.a.text		<span class="comment"># '信息门户'</span></span><br><span class="line">bsObj.a.attrs		<span class="comment"># &#123;'href': 'https://one.bnu.edu.cn', 'target': '_blank'&#125;</span></span><br><span class="line">bsObj.a[<span class="string">'href'</span>]		<span class="comment"># 获取a标签的href属性值：'https://one.bnu.edu.cn'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>找到特定标签：<code>find( name , attrs , recursive , text , **kwargs )</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alink=bsObj.find(<span class="string">'a'</span>)   <span class="comment"># 没有属性限定，找到第一个a标签</span></span><br><span class="line">print(alink)			<span class="comment"># &lt;a href="https://one.bnu.edu.cn" target="_blank"&gt;信息门户&lt;/a&gt;</span></span><br><span class="line">blink=bsObj.find(<span class="string">'a'</span>,text=<span class="string">'学部院系'</span>)	<span class="comment"># 限定了属性 text的值</span></span><br><span class="line">print(blink)			<span class="comment"># &lt;a href="xbyx/index.htm"&gt;学部院系&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
<p>找到所有指定标签：<code>find_all( name , attrs , recursive , text , limit, **kwargs )</code>返回列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alink=bsObj.find_all(<span class="string">'a'</span>)</span><br><span class="line">print(alink)	<span class="comment"># 所有a标签的列表</span></span><br><span class="line">blink=bsObj.find_all(<span class="string">"a"</span>, limit=<span class="number">2</span>)	<span class="comment"># 只找前两个a标签</span></span><br><span class="line">print(blink)				<span class="comment"># [&lt;a href="https://one.bnu.edu.cn" target="_blank"&gt;信息门户&lt;/a&gt;, &lt;a href="http://xxgk.bnu.edu.cn/" target="_blank"&gt;信息公开&lt;/a&gt;]</span></span><br><span class="line">clink=bsObj.find_all(<span class="string">'span'</span>, class_=<span class="string">"more01"</span>)	<span class="comment"># class值符合要求的span标签</span></span><br><span class="line">print(clink)		<span class="comment"># [&lt;span class="more01"&gt;&lt;img alt="" src="images/more3.png"/&gt;&lt;/span&gt;, &lt;span class="more01"&gt;&lt;img alt="" src="images/more3.png"/&gt;&lt;/span&gt;, &lt;span class="more01"&gt;&lt;img alt="" src="images/more3.png"/&gt;&lt;/span&gt;, &lt;span class="more01"&gt;&lt;img alt="" src="images/more3.png"/&gt;&lt;/span&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">imglist = bsObj.find_all(<span class="string">'img'</span>, &#123;<span class="string">"src"</span>:re.compile(<span class="string">".+\.jpg"</span>)&#125;)	<span class="comment"># 符合正则表达的标签</span></span><br><span class="line">print(imglist)</span><br><span class="line"></span><br><span class="line">dlink=bsObj.find(<span class="string">'div'</span>, class_=<span class="string">"nav"</span>).find_all(<span class="string">'a'</span>)	<span class="comment"># find和findall结合使用</span></span><br><span class="line">print(dlink)</span><br></pre></td></tr></table></figure>
</li>
<li><p>相对url转绝对url：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> requests.compat <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">url=<span class="string">'https://www.bnu.edu.cn/'</span></span><br><span class="line">blink = urljoin(url, blink[<span class="string">'href'</span>])</span><br><span class="line">print(blink)	<span class="comment"># https://www.bnu.edu.cn/xbyx/index.htm</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>图像相关（img标签）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clink=bsObj.find(<span class="string">'img'</span>)</span><br><span class="line">print(clink)			<span class="comment"># &lt;img alt="" src="images/logo1.png"/&gt;</span></span><br><span class="line">print(clink[<span class="string">'src'</span>])		<span class="comment"># images/logo1.png</span></span><br><span class="line">logo= requests.get(urljoin(url, clink[<span class="string">'src'</span>]), headers=head) <span class="comment">#获得图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">im=Image.open(BytesIO(logo.content))</span><br><span class="line">im.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存图像</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r'D:\2020Python\Ch8\BNU-logo.png'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f: </span><br><span class="line">    f.write(logo.content)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r'D:\2020Python\Ch8\BNU-logo.'</span>+clink[<span class="string">'src'</span>][<span class="number">-3</span>:], <span class="string">'wb'</span>) <span class="keyword">as</span> f: </span><br><span class="line">    f.write(logo.content)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>class</code>标签的访问：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dlink=bsObj.find('span', class="col-md-10")  #class 是关键词，不能这样使用</span><br><span class="line"><span class="comment"># 解决方案1</span></span><br><span class="line">dlink=bsObj.find(<span class="string">'div'</span>, class_=<span class="string">"item-txt01"</span>)</span><br><span class="line">print(dlink)</span><br><span class="line"><span class="comment"># 解决方案2</span></span><br><span class="line">dlink=bsObj.find(<span class="string">'div'</span>, &#123;<span class="string">'class'</span>:<span class="string">'item-txt01'</span>&#125;)</span><br><span class="line">print(dlink.text)</span><br></pre></td></tr></table></figure>
</li>
<li><p>网页源码树状结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clink=bsObj.find(<span class="string">'li'</span>)</span><br><span class="line">clink.parent  <span class="comment">#父节点</span></span><br><span class="line">clink.children  <span class="comment">#孩子节点</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> clink.children:</span><br><span class="line">    print(child)	<span class="comment"># 输出子节点</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> clink.descendants:    <span class="comment">#子孙节点，后代节点</span></span><br><span class="line">    print(child)</span><br><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> clink.next_siblings:  <span class="comment">#兄弟节点</span></span><br><span class="line">    print(sibling)</span><br><span class="line">clink.find_parent(<span class="string">'div'</span>, class_=<span class="string">'nav'</span>)  <span class="comment">#满足class为‘nav’的父节点</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> clink.findChildren(<span class="string">'a'</span>):  <span class="comment">#找到 a标签 孩子</span></span><br><span class="line">    print(child)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="爬取网页所有图片的示例"><a href="#爬取网页所有图片的示例" class="headerlink" title="爬取网页所有图片的示例"></a>爬取网页所有图片的示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#只爬取url网页上的图片，不爬next网页上的图片</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> requests.compat <span class="keyword">import</span> urljoin</span><br><span class="line">url = <span class="string">'http://news.bnu.edu.cn/sj/gysd/index.htm'</span></span><br><span class="line">head = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36'</span>&#125;</span><br><span class="line">html = requests.get(url, headers = head)</span><br><span class="line">bsObj= BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">allLinks = bsObj.find_all(<span class="string">'div'</span>, class_=<span class="string">"grid"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> allLinks:</span><br><span class="line">    imglink = i.find(<span class="string">'img'</span>)[<span class="string">'src'</span>]	</span><br><span class="line">    imglink = urljoin(url, imglink)	<span class="comment"># 图片链接</span></span><br><span class="line">    name = i.find(<span class="string">'h3'</span>).text		<span class="comment"># 图片标题</span></span><br><span class="line">    print(imglink, name)</span><br><span class="line">    img  = requests.get(imglink, headers = head)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">r'D:\2020Python\Ch8\图片/'</span>+name+imglink[<span class="number">-4</span>:], <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(img.content)		<span class="comment"># 保存图片</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#爬取本网页以及下一页的图片</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.compat <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">url=<span class="string">'http://news.bnu.edu.cn/sj/gysd/index.htm'</span></span><br><span class="line">head = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36'</span>&#125;</span><br><span class="line">path=<span class="string">'D:/2020Python/Ch8/光影师大/'</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">    os.mkdir(path)</span><br><span class="line">nexturl=url</span><br><span class="line"><span class="keyword">while</span> nexturl:</span><br><span class="line">    html = requests.get(nexturl, headers=head)</span><br><span class="line">    bsObj=BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">    imgslink=bsObj.find_all(<span class="string">'div'</span>, class_=<span class="string">"grid"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> imgslink:</span><br><span class="line">        imglink=i.find(<span class="string">'img'</span>)[<span class="string">'src'</span>]</span><br><span class="line">        imglink=urljoin(nexturl,imglink)</span><br><span class="line">        name=i.find(<span class="string">'h3'</span>).text</span><br><span class="line">        name=<span class="string">''</span>.join([i <span class="keyword">for</span> i <span class="keyword">in</span> name <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'\\'</span>,<span class="string">'/'</span>,<span class="string">':'</span>,<span class="string">'*'</span>,<span class="string">'?'</span>,<span class="string">'"'</span>,<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'|'</span>]])</span><br><span class="line">        print(imglink, name)        </span><br><span class="line">        img=requests.get(urljoin(nexturl,imglink), headers=head)</span><br><span class="line">        <span class="keyword">with</span> open(path+name+imglink[<span class="number">-4</span>:], <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(img.content)        </span><br><span class="line">    temp=bsObj.find(<span class="string">'a'</span>,class_=<span class="string">"next"</span>)	<span class="comment"># 获取next标签（下一页）</span></span><br><span class="line">    <span class="keyword">if</span> temp:</span><br><span class="line">        nexturl=urljoin(nexturl,temp[<span class="string">'href'</span>])	<span class="comment"># 获取下一页的url</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nexturl=<span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h3><p>抓取北京师范大学中头条关注网站： <a href="http://news.bnu.edu.cn/zx/ttgz/index.htm" target="_blank" rel="noopener">http://news.bnu.edu.cn/zx/ttgz/index.htm</a> 上迄今为止所 有头条关注报道的发表日期、标题、链接以及浏览次数，保存为 一个csv文件，要求使用函数封装。</p>
<p>思路：</p>
<ol>
<li><p>导入所需库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> requests.compat <span class="keyword">import</span> urljoin</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析这个网站，发现了很神奇的一点，该网站一共68页，应该只有第68页没有<code>next</code>标签，但实际上它第67页就没了。如果用保存图像那个例子里的方式访问，则无法访问到第68页，所以考虑写个函数来获取网站一共多少页，然后<code>for</code>循环读网页内容。</p>
<p>经过仔细观察，可以发现网页下面有一个元素用来显示“现在是第几页/总共多少页”，源代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pages "</span>&gt;</span></span><br><span class="line">		   			            页数：<span class="tag">&lt;<span class="name">span</span>&gt;</span>1/68<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">          总数：<span class="tag">&lt;<span class="name">span</span>&gt;</span>680<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">						</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index.htm"</span> <span class="attr">class</span>=<span class="string">"on_pages"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index1.htm"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index2.htm"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index3.htm"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index4.htm"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index5.htm"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index6.htm"</span>&gt;</span>7<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index7.htm"</span>&gt;</span>8<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index8.htm"</span>&gt;</span>9<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index9.htm"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index1.htm"</span> <span class="attr">class</span>=<span class="string">"next"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../../images/pages04.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index10.htm"</span> <span class="attr">class</span>=<span class="string">"end"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../../images/pages05.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因此可以找到<code>class = pages</code> 的<code>div</code>标签，然后获取其中<code>span</code>标签的内容，并截取<code>/</code>符号后面的内容转为数字，即可得到网站页数，写成函数的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page</span><span class="params">(url, head)</span>:</span></span><br><span class="line">    html = requests.get(url, headers=head)</span><br><span class="line">    bsObj = BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">    <span class="keyword">return</span> int(bsObj.find(class_=<span class="string">"pages"</span>).find(<span class="string">'span'</span>).text.split(<span class="string">'/'</span>)[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来可以通过<code>for</code>循环访问每一页，第一页是<code>index.htm</code>，接下来是<code>index1.htm</code>等等，直到最后是<code>index67.htm</code>。</p>
<ol>
<li><p>分析网页源码可知，在每一页中，我们需要提取的内容一定在<code>class = item-info01</code>的标签中，因此使用<code>findall</code>然后遍历得到的标签列表。</p>
</li>
<li><p>分析每个标签源码可知，文章标题出现在<code>h3</code>中，即<code>title = i.find(&#39;h3&#39;).text</code>。</p>
</li>
<li><p>文章链接是<code>a</code>标签的<code>href</code>属性，是相对链接，要转换为绝对链接，不过这里需要注意，有一些文章用了微信链接等站外网页作为内容，因此这些链接是绝对链接，不需要转换。所以要判断一下首字母是否为<code>h</code>。此外，在我们保存的时候，链接后面要加浏览次数，直接用逗号分隔会导致打开csv时链接和浏览次数连在一起，所以链接本身保存时在末尾加个空格。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">link = i.find(<span class="string">'a'</span>)[<span class="string">'href'</span>]</span><br><span class="line"><span class="keyword">if</span> link[<span class="number">0</span>] != <span class="string">'h'</span>:</span><br><span class="line">	link = urljoin(url, link)</span><br><span class="line">link += <span class="string">' '</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>文章时间是<code>class = time</code>的<code>span</code>标签对应的内容，即<code>time = i.find(&#39;span&#39;, class_=&quot;time&quot;).text</code>。</p>
</li>
<li><p>最后是文章浏览次数，这个网站浏览次数是用script做的，所以要跳转到对应链接，然后从新网页里获取浏览次数。对应的相对链接是<code>script</code>标签中的<code>src</code>属性，因此要跳转的新网页是<code>urljoin(url, i.find(&#39;script&#39;)[&#39;src&#39;])</code>，这个网页的内容只有<code>document.write(&#39;31&#39;)</code>这样的字符，所以获取网页内容后提取它17位开始、倒数第3位结束的内容即可得到浏览次数（类型为字符串）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">viewlink = urljoin(url, i.find(<span class="string">'script'</span>)[<span class="string">'src'</span>])</span><br><span class="line">view = BeautifulSoup(requests.get(viewlink).text, <span class="string">'lxml'</span>).text[<span class="number">16</span>:<span class="number">-3</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后把上述内容按顺序加到列表中，然后在整个循环结束后返回列表即可。完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analy</span><span class="params">(page, url, head)</span>:</span></span><br><span class="line">    lists = []</span><br><span class="line">    nexturl = url</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(page):</span><br><span class="line">        html = requests.get(nexturl, headers=head)</span><br><span class="line">        bsObj = BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">        allLink = bsObj.find_all(class_=<span class="string">"item-info01"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> allLink:</span><br><span class="line">            title = i.find(<span class="string">'h3'</span>).text</span><br><span class="line">            link = i.find(<span class="string">'a'</span>)[<span class="string">'href'</span>]</span><br><span class="line">            <span class="keyword">if</span> link[<span class="number">0</span>] != <span class="string">'h'</span>:</span><br><span class="line">                link = urljoin(url, link)</span><br><span class="line">            link += <span class="string">' '</span></span><br><span class="line">            time = i.find(<span class="string">'span'</span>, class_=<span class="string">"time"</span>).text</span><br><span class="line">            viewlink = urljoin(url, i.find(<span class="string">'script'</span>)[<span class="string">'src'</span>])</span><br><span class="line">            view = BeautifulSoup(requests.get(viewlink).text, <span class="string">'lxml'</span>).text[<span class="number">16</span>:<span class="number">-3</span>]</span><br><span class="line">            lists.append([time, title, link, view])</span><br><span class="line">        nexturl = urljoin(nexturl, <span class="string">'index'</span> + str(index + <span class="number">1</span>) + <span class="string">'.htm'</span>)</span><br><span class="line">    <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>在得到列表后，根据要求输出csv文件，这部分内容是上一课讲过的，基本没有变化，注意编码要用<code>utf-8-sig</code>，如果用其他编码，保存的中文会乱码；如果只是<code>utf-8</code>没<code>sig</code>，则excel打开时中文会乱码。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writecsv</span><span class="params">(lists)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"reportsInfo.csv"</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>, encoding=<span class="string">'utf-8-sig'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f_csv = csv.writer(f)</span><br><span class="line">        headers = [<span class="string">'日期'</span>, <span class="string">'标题'</span>, <span class="string">'链接'</span>, <span class="string">'浏览次数'</span>]</span><br><span class="line">        f_csv.writerow(headers)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> lists:</span><br><span class="line">            f_csv.writerow(row)</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后是主函数部分，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">head = &#123;</span><br><span class="line">    <span class="string">'user-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36'</span>&#125;</span><br><span class="line">url = <span class="string">'http://news.bnu.edu.cn/zx/ttgz/index.htm'</span></span><br><span class="line">page = page(url, head)</span><br><span class="line">lists = analy(page, url, head)</span><br><span class="line">writecsv(lists)</span><br><span class="line">print(<span class="string">"FIN"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-8</title>
    <url>/2020/04/17/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-8/</url>
    <content><![CDATA[<p>这一课讲文件读写。</p>
<a id="more"></a>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ol>
<li><p>文件类型：文本文件（纯文本、源代码、网页）、二进制文件（图片、word、excel、ppt）</p>
</li>
<li><p>读文本文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">r'/path/to/file'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    s = f.read()</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>这样用<code>with open as</code>可以不用写<code>close</code></p>
</li>
<li><p>open函数：<code>open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code> 返回一个文件对象，是可迭代对象</p>
</li>
<li><p>tell函数：<code>f.tell()</code>返回文件指针当前在的位置</p>
</li>
<li><p>文本文件操作：</p>
<p>以下都是写在<code>with open</code>的代码块里面</p>
<ol>
<li>读文本文件：<ol>
<li><code>f.readline()</code>：读一行，到换行符结束，返回字符串</li>
<li><code>f.read(2)</code>：接着读2个字符，返回字符串</li>
<li><code>f.readlines()</code>：把剩下的都读完，返回列表，每一行作为列表中的一个元素</li>
</ol>
</li>
<li>写文本文件：<ol>
<li><code>f.write</code>：写入字符串，不换行，可以在字符串末尾加<code>\n</code>来实现换行</li>
<li><code>f.writelines</code>：写入列表元素，不换行，可以在要换行的元素末尾加<code>\n</code></li>
</ol>
</li>
<li>文件模式相关：<ol>
<li>用新建文件的模式（<code>x</code>）来open文件，如果存在同名文件，则会报错</li>
<li>用<code>w</code>方式写文件，如果存在同名文件，会清空原有内容再写入</li>
<li>用<code>a</code>方式写文件，存在同名文件的时候，不会清空内容，而是在文件末尾写入新内容</li>
<li>用<code>r+</code>的方式读写文件，默认位置为文件开头，读完以后移到结尾</li>
<li>用<code>w+</code>的方式读写文件，清空文件内容以后读写</li>
<li>用<code>a+</code>的方式读写文件，默认位置是文件末尾</li>
<li>带+的都是可读可写，不带+的则只有读或者写</li>
</ol>
</li>
<li>改变文件读写位置：<code>seek(offset, whence=0)</code>，从whence(0起始，1当前，2末尾)偏移offset个字节。例如<code>f.seek(0)</code>可以把文件指针放到最开始的地方。</li>
<li>字符字节说明：utf-8编码中文3字节英文1字节；gbk编码中文2字节英文1字节</li>
</ol>
</li>
<li><p>二进制文件操作：</p>
<ol>
<li>open函数的打开模式为<code>b</code></li>
</ol>
</li>
<li><p>CSV文件：文本文件</p>
<ol>
<li>由若干条记录组成，每条记录由字段组成，字段间由分 隔符分开，最常见的分隔符是逗号，也可以是制表符、分号等</li>
<li>列表读写：<code>csv.reader</code>和<code>csv.writer</code></li>
<li>字典读写：<code>csv.DictReader</code>和<code>csv.DictWriter</code></li>
<li><code>csv.reader(csvfile, dialect=‘excel’, **fmtparams)</code>：以字符串列表的形式读入文件内容，一行是一个列表<ol>
<li>是可迭代对象，可以通过<code>next</code>访问，比如读完文件先用next把第一行存在标题变量里，再遍历剩下的内容</li>
</ol>
</li>
<li><code>csv.writer(csvfile, dialect=‘excel’, **fmtparams)</code>：把字符串列表写入csv文件，注意先写入标题行，再写入剩下内容</li>
<li><code>csv.DictReader(csvfile, fieldnames=None, restkey=None, restval=None, dialect=‘excel’, *args, **kwds)</code>字典方式读入，标题是key，内容是value<ol>
<li>csv文件没有标题行时，可以设定列表指定标题行，然后<code>csv.DictReader(f,headers)</code>来建立内容和标题一一对应的字典</li>
</ol>
</li>
<li><code>csv.DictWriter(csvfile, fieldnames, restval=‘’, extrsaction=‘raise’, dialect=‘excel’, *args, **kwds)</code> 要指定标题行和内容，在创建csv对象时就指定标题，接下来写入标题，最后写入内容</li>
</ol>
</li>
</ol>
<h3 id="随堂练习"><a href="#随堂练习" class="headerlink" title="随堂练习"></a>随堂练习</h3><ol>
<li><p>读入《Declaration.txt》文件，该文件里存的是一篇英文文章 ，要求把这篇文章中的不重复单词（单词的不同时态以及单复数都 看成是不同的单词）进行排序后写入一个新的txt文件，并要求每行 5个单词，同时注意对齐。</p>
<p>思路：</p>
<ol>
<li><p>使用<code>with open</code>方式读入文件并把其中的单词存入列表；</p>
</li>
<li><p>借助<code>Counter</code>统计词频和排序</p>
</li>
<li><p>把排序之后的列表写入新文件</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 读入文件内容，把单词存入列表并返回</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strtolist</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open (name,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        s = f.read()</span><br><span class="line">    words = re.findall(<span class="string">r'[a-zA-Z]+'</span>,s)</span><br><span class="line">    <span class="keyword">return</span> words</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对列表中的单词按字母顺序排序并返回</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortword</span><span class="params">(words)</span>:</span></span><br><span class="line">    list1 = collections.Counter(words)</span><br><span class="line">    list2 = sorted(list1.items())</span><br><span class="line">    list3 = []</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> list2:</span><br><span class="line">        list3.append(key)</span><br><span class="line">    <span class="keyword">return</span> list3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把列表中的元素按要求写入文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writefile</span><span class="params">(lists)</span>:</span></span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'wordlist.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> lists:</span><br><span class="line">            f.write(<span class="string">'&#123;:&lt;16&#125;'</span>.format(i))</span><br><span class="line">            f.write(<span class="string">'\t'</span>)</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                f.write(<span class="string">'\n'</span>)</span><br><span class="line">                </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    words = strtolist(<span class="string">'Declaration.txt'</span>)</span><br><span class="line">    lists = sortword(words)</span><br><span class="line">    writefile(lists)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>读入存有姓名和成绩的 成绩单.csv 文件，计算最终加权成绩（ 小数点后保留两位，三个成绩的权重分别为0.22,0.18,0.6），并 把该成绩追到到原有信息中，保存为一个新的csv文件。</p>
<p>思路：</p>
<ol>
<li><p>读入csv文件，并为标题行添加“最终成绩”</p>
</li>
<li><p>计算平均分并添加到这一行的末尾，保留2位小数</p>
</li>
<li><p>把这一行的数据存到列表中</p>
</li>
<li><p>把刚才的内容逐行写入新的csv文件，注意这里要在之前那个文件关闭之前完成</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line"><span class="keyword">with</span> open (<span class="string">'成绩单.csv'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv=csv.reader(f)</span><br><span class="line">    headers = next(f_csv)</span><br><span class="line">    headers.append(<span class="string">'最终成绩'</span>)</span><br><span class="line">    lists = []</span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> f_csv:</span><br><span class="line">        avg = <span class="number">0.22</span>*int(row[<span class="number">1</span>])+<span class="number">0.18</span>*int(row[<span class="number">2</span>])+<span class="number">0.6</span>*int(row[<span class="number">3</span>])</span><br><span class="line">        row.append(avg)</span><br><span class="line">        row[<span class="number">4</span>]=str(<span class="string">'&#123;:.2f&#125;'</span>.format(row[<span class="number">4</span>]))</span><br><span class="line">        lists.append(row)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'新成绩单.csv'</span>,<span class="string">'w'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> s:</span><br><span class="line">        s_csv=csv.writer(s)</span><br><span class="line">        s_csv.writerow(headers)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> lists:</span><br><span class="line">            s_csv.writerow(row)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-7</title>
    <url>/2020/04/16/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-7/</url>
    <content><![CDATA[<p>这一课讲python中函数和模块的使用。</p>
<a id="more"></a>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><ol>
<li><p>函数定义时可以为参数指定默认值，这样没传参的时候就会用默认值，要先声明没默认值的参数，再声明有默认值的。</p>
</li>
<li><p>调用函数时可以直接指明参数值（<code>mysum1(score1 = 88, score2 = 79)</code>)，不指明的参数写前面，指明的放后面。</p>
</li>
<li><p>指针（*）形式传递可变参数，以元组形式打包多出来的参数，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum2</span><span class="params">(a,b,*c)</span>:</span></span><br><span class="line">	total=a+b</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> c:</span><br><span class="line">        total=total+n</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">print(my_sum2(<span class="number">1</span>,<span class="number">2</span>))				<span class="comment">#c=()	输出3</span></span><br><span class="line">print(my_sum2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))		<span class="comment">#c=(3,4,5)	输出15</span></span><br><span class="line">print(my_sum2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>))	<span class="comment">#c=(3,4,5,10,20)	输出45</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>双指针（**）形式传递可变参数，以字典形式打包多出来的参数，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum3</span><span class="params">(a,b,*c,**d)</span>:</span></span><br><span class="line">	total=a+b</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> c:</span><br><span class="line">        total=total+n</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">        total=total+d[key]</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">print(my_sum3(<span class="number">1</span>,<span class="number">2</span>))							<span class="comment">#c=() d=&#123;&#125; 输出3</span></span><br><span class="line">print(my_sum3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))					<span class="comment">#c=(3,4,5) d=&#123;&#125; 输出15</span></span><br><span class="line">print(my_sum3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,male=<span class="number">6</span>,female=<span class="number">7</span>))	<span class="comment">#c=(3,4,5) d=&#123;'male':6,'female':7&#125; 输出28</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><em>或*</em>的参数如果不位于形参列表的最后位置，则会使其后面声 明的参数为强制命名参数；使用一个星号而不带参数，也可导致强制命名参数。</p>
</li>
<li><p>列表、元组、字典可通过<em>和*</em>作为参数传递给函数。</p>
</li>
<li><p>形参复制了实参所指对象的引用</p>
</li>
</ol>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><ol>
<li>返回多个值时，是元组形式。</li>
</ol>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ol>
<li><p>局部变量全局变量和其他语言基本一致</p>
</li>
<li><p>只要在函数体内有赋值语句，不管在哪一行，这个变量就是局部变量，函数体内也只会用这个局部变量，而不是同名全局变量，例如下述代码会直接报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    print(var)</span><br><span class="line">    var=<span class="number">200</span></span><br><span class="line">fun()</span><br><span class="line"></span><br><span class="line">var=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    var+=<span class="number">1</span></span><br><span class="line">    print(var)</span><br><span class="line">fun()</span><br><span class="line"></span><br><span class="line">报错信息：local variable <span class="string">'var'</span> referenced before assignment</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数体内用全局变量，要声明<code>global</code></p>
</li>
<li><p>函数嵌套函数时，内层函数变量作用域只在内层，不影响外层，如果要内层用外层的，要声明<code>nonlocal</code></p>
</li>
</ol>
<h2 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h2><ol>
<li><p>递归</p>
</li>
<li><p>函数可以作为其他函数的参数</p>
</li>
<li><p>lambda匿名函数：实现行内函数 <code>lambda 形参列表:返回的结果</code></p>
<p>例如：<code>f=lambda x,y: x+y</code>，<code>f(12,34)=46</code></p>
</li>
<li><p>map函数：以把一个函数作用到可迭代对象（如列表）的每一个 元素。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">-2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">b=map(<span class="keyword">lambda</span> x: x+<span class="number">2</span>, a)</span><br><span class="line">print(b)	<span class="comment">#b是一个可迭代对象，print得到它的地址，for循环输出可知b=0,3,5</span></span><br><span class="line">c=map(abs, a)</span><br><span class="line">c=list(c)</span><br><span class="line">print(c)	<span class="comment">#c=[2,1,3]</span></span><br><span class="line">d=map(<span class="keyword">lambda</span> x,y: x+y, a,c)</span><br><span class="line">print(list(d))	<span class="comment">#输出[0,2,6]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>filter函数：筛选出可迭代对象中满足条件的元素，<code>filter( 返回bool类型的函数, 可迭代对象)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=filter(<span class="keyword">lambda</span> x: x&gt;<span class="number">0</span>, (<span class="number">-1</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">0</span>,<span class="number">5</span>))</span><br><span class="line">print(list(a))		<span class="comment"># [2,5]</span></span><br><span class="line">b=filter(str.isalpha, (<span class="string">'word'</span>,<span class="string">','</span>,<span class="string">'\n'</span>,<span class="string">'$'</span>,<span class="string">'1'</span>))</span><br><span class="line">print(list(b))		<span class="comment"># ['word']</span></span><br><span class="line">c=filter(<span class="literal">None</span>,(<span class="number">-1</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">0</span>,<span class="number">5</span>))</span><br><span class="line">print(list(b))		<span class="comment"># [-1,2,-3,5] 传入None时会把序列中的false值比如0、空值等都去掉</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>reduce函数：对可迭代对象的元素进行递归计算，<code>reduce( 带两个参数的函数, 可迭代对象)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=functools.reduce(operator.add,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>])</span><br><span class="line">print(a)	<span class="comment">#25</span></span><br><span class="line">b=functools.reduce(<span class="keyword">lambda</span> x,y:x+y,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>])</span><br><span class="line">print(b)	<span class="comment">#25</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h3><ol>
<li><p>对第二次作业进行函数封装，按功能封装成几个函数。</p>
<p>这个没啥说的，本来就是用函数写的。</p>
</li>
<li><p>利用map、filter、reduce、lambda函数，对一个元素为数字 字符串的列表，分别求出其中包含的所有奇数的乘积以及所有 偶数的乘积。</p>
<p>思路：首先要把列表<code>l</code>的元素从字符串转成整数，从而才能进行奇偶性判断和乘法运算，这里用<code>map</code>函数来完成；接下来用<code>filter</code>函数就可以把奇数和偶数分别放到两个列表中，最后用<code>reduce</code>函数即可进行乘法运算，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">l=[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'14'</span>,<span class="string">'20'</span>,<span class="string">'5'</span>,<span class="string">'7'</span>,<span class="string">'39'</span>,<span class="string">'150'</span>,<span class="string">'6'</span>]</span><br><span class="line">m=list(map(<span class="keyword">lambda</span> x: int(x), l))</span><br><span class="line">a=filter(<span class="keyword">lambda</span> x: x%<span class="number">2</span>==<span class="number">0</span>, m)</span><br><span class="line">b=functools.reduce(<span class="keyword">lambda</span> x,y:x*y,list(a))</span><br><span class="line">c=filter(<span class="keyword">lambda</span> x: x%<span class="number">2</span>==<span class="number">1</span>, m)</span><br><span class="line">d=functools.reduce(<span class="keyword">lambda</span> x,y:x*y,list(c))</span><br><span class="line">print(<span class="string">'偶数乘积是'</span>,b)</span><br><span class="line">print(<span class="string">'奇数乘积是'</span>,d)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一次作业第三题打印结果为24的表达式，我们通过嵌套循环 得到列表的全排列，试试采用递归函数求全排列。</p>
<p>思路：</p>
<ol>
<li><p>列表只有1个元素时，全排列就是列表本身；</p>
</li>
<li><p>列表有2个元素时，全排列是[a,b]和[b,a]；</p>
</li>
<li><p>列表有n个元素时，将第一个元素固定，对剩下n - 1个元素进行全排列。再将第一个元素依此与其他元素交换，对每次交换后剩下的n-1个元素进行全排列。对n-1个元素的全排列就是一个递归过程。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutations</span><span class="params">(l, start, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start==end:</span><br><span class="line">        print(l)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        i = start</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(start, end): </span><br><span class="line">            l[j], l[i] = l[i], l[j]</span><br><span class="line">            permutations(l, start + <span class="number">1</span>, end)</span><br><span class="line">            l[i], l[j] = l[j], l[i]            </span><br><span class="line">num=[<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>]</span><br><span class="line">permutations(num, <span class="number">0</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Privacy Policy in Online Social Network with Targeted Advertising Business</title>
    <url>/2020/04/15/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Privacy-Policy-in-Online-Social-Network-with-Targeted-Advertising-Business/</url>
    <content><![CDATA[<h2 id="在线社交网络隐私政策与定向广告业务"><a href="#在线社交网络隐私政策与定向广告业务" class="headerlink" title="在线社交网络隐私政策与定向广告业务"></a>在线社交网络隐私政策与定向广告业务</h2><a id="more"></a>
<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ol>
<li>社交网络提供商SNP利用用户信息实现定向投放广告，广告商付费</li>
<li>隐私政策：SNP应该利用的用户信息比例</li>
<li>用户、广告商、SNP——&gt;三阶段stackelberg博弈</li>
<li>更高的信息利用将阻碍用户展示信息，降低被利用信息的总量，并损害广告收入，基于用户信息等级与隐私策略之间的关联，进一步刻画出最优隐私策略。</li>
</ol>
<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><ol>
<li>广告商决定支付的广告费（更多数据意味着更精准投放——&gt;更高的广告费）：广告商如何在用户信息利用所限制的投放精准度的基础上进行广告投放，以实现预期收益的最大化?</li>
<li>用户决定在社交平台的活跃度（更好的隐私保护——&gt;更活跃）：在隐私受到侵犯的情况下，用户在社交活动中暴露自己的程度如何?</li>
<li>SNP决定隐私政策（广告费和用户活跃度的权衡）：SNP如何采取适当的隐私政策来最大化他的效用，包括社会网络效益和目标广告收入?</li>
</ol>
<h4 id="System-Model"><a href="#System-Model" class="headerlink" title="System Model"></a>System Model</h4><ol>
<li>用户，决定活跃度（在社交平台上发布的信息等级），收益三部分相加组成：<ol>
<li>网络收益：用户在社交平台上进行社交互动所得到的的收益，由用户自己的隐私等级和其他用户的隐私等级共同决定，这部分是一个对数函数（根据梅特卡夫定律决定函数形式）</li>
<li>隐私损失：由【用户提供信息的程度和SNP的隐私等级】对应的函数共同决定（相乘），是一个增函数</li>
<li>补贴：SNP鼓励用户在社交平台积极活跃，会提供固定的补贴，用户有一定概率拿到，拿到的概率由【用户提供信息的程度和SNP的隐私等级】对应的函数共同决定（相乘）</li>
</ol>
</li>
<li>广告商，决定广告费，收益两部分相乘组成：<ol>
<li>一个用户买该产品的净收益（考虑核算收入和生产成本）</li>
<li>目标用户看了广告以后买产品的概率，两部分相加组成：<ol>
<li>由【用户提供信息的程度和SNP的隐私等级】对应的概率</li>
<li>投放不精准的情况下（不能依靠SNP时）的先验概率（就是广告给不感兴趣的人放了之后这个人来买的概率）</li>
</ol>
</li>
<li>上述两部分相乘是一个用户带来的收益，广告商总收益是把所有目标用户的加起来，再减去支付给SNP的广告费</li>
</ol>
</li>
<li>SNP，决定隐私政策和目标广告费，收益三部分相加（减）组成：<ol>
<li>社交网络价值：用户活跃带来的收益，要去掉对用户活跃度的补贴</li>
<li>目标广告收益：单个用户的广告费*目标用户</li>
<li>隐私问题：出现隐私问题时所面临的金钱、名誉损失，有概率，泄露越多损失越大</li>
</ol>
</li>
<li>stackelberg博弈：<ol>
<li>第一阶段SNP考虑用户和广告商的决策来决定隐私等级和广告费</li>
<li>第二阶段用户根据隐私政策决定活跃度</li>
<li>第三阶段广告商根据用户信息和广告费决定是否投放广告</li>
</ol>
</li>
</ol>
<h4 id="Advertiser’s-Decision"><a href="#Advertiser’s-Decision" class="headerlink" title="Advertiser’s Decision"></a>Advertiser’s Decision</h4><ol>
<li>简单的让收益大于广告费，然后显然隐私政策越大（SNP泄露用户信息越多或用户自己暴露越多），广告商越容易挣钱</li>
</ol>
<h4 id="Users’-Behavior"><a href="#Users’-Behavior" class="headerlink" title="Users’ Behavior"></a>Users’ Behavior</h4><ol>
<li>多个用户之间的交互——&gt;多用户信息展示博弈——&gt;纳什均衡：所有用户都收益最大化</li>
<li>信息展示博弈具有超模性：博弈方行为是紧集，收益函数是连续函数且二阶导大于0——&gt;当其他玩家选择更高决策时，该玩家选择更高决策的效用增加得更多——&gt;一个玩家的最佳反应是其他玩家决策的一个非递减函数</li>
<li>所有用户活跃度从0开始，逐个根据其他用户的活跃度调整自己的来最大化收益，直到收敛——&gt;最小纳什均衡</li>
<li>均衡属性分析：<ol>
<li>假设用户效用总的来说是一个凸函数（活跃度越高，活跃度的提高所带来的收益越小，和超模性不冲突）</li>
<li>隐私损失函数是凹函数：越活跃，隐私损失越多</li>
<li>补贴函数是凸函数：越活跃，补贴增长越少</li>
<li>补贴要能弥补隐私损失函数和补贴函数的冲突比例，避免出现大家都是0的场面（从而都是0的场面不是纳什均衡）</li>
<li>处于NE时，隐私政策越高，用户收益越低，存在一个隐私政策阈值，小于这个值（只用很少一部分隐私），用户会选择完全暴露信息（活跃度=1），大于该值，活跃度&lt;1</li>
<li>当隐私政策小于阈值时，【用户提供信息的程度和SNP的隐私等级相乘】随隐私政策增加而增加；大于阈值时，【】随…增加而减小；直接来说就是，用户愿意完全暴露信息时，提取更多信息能更好地服务用户（或者说补贴等等综合下来最好），反之，则隐私提取越少越好了</li>
<li>如果两个用户对社交网络价值的判断相等，那么他们均衡解对应的活跃度也相等；如果不相等，价值判断高的，均衡解时的活跃度也更高；直接说就是，更看重社交价值的会更倾向于高活跃度</li>
</ol>
</li>
</ol>
<h4 id="SNP’s-Decision"><a href="#SNP’s-Decision" class="headerlink" title="SNP’s Decision"></a>SNP’s Decision</h4><ol>
<li>均衡解没有具体形式——&gt;用户均衡解和隐私政策之间的关系来说明SNP效用函数的单调性</li>
<li>广告商收入中的用户数量是离散的，且取决于隐私政策和广告费</li>
<li>将SNP效用函数拆开：<ol>
<li>广告费收益：单个用户广告费*用户个数（由用户活跃度均衡解、隐私政策和单用户广告费共同决定），通过对广告商效用函数的分析，找到固定隐私政策时最优的单用户广告费</li>
<li>社交网络收益—隐私问题：最优广告费作为隐私政策的函数代入，得到最优隐私政策</li>
</ol>
</li>
<li>最优广告费定价问题：<ol>
<li>把用户个数问题转化成了概率问题：广告商有多大概率向某用户投放广告</li>
<li>社交参数简化为两个值：一高一低</li>
</ol>
</li>
<li>隐私问题：<ol>
<li>社交参数依旧只有两个值，对应的均衡解的隐私政策阈值也是两个值</li>
<li>可以推导出效用函数的单调性</li>
<li>假设隐私问题函数是凹函数，广告商效用函数是凸函数，也就是隐私问题越严重，损失增长得会越多，广告商从中得到的收益增长越少——&gt;求导分析找最优隐私政策的特点</li>
</ol>
</li>
</ol>
<h4 id="Numerical-Result"><a href="#Numerical-Result" class="headerlink" title="Numerical Result"></a>Numerical Result</h4><ol>
<li>这部分很少，没说数值实验具体是怎么做的</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>stackelberg game</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-分片相关</title>
    <url>/2020/04/13/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-%E5%88%86%E7%89%87%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>关于区块链分片的几篇论文。</p>
<a id="more"></a>
<h2 id="1-RapidChain-Scaling-Blockchain-via-Full-Sharding"><a href="#1-RapidChain-Scaling-Blockchain-via-Full-Sharding" class="headerlink" title="1. RapidChain: Scaling Blockchain via Full Sharding"></a>1. RapidChain: Scaling Blockchain via Full Sharding</h2><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ol>
<li>分片目的：解除区块链性能和扩展性的限制</li>
<li>分片定义：将处理事务的开销分配给多个更小的节点组，这些组并行工作以最大限度地提高性能，同时显著地减少每个节点的通信、计算和存储，从而允许系统扩展到大型网络。</li>
<li>现有分片协议的问题：扩展性受限制、安全性</li>
<li>本文RapidChain：公链分片</li>
</ol>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><ol>
<li><p>节点分到不同的committees，区块和账本并行</p>
</li>
<li><p>系统中一共<code>n</code>个节点，则每个committee的大小为$m=c logn$，一共有$k=n/m$个committees，<code>c</code>是一个和安全有关的常数</p>
</li>
<li><p>优点：</p>
<ol>
<li>次线性通信：每个事务线性复杂度</li>
<li>高弹性：可以接受<code>1/3</code>的恶意节点</li>
<li>减少每个committee的开销和延迟</li>
<li>安全性：拜占庭容错</li>
<li>跨分片验证：committees通过路由机制发现其他committees</li>
<li>去中心化引导：新加入节点的设计</li>
</ol>
</li>
<li><p>RapidChain按固定时间周期推进，称为epoch，每个epoch结束时由被选中的reference committee（$C_R$)生成下一轮的随机数，该随机数让每个节点在下一轮开始时有新身份，并避免恶意节点的集中和节点共谋</p>
</li>
<li><p>对等发现和committee间的路由，存交易事务$t_x$的committee记作$C_{out}$</p>
</li>
<li><p>跨分片验证：$C_{out}$在生成区块记账之前会和input committee验证交易合法性</p>
</li>
<li><p>分片内共识：</p>
<ol>
<li>分片内成员用当前epoch的随机数选一个临时leader</li>
<li>leader用流言协议把区块发布给分片内所有节点</li>
<li>使用拜占庭协议（基于某论文的同步协议）确保所有节点同意同一个区块</li>
</ol>
</li>
<li><p>重新配置区块：每个epoch结束时由$C_R$产生，包含内容：</p>
<ol>
<li>下一轮的随机数</li>
<li>参与者列表和committee成员</li>
</ol>
<p>想参加下一轮的节点要在一定时间内解题PoW</p>
</li>
<li><p>这篇的related work部分之后可以参考</p>
</li>
</ol>
<h2 id="2-A-Secure-Sharding-Protocol-For-Open-Blockchains"><a href="#2-A-Secure-Sharding-Protocol-For-Open-Blockchains" class="headerlink" title="2. A Secure Sharding Protocol For Open Blockchains"></a>2. A Secure Sharding Protocol For Open Blockchains</h2><h4 id="Abstract-1"><a href="#Abstract-1" class="headerlink" title="Abstract"></a>Abstract</h4><ol>
<li>区块链有安全性，但规模很小，每秒处理3-7笔交易</li>
<li>ELASTICO：1/4拜占庭攻击，分为多个committees，每个处理自己的事务集合（称作分片）</li>
</ol>
<h4 id="Mehtod"><a href="#Mehtod" class="headerlink" title="Mehtod"></a>Mehtod</h4><ol>
<li>按算力分片</li>
<li>每个epoch流程：<ol>
<li>建立自己的公钥、IP并进行PoW，按公钥ID分为不同Committees</li>
<li>节点互相确认身份，记录自己committee有谁</li>
<li>committee内的共识：PBFT，带多数成员签名广播</li>
<li>最终共识广播：有一个final committee来进行合并（PBFT然后把接收的分片区块在committee内实现共识，然后全网广播）</li>
<li>产生下一轮的随机数，大家开始PoW，开始新的一轮</li>
</ol>
</li>
</ol>
<h2 id="3-A-Proof-of-Stake-Sharding-Protocol-for-Scalable-Blockchains"><a href="#3-A-Proof-of-Stake-Sharding-Protocol-for-Scalable-Blockchains" class="headerlink" title="3. A Proof of Stake Sharding Protocol for  Scalable Blockchains"></a>3. A Proof of Stake Sharding Protocol for  Scalable Blockchains</h2><ol>
<li><code>c</code>组，每组<code>n</code>个，一共<code>nc</code>个节点</li>
<li>普通节点组产生中间区块，发送给最终验证节点组</li>
<li>最终验证节点组产生最终区块，全网广播</li>
<li>每个epoch分为4步：<ol>
<li>分组，组内随机选leader，组内节点把身份信息发给leader，leader向其他组的leader广播</li>
<li>组内共识：一个交易随机分到某组，组内节点PoS，产生新的中间区块</li>
<li>最终验证组合并区块，组内PoS，产生最终区块并广播</li>
<li>t轮之后，刷新重组</li>
</ol>
</li>
</ol>
<h2 id="4-Ostraka-Secure-Blockchain-Scaling-by-Node-Sharding"><a href="#4-Ostraka-Secure-Blockchain-Scaling-by-Node-Sharding" class="headerlink" title="4. Ostraka: Secure Blockchain Scaling by Node Sharding"></a>4. Ostraka: Secure Blockchain Scaling by Node Sharding</h2><ol>
<li>采用UTXO、PoS</li>
<li>矿池、UTXO、区块链存储在被称为分片（shard）的几个机器上，机器可以扩展，每个分片的节点数量不一定一样</li>
<li>有一个机器称为 coordinator跟踪区块链并协调节点间的通信，可以要求某分片回滚到某区块链状态或开始新的链</li>
<li>分片有一个ID，由coordinator分配，决定该分片处理哪些事务</li>
<li>女巫分片：节点相同的分片</li>
<li>事务切分存储在对应分片上</li>
<li>总的来说就是有个类似路由器一样的机器来协调处理跨片事务，这篇基本上没看懂，以后有需要再看看</li>
</ol>
<h2 id="5-OptChain-Optimal-Transactions-Placement-for-Scalable-Blockchain-Sharding"><a href="#5-OptChain-Optimal-Transactions-Placement-for-Scalable-Blockchain-Sharding" class="headerlink" title="5. OptChain: Optimal Transactions Placement for Scalable Blockchain Sharding"></a>5. OptChain: Optimal Transactions Placement for Scalable Blockchain Sharding</h2><ol>
<li>新分片方式，最小化跨分片事务，动态事务分配，把相关和即将相关的事务分组到同一分片</li>
<li>对事务分片的依据：<ol>
<li>这样分是否减少了跨片事务</li>
<li>分片间的负载平衡</li>
</ol>
</li>
<li>TaN结构：UTXO模型的事务网络图结构</li>
<li>跨分片事务处理流程：<ol>
<li>用户创建跨分片事务，流言广播</li>
<li>几个UTXO所在的分片锁定UTXO并流言广播许可（或不许可）</li>
<li>接收事务的分片解锁UTXO并记账</li>
</ol>
</li>
<li>对事务分片的算法：<ol>
<li>TaN：把UTXO事务看做图里的节点，然后按图的拓扑结构分析出度和入度</li>
<li>T2S：用PageRank评分，判断节点加入哪个分片——&gt;尽可能减少跨分片事务</li>
<li>L2S：确认延迟，网络结构决定事务得到确认所需的时间——&gt;尽可能加快事务确认速度</li>
<li>T2S和L2S结合选择事务分片</li>
</ol>
</li>
</ol>
<h2 id="6-Poster-A-Proof-of-Stake-PoS-Blockchain-Protocol-using-Fair-and-Dynamic-Sharding-Management"><a href="#6-Poster-A-Proof-of-Stake-PoS-Blockchain-Protocol-using-Fair-and-Dynamic-Sharding-Management" class="headerlink" title="6. Poster: A Proof-of-Stake(PoS) Blockchain Protocol using Fair and Dynamic Sharding Management"></a>6. Poster: A Proof-of-Stake(PoS) Blockchain Protocol using Fair and Dynamic Sharding Management</h2><ol>
<li>每个epoch会重新分片并选择每个分片的block producers</li>
<li>在上一个epoch中，users用自己的信息和一部分资产注册成为validator（验证器），这个epoch开始以后，validator和事务被分成k个分片，分片规则为：<ol>
<li>验证器的地址和上一个区块的哈希值一起哈希然后对分片个数取余，即可得到验证器的分片</li>
<li>事务地址和…，即可得到事务的分片</li>
</ol>
</li>
<li>使用BFT-DPoS算法，在每个分片内选block producers：<ol>
<li>股权最大的成为该分片的producer</li>
<li>所有producers按顺序循环选总的producer</li>
<li>矿工可以投出与他们所持股份的平方根成比例的选票，而不是与所持股份成线性比例的选票。</li>
<li>根据BFT算法，分片的producer产生自己分片的区块，并由总producer合并广播</li>
</ol>
</li>
</ol>
<h2 id="7-SSChain-A-full-sharding-protocol-for-public-blockchain-without-data-migration-overhead"><a href="#7-SSChain-A-full-sharding-protocol-for-public-blockchain-without-data-migration-overhead" class="headerlink" title="7. SSChain: A full sharding protocol for public blockchain  without data migration overhead"></a>7. SSChain: A full sharding protocol for public blockchain  without data migration overhead</h2><ol>
<li><p>公链，拜占庭弹性，对事务分片和对状态分片，节点无需定期切换分片（避免数据冗余），使用UTXO</p>
</li>
<li><p>节点可以自由加入分片而无需刷新，为避免随之而来的51%攻击问题，本文提出了一个双层结构：</p>
<ol>
<li>根链验证分片的区块，避免恶意节点攻击，激励机制保证矿工愿意加入</li>
<li>分片维护不相交的分类帐并独立处理不相交的交易子集。</li>
<li>SSChain背后的关键思想是根链维护系统的安全性，而切分提高了吞吐量并减少了存储需求。</li>
</ol>
</li>
<li><p>同一分片内的交易有更低的确认延迟和更少的交易费用，进而鼓励用户片内交易</p>
</li>
<li><p>解耦事务验证和状态更新，拆分跨分片事务</p>
</li>
<li><p>激励机制：动态调节根链和分片的算力分配，根据参数可得到不同的吞吐量和安全性</p>
</li>
<li><p>跨分片事务：切分成分片内事务，或者由根链处理</p>
</li>
<li><p>根链：PoW，分类帐修剪机制</p>
</li>
<li><p>事务分片：</p>
<ol>
<li>事务地址包含比特币地址和分片ID</li>
<li>交易分类：<ol>
<li>inputs和outputs在一个分片内</li>
<li>inputs在一个分片内，outputs在不同分片</li>
<li>都在不同分片</li>
</ol>
</li>
<li>跨分片事务：<ol>
<li>交给根链——&gt;随分片增长会很难处理</li>
<li>鼓励用户在同一分片内创建新地址——&gt;跨分片变成同一分片</li>
<li>A+B——&gt;C的事务拆分成A——&gt;C和B——&gt;C（个人感觉这没用啊）</li>
</ol>
</li>
</ol>
</li>
<li><p>状态分片：一些节点储存整个区块链的状态而不是只存分片状态</p>
</li>
<li><p>市场激励机制：动态地调整切分和根链之间的哈希功率分配。在激励机制下，矿商可以自由选择最赚钱的碎片，从而避免了周期性的网络重组。有两个目的：</p>
<ol>
<li>为了维护系统安全，根链占用了整个网络的很大一部分算力。由于切分块是由根链网络验证的，恶意对手至少需要根链哈希能力的一半才能进行双倍开销攻击。</li>
<li>算力被鼓励平均分配到碎片中，这样每个碎片都可以正常工作。</li>
</ol>
</li>
</ol>
<h2 id="8-Trust-Based-Shard-Distribution-Scheme-for-Fault-Tolerant-Shard-Blockchain-Networks"><a href="#8-Trust-Based-Shard-Distribution-Scheme-for-Fault-Tolerant-Shard-Blockchain-Networks" class="headerlink" title="8. Trust-Based Shard Distribution Scheme for Fault-Tolerant Shard Blockchain Networks"></a>8. Trust-Based Shard Distribution Scheme for Fault-Tolerant Shard Blockchain Networks</h2><ol>
<li>TBSD：把恶意节点放到不同的分片，使用信任管理系统和遗传算法</li>
<li>定量衡量节点的信任度，对恶意节点进行信用惩罚</li>
<li>遗传算法找到最优分片方法，使得每个分片的信用度都差不多</li>
<li>总的来说信用系统分为5步：<ol>
<li>每一轮开始时，PoS选一个leader出块</li>
<li>全网广播验证区块，少数服从多数</li>
<li>SCO：节点信用表，由验证节点产生，上一步的验证结果作为信用评分的依据</li>
<li>LCR：根据SCO计算得到的相对信用分布矩阵</li>
<li>最终信用评估</li>
</ol>
</li>
<li>攻击模型：<ol>
<li>恶意节点成为leader</li>
<li>节点共谋</li>
<li>恶意节点行为不一致，一会儿诚实一会儿恶意</li>
</ol>
</li>
<li>分片过程：用GA</li>
</ol>
<h2 id="9-Two-Phase-Cooperative-Bargaining-Game-Approach-for-Shard-Based-Blockchain-Consensus-Scheme"><a href="#9-Two-Phase-Cooperative-Bargaining-Game-Approach-for-Shard-Based-Blockchain-Consensus-Scheme" class="headerlink" title="9. Two-Phase Cooperative Bargaining Game Approach for Shard-Based Blockchain Consensus Scheme"></a>9. Two-Phase Cooperative Bargaining Game Approach for Shard-Based Blockchain Consensus Scheme</h2><ol>
<li>分片后，进行议价博弈，事务总的来说平分给每个分片处理</li>
<li>有一个adjust shard负责确认，其他分片进行普通的挖矿</li>
<li>随机数分片，分片内共识：标准拜占庭一致协议，看起来是对节点分片</li>
<li>节点验证事务和参与共识的过程可看做两阶段博弈：<ol>
<li>事务分配问题</li>
<li>基于分片的共识机制</li>
</ol>
</li>
<li>讨价还价博弈这里没完全看懂，感觉就是分片和节点根据奖励和支出决定是否处理事务，上面的4.1里博弈方是分片，4.2的博弈方是区块链节点</li>
</ol>
<h2 id="A-Node-Rating-Based-Sharding-Scheme-for-Blockchain"><a href="#A-Node-Rating-Based-Sharding-Scheme-for-Blockchain" class="headerlink" title="A Node Rating Based Sharding Scheme for Blockchain"></a>A Node Rating Based Sharding Scheme for Blockchain</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Monoxide: Scale Out Blockchain with Asynchronous Consensus Zones</title>
    <url>/2020/04/07/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Monoxide%20Scale%20Out%20Blockchain%20with%20Asynchronous%20Consensus%20Zones/</url>
    <content><![CDATA[<h2 id="突破区块链不可能三角异步共识组"><a href="#突破区块链不可能三角异步共识组" class="headerlink" title="突破区块链不可能三角异步共识组"></a>突破区块链不可能三角异步共识组</h2><p>这篇没看完。</p>
<a id="more"></a>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ol>
<li>背景：加密货币在匿名在线支付方面很重要</li>
<li>问题：<ol>
<li>随用户和交易的增长，低吞吐量阻碍加密货币系统的扩展</li>
<li>每个节点复制整个网络的通信、存储和状态表示也阻碍了系统的扩展</li>
</ol>
</li>
<li>本文：<ol>
<li>Asynchronous Consensus Zones（异步一致网络）：分区域，不影响去中心化和安全性，每个区域独立并行，块内共识；</li>
<li>诸葛连弩系统：使得攻击单独的一个块的难度和攻击整个区块的难度一样大</li>
</ol>
</li>
</ol>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ol>
<li>TPS（每秒交易数）很低的原因在于区块按顺序建立，而网络延迟导致广播时间不能过短</li>
<li>每一个完整的节点都需要复制整个网络的通信、存储和状态表示，系统受限于硬件设备而无法扩展</li>
<li>综上可扩展的区块链要考虑：<ol>
<li>共识协议的可扩展性</li>
<li>通信、存储、计算和内存的资源使用</li>
<li>去中心化和安全性</li>
</ol>
</li>
<li>以太坊已提出分片的设计</li>
<li>本文异步一致网络：<ol>
<li>分区域，通过在多个独立和并行实例(或一致区域)中划分和处理工作负载来扩展区块链系统</li>
<li>整个网络划分为区域，每个区域负责自己那部分，只在区域内复制，挖矿竞争和交易确认等在区块间异步进行</li>
<li>挑战在于：<ol>
<li>跨区域事务的吞吐量</li>
<li>诚实矿工稀释带来的安全性问题</li>
</ol>
</li>
</ol>
</li>
<li>本文最终原子确认：跨区域事务由原子性分解为多个事务，每个事务涉及单独一个区域</li>
<li>本文诸葛连弩：矿工挖矿成功时可以在不同的区域里创建多个区块，其算力平均分配到各个区域，而攻击者的攻击算力同样也被分到了不同区域，因此攻击单独一个区域和攻击整个系统难度一样</li>
</ol>
<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>对比PoS和PoW，UTXO和账户余额</p>
<ol>
<li>影响区块链系统和共识协议性能的因素：一致性（共识）、通信、存储、表示</li>
<li>PoW耗费算力来竞争记账权，但是加密货币一定程度上有对应现实世界的价值；PoS由节点的股权（财富）来决定区块的产生；本文用PoW，但改PoS也行</li>
<li>加密货币有两种交易模型，UTXO和账户余额，以太坊用了后者（更支持智能合约），本文也用了后者，总之账户余额模型有很多优点</li>
</ol>
<h3 id="System-Design"><a href="#System-Design" class="headerlink" title="System Design"></a>System Design</h3><ol>
<li><p>跨区域事务的执行：</p>
<ol>
<li>区域A执行检查余额然后取钱（ withdraw operation），下一个该区域的区块就会更新余额状态等</li>
<li>区域A把存钱（ deposit operation ）打包成一个中继操作（ relay transaction ）发给区域B</li>
<li>区域B执行存钱操作，不需要检查余额</li>
<li>取钱只涉及区域A，存钱只涉及区域B，因此不需要进行区域间的确认等</li>
</ol>
</li>
<li><p>划分和命名（Partitioning and Naming）：</p>
<ol>
<li>用户地址被均匀划分为$2^k$个区域，一个区域由它的分片尺度k和区域索引s来识别</li>
<li>群swarm：参与相同数据集的复制的一组节点。全节点加入群从而广播信息和接收其他全节点的信息。比特币和以太坊系统只有一个群，大家都保存同样的信息。</li>
<li>本文有多个出于不同目的建立的群，采用分布式哈希表(DHT)进行群寻址和对等发现。</li>
<li>系统中有一个包含所有全节点的全局群，用于复制所有区域的最小公共信息。</li>
<li>在每个群内，全节点稀疏分布，使用gossip protocol广播信息</li>
<li>区域特定的群也用分片尺度k和区域索引s来识别</li>
</ol>
</li>
<li><p>单独一个区域：区域间计算和事务相互隔离、独立并行，随网络增长会创建新区域</p>
<ol>
<li>全节点或矿工有特定标识符来决定在哪个区域内工作</li>
<li>每个区域有自己的区块链</li>
<li>矿工只与同区域的PoW竞争记账权</li>
<li>全节点会忽略其他区域的事务消息</li>
</ol>
</li>
<li><p>最小化跨区域开销：</p>
<ol>
<li>系统在每个节点上维护一个分布式哈希表(DHT)</li>
<li>大多数通信用于复制未经确认的事务，并广播带有已确认事务的新块</li>
<li>获取未确认事务或新块对应的区域索引s后，系统在DHT中选择索引相同的节点，通过gossip protocol把事务和区块发给它们。</li>
<li>只把中继事务发给对应区域，而不是全网广播</li>
<li>用于形成链的最小化数据会被复制到所有区域（下一部分讨论）</li>
</ol>
<h3 id="Efﬁcient-Cross-Zone-Atomicity"><a href="#Efﬁcient-Cross-Zone-Atomicity" class="headerlink" title="Efﬁcient Cross-Zone Atomicity"></a>Efﬁcient Cross-Zone Atomicity</h3><ol>
<li>事务分为取钱（relay）和存钱（deposit）操作，分别在对应的区域进行验证</li>
<li>为避免分叉出现的问题：<ol>
<li>取钱验证一次</li>
<li>存钱验证一次</li>
<li>中继操作隔一定数量的区块后才被打包</li>
</ol>
</li>
</ol>
<h3 id="Defense-Per-Zone-Security"><a href="#Defense-Per-Zone-Security" class="headerlink" title="Defense Per-Zone Security"></a>Defense Per-Zone Security</h3><ol>
<li>允许矿工完成一次PoW在多个区域建立多个区块（区块网？），每个区域只能建立一个</li>
<li>参与诸葛连弩的矿工的算力没被稀释，这样攻击单独一个区域所需的算力仍然是50%</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-6</title>
    <url>/2020/04/01/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-6/</url>
    <content><![CDATA[<p>这一课讲第三方库的安装和使用，然后用<code>wordcloud</code>和<code>jieba</code>生成词云图和中文分词。没有课堂练习，只有一个在上次作业基础上的作业。</p>
<p>我是直接<code>pip</code>安装的，在安装<code>wordcloud</code>时，<code>pip install wordcloud</code>很快就装好了，但是<code>jieba</code>反复出错，最后指定清华镜像，<code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple jieba</code>，这样就飞快地安装好了。</p>
<a id="more"></a>
<h3 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h3><p>(4) 利用<code>wordcloud</code>结合<code>jieba</code>分别对李白（杜甫）诗歌内容中的字和词语进行可视化。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>上节课的作业完成后已经得到了处理好的诗歌字符串和字频统计<code>Counter</code>，那么接下来就可以用这两个变量来得到对应的词云图。</p>
<p>用<code>fit_words()</code>函数根据已经得到的计数器<code>poems_counter</code>生成的字典来制作字频的词云图片，用<code>generate()</code>函数对用<code>jieba</code>进行分词之后的<code>poems_text</code>生成词频的词云图片。在保存图片后可以用<code>PIL</code>中的<code>Image.open()</code>和<code>show()</code>来显示图片。对应的函数代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入库</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> wordcloud</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloud_character</span><span class="params">(poems_counter, name)</span>:</span></span><br><span class="line">    dict_character = dict(poems_counter)</span><br><span class="line">    <span class="comment"># 生成图像对应的遮罩，这样词云图就是按图像里非白色区域来填充的</span></span><br><span class="line">    mask = np.array(Image.open(name + <span class="string">'.jpg'</span>))</span><br><span class="line">    <span class="comment"># 根据图像生成颜色表，这样词云图的颜色就和图像一致了</span></span><br><span class="line">    color = wordcloud.ImageColorGenerator(mask)</span><br><span class="line">    <span class="comment"># 生成词云图变量，背景白色，random_state的值影响字在图中的分布，color_func设定词云颜色，mask设定图像遮罩，font_path指定字体，不指定的话中文没法显示</span></span><br><span class="line">    wc = wordcloud.WordCloud(background_color=<span class="string">"white"</span>, random_state=<span class="number">42</span>, color_func=color, mask=mask, font_path=<span class="string">'C:\Windows\Fonts\simsun.ttc'</span>)</span><br><span class="line">    <span class="comment"># 根据字典生成词云图的内容</span></span><br><span class="line">    wc.fit_words(dict_character)</span><br><span class="line">    <span class="comment"># 保存词云图</span></span><br><span class="line">    wc.to_file(name + <span class="string">"cloud_character.png"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloud_word</span><span class="params">(poems_text, name)</span>:</span></span><br><span class="line">    text = <span class="string">' '</span>.join(jieba.cut(poems_text))</span><br><span class="line">    mask = np.array(Image.open(name + <span class="string">'.jpg'</span>))</span><br><span class="line">    color = wordcloud.ImageColorGenerator(mask)</span><br><span class="line">    wc = wordcloud.WordCloud(background_color=<span class="string">"white"</span>, random_state=<span class="number">42</span>, color_func=color, mask=mask, font_path=<span class="string">'C:\Windows\Fonts\simsun.ttc'</span>)</span><br><span class="line">    <span class="comment"># 根据文本字符串生成词云图的内容</span></span><br><span class="line">    wc.generate(text)</span><br><span class="line">    wc.to_file(name + <span class="string">"cloud_word.png"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_pic</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="comment"># 打开图像</span></span><br><span class="line">    img1 = Image.open(name + <span class="string">"cloud_character.png"</span>)</span><br><span class="line">    img2 = Image.open(name + <span class="string">"cloud_word.png"</span>)</span><br><span class="line">    <span class="comment"># 显示图像</span></span><br><span class="line">    img1.show()</span><br><span class="line">    img2.show()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序部分</span></span><br><span class="line">cloud_character(counter_libai, <span class="string">'libai'</span>)</span><br><span class="line">cloud_character(counter_dufu, <span class="string">'dufu'</span>)</span><br><span class="line">cloud_word(text_libai, <span class="string">'libai'</span>)</span><br><span class="line">cloud_word(text_dufu, <span class="string">'dufu'</span>)</span><br><span class="line">show_pic(<span class="string">"libai"</span>)</span><br><span class="line">show_pic(<span class="string">"dufu"</span>)</span><br></pre></td></tr></table></figure>
<p>（最后生成的词云图是真的怪怪的……）</p>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-5</title>
    <url>/2020/03/31/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-5/</url>
    <content><![CDATA[<p>这一课讲的是字典和集合。</p>
<a id="more"></a>
<h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><ol>
<li><p>对于下列财经数据<code>lst</code>，如何构造公司代码和股票价格的字典<code>d</code>？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst=[(<span class="string">'AXP'</span>,<span class="string">'American Epress Company'</span>,<span class="string">'86.40'</span>),</span><br><span class="line">	(<span class="string">'BA'</span>,<span class="string">'The Boeing Company'</span>,<span class="string">'22.64'</span>),</span><br><span class="line">	(<span class="string">'CAT'</span>,<span class="string">'Caterpillar Inc.'</span>,<span class="string">'99.44'</span>),</span><br><span class="line">	(<span class="string">'CSCO'</span>,<span class="string">'Cisco System Inc.'</span>,<span class="string">'23.78'</span>),</span><br><span class="line">	(<span class="string">'CVX'</span>,<span class="string">'Chevron Corporation'</span>,<span class="string">'115.91'</span>)]</span><br><span class="line">d=&#123;<span class="string">'AXP'</span>:<span class="string">'86.40'</span>,<span class="string">'BA'</span>:<span class="string">'122.64'</span>,<span class="string">'CAT'</span>:<span class="string">'99.44'</span>,<span class="string">'CSCO'</span>:<span class="string">'23.78'</span>,<span class="string">'CVX'</span>:<span class="string">'115.91'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>答案：从列表构造字典，根据定义可以直接使用<code>d={a:c for a,b,c in lst}</code></p>
</li>
<li><p>如何把一个字典中的<code>key</code>和<code>value</code>互换？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=&#123;<span class="string">'blue'</span>:<span class="number">500</span>, <span class="string">'green'</span>:<span class="number">300</span>, <span class="string">'red'</span>:<span class="number">100</span>&#125;</span><br><span class="line">&#123;<span class="number">100</span>:<span class="string">'red'</span>, <span class="number">300</span>:<span class="string">'green'</span>, <span class="number">500</span>:<span class="string">'blue'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>答案：使用<code>items</code>属性即可，<code>new_d={value:key for key, value in d.items()}</code></p>
</li>
</ol>
<h3 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h3><ol>
<li>利用内置数据类型对李白和杜甫的诗歌进行分析，包括：</li>
</ol>
<p>(1)读入李白.txt，得到李白诗歌内容中的所有的汉字，并进一步得到其中的不重复汉字，最后打印所有汉字的个数、不重复汉字的个数、以及不重复汉字，打印汉字时要求每行10个汉字，汉字之间以2个空格分开。</p>
<p>(2)进一步利用字典进行李白诗歌的字频统计，即统计每个字出现的次数，并对字频进行归一化处理（即除以诗歌篇数），然后输出显示字频统计结果，输出显示时根据字频降序排列，只打印频率大于等于0.1的结果，并注意对齐。</p>
<p>(3)采用同上述相同的方法，得到杜甫诗歌的字频统计结果。在此基础上获得李白和杜甫的高频词集合（即频率大于等于0.1的汉字集合），利用集合操作进一步获得两位诗人都爱用的字、李白爱用但杜甫不爱用的字以及杜甫爱用而李白不爱用的字，并输出上述结果，输出时每行10个单词，汉字之间以2个空格分开。</p>
<p>说明：统计时不考虑题目、朝代、作者，只考虑诗歌内容。</p>
<p>作业思路：</p>
<p>首先是要读取txt文件，这里作业提示说用下述代码来读取文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'李白.txt'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    poems_text = f.read()</span><br></pre></td></tr></table></figure>
<p>此时整个文件的内容作为字符串存在<code>poems_text</code>中，并且每首诗之间有换行符，因此使用<code>poems_list = poems_text.splitlines()</code>将每首诗作为列表<code>poems_list</code>中的元素（字符串）存储。</p>
<p>接下来遍历列表元素，因为每首诗格式都是“标题 朝代 作者 诗歌内容”这样，所以对每个字符串查找作者名字，并只留存作者名字之后的字符串内容，就可以得到我们需要统计的诗歌内容，再去掉中文标点、英文标点和空格，就得到了一个处理好的诗歌内容列表，这部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(poems_list)):</span><br><span class="line">    index = poems_list[i].find(name)</span><br><span class="line">    poems_list[i] = poems_list[i][index + <span class="number">3</span>:]</span><br><span class="line">    poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, zhon.hanzi.punctuation))</span><br><span class="line">    poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, string.punctuation))</span><br><span class="line">    poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, <span class="string">' '</span>))</span><br></pre></td></tr></table></figure>
<p>这时<code>poems_num = len(poems_list)</code>即可得到诗歌总数，<code>poems_text = &#39;&#39;.join(poems_list)</code>即可得到处理好之后的字符串。然后进行统计。</p>
<p>我们使用<code>poems_counter = collections.Counter(poems_text)</code>可以得到一个<code>Counter</code>计数器，该计数器是一个字典，<code>key</code> 是字，<code>val</code>是该字出现的次数，按出现次数遍历这个计数器，并把<code>key</code>加入到集合<code>poems_set</code>中，当字频（<code>val/poems_num</code>）低于0.1时，break结束遍历，这样就得到了高频字的集合，这部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> poems_counter.most_common():</span><br><span class="line">    <span class="keyword">if</span> val / poems_num &lt; <span class="number">0.1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    poems_set.add(key)</span><br></pre></td></tr></table></figure>
<p>接下来通过集合运算就可以得到李白和杜甫的交集和差集了。</p>
<p>关于格式化输出，首先是输出诗歌本身的字数、不重复字数和不重复字，每10个换行，字中间是两个空格，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(name + <span class="string">'诗词中总共有'</span> + str(len(poems_text)) + <span class="string">'个汉字，其中不重复的汉字有'</span> + str(len(poems_counter)) + <span class="string">'个，具体如下：'</span>)</span><br><span class="line">print_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> poems_counter:</span><br><span class="line">    print(key, end=<span class="string">'  '</span>)</span><br><span class="line">    print_num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> print_num % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        print()</span><br><span class="line">print()</span><br></pre></td></tr></table></figure>
<p>接下来是字频统计的输出，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'字频统计信息如下：\n汉字---频率'</span>)</span><br><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> poems_counter.most_common():</span><br><span class="line">    <span class="keyword">if</span> val / poems_num &lt; <span class="number">0.1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">'&#123;&#125;\t &#123;&#125;'</span>.format(key, val / poems_num))</span><br></pre></td></tr></table></figure>
<p>最后是字频集合的输出，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> set:</span><br><span class="line">    print(i, end=<span class="string">'  '</span>)</span><br><span class="line">    print_num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> print_num % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        print()</span><br><span class="line">print()</span><br></pre></td></tr></table></figure>
<p>整体代码我把诗歌的预处理部分作为一个函数、诗歌输出作为一个函数、集合输出作为一个函数，最后主函数调用它们。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> zhon.hanzi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poems</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(name + <span class="string">'.txt'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        poems_text = f.read()</span><br><span class="line">    poems_list = poems_text.splitlines()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(poems_list)):</span><br><span class="line">        index = poems_list[i].find(name)</span><br><span class="line">        poems_list[i] = poems_list[i][index + <span class="number">3</span>:]</span><br><span class="line">        poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, zhon.hanzi.punctuation))</span><br><span class="line">        poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, string.punctuation))</span><br><span class="line">        poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, <span class="string">' '</span>))</span><br><span class="line">    poems_num = len(poems_list)</span><br><span class="line">    poems_text = <span class="string">''</span>.join(poems_list)</span><br><span class="line">    poems_counter = collections.Counter(poems_text)</span><br><span class="line">    poems_set = set()</span><br><span class="line">    <span class="keyword">for</span> key, val <span class="keyword">in</span> poems_counter.most_common():</span><br><span class="line">        <span class="keyword">if</span> val / poems_num &lt; <span class="number">0.1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        poems_set.add(key)</span><br><span class="line">    <span class="keyword">return</span> poems_num, poems_text, poems_counter, poems_set</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_poem</span><span class="params">(name, poems_num, poems_text, poems_counter)</span>:</span></span><br><span class="line">    print(name + <span class="string">'诗词中总共有'</span> + str(len(poems_text)) + <span class="string">'个汉字，其中不重复的汉字有'</span> + str(len(poems_counter)) + <span class="string">'个，具体如下：'</span>)</span><br><span class="line">    print_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> poems_counter:</span><br><span class="line">        print(key, end=<span class="string">'  '</span>)</span><br><span class="line">        print_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> print_num % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            print()</span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">'字频统计信息如下：\n汉字---频率'</span>)</span><br><span class="line">    <span class="keyword">for</span> key, val <span class="keyword">in</span> poems_counter.most_common():</span><br><span class="line">        <span class="keyword">if</span> val / poems_num &lt; <span class="number">0.1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">'&#123;&#125;\t &#123;&#125;'</span>.format(key, val / poems_num))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_set</span><span class="params">(set)</span>:</span></span><br><span class="line">    print_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> set:</span><br><span class="line">        print(i, end=<span class="string">'  '</span>)</span><br><span class="line">        print_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> print_num % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            print()</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num_libai, text_libai, counter_libai, set_libai = poems(<span class="string">'李白'</span>)</span><br><span class="line">num_dufu, text_dufu, counter_dufu, set_dufu = poems(<span class="string">'杜甫'</span>)</span><br><span class="line">print_poem(<span class="string">'李白'</span>, num_libai, text_libai, counter_libai)</span><br><span class="line">print_poem(<span class="string">'杜甫'</span>, num_dufu, text_dufu, counter_dufu)</span><br><span class="line">s_both_love = set_libai &amp; set_dufu</span><br><span class="line">s_only_libai = set_libai - set_dufu</span><br><span class="line">s_only_dufu = set_dufu - set_libai</span><br><span class="line">print(<span class="string">'两位诗人都爱用的字有'</span> + str(len(s_both_love)) + <span class="string">'个，这些字为：'</span>)</span><br><span class="line">print_set(s_both_love)</span><br><span class="line">print(<span class="string">'李白爱用但杜甫不爱用的字有'</span>+str(len(s_only_libai))+<span class="string">'个，这些字为：'</span>)</span><br><span class="line">print_set(s_only_libai)</span><br><span class="line">print(<span class="string">'杜甫爱用但李白不爱用的字有'</span>+str(len(s_only_libai))+<span class="string">'个，这些字为：'</span>)</span><br><span class="line">print_set(s_only_dufu)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-4</title>
    <url>/2020/03/23/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-4/</url>
    <content><![CDATA[<p>这一课是讲字符串的，主要是几种字符串函数。</p>
<a id="more"></a>
<h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><ol>
<li><p>下面代码的运行结果是（）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">	print(i)</span><br><span class="line">	s.remove(i)</span><br></pre></td></tr></table></figure>
<p>A. 1 2 3 4 5（一个数字一行）</p>
<p>B. 1 3 5（一个数字一行）</p>
<p>答案：显然这里<code>s</code>是个列表，列表的<code>remove()</code>函数的作用是移除指定元素，只移除匹配到的第一个。按顺序看，最初列表是<code>s=[1,2,3,4,5]</code>，<code>for</code>循环访问列表的第一个元素，并输出<code>1</code>，接着移除<code>1</code>，这之后列表<code>s</code>的元素会整体往前挪一位，变成<code>s=[2,3,4,5]</code>，此时第一个元素变成<code>2</code>，第二个元素变成<code>3</code>，而<code>for</code>循环会去找列表的第二个元素，也就是跳过<code>2</code>访问<code>3</code>，输出并移除，变成<code>s=[2,4,5]</code>，然后输出并移除第三个元素<code>5</code>。</p>
<p>所以最后输出的是<code>1 3 5</code>，选B。</p>
</li>
<li><p>下列操作的结果是（）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">'!..Hi!!!.'</span></span><br><span class="line">s.strip(<span class="string">'!.'</span>)</span><br></pre></td></tr></table></figure>
<p>A. ‘.Hi!!!’        B. ‘.Hi!!!.’        C. ‘!..Hi!!’        D. ‘Hi’</p>
<p>答案：字符串的<code>strip</code>函数是移除字符串左右两边的指定字符元素，如果没指定就移除空格，然后遇到第一个不是指定元素的时候就停止移除操作，并且指定元素不会连起来看，也就是这里的<code>!</code>和<code>.</code>是会被看做两个元素，而不是一个完整的字符串，因此移除的时候并不是找连续的<code>!.</code>，而是移除左右两边所有<code>!</code>和<code>.</code>，也就是选D。</p>
</li>
<li><p>用一行代码把字符串<code>s=&#39;  abcdbacbaab&#39;</code>中的<code>b</code>去掉。</p>
<p>答案：首先可以用字符串中的翻译函数，将所有<code>b</code>翻译成空字符，也就是<code>s.translate(str.maketrans(&#39;&#39;, &#39;&#39;,&#39;b&#39;))</code>。最直接的方法是用字符串的<code>replace</code>函数，将<code>b</code>替换成空字符，即<code>s=s.replace(&#39;b&#39;,&#39;&#39;)</code>。</p>
</li>
<li><p>判断两个单词s1和s2是否构成字谜：即s1和s2的字母和个数相同，只是顺序不同，如cinema何iceman，要求只用一行代码。</p>
<p>答案：如果不要求只用一行代码，那办法有很多了，现在要求只用一行代码，因此只能采用字符串的<code>sorted()</code>函数，该函数会返回一个排好序的字符串，因此可以通过<code>sorted(s1)==sorted(s2)</code>来判断两个字符串是否构成字谜。</p>
</li>
<li><p>如何将<code>s=&#39;d,f,a,c,b,d,g,e,a,f&#39;</code>中的字母进行排序，得到新的字符串<code>s=&#39;a,a,b,c,d,d,e,f,f,g&#39;</code>？</p>
<p>答案：直接来说就是要把原字符串中的<code>,</code>去掉，剩下的字符串按字母顺序排序，然后再把<code>,</code>加回来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">'d,f,a,c,b,d,g,e,a,f'</span> </span><br><span class="line">s1=s.replace(<span class="string">','</span>,<span class="string">''</span>) </span><br><span class="line">s2=sorted(s1) </span><br><span class="line"><span class="string">','</span>.join(s2)</span><br></pre></td></tr></table></figure>
<h3 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h3><ol>
<li><p>在第一课练习的基础上，判断一个字符串是否是回文串（规则更宽松）：</p>
<p>例如：Madam, I’m Adam                 True</p>
<p>A man, a plan, a canal, Panama!                True</p>
<p>客上天然居，居然天上客.                True</p>
<p>答案：我的思路是把字符串里所有的标点和空格去掉，然后把所有字母都转成小写字母，最后用之前写好的函数来判断字符串是否是回文串。 <code>string.punctuation</code>中存有所有标点符号，因此可以将字符串中所有的<code>string.punctuation</code>替换成空字符，从而去掉标点；空格同理；<code>casefold()</code>函数可以使字符串中所有的字符都变成小写。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindromic4</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> num == num[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_space_punc</span><span class="params">(s)</span>:</span></span><br><span class="line">    s_1=s.translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, string.punctuation))</span><br><span class="line">    s_2=s_1.translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, <span class="string">' '</span>))</span><br><span class="line">    s_3=s_2.casefold()</span><br><span class="line">    <span class="keyword">return</span> s_3</span><br><span class="line">    </span><br><span class="line">s1 = <span class="string">"Madam, I'm Adam"</span></span><br><span class="line">s2 = <span class="string">"A man, a plan, a canal, Panama!"</span></span><br><span class="line">s3 = <span class="string">"客上天然居，居然天上客."</span></span><br><span class="line"></span><br><span class="line">print(is_palindromic4(del_space_punc(s1)))</span><br><span class="line">print(is_palindromic4(del_space_punc(s2)))</span><br><span class="line">print(is_palindromic4(del_space_punc(s3)))</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入一个字符串a和字符串b，查找b在a中的所有位置并输出显示。</p>
<p>例如：请输入一个字符串：abcdeabcdeab</p>
<p>请输入另一个字符串：ab</p>
<p>输出0 5 10</p>
<p>答案：直接一些的想法是遍历字符串检索<code>a</code>，然后看下一个字符是否是<code>b</code>，不过百度之后发现可以直接用正则匹配，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">a = input(<span class="string">'请输入一个字符串：'</span>)</span><br><span class="line">b = input(<span class="string">'请输入另一个字符串：'</span>)</span><br><span class="line">print([i.start() <span class="keyword">for</span> i <span class="keyword">in</span> re.finditer(b,a)])</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计一篇文章（看成一个长字符串）中单词的个数，以及文章中不同单词的个数及列表，最后输出显示。（备注：单词的不同时态 以及单复数都看成是不同的单词）。字符串为变量speech，<code>speech=&#39;&#39;&#39;  Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal. Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battle-field of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this. But, in a larger sense, we can not dedicate -- we can not consecrate -- we can not hallow -- this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us -- that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion -- that we here highly resolve that these dead shall not have died in vain -that this nation, under God, shall have a new birth of freedom -- and that government of the people, by the people, for the people, shall not perish from the earth.&#39;&#39;&#39;</code></p>
<p>答案：受上一题的影响，这里也考虑用正则匹配来判断有多少个单词，并把单词放到一个列表中，再根据列表建立字典从而输出词频。统计词频可以用<code>collections.Counter</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">speech=<span class="string">'''  Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal. Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battle-field of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this. But, in a larger sense, we can not dedicate -- we can not consecrate -- we can not hallow -- this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us -- that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion -- that we here highly resolve that these dead shall not have died in vain -that this nation, under God, shall have a new birth of freedom -- and that government of the people, by the people, for the people, shall not perish from the earth.'''</span></span><br><span class="line">words=re.findall(<span class="string">r'[a-zA-Z]+'</span>,speech)</span><br><span class="line">count=len(words)</span><br><span class="line">print(<span class="string">'单词出现次数：'</span>,count)</span><br><span class="line">list2 = collections.Counter(words)</span><br><span class="line">print(dict(list2))</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Let-s-Build-A-Simple-Interpreter笔记-8</title>
    <url>/2020/03/23/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-8/</url>
    <content><![CDATA[<p>还没开始看，看完再写。</p>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Let-s-Build-A-Simple-Interpreter笔记-7</title>
    <url>/2020/03/15/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-7/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part7/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/02/02/lets-build-a-simple-interpreter-part-07/" target="_blank" rel="noopener">翻译</a></p>
<p>（这次翻译又出现了一些不影响理解的小问题。课程代码越来越长，我决定改一下文档结构，不在一开始放整块代码了。）</p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这一课的知识点格外多。</p>
<h4 id="抽象语法树和解析树"><a href="#抽象语法树和解析树" class="headerlink" title="抽象语法树和解析树"></a>抽象语法树和解析树</h4><ol>
<li><p>在之前的代码中，词法分析结束后进行语法分析的同时就完成了运算，这种 interpreter 被称为语法导向解释器 (syntax-directed interpreter)，对于更复杂的语法结构，我们需要建立一个中间表示（intermediate representation, IR），我们的 parser 会 负责构建 IR 而 interpreter 会用来解释由 IR 所代表的输入。一般来说会用树来构建IR。</p>
</li>
<li><p>解析树（有时叫做具体语法树）是一个根据我们的语法定义来表示一门语言的句法结构的树形结构。它基本上展示了你的 <code>parser</code> 如何识别语言结构或者， 换句话说，它展示了你语法的开始符号怎么派生出该编程语言中一个特定的字符串的。</p>
</li>
<li><p>抽象语法树（AST）是我们的解释器和未来编译器项目的中心数据结构。</p>
</li>
<li><p>如下图，分别是的AST和解析树。</p>
<p><img src="https://github.com/kun-bin/image/blob/master/lsbasi_part7_ast_01.png?raw=true" alt="AST和解析树对比"></p>
</li>
<li><p>简单来说，AST就是把操作数放到叶节点，操作符放到中间节点和根节点，操作符节点在树中的高度可以体现运算优先级，括号改变优先级也是通过改变操作符的高度。</p>
</li>
<li><p>具体到代码，首先要构建一个AST类，目前这个类里什么也没有，就只是用来让别的类继承。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AST</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>接下来要定义这个树的节点类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二元操作符类，继承AST</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, left, op, right)</span>:</span></span><br><span class="line">		self.left = left</span><br><span class="line">		self.token = self.op = op</span><br><span class="line">		self.right = right</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 整数类，继承AST</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">		self.token = token</span><br><span class="line">		self.value = token.value</span><br></pre></td></tr></table></figure>
<p><code>Token</code>这个类和前几课里的完全一致。</p>
<p>到此为止，我们就创建好AST的基本结构了，接下来可以通过赋值的方式一点点创建一个解析式的AST，例如<code>2*7+3</code>的AST：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立加号和乘号的Token</span></span><br><span class="line">mul_token = Token(MUL, <span class="string">'*'</span>)</span><br><span class="line">plus_token = Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"><span class="comment"># 先建立乘法操作符的节点</span></span><br><span class="line">mul_node = BinOp(</span><br><span class="line">    <span class="comment"># 左边是第一个乘数</span></span><br><span class="line">    left=Num(Token(INTEGER, <span class="number">2</span>)),</span><br><span class="line">    <span class="comment"># 是乘法</span></span><br><span class="line">    op=mul_token,</span><br><span class="line">    <span class="comment"># 右边是第二个乘数</span></span><br><span class="line">    right=Num(Token(INTEGER, <span class="number">7</span>))</span><br><span class="line">)</span><br><span class="line"><span class="comment">#建立加法操作符的节点</span></span><br><span class="line">add_node = BinOp(</span><br><span class="line">    <span class="comment"># 左边是刚才进行的乘法节点</span></span><br><span class="line">    left=mul_node,</span><br><span class="line">    <span class="comment"># 中间是加号</span></span><br><span class="line">    op=plus_token,</span><br><span class="line">    <span class="comment"># 右边是加数</span></span><br><span class="line">    right=Num(Token(INTEGER, <span class="number">3</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>把上述内容合并到之前的代码中，在<code>Lexer</code>得到词法单元后，不是直接进行运算，而是建立AST，即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parse</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        和之前一样</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        和之前一样</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        和之前一样</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">		<span class="keyword">if</span> token.type == INTEGER:</span><br><span class="line">            self.eat(INTEGER)</span><br><span class="line">            <span class="comment"># 之前是return token.value</span></span><br><span class="line">	    	<span class="keyword">return</span> Num(token)</span><br><span class="line">		<span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">            self.eat(LPAREN)</span><br><span class="line">            <span class="comment"># 之前是value = self.expr()</span></span><br><span class="line">            node = self.expr()</span><br><span class="line">            self.eat(RPAREN)</span><br><span class="line">            <span class="comment"># 之前是return value</span></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 之前是value = self.factor()</span></span><br><span class="line">		node = self.factor()</span><br><span class="line">		<span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">            	self.eat(MUL)</span><br><span class="line">                <span class="comment"># 之前有value *= self.factor()求值</span></span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">            	self.eat(DIV)</span><br><span class="line">                <span class="comment"># 之前有value /= self.factor()求值</span></span><br><span class="line">	    	node = BinOp(left=node, op=token, right=self.factor())</span><br><span class="line">        <span class="comment"># 之前是return value</span></span><br><span class="line">		<span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 之前是value = self.term()</span></span><br><span class="line">        node = self.term()</span><br><span class="line">		<span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">		    token = self.current_token</span><br><span class="line">	    	<span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">				self.eat(PLUS)</span><br><span class="line">                <span class="comment"># 之前有value += self.factor()求值</span></span><br><span class="line">	    	<span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">				self.eat(MINUS)</span><br><span class="line">                <span class="comment"># 之前有value -= self.factor()求值</span></span><br><span class="line">	    	node = BinOp(left=node, op=token, right=self.term())</span><br><span class="line">        <span class="comment"># 之前是return value</span></span><br><span class="line">		<span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.expr()</span><br></pre></td></tr></table></figure>
</li>
<li><p>总结一下就是，原本求值的地方，现在改为不断给<code>node</code>赋值，而<code>node</code>则层层嵌套，最终可以表达出AST。</p>
</li>
<li><p>以<code>7 + 3 * (10 - 1)</code>为例，看这份代码：</p>
<ol>
<li><code>parse</code>调用<code>expr()</code>，进入<code>expr</code>；</li>
<li><code>expr</code>调用<code>term</code>，<code>term</code>调用<code>factor</code>，发现是<code>INTEGER</code>，于是返回<code>Num(token(INTEGER,7))</code>作为<code>node</code>，<code>term</code>发现接下来不是乘除法，于是直接返回<code>node</code>，回到<code>expr</code>，该节点类型以下简写为<code>Num(7)</code>；</li>
<li><code>expr</code>发现接下来是加法，于是<code>node</code>变为<code>BinOp(left=Num(7), op=Token(PLUS, &#39;+&#39;), right=self.term())</code>，再次调用<code>term</code>；</li>
<li><code>term</code>调用<code>factor</code>得到<code>Num(3)</code>，接下来是乘法，于是这里要返回给第三步中<code>expr</code>的<code>right</code>的东西变成了<code>BinOp(left=Num(3), op=Token(MUL, &#39;*&#39;), right=self.factor())</code>，显然又要调用<code>factor</code>；</li>
<li><code>factor</code>判断接下来的左括号，于是调用<code>expr</code>处理，内容和上面的类似，会返回<code>BinOp(left=Num(10), op=Token(MINUS, &#39;-&#39;), right=Num(1))</code>给第四步的<code>right</code>；</li>
<li>以此类推，最终<code>parse</code>中得到的是<code>node=BinOp(left=Num(7), op=Token(PLUS, &#39;+&#39;), right=BinOp(left=Num(3), op=Token(MUL, &#39;*&#39;), BinOp(left=Num(10), op=Token(MINUS, &#39;-&#39;), right=Num(1))))</code>。</li>
</ol>
</li>
</ol>
<h4 id="遍历树求值"><a href="#遍历树求值" class="headerlink" title="遍历树求值"></a>遍历树求值</h4><ol>
<li><p>在得到AST之后，就要开始求值了，我们采用后序遍历的方法来遍历AST进行运算。</p>
<ol>
<li><p>前序遍历：<strong>根</strong>左右</p>
</li>
<li><p>中序遍历：左<strong>根</strong>右</p>
</li>
<li><p>后序遍历：左右<strong>根</strong></p>
</li>
<li><p>显然前中后是指根节点的遍历输出顺序，如下图的树，前序遍历的输出结果是：1-&gt;2-&gt;4-&gt;6-&gt;7-&gt;3-&gt;5，中序遍历是4-&gt;6-&gt;7-&gt;2-&gt;1-&gt;5-&gt;3，后序遍历是7-&gt;6-&gt;4-&gt;2-&gt;5-&gt;3-&gt;1</p>
<p><img src="https://github.com/kun-bin/image/blob/master/visit.png?raw=true" alt="一棵树"></p>
</li>
<li><p>对应到AST中，就是先访问<code>node</code>的<code>left</code>，得到一个结果，再访问<code>right</code>，得到另一个结果，最后访问中间的<code>op</code>，进行运算，伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="comment"># for every child node from left to right</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.children:</span><br><span class="line">		visit(child)</span><br><span class="line">    <span class="comment"># 指加减乘除等运算操作</span></span><br><span class="line">    &lt;&lt;postorder actions&gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>有时可能三种遍历都需要进行一些操作，因此伪代码改为：</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(node)</span>:</span></span><br><span class="line">    &lt;&lt; preorder actions &gt;&gt;</span><br><span class="line">    left_val = visit(node.left)</span><br><span class="line">    &lt;&lt; inorder actions &gt;&gt;</span><br><span class="line">    right_action = visit(node.right)</span><br><span class="line">    &lt;&lt; postorder actions &gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体来实现的时候首先要有<code>NodeVisitor</code>类：</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeVisitor</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        method_name = <span class="string">'visit_'</span> + type(node).__name__</span><br><span class="line">        visitor = getattr(self, method_name, self.generic_visit)</span><br><span class="line">        <span class="keyword">return</span> visitor(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generic_visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">		<span class="keyword">raise</span> Exception(<span class="string">'No visit_&#123;&#125; method'</span>.format(type(node).__name__))</span><br></pre></td></tr></table></figure>
<p>   <code>getattr(object, name, default)</code>函数的作用是，返回<code>object</code>这个变量的<code>name</code>属性，如果没有<code>name</code>则返回<code>default</code>，如果用这个函数的时候没有指明<code>default</code>，那么当<code>name</code>属性不存在时会报错。</p>
<p>   <code>f.__name__</code>的作用是返回<code>f</code>的函数名。</p>
<p>   在这段代码中，首先<code>method_name</code>是当前节点<code>node</code>对应<code>Token</code>的<code>type</code>，接下来返回该<code>NodeVisitor</code>对象的<code>method_name</code>属性，如果不存在则报错。具体来说，当<code>node</code>类型是<code>BinOp</code>时，会返回<code>visit_BinOp(node)</code>，而<code>node</code>类型是<code>Num</code>时，则返回<code>visit_Num(node)</code>。</p>
</li>
<li><p>接下来看我们的解释器<code>Interpreter</code>类，它继承了<code>NodeVisitor</code>：</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(NodeVisitor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parser)</span>:</span></span><br><span class="line">		self.parser = parser</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_BinOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node.op.type == PLUS:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) + self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == MINUS:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) - self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == MUL:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) * self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == DIV:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) / self.visit(node.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Num</span><span class="params">(self, node)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> node.value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">interpret</span><span class="params">(self)</span>:</span></span><br><span class="line">        tree = self.parser.parse()</span><br><span class="line">        <span class="keyword">return</span> self.visit(tree)</span><br></pre></td></tr></table></figure>
<p>   首先是解释器的初始化，我们将<code>parser</code>得到的AST传入<code>Interpreter</code>。</p>
<p>   接下来访问二元运算符节点的函数，该函数逻辑很简单，就是判定传入的<code>node</code>对应的<code>op</code>类型是什么，然后访问其左右节点，最后进行运算。</p>
<p>   最后是访问整数节点的函数，该函数负责将节点的<code>value</code>返回。</p>
<p>   这里要总结一下<code>node</code>这个变量，因为<code>python</code>里不需要指定变量类型，会动态决定，实际上这里的<code>node</code>有两个可能，当它是叶节点的时候，它是整数，也就是<code>Num(Token)</code>类型，在<code>visit</code>函数后会返回并执行<code>visit_Num</code>函数；而当它是中间节点和根节点时，就变成操作符，也就是<code>BinOp(left, op, right)</code>类型，在<code>visit</code>函数后会返回并执行<code>visit_BinOp</code>函数。</p>
</li>
<li><p>当调用解释器的<code>interpret</code>函数时，首先进入<code>visit</code>函数，判定是操作符，转入<code>visit_BinOp</code>函数，再判断运算类型，并访问左右节点直到得到一个返回值，最后进行运算得到结果。</p>
</li>
<li><p>总结一下，整个流程是：parser 从 lexer 中 得到 token 然后返回生成的 AST 给 interpreter 进行遍历并解释执行所给输入。</p>
</li>
</ol>
<h4 id="递归下降"><a href="#递归下降" class="headerlink" title="递归下降"></a>递归下降</h4><p>一个 <strong>递归下降parser</strong> 就 是一个自顶向下的 parser，它使用一组递归过程来处理输入。自顶向下反映了 parser 从 构建解析树的顶部结点开始逐渐构建更低的结点这一事实。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>写一个翻译器（提示：node visitor），它接收一个算术表达式作为输入并打印出它的后缀形式，即逆波兰式(Reverse Polish Notation, RPN)。例如，如果翻译器接收的输入是 表达式 <code>(5 + 3) * 12 / 3</code> 则输入应该是 <code>5 3 + 12 * 3 /</code> 。答案在<a href="https://github.com/rspivak/lsbasi/blob/master/part7/python/ex1.py" target="_blank" rel="noopener">这儿</a>，不过要先自己解决再看啊。</p>
<p>我的想法是：逆波兰式输出顺序实际上就是这一课遍历的顺序，因此只需要在现有的<code>visit_BinOp</code>和<code>visit_Num</code>加上<code>print</code>就行，注意这里因为是后序输出，<code>BinOP</code>需要先<code>visit(left)</code>和<code>visit(right)</code>，再<code>print(op.value)</code>，代码修改如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_BinOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> node.op.type == PLUS:</span><br><span class="line">        tmp = self.visit(node.left) + self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MINUS:</span><br><span class="line">        tmp = self.visit(node.left) - self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MUL:</span><br><span class="line">        tmp = self.visit(node.left) * self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == DIV:</span><br><span class="line">        tmp = self.visit(node.left) // self.visit(node.right)</span><br><span class="line">    print(node.op.value, end=<span class="string">' '</span>)</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Num</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    print(node.value, end=<span class="string">' '</span>)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br></pre></td></tr></table></figure>
</li>
<li><p>写一个翻译器（node visitor），它接收一个算术表达式作为输入并将它打印为 LISP 风 格的记法，即 <code>2 + 3</code> 变成 <code>(+ 2 3)</code> 及 <code>(2 + 3 * 5)</code> 变成 <code>(+ 2 (* 3 5))</code> 。你 可以在<a href="https://github.com/rspivak/lsbasi/blob/master/part7/python/ex2.py" target="_blank" rel="noopener">这儿</a>打到答案，但在查看之前还是要先尝试自己解决。</p>
<p>这是要前序遍历输出，也就是先输出<code>op.value</code>，再进行<code>visit(left)</code>和<code>visit(right)</code>，和练习1相比，就是把<code>visit_BinOp</code>中的<code>print(node.op.value, end=&#39; &#39;)</code>放到最前面。</p>
</li>
</ol>
<p>（这俩练习的答案和我想的还有点不太一样……不过问题不大……）</p>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Let-s-Build-A-Simple-Interpreter笔记-6</title>
    <url>/2020/03/12/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-6/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part6/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/02/01/lets-build-a-simple-interpreter-part-06/" target="_blank" rel="noopener">翻译</a></p>
<p><a href="https://www.oschina.net/translate/lsbasi-part6" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = (</span><br><span class="line">    <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'LPAREN'</span>, <span class="string">'RPAREN'</span>, <span class="string">'EOF'</span></span><br><span class="line">)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        self.type = type</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'Token(<span class="subst">&#123;self.type&#125;</span>, <span class="subst">&#123;repr(self.value)&#125;</span>)'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "4 + 2 * 3 - 6 / 2"</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Lexer error'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.text):</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        value = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            value += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'('</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(LPAREN, <span class="string">'('</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">')'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(RPAREN, <span class="string">')'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.error()</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Interpreter error'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""factor : INTEGER | LPAREN expr RPAREN"""</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == INTEGER:</span><br><span class="line">            self.eat(INTEGER)</span><br><span class="line">            <span class="keyword">return</span> token.value</span><br><span class="line">        <span class="keyword">elif</span> self.current_token.type == LPAREN:</span><br><span class="line">            self.eat(LPAREN)</span><br><span class="line">            value = self.expr()</span><br><span class="line">            self.eat(RPAREN)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">        value = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token_type = self.current_token.type</span><br><span class="line">            <span class="keyword">if</span> token_type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                value *= self.factor()</span><br><span class="line">            <span class="keyword">elif</span> token_type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                value /= self.factor()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        calc&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1))</span></span><br><span class="line"><span class="string">        22</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">        term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        value = self.term()</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token_type = self.current_token.type</span><br><span class="line">            <span class="keyword">if</span> token_type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                value += self.term()</span><br><span class="line">            <span class="keyword">elif</span> token_type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                value -= self.term()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.expr()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            print()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> len(text.strip()):</span><br><span class="line">            interpreter = Interpreter(Lexer(text))</span><br><span class="line">            print(interpreter.parse())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这一课在加减乘除的基础上加入了括号，而括号里的内容又可以看做是一个新的加减乘除表达式，即如下语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr   : term   ((PLUS | MINUS) term)*</span><br><span class="line">term   : factor ((MUL | DIV) factor)*</span><br><span class="line">factor : INTEGER | LPAREN expr RPAREN</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>expr</code>和<code>term</code>没有任何变化，而<code>factor</code>则多了一种可能：<code>(expr)</code>，因此需要作出以下修改：</p>
<ol>
<li><code>Lexer</code>部分添加左右括号的返回；</li>
<li><code>Interpreter</code>现在分成了两个分支，字符类型是<code>INTEGER</code>时，和之前的一样，返回该字符的<code>value</code>；字符类型是左括号时，则返回该括号里的<code>expr</code>的值，并把右括号也读过去。</li>
</ol>
<p>这样的递归语法，称之为递归下降解释器。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>如本文的描述，写一个你自己版本的算术表达式解释器。记住：重复是学习之母。</p>
<p>试着回顾一下整个代码的思路：</p>
<ol>
<li><p>代码除了<code>main()</code>以外，有3个<code>class</code>，分别是<code>Token</code>、<code>Lexer</code>、<code>Interpreter</code>。</p>
</li>
<li><p><code>Token</code>是最基础的词法单元，有两个成员变量：<code>type</code>和<code>value</code>，此外有初始化和输出的函数。</p>
</li>
<li><p><code>Lexer</code>是词法分析器，成员变量为：<code>text</code>（完整的语句）、<code>pos</code>（当前读取到语句位置的索引）、<code>current_char</code>（当前读取出的字符），成员函数为：<code>error</code>（报词法错误）、<code>advance</code>（往后读取一个新字符）、<code>skip_whitespace</code>（跳过空格）、<code>integer</code>（把连续的数字字符转成整数返回）、<code>get_next_token()</code>（返回当前词法单元）。</p>
</li>
<li><p><code>Interpreter</code>是语法解释器，成员变量为：<code>lexer</code>（词法分析器）、<code>current_token</code>（当前处理的词法单元），成员函数为：<code>error</code>（报语法错误）、<code>eat()</code>（往后处理下一个词法单元）、<code>factor</code>、<code>term</code>、<code>expr</code>三个都是语法图里的内容，最后加了一个<code>parse</code>返回<code>expr()</code>。</p>
</li>
</ol>
<p>大致就是这样了。</p>
</li>
</ol>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><p>这一课没有这一部分。</p>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-3</title>
    <url>/2020/03/11/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-3/</url>
    <content><![CDATA[<h3 id="知识点记录"><a href="#知识点记录" class="headerlink" title="知识点记录"></a>知识点记录</h3><p>这次上课有一些是以前不太了解的知识点。</p>
<a id="more"></a>
<h5 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h5><p>包括字符串、列表、元组、字节序列。</p>
<ol>
<li><p>索引访问：</p>
<p>有<code>n</code>个元素的数组，索引范围是<code>[0, n-1]</code>或<code>[-n, -1]</code>，也就是说，除了常规的类似其他语言中数组的下标索引方式，我们还可以通过<code>-1</code>来逆序访问。这在某些时候是很方便的一个操作，比如判断回文字符串。</p>
</li>
<li><p>遍历访问：</p>
<p>遍历也是用<code>for</code>循环，不过和其他语言不同的是，这里<code>for</code>循环中的<code>i</code>类型很随意，可以是<code>1, 2, 3, ...</code>也可以是元组、字符等，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'hello'</span>:</span><br><span class="line">	print(c)</span><br></pre></td></tr></table></figure>
<p>这里的<code>c</code>是字符，最终会把<code>h</code>, <code>e</code>, <code>l</code>, <code>l</code>, <code>o</code> 逐行输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">6</span>)]</span><br><span class="line">	print(t,t[<span class="number">0</span>],t[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>这里的<code>t</code>是元组，最终输出是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>,<span class="number">2</span>) <span class="number">1</span> <span class="number">2</span></span><br><span class="line">(<span class="number">3</span>,<span class="number">4</span>) <span class="number">3</span> <span class="number">4</span></span><br><span class="line">(<span class="number">5</span>,<span class="number">6</span>) <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>切片</p>
<p>序列<code>s</code>可以通过<code>s[i:j:k]</code>来截取其中的一部分，<code>i</code>是起点，<code>j</code>是终点，<code>k</code>是步长，注意这里的起点终点都可以是负数，结合上文可知，<code>s[::-1]</code>实际上就是序列的逆序。注意这个切片并不会改变序列<code>s</code>。想要将切片的下标信息保存下来，我们可以使用<code>slice(i:j:k)</code>函数。这里如果越界了也不会报错。</p>
</li>
<li><p>连接和重复</p>
<p>连接<code>+</code>：<code>s1+s2</code></p>
<p>重复<code>*</code>：<code>s*n</code> 或者 <code>n*s</code></p>
<p>增量赋值：<code>+=</code>和<code>*=</code></p>
<p>元组不可以<code>+=</code>序列，但是反过来序列<code>+=</code>元组是没问题的。</p>
</li>
<li><p>成员关系操作</p>
<p><code>in</code>和<code>not in</code>可以判断一个元素是否在序列中。</p>
<p><code>s.count(value)</code>可以统计<code>value</code>在序列<code>s</code>中出现的次数。</p>
<p><code>s.index(value, [start, [stop]])</code>查找value在序列指定范围 <code>[start,stop)</code>中第一次出现的下标。</p>
</li>
<li><p>序列内置函数</p>
<p><code>len</code> 单纯求序列长度</p>
<p><code>sorted</code>对序列排序并返回排序后的列表，不改变原始序列</p>
<p><code>reversed</code>逆序，不改动原序列，返回反向迭代器</p>
<p><code>max</code>和<code>min</code>求最大值和最小值，要求元素类型都一样</p>
<p><code>sum</code>序列求和，要求不能有非数字</p>
<p><code>enumerate</code>返回元素为<code>元组(计数，元素)</code> 的迭代器</p>
<p><code>zip</code>拼接多个对象<code>iter1、iter2…</code>的元素， 返回一个迭代器，其元素为各对象元素组成的元组。</p>
<p><code>all</code>和<code>any</code>判断序列的元素是否全部和部分为True</p>
</li>
<li><p>序列类型转换</p>
<p><code>str</code> <code>list</code> <code>tuple</code> <code>bytes</code> <code>bytearray</code>可以从字面意义看出是转成什么类型。</p>
</li>
<li><p>的</p>
</li>
<li><p>序列拆分</p>
<p><code>变量1,变量2,…,变量n = 序列</code>这样的赋值语句，可以把序列中的元素拆开赋值给前面的变量，不过类型要统一，比如序列中有元组，那前面对应位置的变量也要写成元组的形式。</p>
<p><code>*变量</code>的形式，可以把多个元素打包赋值给一个变量，但是只能出现一次。</p>
<p>可以用临时变量<code>_</code>来占位从而将指定位置的元素赋值给某个变量，例如<code>_, b, _ = (1, 2, 3)</code>就是把<code>2</code>赋值给<code>b</code>。</p>
</li>
</ol>
<h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><ol>
<li><p><code>del</code>删除元素，赋值修改元素</p>
</li>
<li><p><code>s.append(x)</code> 把<code>x</code>追加到<code>s</code>末尾</p>
</li>
<li><p><code>s.clear()</code> 删除所有元素</p>
</li>
<li><p><code>s.copy()</code> 复制</p>
</li>
<li><p><code>s.extend(t)</code> 和上面的<code>s.append(x)</code>是一样的，区别在于，<code>append</code>把<code>x</code>作为一个整体加到末尾，而<code>extend</code>把<code>x</code>作为一个新的列表合并到<code>s</code>的末尾。</p>
</li>
<li><p><code>s.insert(i,x)</code>插入</p>
</li>
<li><p><code>s.pop([i])</code>返回并移除下标为<code>i</code>的元素，<code>i</code>省略时默认为最后一个元素</p>
</li>
<li><p><code>s.remove(x)</code>移除列表中第一次出现的<code>x</code></p>
</li>
<li><p><code>s.reverse()</code>列表反转</p>
</li>
<li><p><code>s.sort()</code>列表排序</p>
</li>
<li><p>列表解析表达式：处理可迭代对象并生成结果列表，具体格式为<code>[express for i_1 in 可迭代对象1…for i_N in 可迭代对象N [if condition] ]</code></p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">[i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line">[(x+y,x*y) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表解析生成字典和集合</span></span><br><span class="line">a = [(<span class="string">'小黑'</span>,<span class="string">'领导'</span>,<span class="number">30000</span>),(<span class="string">'小白'</span>,<span class="string">'职员'</span>,<span class="number">10000</span>),(<span class="string">'小蓝'</span>,<span class="string">'职员'</span>,<span class="number">5000</span>)]</span><br><span class="line">&#123;i[<span class="number">0</span>]:i[<span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> a&#125;</span><br><span class="line"><span class="comment"># output: &#123;'小黑': 30000, '小白': 10000, '小蓝': 5000&#125;</span></span><br><span class="line">&#123;i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i[<span class="number">2</span>]&gt;=<span class="number">10000</span>&#125;</span><br><span class="line"><span class="comment"># output: &#123;'小白', '小黑'&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><ol>
<li><p>已知一选手的各评委得分<code>score = [95, 85, 89, 88, 86, 95, 89, 98, 85, 75, 80]</code>，运用序列的各项操作求该选手的得分，计算规则：去掉一个最高分和一个最低分，剩下的分数计算平均分。</p>
<p>最直接的思路就是整体求和然后减去最大的和最小的再算平均值，也就是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = [<span class="number">95</span>, <span class="number">85</span>, <span class="number">89</span>, <span class="number">88</span>, <span class="number">86</span>, <span class="number">95</span>, <span class="number">89</span>, <span class="number">98</span>, <span class="number">85</span>, <span class="number">75</span>, <span class="number">80</span>]</span><br><span class="line">s = (sum(score) - max(score) - min(score)) / (len(score) - <span class="number">2</span>)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断一个字符串是否是回文串：<code>a = &#39;abcdcba&#39;  b = &#39;abcdefg&#39;</code></p>
<p>这个题有很多思路，最快的办法就是用前面提到的<code>s[::-1]</code>来实现逆序，即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindromic4</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> num == num[::<span class="number">-1</span>]</span><br><span class="line">a = <span class="string">'abcdcba'</span></span><br><span class="line">b = <span class="string">'abcdefg'</span></span><br><span class="line">print(is_palindromic4(b))</span><br></pre></td></tr></table></figure>
<p>也可以选择把字符串转成<code>list</code>或者<code>tuple</code>然后使用<code>reverse</code>函数来实现逆序。即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list(a)==list(reverse(a))</span><br><span class="line">tuple(a)==tuple(reverse(a))</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码执行后的<code>s</code>是（）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = [<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line">s.append([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">s.extend(<span class="string">'34'</span>)</span><br><span class="line">s.extend([<span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">s.insert(<span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line">s.insert(<span class="number">10</span>, <span class="number">8</span>)</span><br><span class="line">s.pop(<span class="number">2</span>)</span><br><span class="line">s.remove(<span class="string">'a'</span>)</span><br><span class="line">s[<span class="number">4</span>:] = []</span><br><span class="line">s.reverse()</span><br></pre></td></tr></table></figure>
<p>对照每个函数的作用可以很容易判断出最后的结果是<code>[&#39;4&#39;,&#39;3&#39;,[1,2],7]</code></p>
</li>
</ol>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol>
<li><p>使用<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>,<code>**</code>运算符和数字<code>2</code>,<code>3</code>,<code>4</code>,<code>5</code>，构造一个表达式，该表达式中上述4个数字和3种不同运算符各用一次，使得表达式的结果为24，打印出满足条件的表达式。</p>
<p>提示：</p>
<p>(1)构建表达式字符串，然后用内置函数<code>eval</code>计算该字符串 ，例如<code>eval(&#39;3*4/2+5&#39;)</code>返回<code>11.0</code>； </p>
<p>(2)两字符串可通过”+”连接成一个字符串，如<code>’he’+’llo’</code>会 得到<code>’hello’</code>； </p>
<p>(3)本题关键在于求排列，排列有多种实现方式，例如循环。</p>
<p>根据提示很容易想到一个思路：把数字的全排列和运算符的取3个排列分别列出来，然后逐一组合成字符串，使用<code>eval</code>计算结果，如果是24，就输出。查找资料后发现<code>python</code>有一个算排列的库函数<code>itertools.permutations(s, n)</code>，该函数返回列表<code>s</code>中取<code>n</code>个元素的排列结果，该结果也是一个列表，也就是说我们可以通过该函数得到数字和运算符的排列结果，并<code>for</code>循环遍历，将它们组成计算表达式并求结果，然后输出。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">op = [<span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'*'</span>, <span class="string">'/'</span>, <span class="string">'**'</span>]</span><br><span class="line">num = [<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.permutations(num, <span class="number">4</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> itertools.permutations(op, <span class="number">3</span>):</span><br><span class="line">        s = i[<span class="number">0</span>] + j[<span class="number">0</span>] + i[<span class="number">1</span>] + j[<span class="number">1</span>] + i[<span class="number">2</span>] + j[<span class="number">2</span>] + i[<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> float(eval(s)) == <span class="number">24.0</span>:</span><br><span class="line">            print(s)</span><br></pre></td></tr></table></figure>
<p>此外，<code>python</code>中完成24点游戏的思路还有很多很多，复杂一些的办法可以是构造二叉树，然后遍历节点。</p>
</li>
<li><p>输入一个列表，然后删除该列表中的重复的元素，要求删除重复元素后还保持原排序，最后输出结果。例如，输入列表 <code>[0, 1, 1, 1, 3, 0, 3, 2]</code>，输出 <code>[0, 1, 3, 2]</code>。</p>
<p>这个题也有很多思路，比如逐个比较等。有一种很便捷的方法是，对输入列表生成字典，这样就按顺序去掉了重复元素，再将字典的<code>key</code>转成列表即可，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = eval(input(<span class="string">'请输入一个列表：'</span>))</span><br><span class="line">list2 = dict.fromkeys(list1)</span><br><span class="line">list3 = list(list2.keys())</span><br><span class="line">print(list3)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Let-s-Build-A-Simple-Interpreter笔记-5</title>
    <url>/2020/03/09/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-5/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part5/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/30/lets-build-a-simple-interpreter-part-05/" target="_blank" rel="noopener">翻译</a></p>
<p><a href="https://www.oschina.net/translate/lsbasi-part5" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, MUL, DIV, EOF = (</span><br><span class="line">    <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'EOF'</span></span><br><span class="line">)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, PLUS, MINUS, MUL, DIV, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '+', '-', '*', '/', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'Token(<span class="subst">&#123;self.type&#125;</span>, <span class="subst">&#123;repr(self.value)&#125;</span>)'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 * 5", "12 / 3 * 4", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Lexer error'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.text):</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        value = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            value += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.error()</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Interpreter error'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""factor : INTEGER"""</span></span><br><span class="line">        value = self.current_token.value</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">        value = self.factor()</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            <span class="keyword">if</span> self.current_token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                value *= self.factor()</span><br><span class="line">            <span class="keyword">elif</span> self.current_token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                value /= self.factor()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        calc&gt;  14 + 2 * 3 - 6 / 2</span></span><br><span class="line"><span class="string">        17</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">        term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        value = self.term()</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            <span class="keyword">if</span> self.current_token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                value += self.term()</span><br><span class="line">            <span class="keyword">elif</span> self.current_token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                value -= self.term()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.expr()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            print()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(text.strip()):</span><br><span class="line">            interpreter = Interpreter(Lexer(text))</span><br><span class="line">            result = interpreter.parse()</span><br><span class="line">            print(result)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这一课讲的是运算结合性和优先级的处理。</p>
<h4 id="什么是结合性"><a href="#什么是结合性" class="headerlink" title="什么是结合性"></a>什么是结合性</h4><p>当一个操作数（比如 7+3+1 中的 3）两边都有加号时，我们需要一个规则来决定哪个运算符作用于 3，根据经验，是左边的加号起作用（也就是先计算7+3），因此我们把加号看做是左结合的。类似地，减、乘、除也都是左结合的。</p>
<h4 id="什么是优先级"><a href="#什么是优先级" class="headerlink" title="什么是优先级"></a>什么是优先级</h4><p>当一个操作数（比如 7 + 5 <em> 2 中的5）两边有不同的运算符时，先进行运算的那个运算符优先级较高，比如我们说运算符\</em>比+先取运算符，*就有较高的优先级。</p>
<p>在一个表达式中有相同优先级的运算符出现时，我们就使用结合性惯例从左到右执行。</p>
<h4 id="构建语法和写解释器"><a href="#构建语法和写解释器" class="headerlink" title="构建语法和写解释器"></a>构建语法和写解释器</h4><p>以算术表达式为例，优先级列表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>优先级</th>
<th>结合性</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>左结合</td>
<td>+, -</td>
</tr>
<tr>
<td>1</td>
<td>左结合</td>
<td>*, /</td>
</tr>
</tbody>
</table>
</div>
<p>从优先级表构建语法：</p>
<ol>
<li>对于每一个优先级定义一个非终结符。这个非终结符的生成式的 body 应该由本优先级的算术运算符和更高优先级的非终结符组成。</li>
<li>对表达式的基本单元(在我们的例子中是 INTEGER)新建一个额外的非终结符 <code>factor</code>. 一般原则就是如果你有 N 级优先级，你一共会需要 N+1 非终结符：每个优先级一个再 加上基本单元的一个。</li>
</ol>
<p>具体来说我们现在有2个优先级，因此会有3个非终结符，优先级为2的对应<code>expr</code>，优先级为1的对应<code>term</code>，最后是<code>factor</code>。</p>
<p><code>expr</code>要表达包含<code>term</code>的加减运算，即：<code>expr: term((PLUS|MINUS)term)*</code></p>
<p><code>term</code>则是包含<code>factor</code>的乘除运算，即：<code>term； factor((MUL|DIV)factor)*</code></p>
<p>最后<code>factor</code>是基本单元，即：<code>factor: INTEGER</code></p>
<p>然后就是和上一课一样的步骤写代码了。</p>
<p>（总的来说这一课没有什么新知识，但是我还是不能不看教程自己写…）</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>根据本文的描述凭记忆写出一个解释器，不要参考文中的代码。为你的解释器写一些测试，确保它们可以通过。</p>
<p>我太菜了所以并没法凭记忆写一个解释器，于是我开始照着代码抄一下，并很快发现就算是照抄我也会出错…</p>
<p>主要错误如下：</p>
<ol>
<li><code>else</code>后面忘了加<code>:</code>；</li>
<li>某个地方的赋值(<code>=</code>)一个不注意就写成了相等(<code>==</code>)；</li>
<li><code>while self.current_char is not None and self.current_char.isdigit():</code>以及前面判断空格的那个类似的语句，<code>is not None</code>一定要放前面，如果反过来，在当前字符是空的时候，执行<code>isdigit()</code>和<code>isspace()</code>就会报错了，所以要先判定不为空。</li>
</ol>
<p>我好菜啊.jpg</p>
</li>
<li><p>扩展这个解释器来处理包含括号的算术表达式，使得你的解释器可以对嵌套很深很深的算术表达式进行求值如：7 + 3 * (10 / (12 / (3 + 1) - 1))</p>
<p>这个我的想法是要设定一下括号的结合性，左括号是右结合而右括号是左结合，但是不会写。</p>
<p>看了下一课发现是要写递归语法分析，所以放下一课来写吧。</p>
</li>
</ol>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>一个操作符是左结合的是什么意思？</p>
<p>是指当数字左右两边都有该运算符时，数字取左边的运算符。</p>
</li>
<li><p>操作符加减是左结合的还是右结合的？乘除呢？</p>
<p>都是左结合。</p>
</li>
<li><p>操作符加是否比操作符乘有更高的优先级？</p>
<p>否，乘的优先级更高。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-2</title>
    <url>/2020/03/04/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-2/</url>
    <content><![CDATA[<ol>
<li><p>下面程序的运行结果是（    ）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">		<span class="keyword">if</span> i == j == <span class="number">1</span>；</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			print(i, <span class="string">'----'</span>, j)</span><br></pre></td></tr></table></figure>
<p>A.    0 —— 0                B.    0 —— 0<br>​        0 —— 1                       0 —— 1<br>​        0 —— 2                       0 —— 2<br>​        1 —— 0                       1 —— 0<br>​        2 —— 0<br>​        2 —— 1<br>​        2 —— 2</p>
</li>
</ol>
<a id="more"></a>
<p>答案：A（我怀疑这题的选项对齐在网页上显示会出问题，不过懒得改了）</p>
<p><code>break</code>的中断只会断一层，也就是说这个代码在<code>i=j=1</code>的时候，属于<code>j</code>的循环会中断，<code>j=2</code>和<code>j=3</code>将跳过，直接开始<code>i=2, j=0</code>然后继续循环，也就是A选项。</p>
<ol>
<li><p>下面程序的运行结果是（    ）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">		<span class="keyword">if</span> i == j == <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			print(i, <span class="string">'----'</span>, j)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>A.    0 —— 0                B.    0 —— 0<br>​        0 —— 1                       0 —— 1<br>​        0 —— 2                       0 —— 2<br>​        1 —— 0                       1 —— 0<br>​        2 —— 0<br>​        2 —— 1<br>​        2 —— 2</p>
</li>
</ol>
<p>答案：B</p>
<p>这里首先要学习的是<code>python</code>与其他语言中不太一样的<code>else</code>用法，在其他语言中，<code>else</code>只搭配<code>if</code>来做条件判断，而<code>python</code>中有<code>for... else...</code>、<code>while...else...</code>和<code>try...else...</code>的用法，具体来说，在<code>for</code>循环中如果有并触发了<code>break</code>，则<code>for</code>循环后的<code>else</code>语句不会被执行，如果没触发或者没有，则会执行<code>else</code>分支的语句；在<code>while</code>循环中，也是如此，<code>break</code>不执行或不存在的时候，就会执行<code>else</code>语句，而如果执行了<code>break</code>就不会执行<code>else</code>；<code>try</code>中的用法则是当<code>try</code>块中的语句正常执行完毕就会执行<code>else</code>分支。</p>
<p>其次，<code>continue</code>在循环中是用来跳过这次循环并开始下一次循环，比如在<code>j=1</code>的时候<code>continue</code>，则<code>j=1</code>中剩下的语句不执行，但是会开始执行<code>j=2</code>，而不是像<code>break</code>那样跳出<code>j</code>的循环去执行<code>i</code>的循环。</p>
<p>分析这个代码，这个<code>else</code>分支是<code>j</code>的循环对应的，也就是说<code>i=0,j=x</code>时，没触发<code>break</code>，每次都会执行<code>else</code>中的<code>continue</code>，也就是说此时最后一行的打断<code>i</code>的循环的<code>break</code>不会执行；在<code>i=j=1</code>的时候<code>j</code>的循环<code>break</code>了，那么<code>else</code>分支不会执行，就会执行到最后一行的<code>break</code>，从而打断<code>i</code>的循环，程序直接结束，也就是B选项。</p>
<p>课后作业：</p>
<ol>
<li>利用random库，随机出100道两个数的加、减口算题。要求 ： (1)a+b或者a-b，a、b和得数范围均为[0,100]；(2)如果是加法运算，要求有进位；如果是减法运算，要求有退位；(3)在屏幕上打印出结果，每一行显示4道题，注意对齐。示例如下。（示例就不放了总之就是100个加减法运算题，加法有进位减法有借位，输出是格式化的）</li>
</ol>
<p>这个本来是不难的，随机生成两个100以内的数字然后随机决定加减法就行，但是还必须有进位和退位。</p>
<p>一开始的思路是，先随机生成第一个数字<code>a</code>，然后再随机生成<code>0</code>和<code>1</code>来决定加减法，接下来如果是加法，就生成一个在<code>a</code>到<code>100-a</code>之间的数字<code>b</code>，如果是减法，就生成一个在<code>1</code>到<code>a</code>之间的数字<code>b</code>，这两个分支中，如果<code>b</code>不符合进位或者退位，就重新生成，也就是一个<code>while</code>循环。</p>
<p>按这个思路写好运行以后就发现了问题，那个<code>while</code>循环有时候会一直循环下去就是找不到符合进位或退位的数字<code>b</code>，这是因为一开始的数字<code>a</code>如果不合适，那什么数字也没法实现进位或者退位，比如加法中，个位数如果是<code>0</code>，这个数字还不是<code>90</code>，则无论如何也不会遇到进位；而减法中，这个数字如果个位是<code>9</code>，题目又要求不会出现负数的减法，那无论如何都不可能有借位运算。也就是说，先决定加减法，再生成一个恰当的数字<code>a</code>，它要符合一些条件，接着生成一个恰当的数字<code>b</code>，也要符合一些条件。</p>
<p>具体来说，数字<code>a</code>要符合：</p>
<pre><code>    1. 如果是加法，则个位数不是0，或这个数不是90，且范围在1到90之间；
     2. 如果是减法，则个位数不是9，且范围在10到100之间。
</code></pre><p>数字<code>b</code>要符合：</p>
<pre><code>    1. 如果是加法，则小于`100-a`，且个位数之和大于10，或十位数之和大于10；
    2. 如果是减法，则小于`a`，且个位数比`a`的个位数大，或十位数比`a`的十位数大。
</code></pre><p>最后就是格式化输出，然后就结束了，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">    bool = random.randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> bool == <span class="number">0</span>:</span><br><span class="line">        a = random.randint(<span class="number">1</span>, <span class="number">90</span>)</span><br><span class="line">        <span class="keyword">while</span> a != <span class="number">90</span> <span class="keyword">and</span> a % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            a = random.randint(<span class="number">1</span>, <span class="number">90</span>)</span><br><span class="line">        b = random.randint(<span class="number">1</span>, <span class="number">100</span> - a)</span><br><span class="line">        <span class="keyword">while</span> ((a % <span class="number">10</span> + b % <span class="number">10</span>) &lt; <span class="number">10</span>) <span class="keyword">and</span> ((a // <span class="number">10</span> + b // <span class="number">10</span>) &lt; <span class="number">10</span>):</span><br><span class="line">            b = random.randint(<span class="number">1</span>, <span class="number">100</span> - a)</span><br><span class="line">        print(<span class="string">'&#123;:&lt;2&#125; + &#123;:&lt;2&#125;='</span>.format(a, b), end=<span class="string">"\t\t"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a = random.randint(<span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">while</span> a % <span class="number">10</span> == <span class="number">9</span>:</span><br><span class="line">            a = random.randint(<span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line">        b = random.randint(<span class="number">1</span>, a)</span><br><span class="line">        <span class="keyword">while</span> ((b % <span class="number">10</span>) &lt;= (a % <span class="number">10</span>)) <span class="keyword">and</span> ((b % <span class="number">100</span>) &lt;= (a % <span class="number">100</span>)):</span><br><span class="line">            b = random.randint(<span class="number">1</span>, a)</span><br><span class="line">        print(<span class="string">'&#123;:&lt;2&#125; - &#123;:&lt;2&#125;='</span>.format(a, b), end=<span class="string">"\t\t"</span>)</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">4</span> == <span class="number">3</span>:</span><br><span class="line">        print(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<p>补充一下关于<code>print</code>格式化输出的内容：</p>
<p><code>python</code>中的<code>print</code>函数有一个<code>end</code>参数，当直接<code>print</code>而没有<code>end</code>时，默认换行；当<code>end=&quot;&quot;</code>时，就不自动换行了；当<code>end=XXX</code>时，在<code>print</code>后，会接着有<code>XXX</code>，比如上面代码的<code>\t\t</code>，也不自动换行。</p>
<p>在<code>C</code>语言中，可以通过<code>prints(&quot;%d, %d&quot;, a, b)</code>来实现输出<code>a, b</code>，并通过<code>%x.yd</code>（比如<code>%5.3d</code>)来控制输出长度和精度，而<code>python</code>中有类似的用法，即<code>str.format()</code>，其基本语法是通过<code>{}</code>和<code>:</code>来代替<code>%</code>。<code>&#39;{:&lt;2} - {:&lt;2}=&#39;.format(a, b)</code>这样的语句含义是：把<code>a</code>和<code>b</code>按默认顺序填入前面的花括号，并把长度控制为2个字符且左对齐。</p>
<p><code>format()</code>的用法很多。</p>
<p>可以接受不限个数和顺序的参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">"&#123;&#125; &#123;&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)    <span class="comment"># 不设置指定位置，按默认顺序</span></span><br><span class="line"><span class="string">'hello world'</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;0&#125; &#123;1&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">'hello world'</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;1&#125; &#123;0&#125; &#123;1&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">'world hello world'</span></span><br></pre></td></tr></table></figure>
<p>可以指明参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"网站名：&#123;name&#125;, 地址 &#123;url&#125;"</span>.format(name=<span class="string">"菜鸟教程"</span>, url=<span class="string">"www.runoob.com"</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过字典设置参数</span></span><br><span class="line">site = &#123;<span class="string">"name"</span>: <span class="string">"菜鸟教程"</span>, <span class="string">"url"</span>: <span class="string">"www.runoob.com"</span>&#125;</span><br><span class="line">print(<span class="string">"网站名：&#123;name&#125;, 地址 &#123;url&#125;"</span>.format(**site))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过列表索引设置参数</span></span><br><span class="line">my_list = [<span class="string">'菜鸟教程'</span>, <span class="string">'www.runoob.com'</span>]</span><br><span class="line">print(<span class="string">"网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;"</span>.format(my_list))  <span class="comment"># "0" 是必须的</span></span><br></pre></td></tr></table></figure>
<p>可以向<code>format</code>传入对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssignValue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">my_value = AssignValue(<span class="number">6</span>)</span><br><span class="line">print(<span class="string">'value 为: &#123;0.value&#125;'</span>.format(my_value))  <span class="comment"># "0" 是可选的</span></span><br></pre></td></tr></table></figure>
<p>数字格式化输出的完整形式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数字</th>
<th>格式</th>
<th>输出</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.1415926</td>
<td>{:.2f}</td>
<td>3.14</td>
<td>保留小数点后两位</td>
</tr>
<tr>
<td>3.1415926</td>
<td>{:+.2f}</td>
<td>+3.14</td>
<td>带符号保留小数点后两位</td>
</tr>
<tr>
<td>-1</td>
<td>{:+.2f}</td>
<td>-1.00</td>
<td>带符号保留小数点后两位</td>
</tr>
<tr>
<td>2.71828</td>
<td>{:.0f}</td>
<td>3</td>
<td>不带小数</td>
</tr>
<tr>
<td>5</td>
<td>{:0&gt;2d}</td>
<td>05</td>
<td>数字补零 (填充左边, 宽度为2)</td>
</tr>
<tr>
<td>5</td>
<td>{:x&lt;4d}</td>
<td>5xxx</td>
<td>数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td>10</td>
<td>{:x&lt;4d}</td>
<td>10xx</td>
<td>数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td>1000000</td>
<td>{:,}</td>
<td>1,000,000</td>
<td>以逗号分隔的数字格式</td>
</tr>
<tr>
<td>0.25</td>
<td>{:.2%}</td>
<td>25.00%</td>
<td>百分比格式</td>
</tr>
<tr>
<td>1000000000</td>
<td>{:.2e}</td>
<td>1.00e+09</td>
<td>指数记法</td>
</tr>
<tr>
<td>13</td>
<td>{:&gt;10d}</td>
<td>13</td>
<td>右对齐 (默认, 宽度为10)</td>
</tr>
<tr>
<td>13</td>
<td>{:&lt;10d}</td>
<td>13</td>
<td>左对齐 (宽度为10)</td>
</tr>
<tr>
<td>13</td>
<td>{:^10d}</td>
<td>13</td>
<td>中间对齐 (宽度为10)</td>
</tr>
</tbody>
</table>
</div>
<p><code>^</code>,<code>&lt;</code>, <code>&gt;</code> 分别是居中、左对齐、右对齐，后面带宽度， <code>:</code> 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。<code>+</code> 表示在正数前显示 <code>+</code>，负数前显示 <code>-</code>； （空格）表示在正数前加空格。</p>
<p>此外，还可以转进制输出，<code>b</code>、<code>d</code>、<code>o</code>、<code>x</code> 分别是二进制、十进制、八进制、十六进制。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">'&#123;:b&#125;'.format(11) --&gt; 1011</span><br><span class="line">'&#123;:d&#125;'.format(11) --&gt; 11</span><br><span class="line">'&#123;:o&#125;'.format(11) --&gt; 13</span><br><span class="line">'&#123;:x&#125;'.format(11) --&gt; b</span><br><span class="line">'&#123;:#x&#125;'.format(11) --&gt; 0xb</span><br><span class="line">'&#123;:#X&#125;'.format(11) --&gt; 0XB</span><br></pre></td></tr></table></figure>
<ol>
<li>编写程序，求解所有由两个四位数组成的亲和数。（如果两个正整数a和b满足：a的所有真因数（除本身以外的因数）之和等于b，同时b的所有真因数之和等于a，则称a，b是一对亲和数 。）</li>
</ol>
<p>思路是先写一个算真因数之和的函数，接着写两层循环，第一层<code>a</code>是1000到9999，第二层<code>b</code>是1000到<code>a</code>，然后调用函数判断<code>a</code>和<code>b</code>的真因数之和是否符合条件。一个整数<code>n</code>的真因数之和是很好计算的，只需要遍历1到<code>n//2+1</code>看是否整除<code>n</code>，然后把整除的累加一下，就可以了。</p>
<p>但是实际运行的时候，发现这样搞真的很慢，要等好久才会出结果，这是因为两层<code>for</code>循环，每次都要算两个真因数的和，而这也是一层循环，再加上<code>python</code>本身就效率很低，速度就格外慢了，因此最好的办法是能去掉一层循环，或者有什么库可以飞快地计算真因数之和。</p>
<p>然后在查资料的过程中，看到了另一种亲和数的定义：先求出数字<code>n</code>所有真因数之和<code>a</code>，然后再求出数字<code>a</code>所有真因数之和<code>b</code>。如果<code>a!= b</code> 且<code>n==b</code>，则<code>a</code>、<code>b</code>、<code>n</code>都是亲和数。</p>
<p>也就是说，可以只写一层循环<code>a</code>，计算<code>a</code>的真因数之和<code>b</code>，再计算<code>b</code>的真因数之和<code>sum_b</code>，如果<code>a=sum_b</code>，则符合条件输出一下，反之就直接继续下一次循环，算真因数之和的部分没有变化。这样循环少了一层，运算速度快了好多。</p>
<p>此外，看到一个不是用取余，而是用除法和整除结果来判断是否是因数的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d</span><span class="params">(n)</span>:</span>  <span class="comment">#计算数字n所有真因数之和</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n/i == float(n//i):</span><br><span class="line">            res += i</span><br><span class="line">    <span class="keyword">return</span>(res)</span><br></pre></td></tr></table></figure>
<p>猜测<code>python</code>中的除法、整除、取余可能有运算时间的差别，不过应该不大。</p>
<p>最后代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算一个数的真因数和</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_factor</span><span class="params">(n)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            sum += i</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">1000</span>, <span class="number">9999</span>):</span><br><span class="line">    b = sum_of_factor(a)</span><br><span class="line">    <span class="keyword">if</span> b &lt;= a:</span><br><span class="line">        sum_b = sum_of_factor(b)</span><br><span class="line">        <span class="keyword">if</span> sum_b == a:</span><br><span class="line">            print(a, b)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s Build A Simple Interpreter笔记[4]</title>
    <url>/2020/02/28/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-4/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part4/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/28/lets-build-a-simple-interpreter-part-04/" target="_blank" rel="noopener">翻译</a></p>
<p>(这个翻译里有个别地方翻译错了……)</p>
<p><a href="https://www.oschina.net/translate/lsbasi-part4" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, MUL, DIV, EOF = <span class="string">'INTEGER'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'EOF'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, MUL, DIV, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '*', '/', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 * 5", "12 / 3 * 4", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid character'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line">            self.error()</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return an INTEGER token value.</span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> token.value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string">        expr   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = self.factor()</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                result = result * self.factor()</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                result = result // self.factor()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        lexer = Lexer(text)</span><br><span class="line">        interpreter = Interpreter(lexer)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h4 id="正则表达"><a href="#正则表达" class="headerlink" title="正则表达"></a>正则表达</h4><p>虽然课程内容里没有过多涉及这部分，但还是复习一下。从<a href="https://www.runoob.com/regexp/regexp-syntax.html" target="_blank" rel="noopener">这里</a>复制的</p>
<h5 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h5><p>指不会显示在文本中的字符，主要用于控制文本显示格式，例如换行、分页等。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\cx</td>
<td>匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><p>指正则匹配规则中比较特殊的一些标记。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>$</td>
<td>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。</td>
</tr>
<tr>
<td>( )</td>
<td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符 \n 之外的任何单字符。</td>
</tr>
<tr>
<td>[</td>
<td>标记一个中括号表达式的开始。</td>
</tr>
<tr>
<td>\</td>
<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。</td>
</tr>
<tr>
<td>{</td>
<td>标记限定符表达式的开始。</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>指明两项之间的一个选择。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h5><p>指限定表达式匹配次数的符号。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配前面的子表达式任意次，可以是零次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody>
</table>
</div>
<p>例如：<code>/[1-9][0-9]*/</code>是指第一位是1-9的某个数字，后面有任意多个0-9的数字，也就是正整数。</p>
<h4 id="上下文无关语法-BNF"><a href="#上下文无关语法-BNF" class="headerlink" title="上下文无关语法/BNF"></a>上下文无关语法/BNF</h4><ol>
<li><p>由一系列规则组成，被称为产生式；</p>
</li>
<li><p>一条规则由一个非终结符(叫做 <strong>head</strong> 或 生成式的 <strong>左边</strong>)，一个分号，和一系列终结 符和/或非终结符(叫做 <strong>body</strong> 或 <strong>右边</strong>)组成；</p>
</li>
<li><p>第一条规则左边的非终结符被叫做 <strong>开始符号</strong>；</p>
</li>
<li><p>通过语法派生出算术表达式的方式 为：首先从开始符号开始，然后反复地使用所包含的非终结符的规则替换该终结符， 直到生成一个只包含终结符的句子。语法能组成的句子构成了一门语言。</p>
<p>例如：一个只有乘除法的计算表达式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr   : factor ((MUL|DIV) factor)*</span><br><span class="line">factor : INTEGER</span><br></pre></td></tr></table></figure>
<p>有两条规则，其中，<code>expr</code>是开始符号，<code>expr</code>和<code>factor</code>这样的变量是非终结符，<code>MUL</code>、<code>DIV</code>、<code>INTEGER</code>这样的<code>token</code>是终结符。</p>
<p>解读该语法：</p>
<ol>
<li><code>expr</code> 是一个<code>factor</code>后面可选地跟一个乘或除运算符再跟另一个<code>factor</code>，后面也相应可选地跟一个乘或除运算符再跟另一个<code>factor</code>，如此重复。</li>
<li><code>factor</code>是一个整数。</li>
</ol>
</li>
</ol>
<h4 id="语法转代码的规则"><a href="#语法转代码的规则" class="headerlink" title="语法转代码的规则"></a>语法转代码的规则</h4><ol>
<li><p>对于语法中定义的每个规则<code>R</code>，将它做成一个有相同名字的方法，对该规则的引用就变成了一个方法调用：<code>R()</code>。该方法的方法体遵循该规则的步骤，过程中使用相同的准则。</p>
</li>
<li><p>多选一 <code>(a1|a2|aN)</code> 变成 <code>if-elif-else</code>语句。</p>
</li>
<li><p>可选组 <code>(...)*</code> 变成一个可以执行 0 或多次的<code>while</code>循环。</p>
</li>
<li><p>每个<code>Token</code>指针<code>T</code>变成一个 <code>eat</code> 方法调用: <code>eat(T)</code>。<code>eat</code> 方法的工作是：当它匹配到当前的 <code>lookahead</code> 就消耗掉它，然后从<code>lexer</code>中得到一个新<code>token</code>并将它赋值给内部变量 <code>current_token</code>。</p>
<p><img src="https://github.com/kun-bin/image/blob/master/lsbasi_part4_rules.png" alt="语法转换代码示例"></p>
<p>以上面的语法为例：</p>
<ol>
<li><p><code>factor</code>只有一个终结符，所以直接<code>eat()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.eat(INTEGER)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>expr</code>规则体开始的 <code>factor</code> 引用 变成了对 <code>factor()</code> 方法的调用。可行组 <code>(...)*</code> 变成了一个 <code>while</code> 循环，多选一 <code>(MUL|DIV)</code> 变成了一个 <code>if-elif-else</code> 语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.factor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">		token = self.current_token</span><br><span class="line">		<span class="keyword">if</span> token.type == MUL:</span><br><span class="line">	    	self.eat(MUL)</span><br><span class="line">	    	self.factor()</span><br><span class="line">		<span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">	    	self.eat(DIV)</span><br><span class="line">	    	self.factor()</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<p>现在的代码整体是这样的：分为三个<code>class</code>，第一个<code>Token()</code>来定义符号类型，第二个<code>Lexer()</code>是词法分析器，用来把字符串分割成符合词法规则的词法单元并返回，比如跳过空格、把连续的数字拼凑成一个整数等，第三个<code>Interpreter()</code>是语法解释器，按顺序读入词法单元并按语法规则完成运算。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>写一个语法来描述包含任意数量的 <code>+</code>,<code>-</code>, <code>*</code>, 或<code>/</code>操作符的算术表达式。这个语法需要能够派生出像  <code>2 + 7 * 4</code>, <code>7 - 8 / 4</code>, <code>14 + 2 * 3 - 6 / 2</code> 等等这样的表达式。</p>
<p>这里要考虑运算优先级的问题，所以把乘除法作为一个单元，加减法作为另一个单元，加减法是高一级的，这样乘除法会被作为一个整体来优先运算，语法规则如下：（其实这里偷看了下一章的答案）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr: term((ADD|MINUS)term)*</span><br><span class="line">term: factor((MUL|DIV)factor)*</span><br><span class="line">factor: INTEGER</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用这个语法，写一个可以对包含任意数量的 <code>+</code>,<code>-</code>, <code>*</code>, 或<code>/</code>操作符的算术表达式求值的解释器。你们解释器需要能够处理像 <code>2 + 7 * 4</code>, <code>7 - 8 / 4</code>, <code>14 + 2 * 3 - 6 / 2</code> 等等这样的表达式。</p>
<p>首先在添加加法和减法的符号定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在开头添加定义</span></span><br><span class="line">INTEGER, MUL, DIV, EOF, ADD, MINUS = <span class="string">'INTEGER'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'EOF'</span>, <span class="string">'ADD'</span>, <span class="string">'MINUS'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Lexer()的get_next_token()添加词法判断</span></span><br><span class="line"><span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">	self.advance()</span><br><span class="line">	<span class="keyword">return</span> Token(ADD, <span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">	self.advance()</span><br><span class="line">	<span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br></pre></td></tr></table></figure>
<p>接着把上一题写的语法规则转成代码表达，和课程内容类似，<code>factor()</code>部分不变，<code>term()</code>部分是课程中的<code>expr()</code>，<code>expr()</code>部分实际上是把乘除改成加减的<code>term()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.eat(INTEGER)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.factor()</span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">		token = self.current_token</span><br><span class="line">		<span class="keyword">if</span> token.type == MUL:</span><br><span class="line">	    	self.eat(MUL)</span><br><span class="line">	    	self.factor()</span><br><span class="line">		<span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">	    	self.eat(DIV)</span><br><span class="line">	    	self.factor()</span><br><span class="line">	    	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.term()</span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (ADD, MINUS):</span><br><span class="line">		token = self.current_token</span><br><span class="line">		<span class="keyword">if</span> token.type == ADD:</span><br><span class="line">	    	self.eat(ADD)</span><br><span class="line">	    	self.term()</span><br><span class="line">		<span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">	    	self.eat(MINUS)</span><br><span class="line">	    	self.term()</span><br></pre></td></tr></table></figure>
<p>接下来就是把课程示例代码中的<code>expr()</code>改成<code>term()</code>，然后仿照着写新的<code>expr()</code>了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新的expr()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string">    expr   : term   ((ADD | MINUS) term)*</span></span><br><span class="line"><span class="string">    term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">    factor : INTEGER</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    result = self.term()</span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (ADD, MINUS):</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == ADD:</span><br><span class="line">            self.eat(ADD)</span><br><span class="line">            result = result + self.term()</span><br><span class="line">        <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">            self.eat(MINUS)</span><br><span class="line">            result = result - self.term()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>感受是语法规则写出来以后代码就很好写了。</p>
</li>
</ol>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>什么是上下文无关语法（语法）？</p>
<p>上下文无关文法（英语：context-free grammar，缩写为CFG），在计算机科学中，若一个形式文法<code>G = (N, Σ, P, S)</code> 的产生式规则都取如下的形式：<code>V-&gt;w</code>，则谓之。其中 <code>V∈N, w∈(N∪Σ)*</code> 。上下文无关文法取名为“上下文无关”的原因就是因为字符 V 总可以被字串 w 自由替换，而无需考虑字符 V 出现的上下文。一个形式语言是上下文无关的，如果它是由上下文无关文法生成的。</p>
<p>上下文无关文法重要的原因在于它们拥有足够强的表达力来表示大多数程序设计语言的语法；实际上，几乎所有程序设计语言都是通过上下文无关文法来定义的。另一方面，上下文无关文法又足够简单，使得我们可以构造有效的分析算法来检验一个给定字串是否是由某个上下文无关文法产生的。例子可以参见LR 分析器和LL 分析器。</p>
<p>BNF（巴克斯-诺尔范式）经常用来表达上下文无关文法。</p>
<p>（百度百科复制的）</p>
</li>
<li><p>这个语法有几条规则/生成式？（指例子里的那个乘除法的图）</p>
<p>2条。</p>
</li>
<li><p>什么是终结符？（指出图片中的所有终结符）</p>
<p><code>INTEGER</code>这种的</p>
</li>
<li><p>什么是非终结符？（指出图片中的所有非终结符）</p>
<p><code>expr</code>这种的</p>
</li>
<li><p>什么是一条规则的 head？（指出图片中所有的 head/左边）</p>
<p>最左边的</p>
</li>
<li><p>什么是一条规则的 body？（指出图片中所有的 body/右边）</p>
<p>右边的部分</p>
</li>
<li><p>什么是一个语法的开始符号？</p>
<p>最一开始那个</p>
</li>
</ol>
<p>（2.12开始写的文档，2.28才写完……）</p>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-1</title>
    <url>/2020/02/26/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-1/</url>
    <content><![CDATA[<ol>
<li><p>为了给变量x, y, z 赋初值5，下面正确的赋值语句是（）<br>A. xyz=5                    B. x=5 y=5 z=5<br>C. x=5, y=5, z=5        D. x=5;y=5;z=5<br>E. x=y=z=5                 F. x,y,z=5<br>G. x,y,z=5,5,5</p>
<p> [DEG]<br> 没什么说的，运行一下就知道哪个对哪个错了。</p>
</li>
<li><p>x是一个两位数的整数，现将该两位数的个位和十位数字交换，例如13变成31，正确的表达式是（）<br>A. (x%10)*10+x/10           B. (x%10)//10+x/10<br>C. (x/10)%10+x//10          D. (x%10)*10+x//10</p>
<p> [D]<br> 这里要区分“/”和“//”，前者是不取整数的除法，后者是取整，例如7/3=2.333，而7//3=2。</p>
</li>
</ol>
<a id="more"></a>
<p>课后练习：</p>
<ol>
<li>编写程序1：提示输入姓名和出生年份，输出姓名和年龄。运行 结果如：<br>​        请输入你的姓名：<strong><em>张三</em></strong><br>​        你好，张三<br>​        请输入你的出生年份：<strong><em>1999</em></strong><br>​        你好，张三，你今年19岁了。</li>
</ol>
<p>这个很简单了，就是普通的输入输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = input(<span class="string">"请输入你的姓名："</span>)</span><br><span class="line">print(<span class="string">"你好，"</span>, name)</span><br><span class="line">age = input(<span class="string">"请输入你的出生年份："</span>)</span><br><span class="line">print(<span class="string">"你好，"</span>, name, <span class="string">"你今年"</span>, <span class="number">2020</span>-int(age), <span class="string">"岁了"</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>编写程序2： 三角形的三条边长为3、7、9，计算三角形的三个角（提示：余弦定理）</li>
</ol>
<p>这个也还是很简单，虽然我忘了三角形的边角关系公式，不过没关系，百度有。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">a = <span class="number">3</span></span><br><span class="line">b = <span class="number">7</span></span><br><span class="line">c = <span class="number">9</span></span><br><span class="line">A = math.acos((math.pow(c, <span class="number">2</span>) + math.pow(b, <span class="number">2</span>) - math.pow(a, <span class="number">2</span>)) / (<span class="number">2</span> * b * c))</span><br><span class="line">B = math.acos((math.pow(c, <span class="number">2</span>) + math.pow(a, <span class="number">2</span>) - math.pow(b, <span class="number">2</span>)) / (<span class="number">2</span> * a * c))</span><br><span class="line">C = math.acos((math.pow(a, <span class="number">2</span>) + math.pow(b, <span class="number">2</span>) - math.pow(c, <span class="number">2</span>)) / (<span class="number">2</span> * b * a))</span><br><span class="line">print(<span class="string">"弧度值："</span>, A, B, C)</span><br><span class="line">print(<span class="string">"角度值："</span>, math.degrees(A), math.degrees(B), math.degrees(C))</span><br></pre></td></tr></table></figure>
<ol>
<li><p>编写程序3：对猜数字游戏的程序进行如下修改：</p>
<ol>
<li>由用户键盘输入秘密数的上限和下限。</li>
<li>现有的程序每次只能玩一局，对此进行修改，玩完一局后自动进入下一局。</li>
<li>退出游戏时打印用户总共玩的局数（没玩完的局不算），如果局数不为0，则还需打印每一局的猜测次数。</li>
</ol>
</li>
</ol>
<p>这个看起来复杂，但就是条件说的不清楚而已，总的来说要求是用户输入数字的时候玩猜数字，反之结束游戏，然后输出一下统计结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">number = []</span><br><span class="line">a = input(<span class="string">"请输入一个整数下限："</span>)</span><br><span class="line"><span class="keyword">while</span> a.isdigit():</span><br><span class="line">    b = input(<span class="string">"请输入一个整数上限："</span>)</span><br><span class="line">    secret = random.randint(int(a), int(b))</span><br><span class="line">    print(<span class="string">"我有一个"</span>, a, <span class="string">"-"</span>, b, <span class="string">"的秘密数，想要猜出它？请按数字键并回车；如果不想猜了，可按非数字键并回车或直接回车。"</span>)</span><br><span class="line">    inputStr = input(<span class="string">"你猜是？"</span>)</span><br><span class="line">    number.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> inputStr.isdigit():</span><br><span class="line">        guess = int(inputStr)</span><br><span class="line">        number[count] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> guess &lt; secret:</span><br><span class="line">            print(<span class="string">"小了"</span>)</span><br><span class="line">        <span class="keyword">elif</span> guess &gt; secret:</span><br><span class="line">            print(<span class="string">"大了"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"Bingo! 你猜对啦！这个数就是"</span>, secret)</span><br><span class="line">            print(<span class="string">"继续玩下一局！"</span>)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        inputStr = input(<span class="string">"你猜是？"</span>)</span><br><span class="line">    a = input(<span class="string">"请输入一个整数下限："</span>)</span><br><span class="line">print(<span class="string">"再见，下次玩！"</span>)</span><br><span class="line">print(<span class="string">"你一共玩了"</span>, count, <span class="string">"局"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">    print(<span class="string">"第"</span>, i + <span class="number">1</span>, <span class="string">"局猜测次数为"</span>, number[i])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s Build A Simple Interpreter笔记[3]</title>
    <url>/2020/02/01/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-3/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part3/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/26/lets-build-a-simple-interpreter-part-03/" target="_blank" rel="noopener">翻译</a></p>
<p><a href="https://www.oschina.net/translate/lsbasi-part-3" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, PLUS, MINUX, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '+', '-', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">        Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">        Token(PLUS, '+')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'Token(<span class="subst">&#123;self.type&#125;</span>, <span class="subst">&#123;repr(self.value)&#125;</span>)'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 + 5", "12 - 5 + 3", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        <span class="comment"># current token instance</span></span><br><span class="line">        self.current_token = <span class="literal">None</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="comment"># Lexer code                                             #</span></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the 'pos' pointer and set the 'current_char' variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.text):</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        value = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            value += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.error()</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="comment"># Parser / Interpreter code                              #</span></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return an INTEGER token value."""</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> token.value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter."""</span></span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.get_next_token()</span><br><span class="line">        result = self.term()</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                result += self.term()</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                result -= self.term()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.error()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            print()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        interpreter = Interpreter(text)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这一课实现了多个数字的加减操作，思路大致和我想的差不多，不过循环条件是“当前字符是加号或减号”。</p>
<p>引入了句法图的使用和句法分析的概念。</p>
<blockquote>
<p>parser 只是识别出结构并保证它符合某些规范，interpreter 在 parser 成功识别后对表达式进行求值。</p>
</blockquote>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>画一张只包含乘除法的算术表达式句法图，例如“7 <em> 4 / 2 </em> 3”。不开玩笑，拿只钢笔 或铅笔试试。</p>
<p>和加减法的句法图一样。</p>
</li>
<li><p>修改计算器的源代码使它解释只包含乘除法的算术表达式，如“7 <em> 4 / 2 </em> 3”。</p>
<p>把代码里的加减换成乘除就行。</p>
</li>
<li><p>从头写一个可以处理如“7 - 3 + 2 - 1”这样算术表达式的解释器。使用任何你喜欢的语 言都可以，只靠自己，不要参考例子。做这件事时，想想都需要包含的组件：lexer 获取 输入并把它转化为 token 流，parser 从 lexer 提供的 token 流中识别结构， interpreter 在 parser 成功识别到一个合法的算术表达式之后求得其结果。把这些连起 来。花点时间把你学到的知识转化为一个可以运行的算术表达式解释器。</p>
<p>因为我别的语言都不太会，所以决定用C语言。本以为，这是个非常简单的事情，没想到写了两天，我好难过啊T_T</p>
<p>第一天发现根本没法不看python代码直接写，这说明我对整个算法流程都还不熟悉，只知道大概原理，没法自己实现，然后开始照着python代码写。这个过程中还发现我对C语言也不太熟悉，很多东西都记不清了，尤其是字符串数组和指针，实际上我到现在也没搞明白<code>char *str</code>和<code>char str[]</code>什么时候用哪个、怎么用。</p>
<p>第二天，也就是今天（20200202），我决定全用<code>char str[100]</code>这种，但还是有各种各样的问题，不过都渐渐解决了。然后花了一个多小时，才发现最大的问题在于C语言的字符串操作完全不能直接用<code>=</code>之类的方式搞，要用<code>strcpy</code>和<code>strcmp</code>，然后又是一个多小时，才发现我把<code>strcpy(new,old)</code>写成了<code>strcpy(old,new)</code>，然后第三个一小时，发现我上一步有两个用了<code>strcpy</code>的没改过来，还把一个<code>while</code>里的<code>==</code>写成了<code>=</code>。我怕是个傻子吧……</p>
<p>总之，现在写完了，能正常运行出结果。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#define SWAP(a,b) (a)^&#x3D;(b);(b)^&#x3D;(a);(a)^&#x3D;(b)</span><br><span class="line"></span><br><span class="line">char INTEGER[100]&#x3D;&quot;INTEGER&quot;;</span><br><span class="line">char PLUS[100]&#x3D;&quot;PLUS&quot;;</span><br><span class="line">char MINUS[100]&#x3D;&quot;MINUS&quot;;</span><br><span class="line">char END[100]&#x3D;&quot;EOF&quot;;</span><br><span class="line">int i&#x3D;1;</span><br><span class="line"></span><br><span class="line">struct Token		&#x2F;&#x2F;词法单元</span><br><span class="line">&#123;</span><br><span class="line">	char type[100];	&#x2F;&#x2F;类型，可以是integer、plus、minus和end</span><br><span class="line">	char value[100];	&#x2F;&#x2F;值，可以是数字，+，-，eof</span><br><span class="line">&#125;;</span><br><span class="line">struct Intepreter		&#x2F;&#x2F;解释器</span><br><span class="line">&#123;</span><br><span class="line">	int pos;			&#x2F;&#x2F;索引</span><br><span class="line">	char current_char;	&#x2F;&#x2F;当前字符</span><br><span class="line">	char text[100];		&#x2F;&#x2F;输入的字符串</span><br><span class="line">	Token token;		&#x2F;&#x2F;当前词法单元</span><br><span class="line">&#125;;</span><br><span class="line">Intepreter intepreter;</span><br><span class="line">int error()			&#x2F;&#x2F;输错符号的报错</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Invalid syntax&quot;);</span><br><span class="line">	exit(100);</span><br><span class="line">&#125;</span><br><span class="line">Intepreter init(char text[100])	&#x2F;&#x2F;初始化解释器</span><br><span class="line">&#123;</span><br><span class="line">	Token tmp;</span><br><span class="line">	tmp.type[100]&#x3D;&#123;&#125;;</span><br><span class="line">	tmp.value[100]&#x3D;&#123;&#125;;</span><br><span class="line">	Intepreter intepreter;</span><br><span class="line">	strcpy(intepreter.text,text);</span><br><span class="line">	intepreter.pos&#x3D;0;</span><br><span class="line">	intepreter.current_char&#x3D;text[intepreter.pos];</span><br><span class="line">	strcpy(intepreter.token.type,tmp.type);</span><br><span class="line">	strcpy(intepreter.token.value,tmp.value);</span><br><span class="line">	return intepreter;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;索引后移一位改变当前字符</span><br><span class="line">Intepreter advance()</span><br><span class="line">&#123;</span><br><span class="line">	intepreter.pos+&#x3D;1;</span><br><span class="line">	if (intepreter.pos&gt;&#x3D;strlen(intepreter.text))</span><br><span class="line">	&#123;</span><br><span class="line">		intepreter.current_char&#x3D;&#39;\0&#39;;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		intepreter.current_char&#x3D;intepreter.text[intepreter.pos];</span><br><span class="line">	&#125;</span><br><span class="line">	return intepreter;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;跳过空格</span><br><span class="line">void skip_whitespace()</span><br><span class="line">&#123;</span><br><span class="line"> 	while(intepreter.current_char&#x3D;&#x3D;&#39; &#39;)</span><br><span class="line">    &#123;</span><br><span class="line">        intepreter&#x3D;advance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#x2F;&#x2F;返回整数词法单元</span><br><span class="line">int integer()</span><br><span class="line">&#123;</span><br><span class="line"> 	int result&#x3D;0;</span><br><span class="line"> 	while (intepreter.current_char&gt;&#x3D;&#39;0&#39; &amp;&amp; intepreter.current_char&lt;&#x3D;&#39;9&#39;)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		result&#x3D;result*10+(intepreter.current_char-&#39;0&#39;);</span><br><span class="line"> 		intepreter&#x3D;advance();</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用来取词法单元</span><br><span class="line">Token get_next_token()</span><br><span class="line">&#123;</span><br><span class="line">	Token token;</span><br><span class="line">	while(intepreter.current_char!&#x3D;&#39;\0&#39;)</span><br><span class="line">	&#123;</span><br><span class="line">		if(intepreter.current_char&#x3D;&#x3D;&#39; &#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			skip_whitespace();</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(intepreter.current_char&gt;&#x3D;&#39;0&#39; &amp;&amp; intepreter.current_char&lt;&#x3D;&#39;9&#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			strcpy(token.type,INTEGER);</span><br><span class="line">			itoa(integer(),token.value,10);</span><br><span class="line">			return token;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(intepreter.current_char&#x3D;&#x3D;&#39;+&#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			intepreter&#x3D;advance();</span><br><span class="line">			strcpy(token.type,PLUS);</span><br><span class="line">			strcpy(token.value,&quot;+&quot;);</span><br><span class="line">			return token;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(intepreter.current_char&#x3D;&#x3D;&#39;-&#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			intepreter&#x3D;advance();</span><br><span class="line">			strcpy(token.type,MINUS);</span><br><span class="line">			strcpy(token.value,&quot;-&quot;);</span><br><span class="line">			return token;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			error();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	strcpy(token.type,END);</span><br><span class="line">	strcpy(token.value,&quot;EOF&quot;);</span><br><span class="line">	return token;</span><br><span class="line">&#125;</span><br><span class="line">void eat(char type[100])</span><br><span class="line">&#123;</span><br><span class="line">	if (strcmp(intepreter.token.type,type)&#x3D;&#x3D;0)</span><br><span class="line">	&#123;</span><br><span class="line">		intepreter.token &#x3D; get_next_token();</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		int a &#x3D; error();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int term()</span><br><span class="line">&#123;</span><br><span class="line">    Token token;</span><br><span class="line">    strcpy(token.type,intepreter.token.type);</span><br><span class="line">    strcpy(token.value,intepreter.token.value);</span><br><span class="line">    eat(INTEGER);</span><br><span class="line">    return atoi(token.value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;用来算表达式</span><br><span class="line">int expr()</span><br><span class="line">&#123;</span><br><span class="line">	int result&#x3D;0;</span><br><span class="line">	Token token;</span><br><span class="line">	intepreter.token&#x3D;get_next_token();</span><br><span class="line">    result&#x3D;term();</span><br><span class="line">    while ((strcmp(intepreter.token.type,PLUS)&#x3D;&#x3D;0)||(strcmp(intepreter.token.type,MINUS)&#x3D;&#x3D;0))</span><br><span class="line">    &#123;</span><br><span class="line">        strcpy(token.type,intepreter.token.type);</span><br><span class="line">        strcpy(token.value,intepreter.token.value);</span><br><span class="line">        if (strcmp(token.type,PLUS)&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            eat(PLUS);</span><br><span class="line">            result&#x3D;result+term();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (strcmp(token.type,MINUS)&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            eat(MINUS);</span><br><span class="line">            result-&#x3D;term();</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            error();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char text[100];</span><br><span class="line">	printf(&quot;calc&gt;&quot;);</span><br><span class="line">	scanf(&quot;%s&quot;, &amp;text);</span><br><span class="line">	intepreter&#x3D;init(text);</span><br><span class="line">	int result&#x3D;expr();</span><br><span class="line">	printf(&quot;result is %d\n&quot;,result);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>什么是句法图？</p>
<p><strong>句法图</strong> 就是程序语言句法规则的图形表示。基本上，句法图从视觉上向 你展示了在你的程序语言中哪些语句是允许的哪些是不允许的。</p>
</li>
<li><p>什么是句法分析？</p>
<p>从 token 流中识别组合的过程叫 <strong>parsing</strong>。</p>
</li>
<li><p>什么是句法分析器？</p>
<p>解释器或编译器中执行parsing的部分叫 <strong>parser</strong>。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>各种平台遇到过的error处理方式</title>
    <url>/2020/01/31/%E5%90%84%E7%A7%8D%E5%B9%B3%E5%8F%B0%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84error%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>记录一下之前的一些问题。</p>
<a id="more"></a>
<ol>
<li><p>平台：visiual studio<br>error LNK2026: 模块对于 SAFESEH 映像是不安全的<br>解决方法：属性 - &gt; 链接器 - &gt; 附加选项输入 /SAFESEH:NO - &gt; 应用</p>
</li>
<li><p>平台：visiual studio<br>error C4996: ‘fopen’: This function or variable may be unsafe. Consider using fopen_sinstead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help   for details.<br>1&gt;f:\program files (x86)\microsoft visual studio 12.0\vc\include\stdio.h(211) : 参见“fopen”的声明<br>解决方法：预处理器加入_CRT_SECURE_NO_WARNINGS</p>
</li>
<li><p>平台：visiual studio<br>error C2664: “int MessageBoxW(HWND,LPCWSTR,LPCWSTR,UINT)”: 无法将参数 2 从“const char [17]”转换为“LPCWSTR”<br>解决方法：项目菜单-&gt;属性-&gt;配置属性-&gt;常规-&gt;项目默认值-&gt;字符集从unicode改为未设置</p>
</li>
<li><p>平台：visiual studio<br>error LNK2019: 无法解析的外部符号 _main，该符号在函数 ___tmainCRTStartup 中被引用<br>解决方法：右击项目，打开“属性”页，链接器-&gt;系统-&gt;子系统-&gt;/subsystem:windows。如果是刚开始默认的是/subsystem:windows则改为/subsytem:console</p>
</li>
<li><p>平台：visiual studio<br>error LNK2019: 无法解析的外部符号 <strong>imp</strong>timeGetTime@0，该符号在函数 “void __cdecl TimerInit(void)” (?TimerInit@@YAX<br>解决方法：将winmm.lib打入“附加依赖项”</p>
</li>
<li><p>平台：visiual studio<br>fatal error LNK1123: 转换到 COFF 期间失败: 文件无效或损坏<br>解决方法：右键-&gt;工程属性-&gt;配置属性-&gt; 清单工具-&gt;输入和输出-&gt;嵌入清单，选择[否]</p>
</li>
<li><p>突然发现github上的图片打不开，具体来说就是博客里插入了上传到github的图，但是加载不出，这时需要修改hosts文件，如下：</p>
<p>打开路径C:\Windows\System32\drivers\etc下的hosts文件，在最后加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GitHub Start </span><br><span class="line">192.30.253.112    github.com </span><br><span class="line">192.30.253.119    gist.github.com</span><br><span class="line">151.101.184.133    assets-cdn.github.com</span><br><span class="line">151.101.184.133    raw.githubusercontent.com</span><br><span class="line">151.101.184.133    gist.githubusercontent.com</span><br><span class="line">151.101.184.133    cloud.githubusercontent.com</span><br><span class="line">151.101.184.133    camo.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars0.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars1.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars2.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars3.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars4.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars5.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars6.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars7.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars8.githubusercontent.com </span><br><span class="line"> # GitHub End</span><br></pre></td></tr></table></figure>
</li>
<li><p>opencv读取图像释放资源时报错：</p>
<p><code>[ WARN:1] global C:\projects\opencv-python\opencv\modules\videoio\src\cap_msmf.cpp (674) SourceReaderCB::~SourceReaderCB terminating async callback</code></p>
<p>修改代码如下：<code>cap = cv2.VideoCapture(0, cv2.CAP_DSHOW)</code></p>
</li>
<li><p>pycharm更新了一下，然后导入包的时候会有<code>unresolved reference issue</code>的提示，但是能正常运行，就只是看起来不好看。</p>
<p>解决方案：<del><a href="https://www.jianshu.com/p/9555310f1920" target="_blank" rel="noopener">有一个</a>说<code>File</code> → <code>Settings</code> → <code>Editor</code> → <code>File Types</code> → <code>Ignore files and folders</code>，干掉框框中的：<code>__init__.py;</code>，然后：<code>OK</code>等待重新文件扫描。但是我打开看了以后发现我的框里并没有<code>__init__.py</code>。于是就<code>File</code> → <code>Invalidate Caches / Restart</code>，选择<code>Invalidate and Restart</code>，等待重新扫描库文件。这之后就好了。</del>并没有解决问题，算了反正不影响运行，就这样吧。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>无分类项</category>
      </categories>
      <tags>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s Build A Simple Interpreter笔记[2]</title>
    <url>/2020/01/31/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part2/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/25/lets-build-a-simple-interpreter-part-02/" target="_blank" rel="noopener">翻译</a></p>
<p><a href="https://www.oschina.net/translate/build-a-simple-interpreter-part-2" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: 'INTEGER', 'PLUS', 'MINUS', or 'EOF'</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '+', '-', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of class instance</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'Token(<span class="subst">&#123;self.type&#125;</span>, <span class="subst">&#123;self.value&#125;</span>)'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 + 5", "12 - 5", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        <span class="comment"># current token instance</span></span><br><span class="line">        self.current_token = <span class="literal">None</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Error parsing input'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the 'pos' pointer and set the 'current_char' variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.text):</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line">            self.error()</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Parser / Interpreter</span></span><br><span class="line"><span class="string">        expr -&gt; INTEGER PLUS INTEGER</span></span><br><span class="line"><span class="string">        expr -&gt; INTEGER MINUS INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># set current token to the first token from the input</span></span><br><span class="line">        self.current_token = self.get_next_token()</span><br><span class="line">        <span class="comment"># we expect the current token to be an integer</span></span><br><span class="line">        left = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="comment"># we expect the current token to be either a '+' or '-'</span></span><br><span class="line">        op = self.current_token</span><br><span class="line">        <span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">            self.eat(PLUS)</span><br><span class="line">        <span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">            self.eat(MINUS)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">        <span class="comment"># we expect the current token to be an integer</span></span><br><span class="line">        right = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="comment"># after the above call the self.current_token is set to</span></span><br><span class="line">        <span class="comment"># EOF token</span></span><br><span class="line">        <span class="comment"># at this point either the INTEGER PLUS INTEGER or</span></span><br><span class="line">        <span class="comment"># the INTEGER MINUS INTEGER sequence of tokens</span></span><br><span class="line">        <span class="comment"># has been successfully found and the method can just</span></span><br><span class="line">        <span class="comment"># return the result of adding or subtracting two integers,</span></span><br><span class="line">        <span class="comment"># thus effectively interpreting client input</span></span><br><span class="line">        <span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">            result = left.value + right.value</span><br><span class="line">        <span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">            result = left.value - right.value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call with 'input'</span></span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        interpreter = Interpreter(text)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这个处理方式和我想的不太一样…</p>
<p>整体逻辑是：</p>
<ol>
<li><code>get_next_token</code>是词法分析器，输入一个字符串，逐一输出词法单元，比如输入<code>32 + 5</code>，输出的流应该是<code>Token(INTEGER, 32) -&gt; Token(PLUS, +) -&gt; Token(INTEGER, 5)</code>。<br>这个词法分析器用到的辅助函数为<code>advance()</code>，<code>skip_whitespace()</code>和<code>interger()</code>，其中<code>advance()</code>让索引后移一位，<code>skip_whitespace()</code>跳过空格，<code>interger()</code>把连续的数字变成一个完整的数字。注意这里如果是多位数中间有空格，多位数会被拆成两个数字，比如<code>32 3</code>会被判断为<code>32</code>和<code>3</code>，而不是<code>323</code>。<br>词法分析过程中会遇到以下几种情况：(1)空格，要跳过空格，循环继续运行，分析下一个字符；(2)结束符，直接返回<code>EOF</code>对应的<code>token</code>；(3)数字，循环终止，连后面的几位数字字符一起变成一个数字，返回对应的<code>token</code>；(4)是<code>+</code>或者<code>-</code>，索引移到下一位，循环终止，返回运算符对应的<code>token</code>。<br>分析几个辅助函数：<ol>
<li><code>advance()</code>，索引<code>pos</code>后移一位，当前字符<code>current.char</code>的值变为新索引对应的字符。</li>
<li><code>skip_whitespace()</code>，循环调用<code>advance()</code>直到当前字符不是空格。</li>
<li><code>integer()</code>，先声明一个初始为空字符串的<code>result</code>，然后循环把<code>current.char</code>加到<code>result</code>这个字符串里，接着<code>advance()</code>移动到下一位，直到当前字符不是数字。</li>
</ol>
</li>
<li><code>expr()</code>是用来计算表达式的，判断词法分析后的词法单元是否符合规则，然后根据规则来计算结果。辅助函数为<code>eat()</code>，用来判断当前词法单元是否符合规则。</li>
</ol>
<p>以输入<code>32 + 5</code>为例分析整个流程：</p>
<ol>
<li><p>首先运行的是<code>main()</code>，获取输入字符串，存到<code>text</code>中（<code>line116</code>)，并用<code>text</code>初始化<code>interpreter</code>这个解释器类(<code>line121</code>)，此时，<code>interpreter.text</code>就是我们输入的字符串，<code>interpreter.pos</code>是初始值<code>0</code>，<code>self.current_token</code>是初始值<code>None</code>，<code>self.current_char</code>是<code>interpreter.text</code>这个字符串数组下标为<code>pos=0</code>对应的字符，也就是<code>3</code>。</p>
</li>
<li><p>接下来<code>line122</code>调用了表达式计算器<code>expr()</code>，而<code>expr()</code>的第一行调用了词法分析器<code>get_next_token()</code>，因为字符3是数字，所以要去调用<code>integer()</code>函数，并返回一个类型为<code>INTEGER</code>、值为函数结果的<code>TOKEN</code>。<br>在执行完<code>integer()</code>并返回之前，<code>pos=0</code>，<code>current_token=None</code>，<code>current_char=3</code>。</p>
</li>
<li><p>进入<code>integer()</code>函数，最初<code>result</code>是空字符串，<code>current_char=3</code>符合循环条件，进入<code>while</code>循环，<code>result</code>变成<code>3</code>（是字符串格式）,调用<code>advance()</code>，接下来先让索引后移，即<code>pos=1</code>，此时还没移到最后一位，更新<code>current_char=text[pos]=text[1]=2</code>。此时还符合循环条件，<code>result</code>把新的<code>current_char</code>加上，变成<code>32</code>（字符串格式），再次<code>advance()</code>，调用完后，<code>pos=2</code>，依旧没移到最后一位，<code>current_char=text[2]=空格</code>。这时不满足循环条件了，循环结束，返回字符串<code>result</code>对应的数字也就是32。</p>
</li>
<li><p>然后回到<code>get_next_token()</code>，它已经有返回值了，返回给之前的<code>expr()</code>中的<code>self.current_token</code>，这是我们得到的第一个词法单元，是我们要计算的表达式的左值，将它存到<code>left</code>中，之后可以使用<code>left.value</code>来访问它的值，这之后就调用<code>eat()</code>看该值是不是一个<code>INTEGER</code>，如果是，就再次调用<code>get_next_token()</code>继续分析下一个单元，反之则报错。很显然此时<code>current_token</code>是<code>(INTEGER,32)</code>，符合要求，进入<code>get_next_token()</code>。</p>
</li>
<li><p><code>get_next_token()</code>判断此时<code>current_char</code>是空格，因此执行<code>skip_whitespace()</code>。</p>
</li>
<li><p>在<code>skip_whitespace()</code>中，<code>current_char</code>满足循环条件，进入循环体，调用<code>advance()</code>，<code>pos=3</code>，<code>current_char=text[3]=+</code>，循环结束，回到<code>get_next_token()</code>，执行<code>continue</code>，也就是继续进行词法判断。</p>
</li>
<li><p>由于<code>current_char</code>是<code>+</code>，在对应的<code>if</code>分支中，执行<code>advance()</code>，<code>pos=4</code>,<code>current_char=text[4]=空格</code>，然后把<code>+</code>对应的<code>token</code>返回到<code>expr()</code>中。</p>
</li>
<li><p><code>expr()</code>把新得到的<code>token</code>存入<code>op</code>，并通过<code>eat()</code>判断该<code>token</code>是否是一个加号或者减号。此时是加号，又开始了<code>get_next_token()</code>。</p>
</li>
<li><p>这次<code>get_next_token()</code>首先进入空格分支，跳过空格后，<code>pos=5</code>，<code>current_char=5</code>，进入数字分支，执行<code>integer()</code>。<code>integer()</code>中和第三步一样，最终返回数字5，再回到<code>get_next_token()</code>，返回5对应的<code>token</code>给<code>expr()</code>，存在<code>right</code>中。</p>
</li>
<li><p>此时，我们已经完成了词法分析，得到了<code>(INTEGER, 32) -&gt; (PLUS, &#39;+&#39;) -&gt; (INTEGER, 5)</code>的词法结构。由于<code>OP</code>对应的类型是<code>PLUS</code>，对<code>left.value</code>和<code>right.value</code>执行加法，存入<code>result</code>并返回。</p>
</li>
<li><p>再回到<code>line122</code>，<code>result</code>已经得到了结果，<code>line123</code>输出该结果，程序运行结束。</p>
</li>
</ol>
<p>也就是说，在计算表达式结果的函数中调用词法分析器，判断词法分析的结果是否符合规则，如果符合规则，就按规则继续运行。在计算器函数中，只会出现<code>token</code>类型的变量，而词法分析函数会负责把词法单元打包成<code>token</code>交给计算器。</p>
<blockquote>
<p>在解释一个表达式之前，你需要知道它是哪种组合，比如相加或相减。这是 <code>expr</code> 方法本质上做的事： 它从 <code>get_next_token</code> 方法得到的 token 流中找到结构，然后解释它识别出的组合，产 生算术表达式的结果。<br>从 token 流中查找结构，或者说从 token 流中识别组合，的过程叫做 <strong>parsing</strong>. 解释器 或编译器中执行这部分任务的叫 <strong>parser</strong>.<br>现在你知道解释器的 <strong>parsing</strong> 和 <strong>解释</strong> 都在 <code>expr</code> 方法中了── <code>expr</code> 方法首先尝 试从 token 流中识别（即parse） INTEGER -&gt; PLUS -&gt; INTEGER 或 the INTEGER -&gt; MINUS -&gt; INTEGER 组合，在成功识别到（即parsed）其中一个组合时，该方法就解释执行 它并返回给调用者两个整数相加或相减的结果。</p>
</blockquote>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>扩展计算器以处理两个整数相乘</p>
</li>
<li><p>扩展计算器以处理两个整数相除</p>
<p>前两个都很简单，仿照加法减法的代码复制改写就行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运算符声明</span></span><br><span class="line">INTEGER, PLUS, MINUS, MULTIPLY, DIVIDE, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MULTIPLY'</span>, <span class="string">'DIVIDE'</span>, <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get_next_token()</span></span><br><span class="line"><span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">	self.advance()</span><br><span class="line">	<span class="keyword">return</span> Token(MULTIPLY, <span class="string">'*'</span>)</span><br><span class="line"><span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">	self.advance()</span><br><span class="line">	<span class="keyword">return</span> Token(DIVIDE, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># expr()</span></span><br><span class="line"><span class="comment"># 修改读取运算符</span></span><br><span class="line">op = self.current_token</span><br><span class="line"><span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">	self.eat(PLUS)</span><br><span class="line"><span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">	self.eat(MINUS)</span><br><span class="line"><span class="keyword">elif</span> op.type == MULTIPLY:</span><br><span class="line">	self.eat(MULTIPLY)</span><br><span class="line"><span class="keyword">elif</span> op.type == DIVIDE:</span><br><span class="line">	self.eat(DIVIDE)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	self.error()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改计算结果那里</span></span><br><span class="line"><span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">	result = left.value + right.value</span><br><span class="line"><span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">	result = left.value - right.value</span><br><span class="line"><span class="keyword">elif</span> op.type == MULTIPLY:</span><br><span class="line">	result = left.value * right.value</span><br><span class="line"><span class="keyword">elif</span> op.type == DIVIDE:</span><br><span class="line">	result = left.value / right.value</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	self.error()</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改代码以使它可以解释包含任意个数字的加减操作，如“9 - 5 + 3 + 11”</p>
<p>这个也不难。此时的词法结构是<code>INTEGER -&gt; 循环[OP -&gt;INTEGER]</code>，在<code>expr()</code>里首先读取并<code>eat()</code>第一个词法单元，<code>result</code>先等于这个单元的值，接下来用<code>while</code>进行两个词法单元为一组的循环，直到读取到<code>EOF</code>，每个循环里，<code>result</code>与新的<code>INTEGER</code>进行加减运算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改expr()</span></span><br><span class="line">result = left.value</span><br><span class="line"><span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">	op = self.current_token</span><br><span class="line">	<span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">		self.eat(PLUS)</span><br><span class="line">	<span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">		self.eat(MINUS)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		self.error()</span><br><span class="line">	right = self.current_token</span><br><span class="line">	self.eat(INTEGER)</span><br><span class="line">	<span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">		result += right.value</span><br><span class="line">	<span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">		result -= right.value</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		self.error()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>什么是 lexeme？<br>lexeme 是组成 token 的一个字符序列。（这个词翻译过来是<strong>词位</strong>或<strong>词素</strong>）<br><code>token</code>和<code>lexeme</code>的关系类似于类和实例（或者对象）之间的关系。举例来说，变量<code>a</code>和<code>b</code>，它们属于同一种<code>token</code>：<code>identifier</code>，而<code>a</code>的<code>lexeme</code>是<code>a</code>，<code>b</code>的<code>lexeme</code>是<code>b</code>。每个关键字是一种<code>token</code>。<code>token</code>可以附带一个值属性，例如变量<code>a</code>，调用<code>gettoken()</code>时，会返回一个<code>identifier</code>类型的<code>token</code>，其值属性是<code>a</code>。</p>
</li>
<li><p>在 token 流中找到结构的过程叫什么？或者这么问，在 token 流中识别出特定组合的过程叫什么？<br>parsing（翻译是语法分析或句法分析）</p>
</li>
<li><p>解释器（编译器）做 parsing 工作的部分叫什么？<br>parser（也就是语法分析器）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s Build A Simple Interpreter笔记[1]</title>
    <url>/2020/01/30/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/23/lets-build-a-simple-interpreter-part-01/" target="_blank" rel="noopener">翻译</a></p>
<p>上一个翻译页面凉了，找了一个<a href="https://www.oschina.net/translate/build-a-simple-interpreter-part-1" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, PLUS, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, '+', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">        Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">        Token(PLUS, '+')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3+5"</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        <span class="comment"># current token instance</span></span><br><span class="line">        self.current_token = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Error parsing input'</span>)    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        text = self.text    </span><br><span class="line">        <span class="comment"># is self.pos index past the end of the self.text ?</span></span><br><span class="line">        <span class="comment"># if so, then return EOF token because there no more</span></span><br><span class="line">        <span class="comment"># input left to convert into tokens</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(text) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)    </span><br><span class="line">        <span class="comment"># get a character at the position self.pos and decide</span></span><br><span class="line">        <span class="comment"># what token to create based on the single character</span></span><br><span class="line">        current_char = text[self.pos]    </span><br><span class="line">        <span class="comment"># if the character is a digit then convert it to</span></span><br><span class="line">        <span class="comment"># integer, create an INTEGER token, increment self.pos</span></span><br><span class="line">        <span class="comment"># index to point to the next character after the digit,</span></span><br><span class="line">        <span class="comment"># and return the INTEGER token</span></span><br><span class="line">        <span class="keyword">if</span> current_char.isdigit():</span><br><span class="line">            token = Token(INTEGER, int(current_char))</span><br><span class="line">            self.pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> token    </span><br><span class="line">        <span class="keyword">if</span> current_char == <span class="string">'+'</span>:</span><br><span class="line">            token = Token(PLUS, current_char)</span><br><span class="line">            self.pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> token    </span><br><span class="line">        self.error()    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""expr -&gt; INTEGER PLUS INTEGER"""</span></span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.get_next_token()    </span><br><span class="line">        <span class="comment"># we expect the current token to be a single-digit integer</span></span><br><span class="line">        left = self.current_token</span><br><span class="line">        self.eat(INTEGER)    </span><br><span class="line">        <span class="comment"># we expect the current token to be a '+' token</span></span><br><span class="line">        op = self.current_token</span><br><span class="line">        self.eat(PLUS)    </span><br><span class="line">        <span class="comment"># we expect the current token to be a single-digit integer</span></span><br><span class="line">        right = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="comment"># after the above call the self.current_token is set to</span></span><br><span class="line">        <span class="comment"># EOF token    </span></span><br><span class="line">        <span class="comment"># at this point INTEGER PLUS INTEGER sequence of tokens</span></span><br><span class="line">        <span class="comment"># has been successfully found and the method can just</span></span><br><span class="line">        <span class="comment"># return the result of adding two integers, thus</span></span><br><span class="line">        <span class="comment"># effectively interpreting client input</span></span><br><span class="line">        result = left.value + right.value</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call with 'input'</span></span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        interpreter = Interpreter(text)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol>
<li>词法分析(lexical analysis)：把输入字符串拆分成 token 的过程。解释器中做这个工作的部分被称为 <strong>词法分析器</strong>(lexical analyzer)，简称 <strong>lexer</strong> ，也被称作  <strong>scanner</strong> 或 <strong>tokenizer</strong> 。</li>
<li>在完成词法分析后，解释器需要验证token序列是否符合期望的序列，如果符合，则进行一些运算，不符合则抛出异常。</li>
</ol>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><ol>
<li>目的是执行一位数的加法运算，整体逻辑是，先取第一个字符，判断是否是数字，如果是，就把这个数字存在<code>left</code>中，然后取第二个字符，判读是否为加号，如果是，再继续取第三个字符，判断是否为数字并把数字存在<code>right</code>中，接下来就可以计算<code>left.value + right.value</code>了。整个过程中字符的移动依靠一个名为<code>pos</code>的变量，它作为索引，每当取完一个字符，<code>pos</code>的值就会<code>+1</code>，这样直到最后一个字符。</li>
<li><code>Token</code>类构造了一个结构为<code>(类型, 值)</code>的变量，当我们访问某个<code>Token</code>类型的变量<code>v</code>时，可以通过<code>v.type</code>来获取它的类型，通过<code>v.value</code>获取它的值。</li>
<li><code>Interpreter</code>类是我们的解释器类型，其中<code>get_next_token()</code>函数可以从字符串中取一个字符，判断该字符类型是数字还是<code>+</code>，并返回正确的<code>Token</code>结构，比如是数字，就返回<code>Token(INTEGER, int(current_char))</code>，然后索引(<code>pos</code>)往后挪一位，如果既不是数字也不是加号，比如是空格，就会报错，如果已经到最后一位了，会返回<code>EOF</code>。</li>
<li>接下来的<code>eat()</code>函数，参数是判断现在取出来的字符<code>type</code>是否符合设想的<code>type</code>，如果符合，就调用<code>get_next_token()</code>取下一个字符；反之，就输出错误信息。</li>
<li>然后<code>expr()</code>函数用来按顺序从头到尾逐个读取字符，在<code>eat()</code>的帮助下判断整体结构是否符合词法要求（比如这里的要求是<code>INTEGER -&gt; + INTEGER</code>）并执行运算。</li>
<li>最后的<code>main()</code>，将输入的字符串存到<code>text</code>中，并用<code>text</code>初始化类型为<code>Interpreter</code>的变量<code>interpreter</code>，接下来调用<code>interpreter.expr()</code>进行计算，结果存放到<code>result</code>中并输出。</li>
</ol>
<h4 id="python相关"><a href="#python相关" class="headerlink" title="python相关"></a>python相关</h4><ol>
<li><p>python命名规则：以下划线开头的标识符是有特殊意义的。以单下划线开头例如<code>_foo</code> 代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 <code>from xxx import</code> 而导入。<br> 以双下划线开头的 <code>__foo</code> 代表类的私有成员，以双下划线开头和结尾的 <code>__foo__</code> 代表 Python 里特殊方法专用的标识，如 <code>__init__()</code> 代表类的构造函数。</p>
</li>
<li><p>python中的<code>main()</code>函数：python程序按顺序执行，而不是像之前学过的语言那样先找<code>main()</code>然后从<code>main()</code>开始，执行过程中遇到<code>def</code>代码块会先跳过，每个代码块需要保持相同的缩进。</p>
<p> 例如：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># code1</span></span><br><span class="line">print(<span class="string">"test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    str = <span class="string">"function"</span></span><br><span class="line">    print(str)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"main"</span>)</span><br><span class="line">    foo()</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">test</span><br><span class="line">main</span><br><span class="line">function</span><br><span class="line"></span><br><span class="line"><span class="comment"># code2</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    print(<span class="string">"Hello python !!!"</span>)    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_print</span><span class="params">()</span>:</span>  </span><br><span class="line">        print(<span class="string">"in func_print"</span>)   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>  </span><br><span class="line">        print(<span class="string">"In main"</span>)    </span><br><span class="line">    main()  </span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">Hello python !!!</span><br><span class="line">In main</span><br><span class="line"></span><br><span class="line"><span class="comment"># code3</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"Hello python !!!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_print</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"in func_print"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"In main"</span>)</span><br><span class="line"></span><br><span class="line">        func_print()</span><br><span class="line">main()</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">Hello python !!!</span><br><span class="line">In main</span><br><span class="line"><span class="keyword">in</span> func_print</span><br><span class="line"></span><br><span class="line"><span class="comment">#code4</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"Hello python !!!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_print</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"in func_print"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"In main"</span>)</span><br><span class="line"></span><br><span class="line">	func_print()</span><br><span class="line">main()</span><br><span class="line"><span class="comment"># output </span></span><br><span class="line">Hello python !!!</span><br><span class="line"><span class="keyword">in</span> func_print</span><br><span class="line">In main</span><br></pre></td></tr></table></figure>
</li>
<li><p>python中的<code>__name__</code>：<code>__name__</code>是python的一个内置类属性，它天生就存在于一个 python 程序中，代表对应程序名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test()</span><br><span class="line">	print(__name__)</span><br><span class="line">test</span><br></pre></td></tr></table></figure>
<p>直接运行temp2.py 时：<code>__name__=&quot;__main__&quot;</code>，在其它程序中导入temp2.py，则：<code>__name__=&quot;temp2.py&quot;</code>，所以<code>__name__</code>的主要作用就是用来区分，模块是直接被运行还是被导入。</p>
<p>实际使用时，我们会把测试模块时要执行的语句放到<code>if __name__ == &#39;__main__&#39;:</code>这个代码块里，这样测试的时候能看到测试结果，而调用的时候，测试语句不会被执行，也就不用删除测试语句。</p>
</li>
</ol>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>修改代码使得允许输入多位整数，例如<code>12+3</code></p>
<p>多位数不一定是几位数，也就是说我们在得到输入之前无法判断整个字符串第几位是什么类型，但是整体结构一定是<code>连在一起的数字 + 连在一起的数字</code>，因此考虑用<code>while</code>循环读取数字，在当前字符不是数字的情况下跳出循环去读取<code>+</code>，然后继续循环读数字，直到读取出<code>EOF</code>，字符串结束。具体来说是声明<code>left</code>和<code>right</code>两个数字并初始化为0，然后<code>left</code>存第一位数字，接下来乘10+第二位数字，再乘10+第三位数字，依次循环；<code>right</code>也是这样。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改expr()</span></span><br><span class="line">left = right = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> self.current_token.type == <span class="string">'INTEGER'</span>:    </span><br><span class="line">	left = left * <span class="number">10</span> + self.current_token.value    </span><br><span class="line">	self.eat(INTEGER)</span><br><span class="line"><span class="comment"># 中间几行代码省略</span></span><br><span class="line"><span class="keyword">while</span> self.current_token.type != <span class="string">'EOF'</span>:</span><br><span class="line">	right = right * <span class="number">10</span> + self.current_token.value</span><br><span class="line">	self.eat(INTEGER)</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加一个跳过空白符的方法，使你的计算器可以处理包含空白符的输入如<code>12 + 3</code></p>
<p>我们要增加一个<code>Token</code>类型用来识别空格，然后在<code>expr()</code>中读取到空格时就调用<code>eat()</code>来跳过，我们假设空格不会出现在一个多位数的中间（比如<code>1 2 3</code>就会报错)。</p>
<p>具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在代码开始的地方加</span></span><br><span class="line">SPACE = <span class="string">'SPACE'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在get_next_token()里加</span></span><br><span class="line"><span class="keyword">if</span> current_char == <span class="string">' '</span>:</span><br><span class="line">	token = Token(SPACE, current_char)</span><br><span class="line">	self.pos += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在expr()的数字和操作符的前后加</span></span><br><span class="line"><span class="keyword">while</span> self.current_token.value == <span class="string">' '</span>:</span><br><span class="line">	self.eat(SPACE)</span><br></pre></td></tr></table></figure>
<p><strong>这里存在一些问题需要改进</strong>：</p>
<ol>
<li>应该可以想办法跳过多位数中间的空格，也就是直接忽略所有空格；</li>
<li>个人认为不应该在<code>expr()</code>这个函数中出现对字符类型的判断，应该是在<code>expr()</code>中逐位后移，这个过程中调用其他函数来处理忽略空格等情况，也就是说上一个的<code>while</code>循环也不太合适，但是我暂时没想到怎么改，就先这样吧，反正功能上没问题。之后学到正则相关的地方可能会有新的思路。</li>
</ol>
</li>
<li><p>修改代码使得它可以处理<code>-</code>而非<code>+</code>的情况</p>
<p>这个类似于空格，也是要添加一下，我的做法是直接把<code>+</code>和<code>-</code>统一成类型为<code>OP</code>值为对应字符的<code>TOKEN</code>，然后在<code>expr()</code>中最后运算的时候，判断该变量的值是什么，再执行对应的运算。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件开头的PLUS = 'PLUS'修改为</span></span><br><span class="line">OP = <span class="string">'OP'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改get_next_token()</span></span><br><span class="line"><span class="keyword">if</span> current_char == <span class="string">'+'</span> <span class="keyword">or</span> current_char == <span class="string">'-'</span>:</span><br><span class="line">	token = Token(OP, current_char)</span><br><span class="line">	self.pos += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改expr()</span></span><br><span class="line"><span class="keyword">if</span> op.value == <span class="string">'+'</span>:</span><br><span class="line">	result = left + right</span><br><span class="line"><span class="keyword">if</span> op.value == <span class="string">'-'</span>:</span><br><span class="line">	result = left - right</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   <strong>下一课的内容说明了我的想法全是错的…暴风哭泣</strong></p>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>什么是解释器？</p>
<p>解释器把高级语言逐行转译执行。</p>
</li>
<li><p>什么是编译器？</p>
<p>编译器把高级语言翻译成低级语言，再一起执行。</p>
</li>
<li><p>解释器和编译器的区别是什么？</p>
<p>一个是一边翻译一边执行，一个是翻译完再执行。</p>
</li>
<li><p>什么是 token？</p>
<p>有类型的值的对象</p>
</li>
<li><p>将输入拆分成 token 的过程叫什么？</p>
<p>词法分析</p>
</li>
<li><p>解释器中做词法分析的部分叫什么？</p>
<p>词法分析器(lexical analyzer)</p>
</li>
<li><p>解释器或编译器的这个部分还有什么其他常见的名字？</p>
<p>scanner 或 tokenizer</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo + next + github配置blog</title>
    <url>/2020/01/30/hexo-next-github%E9%85%8D%E7%BD%AEblog/</url>
    <content><![CDATA[<h2 id="安装各种东西"><a href="#安装各种东西" class="headerlink" title="安装各种东西"></a>安装各种东西</h2><ol>
<li><p>node.js：<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js官网链接</a> 点击下载安装即可。</p>
</li>
<li><p>Git： <a href="https://www.git-scm.com/download/win" target="_blank" rel="noopener">Git官网链接</a> 点击下载安装即可。</p>
</li>
<li><p>deployer-git： 命令行里输入<code>npm install hexo-deployer-git --save</code>。</p>
</li>
<li><p>Hexo：</p>
<ol>
<li>准备好一个用于存放博客文件的文件夹（比如Github），在该文件夹的根目录下运行刚才装完git以后会出现的git-bash.exe（这里其实直接用cmd进入命令行然后进入博客文件夹也可以）；</li>
<li>输入命令<code>npm install -g hexo-cli</code></li>
</ol>
</li>
<li><p>这里补充一点：安装的版本很重要，如果hexo和node中某个版本较高，后面配置的时候会冲突，使用<code>hexo -v</code>可以查看版本。我目前使用的版本如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo: 4.2.0</span><br><span class="line">hexo-cli: 4.2.0</span><br><span class="line">os: Windows_NT 10.0.19043 win32 x64</span><br><span class="line">node: 12.20.0</span><br><span class="line">v8: 7.8.279.23-node.45</span><br><span class="line">uv: 1.40.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">ares: 1.16.1</span><br><span class="line">modules: 72</span><br><span class="line">nghttp2: 1.41.0</span><br><span class="line">napi: 7</span><br><span class="line">llhttp: 2.1.3</span><br><span class="line">http_parser: 2.9.3</span><br><span class="line">openssl: 1.1.1g</span><br><span class="line">cldr: 37.0</span><br><span class="line">icu: 67.1</span><br><span class="line">tz: 2019c</span><br><span class="line">unicode: 13.0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><ol>
<li>创建Hexo工程：接着刚才那个命令输入<code>hexo init blog</code>，这里会在这个文件夹下新建一个blog文件夹，如果把blog换成其他名字也是可以的。</li>
<li>新建Post：命令行里进入blog文件夹（<code>cd blog</code>），输入<code>hexo new “HelloWorld”</code>，这里会在 <strong>/blog/sources/_post/</strong> 目录下生成 <strong>HelloWorld.md</strong> 文件，可以进去打开编辑内容，在之后想写新博客也是通过这个命令生成文件，或者直接把写好的博客文件放到该目录下。</li>
<li>生成静态文件：命令行里输入<code>hexo generate</code>，也可以简单地写成<code>hexo g</code>。这样就使用 <strong>Hexo</strong> 引擎将 <strong>Markdown</strong> 格式的文件解析成可以使用浏览器查看的 <strong>HTML</strong> 文件，<strong>HTML</strong> 文件存储在 <strong>blog/public</strong> 目录下。</li>
<li>运行Hexo服务器：命令行里输入<code>hexo server</code>，也可以简写成<code>hexo s</code>。这时命令行会有一些提示，其中有个地址，一般是<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，在浏览器里打开这个地址，就能看到博客网站是什么样的了。不过这个时候还只是一个本地博客。</li>
</ol>
<h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p><strong>Hexo</strong> 提供了默认主题 <strong>landscape</strong>，主题的位置在 <strong>blog -&gt;themes</strong> 文件夹下。主题根据自己喜好可以在网上找到，通过 <strong>Git</strong> 进行相应的下载。接下来以Next主题为例。</p>
<ol>
<li>还是在blog文件夹下，命令行里输入<code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code>，这里是用<code>git clone</code>把<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">next主题</a>下载并存放到themes -&gt; next 文件夹里。需要注意的是，<code>git clone</code>这个命令下载起来特别慢，但浏览器直接去github下载的话速度还行，所以也可以直接下载解压改文件夹的名字并放到对应的地方。</li>
<li>修改 <strong>/blog/config.yml</strong> 文件，将其中的 <strong>theme</strong> 对应的内容改成 <strong>next</strong>（比如最初是<code>theme: landscape</code>，现在要换成<code>next</code>主题，就改成<code>theme: next</code>）。如果文件夹的名字不是next，或者用了其他主题等，这里的theme字段改成对应的文件夹名字就行。</li>
<li>接下来可以输入<code>hexo g</code> 和<code>hexo s</code>来查看新的本地博客。</li>
</ol>
<h2 id="建立Github博客"><a href="#建立Github博客" class="headerlink" title="建立Github博客"></a>建立Github博客</h2><ol>
<li><p>在<a href="https://github.com/" target="_blank" rel="noopener">Github官网</a>注册账号并登陆，点首页右上角的加号新建一个仓库(Repository)，仓库的名字为用户名.github.io（比如我的是kun-bin.github.io），这里一定要是这个格式，不然之后没法直接访问博客网站。然后其他的都是默认内容，点create repository就可以了。如果仓库名字输入错了，之后可以在github上这个仓库页面的setting选项中修改。</p>
</li>
<li><p>打开 <strong>/blog/config.yml</strong>文件修改deploy 属性(注意“：”之后有空格 ) 否则配置失败。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;kun-bin&#x2F;kun-bin.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>注意这里repository要替换成自己的仓库地址。</p>
</li>
<li><p>初始化本地仓库：在blog文件夹下的命令行输入<code>git init</code></p>
</li>
<li><p>连接远程仓库：命令行接着输入<code>git remote add origin https://github.com/kun-bin/kun-bin.github.io.git</code>，这里记得把地址改成自己的仓库地址，第一次的时候会要求输入github的账号密码。</p>
</li>
<li><p>发布博客页面：命令行里输入<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>，这等于一次性执行了清空、刷新、部署三个命令，此时在浏览器里已经可以通过<code>用户名.github.io</code>访问博客了，在github的这个仓库里也能看到<strong>/blog/public</strong>文件夹里的内容。</p>
</li>
<li><p>可选：<code>hexo d</code>只是把public文件夹中的内容（也就是静态网页）传到了github的仓库里，应该还可以建立分支把博客配置文件整个传到github上，不过我没做这一步。</p>
</li>
</ol>
<h2 id="关于next主题的配置"><a href="#关于next主题的配置" class="headerlink" title="关于next主题的配置"></a>关于next主题的配置</h2><p>目前在blog文件夹里有一个config.yml文件，我们称之为站点配置文件；而在themes/next文件夹里也有一个config.yml文件，称之为主题配置文件。</p>
<ol>
<li><p>基本信息：打开站点配置文件，找到site模块，可以修改博客标题、作者、描述、语言等等信息，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">subtitle: 副标题</span><br><span class="line">description: 描述</span><br><span class="line">author: 作者</span><br><span class="line">language: 语言（简体中文是zh-Hans）</span><br><span class="line">timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写）</span><br></pre></td></tr></table></figure>
</li>
<li><p>菜单配置：初始网页只有两个菜单：home和archive，可以打开主题配置文件，找到menu模块，把需要的菜单前面的#删了，并注意把||<strong>前面</strong>的空格删了，不然可能会点了菜单以后报错（类似Cannot GET /tags/%20/这样的错）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /|| home                          <span class="comment">//首页</span></span><br><span class="line">  archives: /archives/|| archive          <span class="comment">//归档</span></span><br><span class="line">  categories: /categories/|| th           <span class="comment">//分类</span></span><br><span class="line">  tags: /tags/|| tags                     <span class="comment">//标签</span></span><br><span class="line">  about: /about/|| user                   <span class="comment">//关于</span></span><br><span class="line">  <span class="meta">#schedule: /schedule/|| calendar        <span class="comment">//日程表</span></span></span><br><span class="line">  <span class="meta">#sitemap: /sitemap.xml|| sitemap        <span class="comment">//站点地图</span></span></span><br><span class="line">  <span class="meta">#commonweal: /404/|| heartbeat          <span class="comment">//公益404</span></span></span><br></pre></td></tr></table></figure>
<p>这里||后面的单词是指菜单对应的图标，可以自己修改。此外，日程表那个模块，因为实际上调用的是谷歌日历，国内显然没法用，所以不建议使用。</p>
</li>
<li><p>建立菜单对应的页面：还是在blog文件夹下打开命令行，输入<code>hexo new page &quot;categories&quot;</code>，然后在~/blog/source 文件夹中即可看到categories文件夹，打开里面的index.md文件，设置如下（注意：后面要加空格）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2020-01-30 08:54:26</span><br><span class="line">type: &quot;categories&quot;</span><br></pre></td></tr></table></figure>
<p>tags页面也是一样的方式来建立。</p>
</li>
<li><p>主题风格：一共有四个风格可以选择，打开主题配置文件 找到<code>Scheme Settings</code>，把想用的风格前面的#去掉，比如我这里用了Mist。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line">scheme: Mist</span><br><span class="line"><span class="comment"># scheme: Pisces</span></span><br><span class="line"><span class="comment"># scheme: Gemini</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>侧栏设置：侧栏设置包括：侧栏位置、侧栏显示与否、文章间距、返回顶部按钮等等，打开主题配置文件 找到<code>sidebar</code>，按自己的喜好选择，把想要的那一项的#去掉或者false改成true即可。</p>
</li>
<li><p>头像设置：主题配置文件找到<code>avatar</code>，修改avatar后面的路径为自己头像的路径，头像文件要放到<code>themes/next/source/images</code>中，比如头像文件名为<code>header.jpg</code>，就把那一行写成<code>avatar: /images/header.jpg</code>。如果前面有#就去掉#。</p>
</li>
<li><p>添加搜索：</p>
<ol>
<li><p>还是blog文件夹的命令行里，输入<code>npm install hexo-generator-searchdb --save</code>。</p>
</li>
<li><p>打开站点配置文件找到<code>Extensions</code>在下面添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搜索</span></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  <span class="built_in">limit</span>: 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开主题配置文件找到<code>Local search</code>，将<code>enable</code>设置为<code>true</code>。</p>
</li>
</ol>
</li>
<li><p>还有很多能配置的，比如侧边栏头像下面有github链接，点击页面出现爱心符号，博客背景动态变化等，可自行搜索。</p>
</li>
</ol>
<h2 id="关于ayer主题的配置"><a href="#关于ayer主题的配置" class="headerlink" title="关于ayer主题的配置"></a>关于ayer主题的配置</h2><p>今天（2021.02.26）为了让网页中的公式能稍微好一些，我换了一个新主题<a href="https://shen-yu.gitee.io/2019/ayer/" target="_blank" rel="noopener">ayer</a>。</p>
<ol>
<li><p>安装：在博客文件夹的目录下进命令行输入<code>git clone https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer</code>，如果因为网络原因等问题导致GitHub没法用，可以改用码云：<code>git clone https://gitee.com/mirrors/ayer.git themes/ayer</code>；</p>
</li>
<li><p>博客配置文件中的主题改成<code>ayer</code>；</p>
</li>
<li><p>进主题配置文件进行自己需要的修改，比如调整logo、友情链接、启用公式等等；</p>
</li>
<li><p>需要注意的是，这个主题的分类（categories）、标签（tags）等文件和next主题稍微不一样，需要改一下，以分类为例，进入<code>...\source\categories</code>文件夹，可以看到一个<code>index.md</code>文件，打开以后无论里面有什么内容，都彻底改成以下的：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">"---"(这里的双引号是为了正确显示，实际用的时候没有，最后一行的双引号同理)</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-01-30 08:54:26</span><br><span class="line">type: "categories"</span><br><span class="line">layout: "categories"   </span><br><span class="line">"---"</span><br></pre></td></tr></table></figure>
<p>相应地，其他用到的文件夹里的<code>index.md</code>也这样改。</p>
</li>
<li><p>安装好以后进行<code>hexo clean</code>等等操作，就可以看到新主题的博客了，不过可能和我的屏幕尺寸有关，在文章页面中，固定的目录栏有些靠右，以至于目录显示不完整，而浮动的目录栏有些靠左了，会挡住正文，当目录很长时，文章几乎没法看了。这时需要打开主题中对目录栏的配置，<code>\themes\ayer\source-src\css\_partial</code>文件夹中的<code>tocbot.styl</code>文件，第一部分<code>.tocbot</code>的<code>right</code>属性从<code>-28rem</code>改成<code>-25rem</code>，这样固定目录栏就相对偏左一些，能显示完整了；第六部分<code>.is-position-fixed</code>的<code>right</code>属性从<code>6rem</code>改成<code>0</code>，这样浮动目录栏就会贴着右边，从而不挡左边了；</p>
</li>
<li><p>按上面这个操作改完以后发现网页的显示并没有变化，接着打开<code>\themes\ayer\source\dist</code>文件夹中的<code>main.css</code>文件，然后直接搜索<code>-28rem</code>或者<code>tocbot</code>等关键词，找到以后把<code>-28</code>和<code>6</code>改成合适的数值（<code>-25</code>和<code>0</code>），重新部署网站就会发现目录栏变合适了。</p>
</li>
<li>经过漫长的使用，忽然发现右边那个目录，在白天模式下，背景是半透明的那种效果，会挡住正文的一些内容，而黑夜模式下背景就透明了，什么也挡不住。经过一番研究，发现想要白天模式也透明背景，就需要修改<code>\themes\ayer\source-src\css\_partial</code>文件夹中的<code>tocbot.styl</code>文件，找<code>.is-position-fixed</code>字段中的<code>background-color</code>，把它的值修改为<code>transparent</code>，接着同样是进<code>\themes\ayer\source\dist</code>文件夹中的<code>main.css</code>文件，先定位到刚才<code>tocbot</code>那里，然后往后很近的位置能看到<code>is-position-fixed</code>字段，修改其中的<code>background</code>的值为<code>transparent</code>，这里不能直接全文检索<code>is-position-fixed</code>，因为有好多这个属性，必须精确修改<code>tocbot</code>的这个属性。保存后重新部署就可以看到效果了。</li>
<li>又是漫长的使用，发现hexo在渲染公式的时候，会把一些符号识别成html标记，然后就没法正确渲染，网上查到的方法都是针对下划线、斜体等，解决方法是安装mathjax并修改转义符配置，但我出问题的是大于号和小于号，查到的方法都没啥用，最终找到一个方法，是在写公式的时候，不直接用尖括号来表示大于小于，而是用tex符号，即<code>\lt</code>表示小于，<code>\gt</code>表示大于，这样就不会出问题了，也不影响本地markdown的渲染。</li>
</ol>
<h2 id="GitHub风格日历、标签云、分类雷达图的配置"><a href="#GitHub风格日历、标签云、分类雷达图的配置" class="headerlink" title="GitHub风格日历、标签云、分类雷达图的配置"></a>GitHub风格日历、标签云、分类雷达图的配置</h2><p>由于next主题的css文件是swig格式，而网上查到的GitHub日历等都是ejs格式的，因此在用next主题时没能成功配置好日历等；改用Ayer主题后，该主题就是ejs格式的，因此现在添加了日历等内容。这一部分所有涉及到的下载链接都是在别人网站里复制的，如果链接失效可以直接在网上搜文件名来下载，也可以在我的GitHub项目中的主题文件里找已经修改和配置好的相关内容。</p>
<h3 id="需要下载配置的文件"><a href="#需要下载配置的文件" class="headerlink" title="需要下载配置的文件"></a>需要下载配置的文件</h3><ol>
<li><p>下载<a href="https://pan.miaodrew.workers.dev/Drew/web/js/echarts.min.js?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">echarts.min.js</a>，放到主题文件夹中的<code>\source\js</code>文件夹中，</p>
</li>
<li><p>下载<a href="https://pan.miaodrew.workers.dev/Drew/web/css/matery.css?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">matery.css</a>，放到主题文件夹中的<code>\source\css</code>文件夹中。</p>
</li>
<li><p>打开<code>\layout\_partial\head.ejs</code>文件，在<code>head</code>标记中添加一行：</p>
<p><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/matery.css&quot;&gt;</code></p>
<p>这一行直接加到<code>&lt;head&gt;</code>的下一行就好，在我的文件里是加到了第10行，如下图：</p>
<p><img src="https://i.loli.net/2021/02/27/hAeoFcx8wIYlL2S.png" alt="image-20210227182758974"></p>
</li>
</ol>
<h3 id="GitHub风格日历"><a href="#GitHub风格日历" class="headerlink" title="GitHub风格日历"></a>GitHub风格日历</h3><ol>
<li><p>下载<a href="https://pan.miaodrew.workers.dev/Drew/web/ejs-hexo/post-calendar.ejs?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">post-calendar.ejs</a>，放到<code>\layout\_widget</code>文件夹中，如果没有这个文件夹就自己新建一个。</p>
</li>
<li><p>打开<code>post-calendar.ejs</code>文件，看第7行的内容是否为<code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/echarts.min.js&quot;&gt;&lt;/script&gt;</code>，如果不是则改成这样。</p>
</li>
<li><p>在打算添加文章日历的地方，输入以下这行代码</p>
<p><code>&lt;%- partial(&#39;_widget/post-calendar&#39;) %&gt;</code></p>
<p>例如我要加到归档页面（<code>archive</code>），就打开<code>\layout\archive.ejs</code>文件，进行添加。不过Ayer主题的这个文件里就下面这行内容：</p>
<p><code>&lt;%- partial(&#39;_partial/archive&#39;, {pagination: config.archive, index: true}) %&gt;</code></p>
<p>如果直接在这一行前面或者后面添加日历代码，显示效果会不太好，而且会被左边的侧栏挡住，因此找到<code>\layout\_partial\archive.ejs</code>文件，在添加日历代码的时候可以多尝试几个位置，看哪个合适。我打算把日历放到“归档”这两个字的下面，文章列表的上面，于是整个文件的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section class&#x3D;&quot;outer&quot;&gt;</span><br><span class="line">  &lt;% if (theme.ads &amp;&amp; theme.ads.length !&#x3D; 0)&#123; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;ads&#39;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;% if (theme.broadcast.enable &amp;&amp; pagination &#x3D;&#x3D; 2)&#123; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;_partial&#x2F;broadcast&#39;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;article class&#x3D;&quot;articles&quot;&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">    var title &#x3D; &#39;&#39;;</span><br><span class="line">    if (page.category) title &#x3D; page.category;</span><br><span class="line">    if (page.tag) title &#x3D; &quot;#&quot; + &quot;&amp;nbsp&quot; + page.tag;</span><br><span class="line">    if (page.archive) &#123;</span><br><span class="line">      if (page.year) title &#x3D; page.year + (page.month ? &#39;&#x2F;&#39; + page.month : &#39;&#39;);</span><br><span class="line">      else title &#x3D; __(&#39;archive_a&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;% if (pagination !&#x3D;&#x3D; 2)&#123; %&gt;</span><br><span class="line">    &lt;h1 class&#x3D;&quot;page-type-title&quot;&gt;&lt;%- title %&gt;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">    &lt;% if (pagination &#x3D;&#x3D; 2)&#123; %&gt;</span><br><span class="line">    &lt;% page.posts.each(function(post)&#123; %&gt;</span><br><span class="line">    &lt;%- partial(&#39;article&#39;, &#123;post: post, index: true&#125;) %&gt;</span><br><span class="line">    &lt;% &#125;) %&gt;</span><br><span class="line">  &lt;&#x2F;article&gt;</span><br><span class="line">  &lt;% &#125; else &#123; %&gt;</span><br><span class="line">  &lt;% var last; %&gt;</span><br><span class="line">  &lt;% page.posts.each(function(post, i)&#123; %&gt;</span><br><span class="line">  &lt;% var year &#x3D; post.date.year(); %&gt;</span><br><span class="line">  &lt;% if (last !&#x3D; year)&#123; %&gt;</span><br><span class="line">  &lt;% if (last !&#x3D; null)&#123; %&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;% last &#x3D; year; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;_widget&#x2F;post-calendar&#39;) %&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;archives-wrap&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;archive-year-wrap&quot;&gt;</span><br><span class="line">      &lt;a href&#x3D;&quot;&lt;%- url_for(config.archive_dir + &#39;&#x2F;&#39; + year) %&gt;&quot; class&#x3D;&quot;archive-year&quot;&gt;&lt;%&#x3D; year %&gt;&lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;archives&quot;&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">      &lt;%- partial(&#39;archive-post&#39;, &#123;post: post, even: i % 2 &#x3D;&#x3D; 0&#125;) %&gt;</span><br><span class="line">      &lt;% &#125;) %&gt;</span><br><span class="line">      &lt;% if (page.posts.length)&#123; %&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">  &lt;% if (page.total &gt; 1)&#123; %&gt;</span><br><span class="line">  &lt;nav class&#x3D;&quot;page-nav&quot;&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        var prev_text &#x3D; theme.nav_text.page_prev;</span><br><span class="line">        var next_text &#x3D; theme.nav_text.page_next</span><br><span class="line">      %&gt;</span><br><span class="line">    &lt;%- paginator(&#123;</span><br><span class="line">        prev_text: prev_text,</span><br><span class="line">        next_text: next_text</span><br><span class="line">      &#125;) %&gt;</span><br><span class="line">  &lt;&#x2F;nav&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;&#x2F;section&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后呈现的效果如下：</p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/02/27/sXmQr18FJ6HtNko.png" alt="image-20210227184135159"></p>
<h3 id="标签云"><a href="#标签云" class="headerlink" title="标签云"></a>标签云</h3><ol>
<li><p>下载<a href="https://cdn.jsdelivr.net/gh/InfiniteYinux/cloud@2.44/Hexo/themeConfig/tag-cloud.ejs" target="_blank" rel="noopener">tag-cloud.ejs</a>，放到<code>\layout\_widget</code>文件夹中，如果没有这个文件夹就自己新建一个。</p>
</li>
<li><p>打开<code>tag-cloud.ejs</code>，和前面那个日历一样，检查是否有<code>&lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%- theme.jsDelivr.url %&gt;&lt;%- theme.libs.js.echarts %&gt;&quot;&gt;&lt;/script&gt;</code>，如果有则替换为<code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/echarts.min.js&quot;&gt;&lt;/script&gt;</code>。如果没有就忽略。</p>
</li>
<li><p>在需要添加标签云的地方，输入代码：<code>&lt;%- partial(&#39;_widget/tag-cloud&#39;) %&gt;</code></p>
</li>
<li><p>例如我要将这个添加到原本的标签页面，则找到<code>\layout\tags.ejs</code>文件，添加标签云代码。需要注意的是，Ayer主题本身会在这个页面自动生成标签，因此需要把<code>tags.ejs</code>文件中原本的标签内容那行去掉，整个文件改成了以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section class&#x3D;&quot;outer&quot;&gt;</span><br><span class="line">  &lt;% if (site.tags.length)&#123; %&gt;</span><br><span class="line">    &lt;h1 class&#x3D;&quot;page-type-title&quot;&gt;&lt;%&#x3D; __(&#39;tags&#39;) %&gt;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;%- partial(&#39;_widget&#x2F;tag-cloud&#39;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;&#x2F;section&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此外，标签云本身的标题和Ayer主题中的标题会重复显示，而我更喜欢Ayer本身那个标题，所以编辑了<code>tag-cloud.ejs</code>文件，把第25行的<code>&lt;i class=&quot;fas fa-tags&quot;&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;&lt;%= __(&#39;postTagTitle&#39;) %&gt;</code>中的<code>postTagTitle</code>改成了空格，之所以没直接去掉这一行，是因为觉得空一行好看一些。</p>
</li>
<li><p>整体效果如图，和Ayer主题本身的标签相比，要好看一些。标签的颜色也可以在<code>tag-cloud.ejs</code>文件中自行修改。<img src="https://i.loli.net/2021/02/27/il6UtNjZsCkqozK.png" alt="image-20210227185130174"></p>
</li>
</ol>
<h3 id="分类雷达图"><a href="#分类雷达图" class="headerlink" title="分类雷达图"></a>分类雷达图</h3><ol>
<li><p>下载<a href="https://pan.miaodrew.workers.dev/Drew/web/ejs-hexo/category-radar.ejs?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">category-radar.ejs</a>，放到<code>\layout\_widget</code>文件夹中，如果没有这个文件夹就自己新建一个。</p>
</li>
<li><p>依旧是检查替换<code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/echarts.min.js&quot;&gt;&lt;/script&gt;</code>，如果没有就忽略。</p>
</li>
<li><p>在需要添加分类雷达图的地方，输入代码：<code>&lt;%- partial(&#39;_widget/category-radar&#39;) %&gt;</code></p>
</li>
<li><p>例如我要添加到原本的分类（<code>category</code>）页面，就找到<code>\layout\categories.ejs</code>，这里我不打算去掉原本的分类内容，因此不删除原本的代码，直接添加雷达图代码，修改后的文件整体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section class&#x3D;&quot;outer&quot;&gt;</span><br><span class="line">  &lt;% if (site.categories.length)&#123; %&gt;</span><br><span class="line">    &lt;h1 class&#x3D;&quot;page-type-title&quot;&gt;&lt;%&#x3D; __(&#39;categories&#39;) %&gt;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;categories-box&quot;&gt;</span><br><span class="line">      &lt;%- list_categories() %&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;_widget&#x2F;category-radar&#39;) %&gt;</span><br><span class="line">&lt;&#x2F;section&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果觉得这个雷达图和主题格格不入，想给它加个边框，则可以在刚才的<code>categories.ejs</code>文件最开头的地方粘贴以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">        #contentss &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">        width: 800px;</span><br><span class="line">        height: 1200px;</span><br><span class="line">        max-height: 1200px;</span><br><span class="line">        margin-bottom: 15px;</span><br><span class="line">        margin-top: 15px;</span><br><span class="line">        text-align: center;</span><br><span class="line">        border: 0;</span><br><span class="line">        border-radius: 10px;</span><br><span class="line">        color: rgba(0, 0, 0, .87);</span><br><span class="line">        background: #fff 50%;</span><br><span class="line">        background-size: cover;</span><br><span class="line">        box-shadow: 0 15px 35px rgba(50, 50, 93, .1), 0 5px 15px rgba(0, 0, 0, .07);</span><br><span class="line">        margin:0 auto;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p>然后下面的雷达图代码修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;contentss&quot;&gt;</span><br><span class="line">&lt;%- partial(&#39;_widget&#x2F;category-radar&#39;) %&gt;&lt;&#x2F;div&gt;&#96;或者&#96;&lt;%- partial(&#39;_widget&#x2F;post-calendar&#39;) %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>边框的大小样式颜色等等可以自行修改。不过Ayer主题不加边框就挺合适了，因此我没加。</p>
</li>
<li><p>整体效果如下（这个截图是一开始没注意，把雷达图加到了标签页面，但是不影响雷达图的展示；此外，很显然分类名字过长就会显示不完整，这应该和雷达图的大小有关，懒得改了）：</p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/02/27/4TRVLa5sFIzktBX.png" alt="image-20210227190056808"></p>
<h2 id="如何发布新的博客"><a href="#如何发布新的博客" class="headerlink" title="如何发布新的博客"></a>如何发布新的博客</h2><ol>
<li><p>在blog文件夹的命令行里输入<code>hexo new &quot;标题&quot;</code>，然后进入<strong>/blog/sources/_post/</strong>找到对应的markdown文件就可以开始写了，也可以直接在这个文件夹下新建一个markdown文件，然后添加对应的文件头。写博客的时候根据需求在文件头里填写tags和categories的信息，然后hexo会自动建立好tags和categories的内容并给文章分类。</p>
<p>文件头信息如下编写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>title:<br>date:<br>tags:<br>categories:</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. 写好以后保存，然后还是blog文件夹的命令行，输入&#96;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d&#96;，就发布成功了。</span><br><span class="line"></span><br><span class="line">3. 如果一个文章想设置多个标签，那么在编写文件头信息的时候，要按下面的方式写：</span><br></pre></td></tr></table></figure>
<p>   tags:</p>
<pre><code>   - tag1
   - tag2
   ...
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里&#96;tags:&#96; 后面一定要换行，下面的&#96;-&#96;后面注意有空格。</span><br><span class="line"></span><br><span class="line">## 一些后续问题</span><br><span class="line"></span><br><span class="line">今天（2020.03.16）突然发现当博客内容多起来以后，首页会有翻页，而翻页图标显示是乱的，查了一下发现要改&#96;&#x2F;Blog&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;pagination.swig&#96;这个文件，内容整体替换成下面的：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;html</span><br><span class="line">&#123;%- if page.prev or page.next %&#125;</span><br><span class="line"> &lt;nav class&#x3D;&quot;pagination&quot;&gt;</span><br><span class="line">&#123;&#123;</span><br><span class="line">  paginator(&#123;</span><br><span class="line">    prev_text: &#39;&lt;i class&#x3D;&quot;fa fa-angle-left&quot; aria-label&#x3D;&quot;&#39;+__(&#39;accessibility.prev_page&#39;)+&#39;&quot;&gt;&lt;&#x2F;i&gt;&#39;,</span><br><span class="line">    next_text: &#39;&lt;i class&#x3D;&quot;fa fa-angle-right&quot; aria-label&#x3D;&quot;&#39;+__(&#39;accessibility.next_page&#39;)+&#39;&quot;&gt;&lt;&#x2F;i&gt;&#39;,</span><br><span class="line">    mid_size: 1,</span><br><span class="line">    escape: false</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;&#125;</span><br><span class="line"> &lt;&#x2F;nav&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SSH登录配置"><a href="#SSH登录配置" class="headerlink" title="SSH登录配置"></a>SSH登录配置</h2><p>每次<code>hexo d</code>的时候都要输入用户名和密码会很麻烦，所以今天做了一下这个。</p>
<ol>
<li><p>首先进入博客目录比如<code>C:\Users\LiKun\Documents\GitHub\blog</code>，在这个目录下右键然后打开git bash，如果右键没这个选项那就去开始菜单之类的地方打开git bash然后一点点切目录；</p>
</li>
<li><p>输入<code>ls -al ~/.ssh</code>检查目前是否有已经生成过的密钥文件，这个命令会输出<code>.ssh</code>里的文件，如果其中有<code>id_rsa.pub</code>或者<code>id_dsa.pub</code>，那就直接看第五步，如果这俩都没有就继续第三步；</p>
</li>
<li><p>输入<code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code>，这里注意把自己的邮箱替换进去，看到提示<code>Enter file in which to save the key (/c/Users/you/.ssh/id_rsa):</code>时，直接按回车；</p>
</li>
<li><p>然后会要求输入密码，这个密码要记住，在第一次使用该ssh密钥时系统会要求输入它，也就是说后面会用，<strong>不过这里有个坑</strong>；</p>
</li>
<li><p>输入<code>clip &lt; ~/.ssh/id_rsa.pub</code>，即可把密钥内容复制到剪贴板，或者自己进<code>.ssh</code>找到密钥文件复制也行；</p>
</li>
<li><p>浏览器打开Github页面，右上角头像那里的下拉菜单有个Settings，点开以后左边找到<code>SSH and GPG keys</code>，点开以后右边的界面会列出目前所有的密钥，如果之前没做过那这里是空的；</p>
</li>
<li><p>SSH Keys那里点<code>New SSH Key</code>，名字随便设置，密钥部分粘贴第五步复制的那个，然后保存；</p>
</li>
<li><p>接下来回博客目录，找到<code>_config.yml</code>，也就是站点配置文件，把最下面<code>deploy</code>属性中的<code>repository:</code>内容修改成<code>git@github.com:你的name/你的username.github.io.git</code>的样子，比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:likun1208/likun1208.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>这里有的地方也把<code>repository:</code>写成<code>repo:</code>，应该都行。</p>
</li>
<li><p>然后命令行里<code>hexo d</code>，会要求输入之前第四步里的那个密码；</p>
</li>
<li><p>我本来以为，第四步那个密码是输入一次之后就不用再输入的，然而尝试几次以后发现是每次都要输入，查了很多网页，有说配置ssh的config文件，有说修改host，总之都不太对，最终才发现，这一切都是因为第四步设置了密码，如果第四步不设置密码，一路按回车，就没有任何问题了！ssh似乎没提供修改密码的方式，所以就需要重新输入<code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code>，生成新的密钥文件并复制，然后去github的settings那里删旧密钥加新密钥，其他配置不用改动。</p>
</li>
</ol>
<h2 id="分支同步"><a href="#分支同步" class="headerlink" title="分支同步"></a>分支同步</h2><p>今天研究了一下把博客所有文件上传到github仓库的一个分支，这样可以在多个电脑上同步写博客而不需要用U盘来回复制。首先，如果前面没有自己定义分支的名字，那么我们的网站内容是存放在<code>master</code>分支的，在这一步，我们会新建一个<code>hexo</code>分支，来存放博客文件（指主题文件和博客markdown文件等）。具体来说，当我们需要在多个电脑之间迁移博客时，会受影响的文件如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">文件（夹）</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">scaffolds/</td>
<td style="text-align:center">博客文章的模版</td>
</tr>
<tr>
<td style="text-align:center">source/</td>
<td style="text-align:center">所有博客文章，以及about、tags、categories等page</td>
</tr>
<tr>
<td style="text-align:center">themes/</td>
<td style="text-align:center">网站的主题</td>
</tr>
<tr>
<td style="text-align:center">.gitignore</td>
<td style="text-align:center">在push时需要忽略的文件和文件夹</td>
</tr>
<tr>
<td style="text-align:center">_config.yml</td>
<td style="text-align:center">站点配置文件</td>
</tr>
<tr>
<td style="text-align:center">package.json</td>
<td style="text-align:center">依赖包的名称和版本号</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>在github网站上找到自己的博客项目，新建<code>hexo</code>分支，并设置为主分支；</p>
</li>
<li><p>在本地博客文件夹里打开git bash，输入<code>git clone git@github.com:用户名/用户名.github.io.git</code>，把<code>hexo</code>分支复制到本地，这里的用户名请自行替换；</p>
</li>
<li><p>在博客文件夹里找到<code>.gitignore</code>文件，如果没有这个文件就自己新建一下，注意这个文件开头就是<code>.</code>，整个名字就是<code>.gitignore</code>，然后打开它里面写入以下内容，表示同步的时候忽略这些文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules&#x2F;</span><br><span class="line">public&#x2F;</span><br><span class="line">.deploy*&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的<code>.git</code>文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了；</p>
</li>
<li><p>然后在git bash里输入以下命令，即可完成<code>hexo</code>分支的上传：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit –m &quot;add branch&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>这里的add branch可以改成其他内容，表示这次上传的说明注释；</p>
</li>
<li><p>到此就完成了上传，这样换电脑以后，按照前面的内容把git和hexo以及其他相关东西都安装配置好以后，通过git把这个项目文件下载到本地，就又可以编辑博客了；</p>
</li>
<li><p>如果多个电脑同时在写博客，时不时需要同步博客内容，就不需要<code>git clone</code>下载整个文件，只需要<code>git pull</code>把远程文件同步到本地即可；</p>
</li>
<li><p>总结一下就是，每次写博客之前，首先<code>git pull</code>把github上的博客内容下载到本地；写完新的内容，首先进行<code>hexo clean, hexo g, hexo d</code>把内容渲染成网页并发布，接着<code>git add ., git commit -m &quot;description&quot;, git push</code>把新增和修改的内容也上传到github，这样就可以实现白天在实验室写，晚上回宿舍写的操作了；</p>
</li>
<li><p>以上操作也可以通过github的桌面版程序来完成，还挺方便。</p>
</li>
</ol>
<h2 id="新版live2d"><a href="#新版live2d" class="headerlink" title="新版live2d"></a>新版live2d</h2><p>前面的内容提到了hexo本身可以安装插件并设置live2d的开关，打开以后加载对应模型就能显示了，但是在实际使用的过程中，我发现它支持的是旧版本的live2d，无法显示新版本的，因此研究一番试图加载新版本的。</p>
<p>首先简单说明一下，目前市面上的live2d模型有3个版本，最古老的是2.0版本，它只能用旧版的live2d cubism生成（官网没有对应的版本了），其次是3.0版本，它能用目前所有版本的<a href="https://www.live2d.com/zh-CHS/" target="_blank" rel="noopener">Live2D Cubism</a>软件生成，最新的是4.0版本，能用最新的live2d cubisim制作。虽然可以用同一个软件制作，但是3.0和4.0是不同的，差别在于sdk版本。它们在live2d的模型配置文件（.model.json）中的version都是3，然而用live2d cubism viewer打开查看moc3文件的信息就能发现sdk版本的差异了，这也导致网页渲染的时候要用不同的东西。</p>
<h3 id="3-0版本的处理"><a href="#3-0版本的处理" class="headerlink" title="3.0版本的处理"></a>3.0版本的处理</h3><p>在查找资料的过程中，我首先找到的是众多3.0版本的资料，对比一番可以发现虽然大家原理和代码语法都差不多，但<a href="https://weidows.github.io/post/Web/JavaScript/live2d-moc3/README/" target="_blank" rel="noopener">这个</a>是集大成作，它的行数最少，使用起来很简单，只需要找到主题文件夹中<code>layout</code>目录下的<code>layout.ejs</code>文件（<code>index.ejs</code>应该也可以），然后在最后的<code>&lt;/body&gt;</code>前面添加以下几行代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Live2DCubismCore --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://fastly.jsdelivr.net/gh/Weidows-projects/live2d-moc3/dist/live2dcubismcore.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Include Pixi. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://fastly.jsdelivr.net/gh/Weidows-projects/live2d-moc3/dist/pixi.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://fastly.jsdelivr.net/gh/Weidows-projects/live2d-moc3/dist/live2d.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">addEventListener(<span class="string">"DOMContentLoaded"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">let</span> models=[&#123;<span class="attr">left</span>:<span class="string">"0px"</span>,<span class="attr">bottom</span>:<span class="string">"0px"</span>,<span class="attr">basePath</span>:<span class="string">"https://fastly.jsdelivr.net/gh/likun1208/Live2d_modules@gh-pages/assets"</span>,<span class="attr">role</span>:<span class="string">"test05261"</span>,<span class="attr">background</span>:<span class="string">""</span>,<span class="attr">opacity</span>:<span class="number">1</span>,<span class="attr">mobile</span>:<span class="literal">false</span>,&#125;,];<span class="keyword">new</span> Live2dLoader(models)&#125;);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代码中前3行是加载live2d相关的js文件，第四行是加载模型文件，这一步需要把自己要用的模型上传到GitHub，或者用别人Github中已有的文件。具体来说，需要在Github上建立一个仓库用来存模型文件，然后把模型文件放到仓库中，模型文件夹的名字与模型的<code>model3.json</code>文件的名字一定要保持一致，比如我这里的模型文件夹是<code>gongzi</code>，那么里面的文件一定是<code>gongzi.model3.json</code>，其他文件名不重要。</p>
<p>最后在<code>js</code>代码中，<code>basePath</code>设置为如上述代码所示的<code>&quot;https://fastly.jsdelivr.net/gh/likun1208/Live2d_modules@gh-pages/assets&quot;</code>，因为我的模型是在仓库的<code>assets</code>文件夹中，如果直接放仓库里就不要加<code>assets</code>了，前面的<code>gh-pages</code>是分支名，没分支可以不加，再往前的<code>Live2d_modules</code>是仓库名，<code>likun1208</code>是用户名，<code>https://fastly.jsdelivr.net/gh/</code>是cdn加速，不详细介绍了。总之把<code>basePath</code>按这个方式设置好以后，再把<code>role</code>设置成模型文件夹的名字，也就是我这里的<code>gongzi</code>，必要的步骤就完成了，其他可设置的一系列参数在前面提到的参考文档中可以看到。</p>
<p>在把这些准备好以后，要记得把hexo本身的那个live2d关掉，不然两个都会出现。最后部署博客页面就能看到模型了。</p>
<h3 id="4-0版本的处理"><a href="#4-0版本的处理" class="headerlink" title="4.0版本的处理"></a>4.0版本的处理</h3><p>但是很可惜我想用的模型是4.0版本的，前面那段js会报错，在发现自己重做3.0版本模型特别艰难之后，我走上了寻找4.0解决方案的道路，并查到了<a href="https://github.com/Konata09/Live2dOnWeb" target="_blank" rel="noopener">这个项目</a>，它能自动识别模型版本并用对应的方式渲染，哪个版本都兼容，还可以放多个模型来回切换，这非常好。</p>
<p>需要注意的是，如果模型中有expression等字段，它是无法解析的，虽然不影响模型显示，但是对应的表情动作都不会生效。所支持的字段可以查看项目中给的模型例子然后照着写。</p>
<p>具体在hexo博客中的使用，首先需要把项目文件整个都下载好，把其中的<code>dist</code>和<code>model</code>这两个文件夹复制到主题文件夹中的<code>source</code>文件夹下，把其中的<code>waifu-tips.js</code>和<code>waifu-tips.json</code>这两个文件复制到前述<code>source</code>文件夹中的<code>js</code>文件夹下，现在的文件目录如下（没提到的文件未列出）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- blog</span><br><span class="line">    -themes</span><br><span class="line">        -ayer(主题文件夹)</span><br><span class="line">            -source</span><br><span class="line">                - dist</span><br><span class="line">                - model</span><br><span class="line">                - js</span><br><span class="line">                    waifu-tips.js</span><br><span class="line">                    waifu-tips.json</span><br></pre></td></tr></table></figure>
<p>文件都放好以后，打开<code>waifu-tips.js</code>，在前面有一行<code>&#39;modelUrl&#39;: &#39;model&#39;, // 存放模型的文件夹路径，末尾不需要斜杠</code>，把这一行修改为<code>&#39;modelUrl&#39;: &#39;/model&#39;, // 存放模型的文件夹路径，末尾不需要斜杠</code>（在model前面加<code>/</code>，不然网站解析的时候就不是绝对路径了）；打开前面提到过的主题文件夹中<code>layout</code>目录下的<code>layout.ejs</code>文件，在最后的<code>&lt;/body&gt;</code>前面加下列内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"waifu"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"waifu-message"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"waifu-tool"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-next"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-home"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-message"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-camera"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-volumeup"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-volumedown"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-about"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-cross"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"live2d2"</span> <span class="attr">style</span>=<span class="string">"top:150px"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"live2d4"</span> <span class="attr">style</span>=<span class="string">"top:150px"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    src 中改为你存放的路径    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/dist/live2d_bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"/js/waifu-tips.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于<code>waifu-tips.js</code>中模型列表等各类内容的配置直接参考项目说明即可。</p>
<p>需要注意的是，这里<code>&lt;canvas id=&quot;live2d2&quot; style=&quot;top:150px&quot;&gt;&lt;/canvas&gt;</code>和它下一行的内容中，<code>style=top:150px</code>是我自己加的，正常模型不需要加这个。我加它的原因是要用的达达利亚模型画布比模型本身大一圈，自己没法修改，只能调整模型位置让它贴到页面边缘。不确定如果换个尺寸的显示屏，这里会不会又出问题，总之姑且先这样了。</p>
<p>接下来重新部署网站，就能看到模型了。</p>
<h3 id="鼠标穿透问题"><a href="#鼠标穿透问题" class="headerlink" title="鼠标穿透问题"></a>鼠标穿透问题</h3><p>在用了很久以后，我发现模型总是会挡住页面的可点击内容，比如目录、文章标题等，估计是因为用的模型尺寸大一圈，有很高一片空白区域。这有些影响使用，于是想试着把模型改成可以鼠标穿透点击的效果。经过各种尝试，目前发现的一个解决方案确实有效，但是会导致无法显示模型的工具栏（有切换模型和回到首页等功能），也就是说只能固定显示一个模型，操作方法如下：打开<code>waifu-tips.js</code>，找到如下代码块：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">const waifuStyle = `</span><br><span class="line">#waifu &#123;</span><br><span class="line">$&#123;live2d_settings.waifuEdgeSide&#125;px;</span><br><span class="line">position:fixed;</span><br><span class="line">bottom:0;</span><br><span class="line">z-index:998;</span><br><span class="line">font-size:0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在最后一行<code>font-size:0</code>末尾加个分号，然后增加一行：<code>pointer-events: none</code>，修改后的代码如下：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">const waifuStyle = `</span><br><span class="line">#waifu &#123;</span><br><span class="line">$&#123;live2d_settings.waifuEdgeSide&#125;px;</span><br><span class="line">position:fixed;</span><br><span class="line">bottom:0;</span><br><span class="line">z-index:998;</span><br><span class="line">font-size:0;</span><br><span class="line">pointer-events: none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这实际上就是把整个模型改成了不响应鼠标事件的效果，自然就能让鼠标点击穿透到页面的其他链接，但也同时导致工具栏无法响应。目前还没找到其他既能显示工具栏又能鼠标穿透的方法，先这样吧。</p>
<h2 id="添加待办清单"><a href="#添加待办清单" class="headerlink" title="添加待办清单"></a>添加待办清单</h2><p>今天（2023年10月18日）一时兴起，想在博客里添加个ToDo List，找到一个<a href="https://juejin.cn/post/6889975936381845512" target="_blank" rel="noopener">参考链接</a>，是直接写了个<code>html</code>放到对应的位置，并设置不渲染这个<code>html</code>。虽然这不是我想要的效果，但也勉强能用，于是记录一下整个操作过程：</p>
<ol>
<li>首先新建对应的菜单，这一步参照前面的内容，在主题配置文件中的menu字段加一行即可；</li>
<li>其次新建菜单对应的文件夹，也是参照前面内容，文件夹里只放一个<code>index.html</code>，其中的内容如下： <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">	<span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ToDo List<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.6.10/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        body&#123;</span><br><span class="line">            margin:0;background-color:#fafafa;font:14px 'Helvetica Neue',Helvetica,Arial,sans-serif&#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">h2</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">font-size</span>:<span class="number">12px</span>&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">a</span>&#123;<span class="attribute">color</span>:<span class="number">#000</span>;<span class="attribute">text-decoration</span>:none&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">input</span>&#123;<span class="attribute">outline</span>:<span class="number">0</span>&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">button</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">border</span>:<span class="number">0</span>;<span class="attribute">background</span>:<span class="number">0</span>;<span class="attribute">font-size</span>:<span class="number">100%</span>;<span class="attribute">vertical-align</span>:baseline;<span class="attribute">font-family</span>:inherit;<span class="attribute">font-weight</span>:inherit;<span class="attribute">color</span>:inherit;<span class="attribute">outline</span>:<span class="number">0</span>&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">ul</span>&#123;<span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">list-style</span>:none&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.page-top</span>&#123;<span class="attribute">width</span>:<span class="number">100%</span>;<span class="attribute">height</span>:<span class="number">40px</span>;<span class="attribute">background-color</span>:<span class="number">#db4c3f</span>&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.page-content</span>&#123;<span class="attribute">width</span>:<span class="number">50%</span>;<span class="attribute">margin</span>:<span class="number">0</span> auto&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.page-content</span> <span class="selector-tag">h2</span>&#123;<span class="attribute">line-height</span>:<span class="number">40px</span>;<span class="attribute">font-size</span>:<span class="number">18px</span>;<span class="attribute">color</span>:<span class="number">#fff</span>&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span>&#123;<span class="attribute">width</span>:<span class="number">50%</span>;<span class="attribute">margin</span>:<span class="number">0</span> auto;<span class="attribute">box-sizing</span>:border-box&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.task-input</span>&#123;<span class="attribute">width</span>:<span class="number">99%</span>;<span class="attribute">height</span>:<span class="number">30px</span>;<span class="attribute">outline</span>:<span class="number">0</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ccc</span>&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.task-count</span>&#123;<span class="attribute">display</span>:flex;<span class="attribute">margin</span>:<span class="number">10px</span> <span class="number">0</span>&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.task-count</span> <span class="selector-tag">li</span>&#123;<span class="attribute">padding-left</span>:<span class="number">10px</span>;<span class="attribute">flex</span>:<span class="number">1</span>;<span class="attribute">color</span>:<span class="number">#dd4b39</span>&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.task-count</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span>&#123;<span class="attribute">padding</span>:<span class="number">5px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.action</span>&#123;<span class="attribute">text-align</span>:center;<span class="attribute">display</span>:flex&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.action</span> <span class="selector-tag">a</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span> <span class="number">10px</span>;<span class="attribute">flex</span>:<span class="number">1</span>;<span class="attribute">padding</span>:<span class="number">5px</span> <span class="number">0</span>;<span class="attribute">color</span>:<span class="number">#777</span>&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.action</span> <span class="selector-tag">a</span><span class="selector-pseudo">:nth-child(3)</span>&#123;<span class="attribute">margin-right</span>:<span class="number">0</span>&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.active</span>&#123;<span class="attribute">border-bottom</span>: <span class="number">2px</span> solid <span class="number">#629A9C</span>&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.tasks</span>&#123;<span class="attribute">background-color</span>:<span class="number">#fff</span>&#125;<span class="selector-class">.no-task-tip</span>&#123;<span class="attribute">padding</span>:<span class="number">10px</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">10px</span>;<span class="attribute">display</span>:block;<span class="attribute">border-bottom</span>:<span class="number">1px</span> solid <span class="number">#ededed</span>;<span class="attribute">color</span>:<span class="number">#777</span>&#125;<span class="selector-class">.big-title</span>&#123;<span class="attribute">color</span>:<span class="number">#222</span>&#125;<span class="selector-class">.todo-list</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">list-style</span>:none&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.todo-list</span> <span class="selector-tag">li</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">font-size</span><span class="selector-pseudo">:16px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">border-left</span>: 5<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#629A9C</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">box-shadow</span>: 0 1<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0,0,0,0<span class="selector-class">.07</span>);</span></span><br><span class="line">            margin-bottom: 16px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.todo-list</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">background-color</span>:<span class="number">#fafafa</span>&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.todo-list</span> <span class="selector-tag">li</span><span class="selector-class">.editing</span>&#123;<span class="attribute">border-bottom</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.todo-list</span> <span class="selector-tag">li</span><span class="selector-class">.editing</span> <span class="selector-class">.edit</span>&#123;<span class="attribute">display</span>:block;<span class="attribute">padding</span>:<span class="number">13px</span> <span class="number">17px</span> <span class="number">12px</span> <span class="number">17px</span>;<span class="attribute">margin</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">43px</span>&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.todo-list</span> <span class="selector-tag">li</span><span class="selector-class">.editing</span> <span class="selector-class">.view</span>&#123;<span class="attribute">display</span>:none&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.toggle</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:16px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:16px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">top</span><span class="selector-pseudo">:2px</span>;</span></span><br><span class="line">            left: 15px;</span><br><span class="line"><span class="css">            <span class="selector-tag">bottom</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin</span><span class="selector-pseudo">:auto</span> 0;</span></span><br><span class="line">            cursor: pointer;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.todo-list</span> <span class="selector-tag">li</span> <span class="selector-tag">label</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">white-space</span><span class="selector-pseudo">:pre-line</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">word-break</span><span class="selector-pseudo">:break-all</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">padding</span><span class="selector-pseudo">:15px</span> 60<span class="selector-tag">px</span> 15<span class="selector-tag">px</span> 15<span class="selector-tag">px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-left</span><span class="selector-pseudo">:45px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">display</span><span class="selector-pseudo">:block</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">line-height</span><span class="selector-pseudo">:1.2</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">transition</span><span class="selector-pseudo">:color</span> <span class="selector-class">.4s</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.todo-list</span> <span class="selector-tag">li</span><span class="selector-class">.completed</span> <span class="selector-tag">label</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>:<span class="selector-id">#d9d9d9</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">text-decoration</span><span class="selector-pseudo">:line-through</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.todo-list</span> <span class="selector-tag">li</span> <span class="selector-class">.destroy</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">display</span><span class="selector-pseudo">:none</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:16px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:16px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">top</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">right</span><span class="selector-pseudo">:15px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">bottom</span><span class="selector-pseudo">:10px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin</span><span class="selector-pseudo">:auto</span> 0;</span></span><br><span class="line">            cursor: pointer;</span><br><span class="line"><span class="css">            <span class="selector-tag">font-size</span><span class="selector-pseudo">:28px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>:<span class="selector-id">#cc9a9a</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">transition</span><span class="selector-pseudo">:color</span> <span class="selector-class">.2s</span> <span class="selector-tag">ease-out</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.todo-list</span> <span class="selector-tag">li</span> <span class="selector-class">.destroy</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:<span class="number">#af5b5e</span>&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.todo-list</span> <span class="selector-tag">li</span> <span class="selector-class">.destroy</span><span class="selector-pseudo">:after</span>&#123;<span class="attribute">content</span>:<span class="string">'×'</span>&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.todo-list</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.destroy</span>&#123;<span class="attribute">display</span>:block&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.todo-list</span> <span class="selector-tag">li</span> <span class="selector-class">.edit</span>&#123;<span class="attribute">display</span>:none&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.todo-list</span> <span class="selector-tag">li</span><span class="selector-class">.editing</span><span class="selector-pseudo">:last-child</span>&#123;<span class="attribute">margin-bottom</span>:-<span class="number">1px</span>&#125;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-top"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>任务计划列表<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"big-title"</span>&gt;</span>添加任务：<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">            <span class="attr">placeholder</span>=<span class="string">"例如：吃饭睡觉打豆豆；  提示：+回车即可添加任务，双击列表标题即可编辑"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"task-input"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">"text"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">v-on:keyup.enter</span>=<span class="string">"enterFn"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">v-model</span>=<span class="string">"todo"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"task-count"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;unComplete&#125;&#125;个任务未完成<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"action"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">:class</span>=<span class="string">"&#123;active:visibility!=='unCompleted'&amp;&amp;visibility!=='completed'&#125;"</span> <span class="attr">href</span>=<span class="string">"#all"</span>&gt;</span>所有任务<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">:class</span>=<span class="string">"&#123;active:visibility==='unCompleted'&#125;"</span> <span class="attr">href</span>=<span class="string">"#unCompleted"</span>&gt;</span>未完成的任务<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">:class</span>=<span class="string">"&#123;active:visibility==='completed'&#125;"</span> <span class="attr">href</span>=<span class="string">"#completed"</span>&gt;</span>完成的任务<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"big-title"</span>&gt;</span>任务列表：<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tasks"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"no-task-tip"</span> <span class="attr">v-show</span>=<span class="string">"!list.length"</span>&gt;</span>还没有添加任何任务<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"todo-list"</span> <span class="attr">v-show</span>=<span class="string">"list.length"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"todo"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">v-for</span>=<span class="string">"item in filterData"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">v-bind:class</span>=<span class="string">"&#123;completed:item.isComplete,editing:item===edtorTodos&#125;"</span></span></span><br><span class="line"><span class="tag">            &gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"view"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"toggle"</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">type</span>=<span class="string">"checkbox"</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">v-model</span>=<span class="string">"item.isComplete"</span></span></span><br><span class="line"><span class="tag">                    /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span> @<span class="attr">dblclick</span>=<span class="string">"edtorTodo(item)"</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">button</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">class</span>=<span class="string">"destroy"</span></span></span><br><span class="line"><span class="tag">                            @<span class="attr">click</span>=<span class="string">"delFn(item)"</span></span></span><br><span class="line"><span class="tag">                    &gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">class</span>=<span class="string">"edit"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">type</span>=<span class="string">"text"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">v-focus</span>=<span class="string">"edtorTodos===item"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">v-model</span>=<span class="string">"item.title"</span></span></span><br><span class="line"><span class="tag">                        @<span class="attr">blur</span>=<span class="string">"edtoEnd(item)"</span></span></span><br><span class="line"><span class="tag">                        @<span class="attr">keyup.enter</span>=<span class="string">"edtoEnd(item)"</span></span></span><br><span class="line"><span class="tag">                        @<span class="attr">keyup.esc</span>=<span class="string">"cancelEdit(item)"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//存取localStorage中的数据</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> store = &#123;</span></span><br><span class="line">    save(key,value)&#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.localStorage.setItem(key,<span class="built_in">JSON</span>.stringify(value));</span></span><br><span class="line">    &#125;,</span><br><span class="line">    fetch(key)&#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(key))||[];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="actionscript"><span class="comment">//list取出所有的值</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> list = store.fetch(<span class="string">"storeData"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el:<span class="string">".main"</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line">        list,</span><br><span class="line"><span class="actionscript">        todo:<span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">        edtorTodos:<span class="string">''</span>,<span class="comment">//记录正在编辑的数据,</span></span></span><br><span class="line"><span class="actionscript">        beforeTitle:<span class="string">""</span>,<span class="comment">//记录正在编辑的数据的title</span></span></span><br><span class="line"><span class="actionscript">        visibility:<span class="string">"all"</span><span class="comment">//通过这个属性值的变化对数据进行筛选</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    watch:&#123;</span><br><span class="line"><span class="actionscript">        <span class="comment">//下面的这种方法是浅监控</span></span></span><br><span class="line">      /*list:function()&#123;//监控list这个属性，当这个属性对应的值发生变化就会执行函数</span><br><span class="line"><span class="actionscript">          store.save(<span class="string">"storeData"</span>,<span class="keyword">this</span>.list);</span></span><br><span class="line">      &#125;*/</span><br><span class="line"><span class="actionscript">      <span class="comment">//下面的是深度监控</span></span></span><br><span class="line">        list:&#123;</span><br><span class="line"><span class="actionscript">            handler:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                store.save(<span class="string">"storeData"</span>,<span class="keyword">this</span>.list);</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            deep:<span class="literal">true</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"><span class="actionscript">        enterFn(ev)&#123;<span class="comment">//添加任务</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">//向list中添加一项任务</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">//事件处理函数中的this指向的是当前这个根实例</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span>(<span class="keyword">this</span>.todo==<span class="string">""</span>)&#123;<span class="keyword">return</span>;&#125;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.list.push(&#123;</span></span><br><span class="line"><span class="actionscript">                    title:<span class="keyword">this</span>.todo,</span></span><br><span class="line"><span class="actionscript">                    isComplete:<span class="literal">false</span></span></span><br><span class="line">                &#125;);</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.todo = <span class="string">""</span>;</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        delFn(item)&#123;<span class="comment">//删除任务</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> index = <span class="keyword">this</span>.list.indexOf(item);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.list.splice(index,<span class="number">1</span>)</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        edtorTodo(item)&#123;<span class="comment">//编辑任务</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">//编辑任务的时候记录编辑之前的值</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.beforeTitle = item.title;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.edtorTodos = item;</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        edtoEnd(item)&#123;<span class="comment">//编辑完成</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.edtorTodos=<span class="string">""</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// this.cancelEdit = this.edtorTodos;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        cancelEdit(item)&#123;<span class="comment">//取消编辑</span></span></span><br><span class="line"><span class="actionscript">            item.title = <span class="keyword">this</span>.beforeTitle;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.beforeTitle = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.edtorTodos=<span class="string">''</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    directives:&#123;</span><br><span class="line"><span class="actionscript">        <span class="string">"focus"</span>:&#123;</span></span><br><span class="line">            update(el,binding)&#123;</span><br><span class="line">                if(binding.value)&#123;</span><br><span class="line">                    el.focus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        unComplete()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>  <span class="keyword">this</span>.list.filter(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> !item.isComplete</span></span><br><span class="line">            &#125;).length</span><br><span class="line">        &#125;,</span><br><span class="line">        filterData()&#123;</span><br><span class="line"><span class="actionscript">            <span class="comment">//过滤的时候有三种情况 all completed unCompleted</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> filter = &#123;</span></span><br><span class="line"><span class="actionscript">                all:<span class="function"><span class="keyword">function</span><span class="params">(list)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> list;</span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="actionscript">                completed:<span class="function"><span class="keyword">function</span><span class="params">(list)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> list.filter(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="actionscript">                        <span class="keyword">return</span> item.isComplete;</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;,</span><br><span class="line"><span class="actionscript">                unCompleted:<span class="function"><span class="keyword">function</span><span class="params">(list)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> list.filter(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="actionscript">                        <span class="keyword">return</span> !item.isComplete;</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">//如果找到了过滤函数，就返回过滤后的数据，如果没有找到就返回所有的数据</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> filter[<span class="keyword">this</span>.visibility]?filter[<span class="keyword">this</span>.visibility](list):list;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">hashFn</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> hash = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>);</span></span><br><span class="line">    vm.visibility = hash;</span><br><span class="line">&#125;</span><br><span class="line">hashFn();</span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>,hashFn);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>接着在博客配置文件中，找到<code>skip_render</code>字段，冒号后面加入这个清单网页的地址，例如<code>todo\*.html</code>；</li>
<li>最后clean+g+d就完成了。</li>
</ol>
<p>这个方法做出来的网页，是把添加的内容浏览器缓存了，也就是说，如果其他人打开我的博客添加了自己的内容，那么也只有添加者能看到，同样我添加的内容别人也看不到，甚至换个浏览器或者清缓存也会丢失内容。而且也没找到方法把它嵌入到我的主题里，这使得它和其他页面相比，非常不统一。此外，如果需要从这个待办页面返回博客，还得在代码里添加跳转博客地址的链接，例如<code>&lt;h2 bref=链接&gt;返回博客&lt;/h2&gt;</code>。</p>
<p>鉴于这个网页外观和操作方式我都不太满意，也没找到更合适的方法，而且日常大多数时候会用跨平台软件来记录待办事项，最终决定去掉这个功能了。</p>
<h2 id="添加相册"><a href="#添加相册" class="headerlink" title="添加相册"></a>添加相册</h2><ol>
<li>输入<code>hexo new page photos</code>新建相册的页面，并注意在主题配置文件里添加对应的侧边栏；</li>
<li>进入<code>photos</code>文件夹，修改其中的<code>index.md</code>如下：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Gallery</span><br><span class="line"></span><br><span class="line">albums: [["imgurl", "imgcaption"], ["imgurl", "imgcaption"]]</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
<li>然后把要添加的图片放到<code>photos</code>文件夹中，并把<code>index.md</code>文件夹中的<code>imgurl</code>和<code>imgcaption</code>修改成图像的路径和标题，路径要注意带上级文件夹，和后缀名，例如我的路径就是<code>photos/ff14-伊修加德.png</code>。</li>
<li>部署后就能看到照片了，之后再加新的照片就也是复制进来，然后打开<code>index.md</code>文件，在<code>albums</code>的方括号里添加新的链接和标题。</li>
</ol>
<h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><p>目前是在ayer主题下添加的评论，用了<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a>，设置流程如下：</p>
<ol>
<li>注册<a href="https://www.leancloud.cn/" target="_blank" rel="noopener">leancloud</a>，需要填邮箱、密码等信息，注册完之后回首页，进入控制台，创建应用，选免费的开发版；</li>
<li>创建好应用后，进入应用—&gt;设置—&gt;应用凭证，可以看到AppID和AppKey；</li>
<li>打开ayer的主题配置文件，拉到最下面，找到<code>leancloud</code>字段，把它下面的<code>enable</code>设置为<code>true</code>，<code>app id</code>和<code>app key</code>分别设置成上一步页面中看到的ID和Key；</li>
<li>在<code>leancloud</code>下面有<code>valine</code>字段，把<code>enable</code>设置为<code>true</code>，<code>avatar</code>和<code>placeholder</code>分别表示评论头像和评论区的提示语，可以根据喜好修改，不改也行；</li>
<li>保存后重新生成网站就好了。</li>
</ol>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://segmentfault.com/a/1190000018761324" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018761324</a></p>
<p><a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">https://www.jianshu.com/p/3a05351a37dc</a></p>
<p><a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502" target="_blank" rel="noopener">https://blog.csdn.net/nightmare_dimple/article/details/86661502</a></p>
<p><a href="https://blog.csdn.net/lihangll/article/details/103335246" target="_blank" rel="noopener">https://blog.csdn.net/lihangll/article/details/103335246</a></p>
<p><a href="https://www.cnblogs.com/xinxiandong/p/3867505.html" target="_blank" rel="noopener">https://www.cnblogs.com/xinxiandong/p/3867505.html</a></p>
<p><a href="https://blog.csdn.net/hhgggggg/article/details/77853665" target="_blank" rel="noopener">https://blog.csdn.net/hhgggggg/article/details/77853665</a></p>
<p><a href="https://blog.csdn.net/xiaomengzi_16/article/details/98847298" target="_blank" rel="noopener">https://blog.csdn.net/xiaomengzi_16/article/details/98847298</a></p>
<p><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762</a></p>
<p><a href="https://blog.csdn.net/White_Idiot/article/details/80685990" target="_blank" rel="noopener">https://blog.csdn.net/White_Idiot/article/details/80685990</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1597223" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1597223</a></p>
<p><a href="https://cndrew.cn/2020/03/03/calender/" target="_blank" rel="noopener">https://cndrew.cn/2020/03/03/calender/</a></p>
<p><a href="https://weidows.github.io/post/Web/JavaScript/live2d-moc3/README/" target="_blank" rel="noopener">👉live2d-moc3-web-集成渲染库 | ⭐️齐下无贰⭐️</a></p>
<p><a href="https://github.com/LitStronger/live2d-moc3" target="_blank" rel="noopener">GitHub - LitStronger/live2d-moc3: live2d, 适用于加载新版moc3游戏角色模型(碧蓝航线)。附带使用例子</a></p>
<p><a href="https://github.com/Konata09/Live2dOnWeb" target="_blank" rel="noopener">GitHub - Konata09/Live2dOnWeb: Add Live2D widget in your website. Support Cubism 2, 3, 4</a></p>
]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
