<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>论文记录-Online Organizing Large-scale Heterogeneous Tasks and Multi-skilled Participants in Mobile Crowdsensing</title>
    <url>/2021/05/26/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Online%20Organizing%20Large-scale%20Heterogeneous%20Tasks%20and%20Multi-skilled%20Participants%20in%20Mobile%20Crowdsensing/</url>
    <content><![CDATA[<h1 id="Online-Organizing-Large-scale-Heterogeneous-Tasks-and-Multi-skilled-Participants-in-Mobile-Crowdsensing"><a href="#Online-Organizing-Large-scale-Heterogeneous-Tasks-and-Multi-skilled-Participants-in-Mobile-Crowdsensing" class="headerlink" title="Online Organizing Large-scale Heterogeneous Tasks and Multi-skilled Participants in Mobile Crowdsensing"></a>Online Organizing Large-scale Heterogeneous Tasks and Multi-skilled Participants in Mobile Crowdsensing</h1><p>是TMC的审稿。</p>
<a id="more"></a>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>目的：在线收集大规模异构任务和多技能参与者</p>
<p>方法：层次树和时间序列</p>
<p>内容：计算模式、树的创建方法和任务分配策略</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>场景：多技能参与者的在线众包平台上实时分配大规模异构任务</p>
<p>面临的问题：</p>
<ol>
<li>丰富的技能类型。技能类型太多，甚至需要一些领域的专业知识才能合理分类，平台应该如何处理。</li>
<li>不规则的任务时空要求。</li>
<li>多任务时空重叠。针对相同内容的任务，平台可以去除冗余；不同内容的任务，平台分给同一个workers可以减少其移动成本。</li>
<li>参与者和任务的动态性。任务和参与者随时到达或者离开平台。考虑参与者接了任务却没完成就离线的情况。任务一旦被分配了就不能被删除。</li>
<li>多技能参与者。</li>
<li>参与感知和机会感知。两种类型的参与者都应该能参与进来。</li>
<li>点推荐和轨迹推荐。两种任务推荐算法共存。</li>
</ol>
<p>现有文献主要在线多任务分配问题的不同方面提出了具体解决方案：</p>
<ol>
<li>针对即时任务分配问题，提出了基于贪婪的任务分配算法</li>
<li>针对时空异构任务分配，提出了分布式参与者选择框架</li>
<li>在任务动态异构的场景，考虑任务成本和能力等约束，选择能满足任务需求的最少数量的参与者</li>
<li>自组织移动众包框架，任务提供者可以主动、实时地向周围的移动参与者发布任务，从而快速获取高质量的传感数据。</li>
<li>两阶段任务分配框架，将机会感知和参与感知的优势结合起来。</li>
<li>多时空约束（包括任务位置、时间窗口、参与者轨迹等）的任务分配问题</li>
<li>不同预算的多任务，满足信息质量需求，考虑不同参与者的激励需求、传感能力和移动性。</li>
</ol>
<p>上述解决方案的问题：没能同时解决这些问题</p>
<p>存在这一问题的原因：数据结构过于简单</p>
<p>本文方案：</p>
<ol>
<li>原子化时间和空间——处理不规则时空问题，简化多任务时空重叠问题</li>
<li>将异构任务划分为原子任务，使用层次树进行组织——包括技能层、时间层、空间层和原子化任务层（叶节点），技能是需求驱动的，并不提前列出所有技能。技能层、时间层和空间层是可扩展、自适应的。</li>
<li>使用时间序列组织动态参与者，将空间、时间和技能约束等封装，根据时间限制加入队列，参与感知和机会感知都可以，点推荐和轨迹推荐共存。</li>
<li>综合上述，得到在线大规模异构任务分配算法。</li>
</ol>
<p>本文贡献：</p>
<ol>
<li>第一个研究这个的</li>
<li>两个数据结构结合</li>
<li>实验表明了有效性</li>
</ol>
<p>本文组织结构：略</p>
<h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><h2 id="3-Methodology"><a href="#3-Methodology" class="headerlink" title="3. Methodology"></a>3. Methodology</h2><h2 id="4-Evaluation"><a href="#4-Evaluation" class="headerlink" title="4. Evaluation"></a>4. Evaluation</h2><h2 id="5-Conclusion-and-future-work"><a href="#5-Conclusion-and-future-work" class="headerlink" title="5. Conclusion and future work"></a>5. Conclusion and future work</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>crowdsourcing</tag>
        <tag>审稿意见</tag>
      </tags>
  </entry>
  <entry>
    <title>Github项目数据统计</title>
    <url>/2021/04/30/Github%E9%A1%B9%E7%9B%AE%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="Github项目数据统计"><a href="#Github项目数据统计" class="headerlink" title="Github项目数据统计"></a>Github项目数据统计</h1><p>​      由于需要统计Dapp项目的发展历程数据，在查资料时看到了<a href="https://zhuanlan.zhihu.com/p/32759663" target="_blank" rel="noopener">以太坊 Dapp 调研</a>，这份统计只包含了2017年12月20日及之前的数据，而现在已经是2021年了，因此我模仿这个进行了新的统计。</p>
<a id="more"></a>
<h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p>经过一系列学习，我终于掌握了GitHub api的基础使用。简单来说，我们可以通过访问api接口进行查询并获取数据。通过关键字dapp进行查询的api是<code>https://api.github.com/search/repositories?q=dapp</code>，用浏览器直接打开这个链接可以看到如下图的内容：</p>
<p><img src="https://i.loli.net/2021/04/30/nXQsavbDH98PJxc.png" alt="image-20210430103142883"></p>
<p>第一行的<code>total_count</code>是所有结果的总数，接下来有30个<code>items</code>，每一个都是对应的项目，点开第一个可以看到其数据格式为：</p>
<p><img src="https://i.loli.net/2021/04/30/qNL3xuYcrlByVbW.png" alt="image-20210430103308097"></p>
<p>图中显示的内容并不完整，还有很多信息比如stars数量等都可以直接获取。</p>
<p>但是总共有19930个项目，却只获取到30个，这显然是不够的，想获取更多项目就需要修改api的内容，改成<code>https://api.github.com/search/repositories?q=dapp&amp;page=1&amp;per_page=100</code>，修改后就可以获取到100条项目信息了，这是每页项目数的上限，将api中的<code>page=1</code>改成<code>page=2</code>即可得到新的100条信息，然而由于api限制，通过这样的方法最多可以获取1000条（即<code>page=10</code>），超过1000条后会有报错信息。为了能获取到更多项目，我们需要对访问查询作出限制，使得每次查询结果都不超过1000条，然后将多次查询结果合并起来得到完整结果，例如仅查找创建于2021年1月至2月的项目数，这样就可以得到1000条以内的结果，再逐页访问即可。限制时间的api为：<code>https://api.github.com/search/repositories?q=dapp+created:2021-04-01T00:00:00..2021-05-01&amp;page=1&amp;per_page=100</code>，这个api可以获取创建时间在2021年4月1日至5月1日的所有项目数据，如果要获取其他时间范围，对api中的时间进行修改即可，可以精确到秒；如果时间限制是早于或晚于某个时间点，则写成<code>created:&gt;=2021-04-01T00:00:00</code>，大于等于符号可以改成小于等于或者大于或者小于。如果想限制其他字段，比如更新时间，则把created修改为updated即可。</p>
<p>具体到写python代码时，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> github3 <span class="keyword">import</span> login, GitHub</span><br><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    result = requests.get(<span class="string">"https://api.github.com/search/repositories?q=dapp+created:2021-04-01T00:00:00..2021-05-01&amp;page=6&amp;per_page=100"</span>)</span><br><span class="line">    response_dict = result.json()</span><br><span class="line">    repo_dicts = response_dict[<span class="string">'items'</span>]</span><br><span class="line">    print(<span class="string">"Toal repositories:"</span>, response_dict[<span class="string">'total_count'</span>])</span><br><span class="line">    print(<span class="string">"Repositories returned:"</span>, len(repo_dicts))</span><br><span class="line">    keys = &#123;<span class="string">'id'</span>,<span class="string">'full_name'</span>,<span class="string">'html_url'</span>,<span class="string">'commits_url'</span>,<span class="string">'language'</span>,<span class="string">'description'</span>,<span class="string">'forks_count'</span>,<span class="string">'stargazers_count'</span>,<span class="string">'watchers_count'</span>,<span class="string">'created_at'</span>,<span class="string">'pushed_at'</span>,<span class="string">'updated_at'</span>&#125;</span><br><span class="line">    save_dicts = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> repo_dicts:</span><br><span class="line">        j = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> i.items() <span class="keyword">if</span> key <span class="keyword">in</span> keys&#125;</span><br><span class="line">        save_dicts.append(j)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'test.csv'</span>, <span class="string">'a+'</span>, newline=<span class="string">''</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f: </span><br><span class="line">        fieldnames = [<span class="string">'id'</span>,<span class="string">'full_name'</span>,<span class="string">'html_url'</span>,<span class="string">'commits_url'</span>,<span class="string">'language'</span>,<span class="string">'description'</span>,<span class="string">'forks_count'</span>,<span class="string">'stargazers_count'</span>,<span class="string">'watchers_count'</span>,<span class="string">'created_at'</span>,<span class="string">'pushed_at'</span>,<span class="string">'updated_at'</span>]</span><br><span class="line">        writer = csv.DictWriter(f,fieldnames=fieldnames)</span><br><span class="line">        <span class="comment">#writer.writeheader()</span></span><br><span class="line">        writer.writerows(save_dicts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<!--这段代码`import`的一些包其实没有用到，是最初学着写的时候都引入了，之后没删。-->
<p>代码第9行使用<code>requests.get()</code>获取api的数据，接着使用<code>.json()</code>将它转为字典。这个字典的<code>total_count</code>项就是前面图中显示的项目总数，这里我们没有用到；字典的<code>items</code>项则是我们需要的项目列表，将它单独存到<code>repo_dicts</code>，显然获取的项目列表数并不等于项目总数。</p>
<p>接下来把这次数据处理所需要的字段写到<code>keys</code>中，从<code>repo_dicts</code>中提取这些列的内容存到新列表<code>save_dicts</code>中，再将这些数据保存到csv文件里。这个提取数据并保存的过程应该有更简练的代码写法，我懒得改了就这样吧。</p>
<p>最终得到的csv文件如下图所示：</p>
<p><img src="https://i.loli.net/2021/04/30/YIcsFzMrN1Cb93l.png" alt="image-20210430105338111"></p>
<p>这个数据总量比api那里的总量要多一些，显然是有重复的，因此要进行去重，我们选择把相同id的条目删了，只保留一个。excel本身就有去重的功能，在python里用pandas也可以，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    frame=pd.read_csv(<span class="string">'test.csv'</span>,engine=<span class="string">'python'</span>)</span><br><span class="line">    data = frame.drop_duplicates(subset=[<span class="string">'id'</span>], keep=<span class="string">'first'</span>, inplace=<span class="literal">False</span>)</span><br><span class="line">    data.to_csv(<span class="string">'newtest.csv'</span>, encoding=<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>这样就得到了一份到目前为止所有和dapp相关的项目表。</p>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>接下来要对所有数据进行分析统计。我们要做的图表如下：</p>
<ol>
<li>每月新Dapp项目数量分布</li>
<li>项目创建及更新时间分布</li>
<li>项目语言分布</li>
</ol>
<p>第3个最简单，我们先看它。</p>
<h3 id="项目语言分布"><a href="#项目语言分布" class="headerlink" title="项目语言分布"></a>项目语言分布</h3><p>从csv文件读入数据后，按<code>language</code>列进行数量统计即可，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import csv</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">pd.set_option(&#39;display.max_rows&#39;,None)</span><br><span class="line">pd.set_option(&#39;display.max_columns&#39;, None)</span><br><span class="line">pd.set_option(&#39;display.width&#39;, 1000)</span><br><span class="line">pd.set_option(&#39;display.max_colwidth&#39;, 1000)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    frame&#x3D;pd.read_csv(&#39;newtest.csv&#39;,engine&#x3D;&#39;python&#39;)</span><br><span class="line">    df1 &#x3D; frame.language.value_counts()</span><br><span class="line">    print(df1)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">JavaScript           <span class="number">10018</span></span><br><span class="line">C<span class="comment">#                    2087</span></span><br><span class="line">HTML                  <span class="number">1019</span></span><br><span class="line">TypeScript             <span class="number">806</span></span><br><span class="line">CSS                    <span class="number">376</span></span><br><span class="line">Solidity               <span class="number">336</span></span><br><span class="line">Vue                    <span class="number">335</span></span><br><span class="line">Java                   <span class="number">295</span></span><br><span class="line">Python                 <span class="number">256</span></span><br><span class="line">Shell                  <span class="number">139</span></span><br><span class="line">Go                     <span class="number">133</span></span><br><span class="line">C++                    <span class="number">120</span></span><br><span class="line">Dockerfile              <span class="number">72</span></span><br><span class="line">PHP                     <span class="number">65</span></span><br><span class="line">Kotlin                  <span class="number">54</span></span><br><span class="line">Ruby                    <span class="number">52</span></span><br><span class="line">Swift                   <span class="number">49</span></span><br><span class="line">Dart                    <span class="number">37</span></span><br><span class="line">Rust                    <span class="number">34</span></span><br><span class="line">Objective-C             <span class="number">30</span></span><br><span class="line">Jupyter Notebook        <span class="number">30</span></span><br><span class="line">C                       <span class="number">25</span></span><br><span class="line">Makefile                <span class="number">24</span></span><br><span class="line">WebAssembly             <span class="number">22</span></span><br><span class="line">TSQL                    <span class="number">19</span></span><br><span class="line">SCSS                    <span class="number">17</span></span><br><span class="line">PowerShell              <span class="number">10</span></span><br><span class="line">F<span class="comment">#                      10</span></span><br><span class="line">TeX                      <span class="number">9</span></span><br><span class="line">Perl                     <span class="number">8</span></span><br><span class="line">Clojure                  <span class="number">8</span></span><br><span class="line">Haskell                  <span class="number">7</span></span><br><span class="line">R                        <span class="number">7</span></span><br><span class="line">Svelte                   <span class="number">6</span></span><br><span class="line">CoffeeScript             <span class="number">6</span></span><br><span class="line">Scala                    <span class="number">6</span></span><br><span class="line">Nix                      <span class="number">5</span></span><br><span class="line">Visual Basic             <span class="number">5</span></span><br><span class="line">Visual Basic .NET        <span class="number">5</span></span><br><span class="line">D                        <span class="number">4</span></span><br><span class="line">Elm                      <span class="number">4</span></span><br><span class="line">Smarty                   <span class="number">3</span></span><br><span class="line">Elixir                   <span class="number">3</span></span><br><span class="line">GLSL                     <span class="number">3</span></span><br><span class="line">ASP                      <span class="number">3</span></span><br><span class="line">HCL                      <span class="number">3</span></span><br><span class="line">PLpgSQL                  <span class="number">2</span></span><br><span class="line">ShaderLab                <span class="number">2</span></span><br><span class="line">OCaml                    <span class="number">2</span></span><br><span class="line">Logos                    <span class="number">2</span></span><br><span class="line">Blade                    <span class="number">2</span></span><br><span class="line">Roff                     <span class="number">2</span></span><br><span class="line">LiveScript               <span class="number">2</span></span><br><span class="line">Hack                     <span class="number">2</span></span><br><span class="line">PLSQL                    <span class="number">2</span></span><br><span class="line">Sass                     <span class="number">1</span></span><br><span class="line">ECL                      <span class="number">1</span></span><br><span class="line">GDScript                 <span class="number">1</span></span><br><span class="line">NSIS                     <span class="number">1</span></span><br><span class="line">Stata                    <span class="number">1</span></span><br><span class="line">CMake                    <span class="number">1</span></span><br><span class="line">MATLAB                   <span class="number">1</span></span><br><span class="line">EJS                      <span class="number">1</span></span><br><span class="line">Twig                     <span class="number">1</span></span><br><span class="line">QML                      <span class="number">1</span></span><br><span class="line">XML                      <span class="number">1</span></span><br><span class="line">Batchfile                <span class="number">1</span></span><br><span class="line">Crystal                  <span class="number">1</span></span><br><span class="line">Apex                     <span class="number">1</span></span><br><span class="line">Emacs Lisp               <span class="number">1</span></span><br><span class="line">Lua                      <span class="number">1</span></span><br><span class="line">Racket                   <span class="number">1</span></span><br><span class="line">VimL                     <span class="number">1</span></span><br><span class="line">Handlebars               <span class="number">1</span></span><br><span class="line"><span class="number">4</span>D                       <span class="number">1</span></span><br><span class="line">PureScript               <span class="number">1</span></span><br><span class="line">Pascal                   <span class="number">1</span></span><br><span class="line">Io                       <span class="number">1</span></span><br><span class="line">Assembly                 <span class="number">1</span></span><br><span class="line">Name: language, dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="每月新增Dapp项目数量分布"><a href="#每月新增Dapp项目数量分布" class="headerlink" title="每月新增Dapp项目数量分布"></a>每月新增Dapp项目数量分布</h3><p>从csv文件读入数据后，访问<code>created_at</code>这一列并截取其前7位，即可得到每个项目的创建年月，统计每个月创建的项目数量即可得到数据结果，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">pd.set_option(<span class="string">'display.max_rows'</span>,<span class="literal">None</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.max_columns'</span>, <span class="literal">None</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.width'</span>, <span class="number">1000</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.max_colwidth'</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    frame=pd.read_csv(<span class="string">'newtest.csv'</span>,engine=<span class="string">'python'</span>)</span><br><span class="line">    frame[<span class="string">'created'</span>] = frame[<span class="string">'created_at'</span>].str[<span class="number">0</span>:<span class="number">7</span>]</span><br><span class="line">    df1 = frame.created.value_counts()</span><br><span class="line">    print(df1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>这份数据内容很多，因此就不列出了。</p>
<h3 id="项目创建及更新时间分布"><a href="#项目创建及更新时间分布" class="headerlink" title="项目创建及更新时间分布"></a>项目创建及更新时间分布</h3><p>由于数据很多，因此这里并不逐月统计，对于创建时间，统计每半年的项目数；对于更新时间，统计每一年的项目数，例如创建于2009年10月至2010年4月且最后一次更新于2014年4月至2015年4月的项目有1个，则这一对时间所对应的值就是1。以此类推，可以得到一份完整表格。</p>
<p>我们首先读入csv文件，截取创建和更新的年月数据，并依次分组并统计每组的项目数，这样就可以得到每组年月对所对应的项目数，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">pd.set_option(<span class="string">'display.max_rows'</span>,<span class="literal">None</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.max_columns'</span>, <span class="literal">None</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.width'</span>, <span class="number">1000</span>)</span><br><span class="line">pd.set_option(<span class="string">'display.max_colwidth'</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    frame=pd.read_csv(<span class="string">'newtest.csv'</span>,engine=<span class="string">'python'</span>)</span><br><span class="line">    frame[<span class="string">'created'</span>] = frame[<span class="string">'created_at'</span>].str[<span class="number">0</span>:<span class="number">7</span>]</span><br><span class="line">    frame[<span class="string">'updated'</span>] = frame[<span class="string">'updated_at'</span>].str[<span class="number">0</span>:<span class="number">7</span>]</span><br><span class="line">    group = frame.groupby([<span class="string">'created'</span>,<span class="string">'updated'</span>])</span><br><span class="line">    dict_tmp = dict(group.size())</span><br><span class="line">    print(dict_tmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>得到的结果是<code>... (&#39;2021-03&#39;, &#39;2021-03&#39;): 473, (&#39;2021-03&#39;, &#39;2021-04&#39;): 151,...</code>这样的格式，将这些放到excel里并进行分列、去除无效数据等处理，最终可以得到如下图所示的表格：</p>
<p><img src="https://i.loli.net/2021/04/30/tS9wECnmoiONprB.png" alt="image-20210430122233349"></p>
<p>接下来筛选出created列中2014-11~2015-04之间的数据，将筛选后的updated和num这两列复制到新区域（比如sheet4），按升序排列，如下图，选中2015-04之前的数据，就可以在右下角看到这个时间段内的项目数总和。</p>
<p><img src="https://i.loli.net/2021/04/30/Eq83h4BrRxLd5z6.png" alt="image-20210430122713555"></p>
<p>用类似的方法进行多次筛选、排序、求和，最终可以得到如下数据表：</p>
<p><img src="https://i.loli.net/2021/04/30/1Qok6Z9U2r5RtvO.png" alt="image-20210430124738534"></p>
<p>行表示创建时间，列表示更新时间。</p>
<h2 id="图像生成"><a href="#图像生成" class="headerlink" title="图像生成"></a>图像生成</h2><p>使用<code>Echarts</code>生成图表，因为没学过前端，所以就直接用了<a href="https://zhuanlan.zhihu.com/p/32759663" target="_blank" rel="noopener">以太坊 Dapp 调研</a>给出的js代码，链接为 <a href="https://github.com/heeeeeng/my_docs/tree/master/ethereum_dapp/data_viewer" target="_blank" rel="noopener">Github</a> 。</p>
<p>所有数据是直接在<code>web.js</code>中写好的，并不是从其他文件读取，且文件开头的<code>var scatter_origin_data</code>其实可以删了。此外，这份文件中的个人和组织项目散点图我并不需要，因此也直接删了。</p>
<p>接下来将<code>web.js</code>中的数据修改成前面统计好的数据，打开<code>web.html</code>就可以看到图表了。</p>
<p>由于hexo博客也可以显示echarts，因此我就把图表放这里了。</p>
<div id="echarts7728" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts7728'));
        // 指定图表的配置项和数据
        var option = {
title: {
            text: '每月新Dapp项目数量分布',
            x:'center'
        },
        tooltip: {
            trigger: 'axis'
        },
        toolbox: {
            show: true,
            feature: {
                dataZoom: {
                    yAxisIndex: 'none'
                },
                dataView: {readOnly: false},
                magicType: {type: ['line', 'bar']},
                restore: {},
                saveAsImage: {}
            }
        },
        xAxis:  {
            name: "创建时间",
            type: 'category',
            boundaryGap: false,
            data: ["2009-01","2009-02","2009-03","2009-04","2009-05","2009-06","2009-07","2009-08","2009-09","2009-10","2009-11","2009-12","2010-01","2010-02","2010-03","2010-04","2010-05","2010-06","2010-07","2010-08","2010-09","2010-10","2010-11","2010-12","2011-01","2011-02","2011-03","2011-04","2011-05","2011-06","2011-07","2011-08","2011-09","2011-10","2011-11","2011-12","2012-01","2012-02","2012-03","2012-04","2012-05","2012-06","2012-07","2012-08","2012-09","2012-10","2012-11","2012-12","2013-01","2013-02","2013-03","2013-04","2013-05","2013-06","2013-07","2013-08","2013-09","2013-10","2013-11","2013-12","2014-01","2014-02","2014-03","2014-04","2014-05","2014-06","2014-07","2014-08","2014-09","2014-10","2014-11","2014-12","2015-01","2015-02","2015-03","2015-04","2015-05","2015-06","2015-07","2015-08","2015-09","2015-10","2015-11","2015-12","2016-01","2016-02","2016-03","2016-04","2016-05","2016-06","2016-07","2016-08","2016-09","2016-10","2016-11","2016-12","2017-01","2017-02","2017-03","2017-04","2017-05","2017-06","2017-07","2017-08","2017-09","2017-10","2017-11","2017-12","2018-01","2018-02","2018-03","2018-04","2018-05","2018-06","2018-07","2018-08","2018-09","2018-10","2018-11","2018-12","2019-01","2019-02","2019-03","2019-04","2019-05","2019-06","2019-07","2019-08","2019-09","2019-10","2019-11","2019-12","2020-01","2020-02","2020-03","2020-04","2020-05","2020-06","2020-07","2020-08","2020-09","2020-10","2020-11","2020-12","2021-01","2021-02","2021-03","2021-04"]
        },
        yAxis: {
            name: '新项目数量',
            type: 'value',
            axisLabel: {
                formatter: '{value}'
            }
        },
        series: [
            {
                name:'新项目数量',
                type:'line',
                data: [1,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,2,0,1,2,1,3,2,1,2,2,2,0,1,5,2,3,5,2,1,1,5,4,4,3,3,8,8,8,5,7,5,8,11,16,9,9,5,6,6,12,19,5,12,16,10,14,21,29,29,26,18,29,34,34,32,34,52,42,49,63,56,50,58,66,64,66,60,41,37,69,60,75,109,128,118,148,203,193,217,223,229,339,353,455,425,625,506,526,596,488,490,432,456,441,341,433,391,385,387,383,379,278,303,313,288,320,288,291,407,479,348,381,316,339,411,448,392,492,456,633,581],
                markPoint: {
                    data: [
                        {type: 'max', name: '最大值'}
                    ]
                },
                markLine: {
                    data: [
                        {type: 'average', name: '平均值'}
                    ]
                }
            }
        ]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>
<div id="echarts3527" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts3527'));
        // 指定图表的配置项和数据
        var option = {
        title : {
            text: '项目语言分布',
            x:'center'
        },
        tooltip : {
            trigger: 'item',
            formatter: "{b} <br/> 项目数量: {c} ({d}%) "
        },
        legend: {
            orient: 'vertical',
            left: 'left',
            data: ['JavaScript','HTML', 'TypeScript', 'CSS', 'Others']
        },
        series : [
            {
                name: '项目语言分布',
                type: 'pie',
                radius : '55%',
                center: ['50%', '60%'],
                data:[
                    {value:10018, name:'JavaScript'},
                    {value:2087, name:'C#'},
                    {value:1019,name:"HTML"},
                    {value:806,name:"TypeScript"},
                    {value:376,name:"CSS"},
                    {value:336,name:"Solidity"},
                    {value:335,name:"Vue"},
                    {value:295,name:"Java"},
                    {value:256,name:"Python"},
                    {value:139,name:"Shell"},
                    {value:133,name:"Go"},
                    {value:120,name:"C++"},
                    {value:687, name:'Others'}
                ],
                itemStyle: {
                    emphasis: {
                        shadowBlur: 10,
                        shadowOffsetX: 0,
                        shadowColor: 'rgba(0, 0, 0, 0.5)'
                    }
                }
            }
        ]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>
<div id="echarts9102" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts9102'));
        // 指定图表的配置项和数据
        var option = {
        title : {
            text: '剩余语言分布',
            x:'center'
        },
        tooltip : {
            trigger: 'item',
            formatter: "{b} <br/> 项目数量: {c} ({d}%) "
        },
        series : [
            {
                name: '编程语言数量分布',
                type: 'pie',
                radius : '55%',
                center: ['50%', '60%'],
                data:[                    
                    {value:72,name:"Dockerfile"},
                    {value:65,name:"PHP"},
                    {value:54,name:"Kotlin"},
                    {value:52,name:"Ruby"},
                    {value:49,name:"Swift"},
                    {value:37,name:"Dart"},
                    {value:34,name:"Rust"},
                    {value:30,name:"Jupyter Notebook"},
                    {value:30,name:"Objective-C"},
                    {value:25,name:"C"},
                    {value:24,name:"Makefile"},
                    {value:22,name:"WebAssembly"},
                    {value:19,name:"TSQL"},
                    {value:17,name:"SCSS"},
                    {value:10,name:"PowerShell"},
                    {value:10,name:"F#"},
                    {value:137,name:"Others"},
                ],
                itemStyle: {
                    emphasis: {
                        shadowBlur: 10,
                        shadowOffsetX: 0,
                        shadowColor: 'rgba(0, 0, 0, 0.5)'
                    }
                }
            }
        ]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>
<p><img src="https://i.loli.net/2021/04/30/UC8DSlosXBIu5Mv.png" alt="fe0b04c74a9bae3058a8c53ba973f4e"></p>
<p>热力图不知道为什么始终没法在这里显示，所以就放个截图了……</p>
]]></content>
      <categories>
        <category>无分类项</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>Echarts</tag>
        <tag>Github</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Eliciting Information from Heterogeneous Mobile Crowdsourced Workers Without Verification</title>
    <url>/2021/04/15/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Eliciting%20Information%20from%20Heterogeneous%20Mobile%20Crowdsourced%20Workers%20Without%20Verification/</url>
    <content><![CDATA[<h1 id="Eliciting-Information-from-Heterogeneous-Mobile-Crowdsourced-Workers-Without-Verification"><a href="#Eliciting-Information-from-Heterogeneous-Mobile-Crowdsourced-Workers-Without-Verification" class="headerlink" title="Eliciting Information from Heterogeneous Mobile Crowdsourced Workers Without Verification"></a>Eliciting Information from Heterogeneous Mobile Crowdsourced Workers Without Verification</h1><p>这篇和Strategic Information Revelation in Crowdsourcing Systems Without Verification是同一批作者的，针对的问题一样，内容方法看着也差不多，希望别一模一样……</p>
<a id="more"></a>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>问题：无验证的信息提取（IEWV）</p>
<p>思路：激励workers高质量和如实报告</p>
<p>常规方法：多数投票——符合多数解决方案的workers获得报酬</p>
<p>存在问题：未考虑workers的异构性</p>
<p>本文方法：两阶段Stackelberg博弈</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>本文场景：</p>
<ol>
<li>workers求解准确率异构（即，不同workers以不同概率生成高质量数据）</li>
<li>考虑数据质量与平台成本之间的平衡</li>
</ol>
<p>本文方法：多数投票机制</p>
<p>需要解决的问题：</p>
<ol>
<li>给定奖励，多数投票机制下，异构workers会如何行动；</li>
<li>workers的异构性如何影响平台的最优奖励设计和均衡；</li>
<li>在提升平台均衡方面，知道workers异构方案准确性有什么价值。</li>
</ol>
<p>本文的两阶段博弈：</p>
<ol>
<li>平台决定多数投票机制的奖励等级，目标是最大化收益，该收益考虑了workers解决方案质量和平台总支出之间的均衡；</li>
<li>每个worker选择自己的努力等级和报告策略，目标是最大化自己收益。</li>
</ol>
<p>本文考虑两种情况：</p>
<ol>
<li>不完全信息博弈（平台不知道workers的准确率）</li>
<li>完全信息博弈（平台知道workers的准确率）</li>
</ol>
<h3 id="Key-Contributions"><a href="#Key-Contributions" class="headerlink" title="Key Contributions"></a>Key Contributions</h3><ol>
<li>分析了IEWV问题中异构workers场景下的平台均衡</li>
<li>分析了多均衡共存的场景</li>
<li>刻画了workers的最优策略</li>
<li>刻画了workers异构性对平台均衡的影响</li>
<li>刻画了得知workers异构性的价值</li>
</ol>
<h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><h3 id="Information-Elicitation"><a href="#Information-Elicitation" class="headerlink" title="Information Elicitation"></a>Information Elicitation</h3><p>略</p>
<h3 id="Information-Aggregation"><a href="#Information-Aggregation" class="headerlink" title="Information Aggregation"></a>Information Aggregation</h3><p>略</p>
<h2 id="3-Model"><a href="#3-Model" class="headerlink" title="3. Model"></a>3. Model</h2><h3 id="Workers’-Decision-Problem"><a href="#Workers’-Decision-Problem" class="headerlink" title="Workers’ Decision Problem"></a>Workers’ Decision Problem</h3><h4 id="Workers-and-Task"><a href="#Workers-and-Task" class="headerlink" title="Workers and Task"></a>Workers and Task</h4><p>集合：$N=\{1,2,…,N\}$表示到达平台的workers</p>
<p>待求解问题的答案是二选一，记作$X=\{-1,1\}$</p>
<p>$x\in X$表示该任务的正确答案</p>
<p>$x_i^{estimate}\in X$表示第$i$个worker对任务答案的估计值</p>
<p>$x_i^{estimate}\in X$表示第$i$个worker向平台上报的任务答案</p>
<h4 id="Worker-Effort-Exertion-and-Reporting-Strategy"><a href="#Worker-Effort-Exertion-and-Reporting-Strategy" class="headerlink" title="Worker Effort Exertion and Reporting Strategy"></a>Worker Effort Exertion and Reporting Strategy</h4><p>workers的任务质量依赖于努力程度，记作$e_i\in \{0,1\}$</p>
<p>workers可通过付出一定代价来努力从而提高任务质量（即准确率）</p>
<p>第$i$个worker的求解方案准确率记作$p_i\in (0.5,1])$</p>
<script type="math/tex; mode=display">
P(x_i^{estimate}=x)=\left\{
\begin{matrix}
p_i,\ \ &if\ \ e_i=1\ \ with\ \ a\ \ cost\ \ c_i\geq 0, \\
0.5,\ \ &if\ \ e_i=0.
\end{matrix}
\right.</script><p>workers异构性的体现：$N$个workers中有$k$个高质量的求解准确率为$p_h$，和$N-k$个低质量的求解准确率为$p_l$，$0.5&lt;p_l&lt;p_h\leq 1$</p>
<p>workers的上报策略：$v_i=\{1,-1,rd\}$，其中，努力的workers可以选择$\{1,-1\}$分别表示如实报告和谎报；而不努力的workers可以选择$rd$表示以0.5的概率随机上报</p>
<script type="math/tex; mode=display">
x_i^{report}=
\left\{
\begin{matrix}
x_i^{estimate},\ \ &if\ \  v_i=1\\
-x_i^{estimate},\ \ &if\ \  v_i=-1\\
1\ \  or\ \  -1\ \  with\ \  an\ \  equal\ \  probability,\ \ &if\ \  v_i=rd.
\end{matrix}
\right.</script><p>本文不考虑多个workers共谋等情况。</p>
<p>workers的策略记作$s_i=(e_i,v_i)$，属于集合$S_i=\{(0,rd),(1,1),(1,-1)\}$</p>
<h4 id="Internal-Reward-for-Truthful-Reports"><a href="#Internal-Reward-for-Truthful-Reports" class="headerlink" title="Internal Reward for Truthful Reports"></a>Internal Reward for Truthful Reports</h4><p>第$i$个worker如果努力且如实上报，则会得到内在奖励$l_i\geq 0$</p>
<p>反之，谎报会得到内在惩罚$-l_i$</p>
<p>不努力的worker会随机上报，他的内在奖励为0</p>
<h4 id="Consistency-Reward-for-Output-Agreement"><a href="#Consistency-Reward-for-Output-Agreement" class="headerlink" title="Consistency Reward for Output Agreement"></a>Consistency Reward for Output Agreement</h4><p>一致性奖励记作$R\geq 0$</p>
<p>除了第$i$个worker以外，其余workers的多数投票方案记作$x_{-i}^{majority}$</p>
<p>从第$i$个worker的角度来看，多数投票方案是：</p>
<script type="math/tex; mode=display">
x_{-i}^{majority}=
\left \{
\begin{matrix}
1,\ \ if\ \ \sum_{j\in N,j\neq i}x_j^{report}>0,\\
-1,\ \ if\ \ \sum_{j\in N,j\neq i}x_j^{report}<0,\\
tie,\ \ if\ \ \sum_{j\in N,j\neq i}x_j^{report}=0.
\end{matrix}
\right.</script><p>第$i$个worker的上报值与多数投票方案一致或者多数投票方案是tie的情况下，该worker会得到奖励；反之则不会。</p>
<p>第$i$个worker得到奖励R的概率记作$P_i(R,p,s)$，$p=(p_j,\forall j\in N)$，$s=(e,v)$，$e=(e_j,\forall j \in N)$，$v=(v_j,\forall j \in N)$</p>
<h4 id="Worker-Payoff-Maximization-Problem"><a href="#Worker-Payoff-Maximization-Problem" class="headerlink" title="Worker Payoff Maximization Problem"></a>Worker Payoff Maximization Problem</h4><p>worker的收益函数：$u_i(R,s)=R*P_i(R,p,s)+v_il_i-e_ic_i$</p>
<p><strong>博弈1：</strong>$\Omega_1=(N,S,u)$，其中：</p>
<ol>
<li><p>$N$：N个workers的集合</p>
</li>
<li><p>$S$：第$i$个worker的策略空间为$s_i\in S_i=\{(0,rd),(1,1),(1,-1)\}$。所有workers的策略记作$s=(s_i,\forall i\in N)$，所有workers的可行策略集合记作$S=\prod_{i\in N}S_i$。</p>
<p><em>这里应该是集合的笛卡尔积，不过这个表达不太确定是否正确。</em></p>
</li>
<li><p>$u$：向量$u=(u_i,\forall i \in N)$包含了所有workers的收益</p>
</li>
</ol>
<p>该博弈中，给定报酬$R$和其他workers的决策$s_{-i}=(e_{-i},v_{-i})=((e_j,v_j),\forall j \neq i)$，第$i$个worker需要求解下述优化问题。</p>
<p><strong>问题1：</strong>第$i$个worker的收益最大化</p>
<p>$max\ \ u_i(R,s,s_{-i})$</p>
<p>$var.\ \ s_i\in\{(0,rd),(1,1),(1,-1)\}.$</p>
<p><strong>定义1：</strong>纳什均衡：在给定$R$的情况下，如果对于所有$s_i’\in S_i$，和所有$i\in N$，都有$u_i(R,s_i^<em>,s_{-i}^</em>)\geq u_i(R,s_i’,s_{-i}^<em>)$，则认为策略$s^</em>=\prod_{i\in N}s_i^*$构成了博弈$\Omega_1$的一个纳什均衡。</p>
<p>注意：第$i$个worker的策略选择是前面<strong>问题1</strong>的优化解决方案，是与平台支付报酬$R$和其他worker策略$s_{-i}$相关的函数。</p>
<h3 id="Platform’s-Reward-Design-Problem"><a href="#Platform’s-Reward-Design-Problem" class="headerlink" title="Platform’s Reward Design Problem"></a>Platform’s Reward Design Problem</h3><h4 id="Accuracy-of-Aggregated-Estimate"><a href="#Accuracy-of-Aggregated-Estimate" class="headerlink" title="Accuracy of Aggregated Estimate"></a>Accuracy of Aggregated Estimate</h4><p>平台根据所有workers的上报值进行多数投票猜测最终的值</p>
<script type="math/tex; mode=display">
x_p^{estimate}=
\left \{
\begin{matrix}
1,\ &if\ \sum_{i=1}^Nx_i^{report}>0,\\
-1,\ &if\ \sum_{i=1}^Nx_i^{report}<0,\\
1\ or\ -1\ with\ an\ equal\ probability,\ &if\ \sum_{i=1}^Nx_i^{report}=0.
\end{matrix}
\right.</script><p>$P_a(R,p,N)$表示上述公式得到的聚合解决方案是正确的概率</p>
<p>假设：N是基数且$N\geq 4$</p>
<h4 id="Expected-Consistency-Rewards"><a href="#Expected-Consistency-Rewards" class="headerlink" title="Expected Consistency Rewards."></a>Expected Consistency Rewards.</h4><p>workers总一致性奖励期望记作$E[R^T]$</p>
<h4 id="Platform’s-Payoff-Maximization-Problem"><a href="#Platform’s-Payoff-Maximization-Problem" class="headerlink" title="Platform’s Payoff Maximization Problem"></a>Platform’s Payoff Maximization Problem</h4><p>平台收益函数：</p>
<script type="math/tex; mode=display">
\prod(R)=\beta P_a(R,p,N)-E[R^T]</script><p>$\beta&gt;0$表示平台对准确率分配的权重</p>
<p><strong>问题2：</strong>平台的收益最大化：</p>
<p>$max \prod(R)$</p>
<p>$var. R\geq0$</p>
<h3 id="Two-Stage-Game"><a href="#Two-Stage-Game" class="headerlink" title="Two-Stage Game"></a>Two-Stage Game</h3><p>阶段1：平台决定R</p>
<p>阶段2：workers选择努力和上报策略</p>
<p>博弈求解方法：逆向归纳</p>
<p>符号表达：</p>
<p>$X$：任务类型空间</p>
<p>$x$：任务真实类型</p>
<p>$x_i^{estimate}$：第$i$个worker的估计值</p>
<p>$x_i^{report}$：第$i$个worker的上报值</p>
<p>$x_{-i}^{majority}$：除了第$i$个worker以外，剩下workers的多数投票方案</p>
<p>$x_p^{estimate}$：平台的聚合估计值</p>
<p>$s_i\triangleq(e_i,v_i)$：第$i$个worker的策略（努力策略和上报策略）</p>
<p>$c_i$：第$i$个worker的努力成本</p>
<p>$l_i$：第$i$个worker的内部奖励</p>
<p>$p_i$：第$i$个worker努力时的准确率</p>
<p>$R$：平台的一致性奖励</p>
<p>$\beta$：平台对聚合准确率的权重</p>
<p>$E[R^T]$：所有workers一致性奖励的期望</p>
<h2 id="4-Incomplete-Information"><a href="#4-Incomplete-Information" class="headerlink" title="4. Incomplete Information"></a>4. Incomplete Information</h2><p>每个worker的准确率只有自己知道，其他workers和平台都不知道。</p>
<h3 id="Workers’-Decisions-at-Stage-II"><a href="#Workers’-Decisions-at-Stage-II" class="headerlink" title="Workers’ Decisions at Stage II"></a>Workers’ Decisions at Stage II</h3><h4 id="Workers’-Heterogeneity"><a href="#Workers’-Heterogeneity" class="headerlink" title="Workers’ Heterogeneity"></a>Workers’ Heterogeneity</h4><p>workers异构性的体现：</p>
<ol>
<li>准确率异构——&gt;$k$个高准确率$p_h$workers，用集合$N_h$表示，$N-k$个低准确率$p_l$，用集合$N_l$表示，$1\leq k\leq N-1,0.5&lt;p_l&lt;p_h\leq 1$，这些参数的数值是公开信息。</li>
<li>努力时的成本和内在奖励/惩罚相同——&gt;$c_i=c,l_i=l,l&lt;c$</li>
</ol>
<h4 id="Workers’-Equilibrium-Behaviors"><a href="#Workers’-Equilibrium-Behaviors" class="headerlink" title="Workers’ Equilibrium Behaviors"></a>Workers’ Equilibrium Behaviors</h4><p>假设：同类型worker（准确率相同）会选择相同的策略</p>
<p><strong>定义2：</strong>对称纳什均衡（SNE）</p>
<ol>
<li>n-SNE：所有workers都不努力和如实报告</li>
<li>f-SNE：所有workers都努力和如实报告</li>
<li>p-SNE：高质量workers努力和如实报告，低质量workers则相反</li>
</ol>
<p><strong>命题1：</strong>workers之间的SNE</p>
<ol>
<li>当$R\geq 0$时一定存在一个n-SNE</li>
<li>存在一个阈值$R_f\geq 0$，当$R\geq R_f$时，一定存在一个f-SNE</li>
<li>当$k\geq k_1$时，存在两个阈值$0&lt;R_p^l\leq R_p^h$，使得在$R_p^l\leq R \leq R_p^h$时，一定存在一个p-SNE</li>
</ol>
<p>阈值之间的关系取决于$k$的大小：当$k$较小时，$R_f\leq R_p^l$；当$k$较大时，$R_f&gt;R_p^l$。</p>
<p>由命题1可得：</p>
<ol>
<li>对于任意非负一致性奖励$R$，一定存在一个n-SNE，所有workers都没有动机努力和如实报告；努力worker的收益是$\frac{R}{2}+l-c$，不努力worker的收益是$\frac{R}{2}$，由于$l&lt;c$，显然不努力更好。</li>
<li>当一致性奖励足够大时，存在f-SNE，所有workers都会努力和如实报告。</li>
<li>workers准确率的异构性允许我们通过机制来使不同准确率的workers采取不同策略，当一致性准确率在合适范围内时，存在p-SNE使得高准确率workers努力且如实报告，而低准确率workers不努力并随机报告。</li>
</ol>
<p>各均衡解存在性与参数的关系：</p>
<ol>
<li>$k&lt;k_1:$ 高准确率workers很少时，不存在p-SNE。</li>
<li>$k_1\leq k\leq k_2:$ 高准确率workers人数适量时，存在p-SNE，但平台报酬$R$的下限很高（$R_p^l&gt;R_f$）。</li>
<li>$k\geq k_2:$ 高准确率workers足够多时，存在p-SNE，且$R_p^l&lt;R_f$。当k很大时，高质量workers在p-SNE得到报酬的概率与在f-SNE得到报酬的概率相近，低质量workers也会被激励选择(1,1)策略。</li>
</ol>
<p>帕累托最优均衡解：</p>
<p><strong>命题2：</strong>给定一致性奖励$R$，一定存在一个帕累托最优均衡解。</p>
<p>这意味着可以通过调整一致性奖励来引导worker的努力策略和上报策略。</p>
<p><strong>命题3：</strong>策略空间（$s_i^*=(0,rd),\forall i\in N_h,s_j=(1,1),\forall i\in N_l$）不存在均衡解。</p>
<p>这意味着不会出现低质量workers努力而高质量workers随机的场面。对于给定的R，高质量workers有更高的概率拿到奖励。在努力成本不变的前提下，高准确率workers更愿意选择(1,1)的策略。换言之，多数投票方案更能吸引高准确率workers。然而，在完全信息的场景下这一条并不成立。</p>
<h3 id="Platform’s-Reward-Design-at-Stage-I"><a href="#Platform’s-Reward-Design-at-Stage-I" class="headerlink" title="Platform’s Reward Design at Stage I"></a>Platform’s Reward Design at Stage I</h3><p>$P_f,P_p,P_n:$ workers在三种均衡下的聚合准确率</p>
<p>$E[R_f^T],E[R_p^T],E[R_n^T]:$ 三种均衡下的总期望一致性奖励</p>
<p>$\eta_f,\eta_p,\eta_n:$ 三种均衡下的效率（是指一致性奖励的效率）</p>
<p>效率计算方式：</p>
<p>$\eta_f=\frac{P_f-P_n}{E[R_f^T]}$</p>
<p>$\eta_p=\frac{P_p-P_n}{E[R_p^T]}$</p>
<p>$\eta_n=\frac{P_n-P_n}{E[R_n^T]}=0$</p>
<p>上面这个计算式反过来（也就是$\frac{1}{\eta_f}$）的含义是：对于单位准确率而言，从均衡n-SNE提高到f-SNE所需要支出的平均一致性奖励。$\eta_p$也是类似的含义。</p>
<p>平台的最优决策R：</p>
<p><strong>定理1：</strong>给定任意参数$(\beta,N,c,l,p_l,p_h,k)$，平台可以引导workers达到f-SNE和对应的效率$\eta_f$</p>
<ol>
<li><p>如果p-SNE存在，且$\eta_p\geq \eta_f$，平台的最优一致性奖励为：</p>
<script type="math/tex; mode=display">
R^* = 
\left\{
\begin{matrix}
0,\ &if\ \beta<\frac{1}{\eta_p}, \\
R_p^l,\  &if\ \frac{1}{\eta_p}\leq\beta<\frac{E[R_f^T]-E[R_p^T]}{P_f-P_p}\\
R_f,\  &if\ \beta \geq \frac{E[R_f^T]-E[R_p^T]}{P_f-P_p};\\
\end{matrix}
\right.</script></li>
<li><p>其他情况下的平台最优一致性奖励为：</p>
<script type="math/tex; mode=display">
R^*=
\left \{
\begin{matrix}
0,&\ if\ \beta<1/\eta_f,\\
R_f,&\ if\ \beta\geq1/\eta_f.
\end{matrix}
\right.</script></li>
</ol>
<p><img src="https://i.loli.net/2021/05/07/E2af8LhbsgiKpUC.png" alt="image-20210507094050695"></p>
<p><img src="https://i.loli.net/2021/05/07/2PdRjKWyF7prVfT.png" alt="image-20210507094124550"></p>
<p>分析<strong>定理1</strong>可得：</p>
<ol>
<li>当p-SNE存在，且效率高于f-SNE，对应图4中的$k&gt;k^{THR}$区域，平台会根据$\beta$来引导均衡从而最大化收益。当$\beta$较小时，由于较低的准确率评价，平台不会提供任何激励，R=0，从而n-SNE是帕累托最优，对应图3中$k&gt;k^{THR}$区域中下面的白色部分。当$\beta$合适时，即图3中的蓝色区域，平台会选择$R=R_p^l$从而得到p-SNE。当$\beta$很大时，即图3中的灰色区域，平台会选择$R=R_f$，得到f-SNE，同时在一致性奖励方面支出很大。</li>
<li>当p-SNE不存在，或其效率低于f-SNE，对应图4中的$k&lt;k^{THR}$区域，类似前面的分析，$\beta$较小时，是n-SNE；反之则是p-SNE。</li>
</ol>
<h2 id="5-Complete-Information-Weighted-Aggregation"><a href="#5-Complete-Information-Weighted-Aggregation" class="headerlink" title="5. Complete Information: Weighted Aggregation"></a>5. Complete Information: Weighted Aggregation</h2><p>每个worker的准确率$p_i$是公开信息</p>
<h3 id="Workers’-Decisions"><a href="#Workers’-Decisions" class="headerlink" title="Workers’ Decisions"></a>Workers’ Decisions</h3><p>这一步和前面的<strong>博弈1</strong>、<strong>命题1</strong>一样。</p>
<h3 id="Platform’s-Reward-Design"><a href="#Platform’s-Reward-Design" class="headerlink" title="Platform’s Reward Design"></a>Platform’s Reward Design</h3><p>平台使用加权多数规则（weighted majority rule）来决定最终的聚合准确率：</p>
<script type="math/tex; mode=display">
x_p^{estimate}=
\left\{
\begin{matrix}
1,\ &if\ \sum_{i=1}^Nw_i(p_i,s_i)x_i^{report}>0\\
-1,\ &if\ \sum_{i=1}^Nw_i(p_i,s_i)x_i^{report}<0\\
1\ or\ -1\ with\ equal\ prob.,\ &if\ \sum_{i=1}^Nw_i(p_i,s_i)x_i^{report}=0
\end{matrix}
\right.</script><p>其中，</p>
<script type="math/tex; mode=display">
w_i(p_i,s_i)=log\frac{\rho(p_i,s_i)}{1-\rho(p_i,s_i)}, \\
\rho(p_i,s_i)=
\left\{
\begin{matrix}
0.5,\ &if\ s_i=(0,rd), \\
p_i,\ &if\ s_i=(1,1), \\
1-p_i,\ &if\ s_i=(1,-1).
\end{matrix}
\right.</script><p>权重公式既能提高聚合准确率，又会显著影响平台决定的报酬。</p>
<p>第i个worker的权重$w_i(p_i,s_i)$由其准确率和策略共同决定，因此：</p>
<ol>
<li>在f-SNE时（所有workers都选择<code>(1,1)</code>策略），高质量workers有更高权重，高低质量的权重都是正数；</li>
<li>在p-SNE时（高质量workers采取<code>(1,1)</code>而低质量workers采取<code>(0,rd)</code>），高质量workers权重为正数，低质量workers权重为0；</li>
<li>在n-SNE时（所有workers都选择<code>(0,rd)</code>策略），大家权重都是0，平台随机得到最终答案。</li>
</ol>
<p>数字符号定义如下：</p>
<ol>
<li>$P_f^{wm},P_p^{wm},P_n^{wm}$分别表示在加权多数规则情况下，f-SNE、p-SNE和f-SNE对应的聚合准确率；</li>
<li>$\eta_f^{wm},\eta_p^{wm},\eta_n^{wm}$分别表示在加权多数规则情况下，f-SNE、p-SNE和f-SNE对应的效率。</li>
</ol>
<p>计算方式：</p>
<p>$\eta_f^{wm}=(P_f^{wm}-P_n^{wm})/E[R_f^T]$</p>
<p>$\eta_p^{wm}=(P_p^{wm}-P_n^{wm})/E[R_p^T]$</p>
<p>$\eta_n^{wm}=(P_n^{wm}-P_n^{wm})/E[R_n^T]=0$</p>
<p>workers的均衡解行为和不完全信息一致，每种均衡对应的总一致性奖励（$E[R_f^T],E[R_p^T],E[R_n^T]$）也一致。</p>
<p><strong>命题4：</strong>给定参数$(\beta,N,c,l,p_l,p_h,k)$，如果f-SNE和p-SNE共存，则$P_f^{wm}\geq P_p^{wm}$</p>
<p><strong>证明：</strong>在p-SNE，低准确率workers采取<code>(0,rd)</code>，高准确率workers采取<code>(1,1)</code>，根据计算权重的公式，低质量workers权重为0，高质量workers权重为正数，基于此可计算得到$P_p^{wm}$。在f-SNE，所有workers采取<code>(1,1)</code>，按照p-SNE分配权重是可行的，此时$P_f^{wm}= P_p^{wm}$。由于权重计算公式是最优的，因此可得$P_f^{wm}\geq P_p^{wm}$。</p>
<p><em>补充：这个证明没看懂，个人对命题4的理解是说，两个均衡解共存时，f-SNE是所有workers都努力并如实报告，p-SNE是只有高质量workers努力并如实报告，显然f-SNE多了低质量workers努力贡献的准确率，因此总的准确率会更高。</em></p>
<p>由此，可以刻画平台的最优决策，和<strong>定理1</strong>一样，只有符号表达替换了。</p>
<p><img src="https://i.loli.net/2021/05/18/1Rf8TAgeHwkzsEn.png" alt="image-20210518162745417"></p>
<p>图5是新的均衡图解。蓝色区域更大了，也就是说在完全信息的场景下，平台更可能只让高质量workers努力和正确上报。</p>
<p><strong>定理2：</strong>令$\prod^{inc<em>}$和$\prod^{com</em>}$表示平台在不完全信息和完全信息情况下对应的最优收益。给定参数$(\beta,N,c,l,p_l,p_h,k)$，可得：$\prod^{com<em>}\geq \prod^{inc</em>}$。</p>
<h2 id="6-Complete-Information-Discriminatory-Reward-Policy"><a href="#6-Complete-Information-Discriminatory-Reward-Policy" class="headerlink" title="6. Complete Information: Discriminatory Reward Policy"></a>6. Complete Information: Discriminatory Reward Policy</h2><p>第5章中，平台给不同准确率的workers相同的奖励；本章中则采取有差别的奖励策略，即便是和多数一致方案相同，也会因为准确率不同而得到不同的奖励：低准确率得到的奖励是$R_{low}$，高准确率得到的奖励是$R_{high}$。</p>
<h3 id="Workers’-Decisions-1"><a href="#Workers’-Decisions-1" class="headerlink" title="Workers’ Decisions"></a>Workers’ Decisions</h3><p><strong>命题5：</strong>workers的SNE是</p>
<ol>
<li>$R_{low}$和$R_{high}$都大于等于0时，$s_i^*=(0,rd),\forall i$是一个SNE；</li>
<li>存在两个阈值$R_f^l$和$R_f^h$均大于0，使得当$R_{low}\geq R_f^l$且$R_{high}\geq R_f^h$时，$s_i^*=(1,1),\forall i$是一个SNE；</li>
<li>存在两个阈值$R_p^l$和$R_p^h$均大于0，使得当$R_{low}\leq R_p^l$且$R_{high}\geq R_p^h$时，高质量workers采取$(1,1)$而低质量workers采取$(0,rd)$是SNE；</li>
<li>存在两个阈值$R_{pl}^l$和$R_{pl}^h$均大于0，使得当$R_{low}\geq R_{pl}^l$且$R_{high}\leq R_{ph}^h$时，低质量workers采取$(1,1)$而高质量workers采取$(0,rd)$是SNE。</li>
</ol>
<h3 id="Platform’s-Optimal-Reward-Design"><a href="#Platform’s-Optimal-Reward-Design" class="headerlink" title="Platform’s Optimal Reward Design"></a>Platform’s Optimal Reward Design</h3><p><strong>定理3：</strong></p>
<ol>
<li>使用$\prod_{UP}^{com<em>}$和$\prod_{DP}^{com</em>}$表示平台在均等奖励和差分奖励的情况下的最优支出，则有：$\prod_{DP}^{com<em>}\geq\prod_{UP}^{com</em>}$</li>
<li>存在阈值$\bar{\beta}$，使得当$\beta\geq \bar{\beta}$时，如果UP的最优SNE是n-SNE，且DP的最优SNE不是f-SNE、p-SNE或者pl-SNE，则DP的社会财富比UP高。</li>
</ol>
<p>定理3说明从平台来看，采取差分奖励策略会带来不比均等奖励策略糟糕的支出和社会财富。DP并不一定会损害社会财富，反而会带来双赢的场面。</p>
<h2 id="7-Numerical-Results"><a href="#7-Numerical-Results" class="headerlink" title="7. Numerical Results"></a>7. Numerical Results</h2><p>分析高质量workers的数量$k$和高质量workers准确率$p_h$对平台与workers收益的影响。</p>
<h3 id="Incomplete-Information"><a href="#Incomplete-Information" class="headerlink" title="Incomplete Information"></a>Incomplete Information</h3><h3 id="Complete-Information"><a href="#Complete-Information" class="headerlink" title="Complete Information"></a>Complete Information</h3><h2 id="8-Conclusion"><a href="#8-Conclusion" class="headerlink" title="8. Conclusion"></a>8. Conclusion</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>crowdsourcing</tag>
        <tag>game theory</tag>
        <tag>Stackelberg game</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链行业总结</title>
    <url>/2021/04/10/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A1%8C%E4%B8%9A%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="区块链行业总结"><a href="#区块链行业总结" class="headerlink" title="区块链行业总结"></a>区块链行业总结</h1>]]></content>
      <categories>
        <category>slides</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-A Novel Paradigm for Disaster-Response Networks: Framework, Strategy and Solution</title>
    <url>/2021/03/06/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-A%20Novel%20Paradigm%20for%20Disaster-Response%20Networks%20Framework,%20Strategy%20and%20Solution/</url>
    <content><![CDATA[<h1 id="灾害应对网络的新范式：框架、策略与解决方案"><a href="#灾害应对网络的新范式：框架、策略与解决方案" class="headerlink" title="灾害应对网络的新范式：框架、策略与解决方案"></a>灾害应对网络的新范式：框架、策略与解决方案</h1><p>这篇是投稿到IEEE Wireless Communications Magazine的论文，现在要写审稿意见。</p>
<p>作者：</p>
<p>中国电力科学研究院</p>
<p>西安电子科技大学</p>
<p>华中科技大学</p>
<p>西北工业大学</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ol>
<li>起因：自然灾害频发、恐怖势力猖獗</li>
<li>特性：DRN（disaster-response network灾害应对网络）更看重网络的灵活性和应急救援能力，对网络框架和资源配置策略提出了新的要求</li>
<li>技术基础：卫星通信和无人机（UAV）动态中继</li>
<li>本文：提出了DRN建设和资源配置的新范式，通过卫星和无人机构建动态可扩展的DRN；提出了新的网络资源配置视角；在DRN框架下设计了资源调度计划。</li>
</ol>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="DRN的结构"><a href="#DRN的结构" class="headerlink" title="DRN的结构"></a>DRN的结构</h3><ol>
<li>需求：快速恢复通信，为救灾提供前提，提高救援效率</li>
<li>关键问题：个人安全</li>
<li>传统DRN：在快速部署和网络灵活性方面不好</li>
<li>新技术DRN：根据是否使用其他基础设施分为两类，基础设施包括可移动和可部署的ICT资源单元（MDRU）、卫星、无人机；总的来说使用其他基础设施的这一类更好</li>
<li>大多数现有网络的问题：只重视容量或覆盖性能，忽视救灾需求，尤其是用户的人身安全</li>
</ol>
<h3 id="DRN中的资源分配"><a href="#DRN中的资源分配" class="headerlink" title="DRN中的资源分配"></a>DRN中的资源分配</h3><ol>
<li>受灾用户的实时需求通常远远大于 DRN 的能力。因此，资源配置策略成为决定系统效率的关键因素。传统网络中的资源配置策略通常涉及容量、延迟或吞吐量，并相应地进行优化。</li>
<li>救灾的特殊性，即及时性和任务导向性，加上DRN之间的建筑差异，使得现有的资源配置策略不适应。由于时间和任务导向，主要考虑如何提高受灾用户的救援能力。因此，DRN 中的资源分配策略需要更多地考虑应用层的要求，而不是物理层的性能。</li>
</ol>
<h3 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h3><ol>
<li>针对时效性和任务导向，提出了一种新范式</li>
<li>采用卫星、无人机</li>
<li>快速部署、动态覆盖、灵活中继</li>
<li>第二部分：DRN的框架；第三部分：跨层资源优化和资源分配方案的开发；第四部分：性能评估；第五部分：总结</li>
</ol>
<h2 id="Disaster-response-network"><a href="#Disaster-response-network" class="headerlink" title="Disaster response network"></a>Disaster response network</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ol>
<li>由空间层、空气层和地面层组成：用户在地面层，需要发射信号；无人机在空气层收集信号传递给空间层的卫星；卫星和卫星基站通信。</li>
<li>空间层：使用低轨道卫星、中心化网络控制器</li>
<li>空气层：无人机作为中继来弥补卫星欠缺的灵活性等；假设无人机数量大于卫星容量，配备移动充电设施，可动态规划工作路径；简化卫星信道受大气变化的影响问题，重点关注资源分配策略</li>
<li>地面层：遇险用户发射求救信号成功则被视为成功救援；用户分为三类：成功发出信号的被救援用户（R-user）、有足够电量试图发求救信号的活跃用户（A-user）、用完电池无能为力的沉默用户（S-user）</li>
<li>本文框架中的A-user通过无人机中继器向卫星发信号，无人机分配完成后网络拓扑保持不变，每个用户只涉及一个无人机中继，使用译码转发和波束形成技术，用户与无人机中继之间的链路采用Nakagami衰落信道模型</li>
</ol>
<h3 id="资源分配策略"><a href="#资源分配策略" class="headerlink" title="资源分配策略"></a>资源分配策略</h3><ol>
<li>控制层和数据层通过卫星上的中心化网络解耦</li>
<li>控制层：网络控制器制定通信请求接收率（CRAR），接收用户、无人机报告的信道状态信息，收集用户设备的剩余工作时间</li>
<li>资源分配问题：用户的剩余电量不同，卫星要在电量耗尽前接收用户的遇险通信请求；通信请求的数量可能超过网络容量，要综合考虑用户设备的剩余工作时间和卫星、无人机可以处理的通信请求。</li>
</ol>
<h2 id="Resource-allocation"><a href="#Resource-allocation" class="headerlink" title="Resource allocation"></a>Resource allocation</h2><ol>
<li>用CRAR作为系统效率指标，即优化目标是提高CRAR</li>
<li>t时刻的CRAR指当前CRAR和未来CRAR的总和<ol>
<li>当前CRAR：s(t)</li>
<li>未来CRAR：$\sum_{\tau=t+1}^{\infty}P_{\tau}(B, C_{v-u}, C_{u-s})$</li>
<li>$B, C_{u-s},C_{v-u}$分别表示用户电量、空间层频道和空气层频道</li>
<li>电量越多用户等待救援的时间越久</li>
</ol>
</li>
<li>无人机算力有限，因此需要降低资源分配算法的复杂度——本文资源分配分为两阶段：空间层和空气层各一阶段</li>
<li>第一阶段中，对于每个无人机中继，网络控制器都会收集 CSI（频道状态信息） 并保持空气层链路的信道增益，这是成功传输的最关键因素之一。卫星根据卫星接入能力以更大的信道增益访问无人机中继</li>
<li>第二阶段中，t时刻的空气层链路资源分配方案：用矩阵表示卫星到无人机的分配方案、无人机到用户的分配方案和根据信道容错率判断的信道可用性（1或者0），用户电量不同会有不同的权重（低电量高延迟的优先级高），计算上述矩阵卷积相乘的F范数来作为目标函数</li>
<li>优化算法：贪婪的迭代匹配过程</li>
</ol>
<h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><ol>
<li>仿真模拟实验：用户由泊松点过程建模，使用二进制相移键控发送信号，位错误概率阈值$\epsilon=10^3$，进行20轮实验</li>
</ol>
<h3 id="CRAR"><a href="#CRAR" class="headerlink" title="CRAR"></a>CRAR</h3><ol>
<li>不同信噪比下，无人机数量和CRAR之间的关系</li>
</ol>
<h3 id="传输功率"><a href="#传输功率" class="headerlink" title="传输功率"></a>传输功率</h3><ol>
<li>不同无人机数量下，CRAR和传输功率之间的关系</li>
</ol>
<h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>提出了灾害应对系统中的资源分配方案，可改善CRAR</p>
<h2 id="审稿意见"><a href="#审稿意见" class="headerlink" title="审稿意见"></a>审稿意见</h2><h3 id="Strength"><a href="#Strength" class="headerlink" title="Strength"></a>Strength</h3><ul>
<li></li>
<li></li>
</ul>
<h3 id="Weakness"><a href="#Weakness" class="headerlink" title="Weakness"></a>Weakness</h3><ul>
<li>创新性较差，实质就提出了一个基于电量和延迟的资源分配方案</li>
<li>灾害应对系统的通信恢复过程除了考虑用户电量和延迟，也应当考虑用户本身的生命体征等；第一部分中提到的其他DRN存在的问题，本文中的DRN同样也有</li>
<li>公式1中的P函数具体形式没有介绍，且后文中的资源分配方案是否能得到最优的R(t)也需要进行分析</li>
<li>没有具体介绍空间层（卫星和无人机）的分配方案，“卫星以较大的信道增益访问无人机”是否会和卫星本身的容量和传输能力发生冲突，如果发生冲突（即资源不够分配）时，应当如何向不同的无人机分配资源？</li>
<li><del>网络控制器是卫星和无人机上都有吗？是否可以把无人机的资源分配计算工作放到卫星上，无人机仅进行通信中继？</del></li>
<li>在用户设备与无人机建立通信连接后，如果因为意外导致连接断开如何判断和处理？</li>
<li>在灾害应对系统中，直接将信息发送成功视作救援成功合适吗？是否还需要考虑周期性确认用户状态等后续操作带来的能量消耗？</li>
<li>实验中用作对比的传统方案具体是指哪种方案？</li>
<li>实验是数值仿真还是小规模的无人机仿真？如果是前者，无人机和卫星在实际使用场景的差异很大，数值仿真无法有效说明方案的效率；如果进行了无人机实验，则型号等相关参数应该在实验部分进行说明。</li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>灾害应对网络</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-中世纪历史与文化</title>
    <url>/2021/03/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%AD%E4%B8%96%E7%BA%AA%E5%8E%86%E5%8F%B2%E4%B8%8E%E6%96%87%E5%8C%96/</url>
    <content><![CDATA[<h1 id="中世纪历史与文化"><a href="#中世纪历史与文化" class="headerlink" title="中世纪历史与文化"></a>中世纪历史与文化</h1><h2 id="第一章-波埃修斯与欧洲的崛起"><a href="#第一章-波埃修斯与欧洲的崛起" class="headerlink" title="第一章 波埃修斯与欧洲的崛起"></a>第一章 波埃修斯与欧洲的崛起</h2><h3 id="波埃修斯：新柏拉图主义者"><a href="#波埃修斯：新柏拉图主义者" class="headerlink" title="波埃修斯：新柏拉图主义者"></a>波埃修斯：新柏拉图主义者</h3><ol>
<li>波埃修斯的成就：<ol>
<li>翻译《工具论》by亚里士多德的前三篇，介绍了一种思维方式；</li>
<li>著作《分类之书》、论算术的论文、对音乐的说明、《哲学的慰藉》等；</li>
<li>将“原理”“主体”“本质”等基础概念引入欧洲学术话语；</li>
<li>“知识并不来自所认知的事物，而是进行思考与认识的主题的认知能力所固有的”；</li>
<li>“四艺”的概念</li>
</ol>
</li>
<li>对后世的影响：<ol>
<li>《哲学的慰藉》：见证了古典文化在最终熄灭前发出最后的火光；</li>
<li>但丁、豪斯费霍尔等作者深受影响；</li>
<li>”哲学“与”命运“的讨论支撑着基督教，对自由意志的探讨意义深远；</li>
<li>推进神学与哲学之辩——&gt;中世纪理性与信仰日趋严重分化与对立</li>
</ol>
</li>
<li>在这之后：学术与知识逐渐随古代的结束而沉默，许多学派被取缔，艺术停滞在圣像的形式主义上，留下的只有基督教、教会和异端。中世纪的教育体系不再关注传统教育内容——科学研究与实验，而更多地体现为护教、阐释、劝勉、布道和虔敬。</li>
</ol>
<h3 id="传承到中世纪的知识"><a href="#传承到中世纪的知识" class="headerlink" title="传承到中世纪的知识"></a>传承到中世纪的知识</h3><ol>
<li>《论基督教教义》by圣奥古斯丁：符号学——事物通过符号被认识</li>
<li>《指南》by卡西奥多鲁斯：基督教的教育规划</li>
<li>《语文学与墨丘利的婚约》by马蒂安努斯$\cdot$卡佩拉：寓言式的有关技艺的基础教程</li>
</ol>
<h3 id="罗马与外族的融合"><a href="#罗马与外族的融合" class="headerlink" title="罗马与外族的融合"></a>罗马与外族的融合</h3><ol>
<li>来到罗马帝国的土地上的外族人一方面想要战胜先进文明，同时另一方面又效仿着先进文明，典型的例子：哥特人</li>
</ol>
<h4 id="哥特人"><a href="#哥特人" class="headerlink" title="哥特人"></a>哥特人</h4><ol>
<li>”没有法律任何国家都不能长存“</li>
<li>”复兴罗马“成为接下来数百年乃至整个中世纪的标语，在历史的不同阶段以不同面貌出现，也以不同方式被付诸实践</li>
<li>最初（4世纪初以来）罗马人向哥特人派遣基督教传教士，而这也受到了异教徒的抵抗，由此发生了哥特人的罗马化。在这一阶段，乌尔菲拉主教将《圣经》翻译为哥特方言，尽管翻译存在很多问题，但这仍然推进了哥特人向地中海高等文化的转变。</li>
<li>到5世纪左右，哥特人分为西哥特和东哥特两部分</li>
<li>5世纪后期，西哥特国王们编撰了一系列法令集，这些成文法一直沿用至中世纪盛期，它们将”罗马人“从”哥特人“中分离出来，并形成”成文法区域“</li>
<li>在与法兰克人打仗并战败后，哥特人被迫来到赛蒂马尼亚和西班牙，并建立新的哥特王国。在此之后原本信奉阿里乌教派的哥特人皈依了天主教，修订了教会法。</li>
<li>尽管哥特人认可天主教会的合法性，但事实上哥特人与罗马教会、教宗之间并未建立法律上的联系，哥特-西班牙的天主教徒更多地保持了自身的独立性</li>
<li>11世纪教会改革，西班牙被纳入罗马教宗的普世主教区（指世俗君主放弃神职叙任权）</li>
</ol>
<h4 id="法兰克人"><a href="#法兰克人" class="headerlink" title="法兰克人"></a>法兰克人</h4><ol>
<li>在哥特人发展的同时，法兰克人也在发展；法兰克人的起源混沌不清，没有详细记载，更多的是各种神话</li>
<li>法兰克的整个发展过程中都得到了罗马帝国的帮助，尤其是经济扶持；相应地，墨洛温王朝将罗马遗留的军事、民政管理系统作为自身的统治基础。</li>
<li>古典文化在墨洛温王朝经历了转型、退化，并没有像在哥特王国那样突然消亡。</li>
<li>法兰克王国的创立者克洛维死后，按其意愿，法兰克王国分给了他的四个儿子，这一分裂的继承法由此传承下去，直到9、10世纪随加洛林王朝的结束而结束。</li>
<li>法兰克王国的由于分裂的继承法没能形成稳定的证券，但同时诞生了一系列下属王国</li>
</ol>
<h4 id="东罗马帝国（拜占庭）"><a href="#东罗马帝国（拜占庭）" class="headerlink" title="东罗马帝国（拜占庭）"></a>东罗马帝国（拜占庭）</h4><ol>
<li>在波埃修斯的时代，东罗马统治者是查士丁尼大帝，他实行了一系列复兴政策：<ol>
<li>收复落入蛮族统治的西部省份——战争同时带来巨大的负担，以君士坦丁堡为中心建立的政治经济集权体制绑架了被收复省份的发展机会，削弱了其生产和抵抗的力量，反而加快了罗马帝国的衰落</li>
<li>编撰罗马法法典《民法大全》（又被称为《查士丁尼法典》）——11世纪末，引发了西方以大学为基础的学术勃兴</li>
<li>关闭雅典学园——科学发展逐渐停滞，不再有根本上的创新</li>
</ol>
</li>
<li>陆陆续续的外敌入侵：<ol>
<li>来自中亚的匈人入侵</li>
<li>南面皈依伊斯兰教的阿拉伯人</li>
<li>各类蛮族：斯拉夫人、阿瓦尔人、佩切涅格人、保加利亚人</li>
<li>伦巴第人入侵意大利</li>
</ol>
</li>
<li>11世纪诺曼人的到来终结了拜占庭势力对伦巴第和意大利南部的影响</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>罗马象征着先进的物质、社会和文化发展水平，”朝向罗马“（Romorientierung）这一确凿的、潜意识上的进程从未消解。与之对应的，在罗马彼岸居住着古代意义上的”野蛮人“，他们相对于罗马而言处于低等文化，只拥有少数铁器；没有城市和铺设的道路；只有纯粹的口头文化而没有文字，很长一段时间内用凿刻的符文作为咒语或简单的名字；没有科学也没有持久的历史传统；宗教崇拜鲜为人知。</p>
<p>西方世界的不同地域对接受和继承高等书写文化有着完全不同的启动环境，离地中海高等文明越远的地方，高等文明遭到的拒绝和限制就越明显，其童话效应也更为迟缓和微弱。</p>
<p>不过爱尔兰与众不同，西方学术的复兴从那里受益，尽管波埃修斯的作品并未在爱尔兰产生任何影响。</p>
<h2 id="第二章-大格里高利和法兰克人的新兴权力"><a href="#第二章-大格里高利和法兰克人的新兴权力" class="headerlink" title="第二章 大格里高利和法兰克人的新兴权力"></a>第二章 大格里高利和法兰克人的新兴权力</h2><h2 id="第三章-查理曼与第一次“罗马帝国的复兴”"><a href="#第三章-查理曼与第一次“罗马帝国的复兴”" class="headerlink" title="第三章 查理曼与第一次“罗马帝国的复兴”"></a>第三章 查理曼与第一次“罗马帝国的复兴”</h2><h2 id="第四章-王国的巩固与罗马帝国的第二次复兴"><a href="#第四章-王国的巩固与罗马帝国的第二次复兴" class="headerlink" title="第四章 王国的巩固与罗马帝国的第二次复兴"></a>第四章 王国的巩固与罗马帝国的第二次复兴</h2><h2 id="第五章-末世危险地临近了"><a href="#第五章-末世危险地临近了" class="headerlink" title="第五章 末世危险地临近了"></a>第五章 末世危险地临近了</h2><h2 id="第六章-“真正的皇帝是教宗”"><a href="#第六章-“真正的皇帝是教宗”" class="headerlink" title="第六章 “真正的皇帝是教宗”"></a>第六章 “真正的皇帝是教宗”</h2><h2 id="第七章-教宗分立的漫长世纪"><a href="#第七章-教宗分立的漫长世纪" class="headerlink" title="第七章 教宗分立的漫长世纪"></a>第七章 教宗分立的漫长世纪</h2><h2 id="第八章-天主的代理人"><a href="#第八章-天主的代理人" class="headerlink" title="第八章 天主的代理人"></a>第八章 天主的代理人</h2><h2 id="第九章-法理高奏凯歌"><a href="#第九章-法理高奏凯歌" class="headerlink" title="第九章 法理高奏凯歌"></a>第九章 法理高奏凯歌</h2><h2 id="第十章-理性之光"><a href="#第十章-理性之光" class="headerlink" title="第十章 理性之光"></a>第十章 理性之光</h2><h2 id="第十一章-君主制"><a href="#第十一章-君主制" class="headerlink" title="第十一章 君主制"></a>第十一章 君主制</h2><h2 id="第十二章-对最后的审判与重生的期待"><a href="#第十二章-对最后的审判与重生的期待" class="headerlink" title="第十二章 对最后的审判与重生的期待"></a>第十二章 对最后的审判与重生的期待</h2>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>中世纪历史与文化</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+reveal实现slide</title>
    <url>/2021/03/02/hexo+reveal%E5%AE%9E%E7%8E%B0slide/</url>
    <content><![CDATA[<h1 id="hexo-reveal"><a href="#hexo-reveal" class="headerlink" title="hexo+reveal"></a>hexo+reveal</h1><h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p>今天终于搞成了用<code>reveal.js</code>在博客里显示ppt的效果。感谢做模块的大佬，以至于安装过程还挺简单的。步骤如下：</p>
<ol>
<li><p>安装：命令行进入博客目录，输入<code>npm i hexo-generator-slidehtml</code></p>
</li>
<li><p>安装好以后，一个按格式（格式见后文）写好的markdown文件就会被渲染成slide格式的html网页了，需要访问的时候，在博客的链接后面加<code>slide.html</code>即可，比如某个博客的链接是<code>http://www.clo5de.info/hexo-generator-slidehtml/2019/04/03/nonTitleMerge/</code>，那么它对应的slide链接就是<code>http://www.clo5de.info/hexo-generator-slidehtml/2019/04/03/nonTitleMerge/slide.html</code>。</p>
</li>
<li><p>但是这样安装好的没法渲染公式，因此要进入<code>\blog\node_modules\hexo-generator-slidehtml\layout</code>目录，打开<code>post-slide.ejs</code>文件，添加<code>&lt;script src=&quot;https://cdn.bootcss.com/reveal.js/3.4.1/plugin/math/math.js&quot;&gt;&lt;/script&gt;</code>（和其他script放一起就行），并在<code>Reveal.initialize</code> 代码块中添加一行<code>plugins: [ RevealMath ],</code>注意这一行最后有个逗号不要忘了。</p>
</li>
<li><p>关于math的设置也还有其他可选项，可以参考<a href="https://revealjs.com/math/" target="_blank" rel="noopener">官网</a></p>
</li>
<li><p>此外我在官网还下载了<code>reveal.js</code>的完整内容，并把其中的<code>plugin</code>文件夹整个复制到了<code>\blog\node_modules\hexo-generator-slidehtml\layout</code>目录下；而刚才那个<code>post-slide.ejs</code>的<code>Reveal.initialize</code> 代码块中的<code>dependencies</code>也增加了以下两行：</p>
<p><code>{ src: &#39;https://cdn.bootcss.com/reveal.js/3.4.1/plugin/math/math.esm.js&#39; },</code></p>
<p><code>{ src: &#39;https://cdn.bootcss.com/reveal.js/3.4.1/plugin/math/math.js&#39; },</code></p>
<p>不过这一步的操作按理说是不需要的，只是我一开始怎么也没法刷新出公式，猜测可能和网页缓存等有关。</p>
</li>
<li><p>按官网的说法，如果要写markdown行内公式，就需要把内容放到如下代码所示的符号中间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;$$公式内容$$&#96;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>If you want to include math inside of a presentation written in Markdown you need to wrap the formula in backticks. This prevents syntax conflicts between LaTeX and Markdown</p>
</blockquote>
</li>
<li><p>不过根据我自己的使用，markdown语法的公式就可以正常显示了，不需要按上面的格式来写。</p>
</li>
<li><p>如果写latex公式，就放到<code>&lt;section&gt;&lt;/section&gt;</code>中间，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">  &lt;h2&gt;The Lorenz Equations&lt;&#x2F;h2&gt;</span><br><span class="line">  \[\begin&#123;aligned&#125;</span><br><span class="line">  \dot&#123;x&#125; &amp; &#x3D; \sigma(y-x) \\</span><br><span class="line">  \dot&#123;y&#125; &amp; &#x3D; \rho x - y - xz \\</span><br><span class="line">  \dot&#123;z&#125; &amp; &#x3D; -\beta z + xy</span><br><span class="line">  \end&#123;aligned&#125; \]</span><br><span class="line">&lt;&#x2F;section&gt;</span><br></pre></td></tr></table></figure>
<p>这个公式的展示效果在官网上可以看到。</p>
</li>
<li><p>在搞了各种配置之后公式如果还没渲染，就等一等，可能和缓存有关。</p>
</li>
<li><p>对于需要制作成slide的markdown文件，只需要在原先写标题日期分类和tags等内容的那个地方增加一个字段：<code>slidehtml: true</code>，这个也可以写进<code>hexo new</code>的模板，这样方便一些。markdown文件中要有一行<code>&lt;!-- #Slide Start# --&gt;</code>（去掉#，这里加#是为了避免接下来直接渲染slide），整个文件内容会以此分为两部分，在这一行前面的，就会展示在博客内容中，而这一行后面的，则会出现在对应的slide中。例如本篇博客的内容就到此结束了，而如果在网址后面添加<code>slide.html</code>，则会看到我复制别人的slide内容。</p>
</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://github.com/jackey8616/hexo-generator-slidehtml" target="_blank" rel="noopener">https://github.com/jackey8616/hexo-generator-slidehtml</a></li>
<li><a href="https://revealjs.com/math/" target="_blank" rel="noopener">https://revealjs.com/math/</a></li>
<li><a href="https://www.lfhacks.com/assets/revealjs.html" target="_blank" rel="noopener">https://www.lfhacks.com/assets/revealjs.html</a></li>
<li><a href="http://vishalgupta.me/md-slides/" target="_blank" rel="noopener">http://vishalgupta.me/md-slides/</a></li>
</ol>
]]></content>
      <categories>
        <category>slides</category>
      </categories>
      <tags>
        <tag>博客配置</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Closed-Form Expression for the Poisson-Binomial Probability Density Function</title>
    <url>/2021/02/12/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Closed-Form%20Expression%20for%20the%20Poisson-Binomial%20Probability%20Density%20Function/</url>
    <content><![CDATA[<h1 id="Closed-Form-Expression-for-the-Poisson-Binomial-Probability-Density-Function"><a href="#Closed-Form-Expression-for-the-Poisson-Binomial-Probability-Density-Function" class="headerlink" title="Closed-Form Expression for the Poisson-Binomial Probability Density Function"></a>Closed-Form Expression for the Poisson-Binomial Probability Density Function</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>二项分布概率密度函数描述了当单个成功概率在试验中保持不变时 N 次独立试验中的成功数。而当这个成功概率会改变时，概率密度函数就转变为泊松-二项分布。</p>
<p>例子：</p>
<ol>
<li>可靠性理论/容错：当N个子进程中有至少M个失败时，我们认为该进程失败。第n个子进程的失败概率为$p_n$，计算整个进程的失败概率。</li>
<li>目标追踪：当传感器在N次连续独立查找中至少检测到M次时，目标追踪会被启动。给定可能会改变的每次查找检测概率$p_n$，确定追踪启动的概率。</li>
<li>模式识别/决策理论：如果第n个专家在诊断某特殊情况是否发生时，有$p_n$的概率得到正确的判断，那么为了实现超过某一百分数的正确率，需要多少位独立专家的重合判定。</li>
<li>教育考试设计：标准化考试中有N个等权重问题，给定至少正确解答其中n个问题的学生百分数，据此推算每个问题正确回答学生的百分数，从而确定问题是否表现出所需的难度扩散。（这是一个逆向泊松二项分布的问题）</li>
<li>多传感器融合：给定一个由N个传感器组成的网络，其检测/无检测输出将通过投票结果进行组合，为了实现指定的M-out-N”融合”误报概率，每个传感器的误报率应该是多少。</li>
<li>项目管理/资源分配：有K个工作站，每个工作站分配到$r_k$个资源，每个工作站达到其各自生产配额的概率为$p_k=f(r_k)$。给定L个附加工作站的可用性，并假设函数$f()$可逆，应向新工作站分配多少资源，以便K+L个工作站中至少 M 个工作站能达到其生产配额的概率为P。</li>
</ol>
<p>本文组织结构：</p>
<ol>
<li>单独每次事件成功率与泊松-二项分布概率密度函数之间的关系</li>
<li>数值技术（多项式插值和离散傅里叶变换）</li>
<li>通过获取二项系数、二项式 cdf 和泊松-二项性时刻（Poisson-binomial moments，这个翻译不知道是否正确）的新表示来演示这些表达式的使用</li>
<li>解决前面的第6个例子作为应用展示</li>
<li>使用多项式技术和矩阵理论技术解决逆向泊松-二项分布的问题</li>
<li>总结</li>
</ol>
<h2 id="GROUNDWORK"><a href="#GROUNDWORK" class="headerlink" title="GROUNDWORK"></a>GROUNDWORK</h2><p>在N次独立实验中，第k次的成功率为$p_k$，失败率为$1-p_k$。成功的次数Y可以被写作$Y=X_1+X_2+…+X_N$，这N个相互独立的随机变量$X_k$，分布向量为$[Pr\{X_k=0\}\ \ Pr\{X_k=1\}]=[1-p_k\ \ p_k]$，其中$Pr\{u\}$表示$u$的概率。而这些随机变量的和式Y的分布就是泊松二项概率密度函数，其表达式通过线性卷积可以得到：</p>
<script type="math/tex; mode=display">
[Pr\{Y=0\}\ \ Pr\{Y=1\}...Pr\{Y=N\}]\\
= [1-p_1\ \ p_1]*[1-p_2\ \ p_2]*...*[1-p_N\ \ p_N] \tag{1}</script><p>对公式1两边使用Z变换，可得泊松二项概率密度函数的两种生成函数：</p>
<script type="math/tex; mode=display">
P_0+P_1z+P_2z^2+...+P_Nz^N\\
=(1-p_1+p_1z)(1-p_2+p2_z)...(1-p_N+p_Nz) \tag{2}</script><p>其中$P_n$表示$Pr\{Y=n\}$</p>
<p>公式(2)的右边稍微改动一下可得：</p>
<script type="math/tex; mode=display">
P_0+P_1z+P_2z^2+...+P_Nz^N\\
=\alpha(z-s_1)(z-s_2)...(z-s_N) \tag{3a}</script><p>其中</p>
<script type="math/tex; mode=display">
\alpha = \prod_{k=1}^N P_k \tag{3b}</script><script type="math/tex; mode=display">
s_k = -(1-p_k)/p_k \tag{3c}</script><p>上述过程用matlab可以写成：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[P,Q]</span>=<span class="title">ProbMofN</span><span class="params">(p)</span></span></span><br><span class="line"><span class="comment">% 给定N个元素的向量p，它表示N个独立重复实验的成功概率，该函数的返回值包括：</span></span><br><span class="line"><span class="comment">% P：N+1个元素，表示0次成功、1次成功、2次成功...N次成功（泊松-二项式的pdf）</span></span><br><span class="line"><span class="comment">% Q：N+1个元素，表示至少0次成功、至少1次成功、...、至少N次成功的概率（泊松-二项式的cdf）</span></span><br><span class="line">p(p==<span class="number">0</span>)=[];	<span class="comment">% 消除等于0的元素</span></span><br><span class="line">n=<span class="built_in">length</span>(p);</span><br><span class="line">alpha=prob(p);</span><br><span class="line">s=-(<span class="number">1</span>-p)./p;</span><br><span class="line">S=poly(s); <span class="comment">% S就是根为向量s的多项式的N+1个系数的向量，也就是说，S(1)*x^N+...+S(N)*x+S(N+1)</span></span><br><span class="line"></span><br><span class="line">temp_P=alpha*S;</span><br><span class="line">temp_Q=cumsum(temp_P);</span><br><span class="line"></span><br><span class="line">P=temp_P[N+<span class="number">1</span>:<span class="number">-1</span>:<span class="number">1</span>];</span><br><span class="line">Q=temp_Q[N+<span class="number">1</span>:<span class="number">-1</span>:<span class="number">1</span>];</span><br><span class="line"><span class="comment">%================================</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span>=<span class="title">invProbMofN</span><span class="params">(P)</span></span></span><br><span class="line"><span class="comment">% 给定N个元素的向量P，它表示N次实验后，0次成功、1次成功、...、N次成功的概率，该函数的返回值为：</span></span><br><span class="line"><span class="comment">% p：N个元素的向量，表示每次实验的成功率</span></span><br><span class="line">N1=<span class="built_in">length</span>(P); <span class="comment">% N1=N+1</span></span><br><span class="line">S=P[N1:<span class="number">-1</span>:<span class="number">1</span>]; </span><br><span class="line">s=roots(S); <span class="comment">% s是N个元素的向量，表示生成函数的根</span></span><br><span class="line">p=<span class="number">1.</span>/(<span class="number">1</span>-s); <span class="comment">% p是N个元素的向量，表示每次事件的成功率</span></span><br></pre></td></tr></table></figure>
<p>这样的计算过程虽然很好用，但是在对泊松-二项式pdf进行进一步分析或推导新结论时不太方便。于是本文提出了近似表达式。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>泊松分布</tag>
      </tags>
  </entry>
  <entry>
    <title>Ren&#39;py引擎的使用</title>
    <url>/2021/02/11/Ren-py%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Ren’py引擎的使用"><a href="#Ren’py引擎的使用" class="headerlink" title="Ren’py引擎的使用"></a>Ren’py引擎的使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>Renpy可以在<a href="https://www.renpy.org/" target="_blank" rel="noopener">官方网站</a>下载；</li>
<li>除了安装引擎本身以外，还需要准备python2和python3；</li>
<li>解包游戏文件需要使用python3安装unrpa，命令行中的安装命令为<code>py -3 -m pip install unrpa</code>；</li>
</ol>
<h2 id="制作游戏"><a href="#制作游戏" class="headerlink" title="制作游戏"></a>制作游戏</h2><h2 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h2><ol>
<li><code>unrpa -mp 目标路径 rpa文件路径</code>即可将rpa文件解包成rpy文件和rpyc文件</li>
</ol>
]]></content>
      <categories>
        <category>Renpy</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>Renpy</tag>
      </tags>
  </entry>
  <entry>
    <title>仙境之夜攻略记录</title>
    <url>/2021/02/11/%E4%BB%99%E5%A2%83%E4%B9%8B%E5%A4%9C%E6%94%BB%E7%95%A5%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="仙境之夜攻略记录"><a href="#仙境之夜攻略记录" class="headerlink" title="仙境之夜攻略记录"></a>仙境之夜攻略记录</h1><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><div class="table-container">
<table>
<thead>
<tr>
<th>中文</th>
<th>英文</th>
<th>编号</th>
</tr>
</thead>
<tbody>
<tr>
<td>白兔</td>
<td>White Rabbit</td>
<td>WR</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>King Claudius of Clubs</td>
<td>KC</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>Queen Catherine of Clubs</td>
<td>QC</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>Countess Jamala of Clubs</td>
<td>JC</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>King David of Diamonds</td>
<td>KD</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>Queen Diana of Diamonds</td>
<td>QD</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>Princess Julie of Diamonds</td>
<td>JD</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>King Harry of Hearts</td>
<td>KH</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>Queen Hera of Hearts</td>
<td>QH</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>Duke Jorge of Hearts</td>
<td>JH</td>
</tr>
<tr>
<td>黑桃国王所罗门</td>
<td>King Solomon of Spades</td>
<td>KS</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>Queen Sarah of Spades</td>
<td>QS</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>Prince John of Spades</td>
<td>JS</td>
</tr>
<tr>
<td>小丑 柴郡猫</td>
<td>Cheshire Cat, The Joker</td>
<td>JK</td>
</tr>
<tr>
<td>外来者 爱丽丝</td>
<td>Alice, The Outsider</td>
<td>A</td>
</tr>
</tbody>
</table>
</div>
<h3 id="活动喜好"><a href="#活动喜好" class="headerlink" title="活动喜好"></a>活动喜好</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>槌球</th>
<th>驯鹰</th>
<th>音乐</th>
<th>马术</th>
<th>下午茶</th>
<th>网球</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>无感</td>
<td>厌恶</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
<td>喜欢</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>厌恶</td>
<td>无感</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
<td>喜欢</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>厌恶</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
<td>无感</td>
<td>喜欢</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
<td>喜欢</td>
<td>厌恶</td>
<td>无感</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>喜欢</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
<td>无感</td>
<td>厌恶</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
<td>喜欢</td>
<td>无感</td>
<td>厌恶</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
<td>无感</td>
<td>厌恶</td>
<td>喜欢</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>无感</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>无感</td>
<td>厌恶</td>
<td>喜欢</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>喜欢</td>
<td>无感</td>
<td>厌恶</td>
<td>厌恶</td>
<td>喜欢</td>
<td>无感</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>喜欢</td>
<td>厌恶</td>
<td>无感</td>
<td>无感</td>
<td>喜欢</td>
<td>厌恶</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>喜欢</td>
<td>喜欢</td>
<td>厌恶</td>
<td>无感</td>
<td>厌恶</td>
<td>无感</td>
</tr>
</tbody>
</table>
</div>
<h3 id="初始立场"><a href="#初始立场" class="headerlink" title="初始立场"></a>初始立场</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>战争</th>
<th>魔法</th>
<th>贸易</th>
<th>边境</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>反对</td>
<td>支持</td>
<td>征税</td>
<td>有些反对</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>支持</td>
<td>支持</td>
<td>征税</td>
<td>闭关</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>支持</td>
<td>反对</td>
<td>没有主见</td>
<td>开放</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>支持</td>
<td>反对</td>
<td>自由</td>
<td>闭关</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>反对</td>
<td>支持</td>
<td>征税</td>
<td>开放</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>皆可</td>
<td>皆可</td>
<td>自由（强烈）</td>
<td>皆可</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>反对</td>
<td>反对</td>
<td>自由</td>
<td>开放</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>反对</td>
<td>支持</td>
<td>自由</td>
<td>开放</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>反对</td>
<td>支持</td>
<td>自由</td>
<td>开放</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>反对</td>
<td>支持</td>
<td>征税</td>
<td>开放</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>反对</td>
<td>支持</td>
<td>征税</td>
<td>开放</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>支持</td>
<td>反对</td>
<td>自由</td>
<td>闭关</td>
</tr>
</tbody>
</table>
</div>
<h3 id="秘密和对他人的看法"><a href="#秘密和对他人的看法" class="headerlink" title="秘密和对他人的看法"></a>秘密和对他人的看法</h3><p><strong>列人物</strong>对<strong>行人物</strong>的看法，例如第二行第三列“被其支配”表示所罗门对莎拉的看法。行列相同的格子表示这个角色的秘密。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>被妻子的魔法控制了</td>
<td>被其支配</td>
<td>可爱的儿子</td>
<td>不待见对方</td>
<td>友好</td>
<td>互相怀疑</td>
<td>敌对</td>
<td>友好</td>
<td>对我来说也像自己的女儿一样</td>
<td>友好</td>
<td>友好</td>
<td>可疑</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>受控的丈夫</td>
<td>对黑桃蘑菇上瘾</td>
<td>受控的儿子</td>
<td>若意见相同，可以友好相处</td>
<td>无感</td>
<td>互相怀疑</td>
<td>敌对</td>
<td>无感</td>
<td>无感</td>
<td>无感</td>
<td>敌对（姐妹关系）</td>
<td>无感</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>亲爱的父亲</td>
<td>独裁的母亲</td>
<td>和方片公主相爱</td>
<td>很容易操纵我</td>
<td>友好</td>
<td>友好</td>
<td>仰慕</td>
<td>友好</td>
<td>坠入爱河！</td>
<td>有意思的姨丈</td>
<td>有点怕她，但是是个有意思的人</td>
<td>很容易操纵我</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>令人厌恶的蠢蛋</td>
<td>若意见相同，可以友好相处</td>
<td>易操纵</td>
<td>是炸脖龙！</td>
<td>糟糕的婚姻</td>
<td>值得信任</td>
<td>勒索对象</td>
<td>若意见相同，可以友好相处</td>
<td>我想得到她</td>
<td>敌对</td>
<td>敌对</td>
<td>不为人知的弟弟！</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>友好</td>
<td>糟糕的悍妇</td>
<td>可爱的小伙子</td>
<td>可怕的怪物！</td>
<td>不是仙境世界的本地人</td>
<td>值得信任</td>
<td>被领养后遇到的刻薄哥哥</td>
<td>友好</td>
<td>可爱的小姑娘</td>
<td>被领养后遇到的冷漠哥哥</td>
<td>棘手之人</td>
<td>旧爱</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>高度怀疑</td>
<td>高度怀疑</td>
<td>蠢蛋，没有威胁</td>
<td>独裁者，需要遏制他</td>
<td>我会保护她</td>
<td>前任黑桃女王</td>
<td>高度怀疑</td>
<td>高度怀疑</td>
<td>多愁善感的小姑娘，没有威胁</td>
<td>老蠢蛋，没有威胁</td>
<td>太情绪化，没有威胁</td>
<td>高度怀疑</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>敌对</td>
<td>敌对</td>
<td>敌人之子</td>
<td>勒索我的人</td>
<td>与我无关</td>
<td>…谁啊？</td>
<td>他的身体正长出像怪物一样的肿瘤</td>
<td>轻浮的女人，我要控制她！</td>
<td>和她妈太像了</td>
<td>愚蠢的弟弟</td>
<td>我的弟弟很听她的</td>
<td>这家伙是什么立场？</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>应该是我的敌人</td>
<td>令人厌恶的女人</td>
<td>敌人的可爱儿子</td>
<td>可怕的暴君</td>
<td>可爱而不幸的女人</td>
<td>她让我很不自在…</td>
<td>控制狂！</td>
<td>是一名不为人知的女巫</td>
<td>完美！</td>
<td>亲爱的小叔子</td>
<td>让她高兴就对了！</td>
<td>他让我很不自在…</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>应该是我的敌人</td>
<td>令人厌恶的女人</td>
<td>我爱他！</td>
<td>让我害怕的人</td>
<td>可爱的女人，可惜婚姻不幸福</td>
<td>看起来很友好</td>
<td>父王（有点无趣）</td>
<td>完美的母后</td>
<td>和黑桃王子陷入爱河</td>
<td>亲爱的叔叔</td>
<td>亲爱的婶婶（只要不生气）</td>
<td>很有说服力！</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>友好的妹夫</td>
<td>可恨的小姨子</td>
<td>可爱的小侄子</td>
<td>敌人！</td>
<td>可怜的妹妹…</td>
<td>看起来很有涵养</td>
<td>无聊的哥哥</td>
<td>友好的嫂子</td>
<td>可爱的小侄女</td>
<td>偷了妻子的水果塔！</td>
<td>喜怒无常的妻子</td>
<td>值得信任的顾问</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>友好的妹夫</td>
<td>可恨的妹妹</td>
<td>可爱的小侄子</td>
<td>敌人！</td>
<td>可怜又悲惨的女人</td>
<td>有点无聊</td>
<td>大舅子</td>
<td>友好的嫂子</td>
<td>可爱的小侄女</td>
<td>有点无聊的丈夫</td>
<td>和乔治公爵有外遇</td>
<td>情人</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>蠢蛋</td>
<td>糟糕的女人</td>
<td>缺心眼，容易受骗</td>
<td>我的哥哥</td>
<td>我对她还有感情…</td>
<td>她是从哪来的？</td>
<td>试试操纵他</td>
<td>试试操纵她</td>
<td>缺心眼，容易受骗</td>
<td>我的情敌</td>
<td>我爱她！</td>
<td>梅花王国培养他来暗中破坏红心王国</td>
</tr>
</tbody>
</table>
</div>
<h2 id="给自己的提醒"><a href="#给自己的提醒" class="headerlink" title="给自己的提醒"></a>给自己的提醒</h2><h3 id="仙境世界的灾难"><a href="#仙境世界的灾难" class="headerlink" title="仙境世界的灾难"></a>仙境世界的灾难</h3><p>如果克劳狄斯王和所罗门王、莎拉王后、戴安娜王后及赫拉女王碰面，会发生什么事？大卫王似乎想深入了解约翰王子</p>
<p>如果克劳狄斯王和所罗门王、莎拉王后、戴安娜王后及赫拉女王碰面，会发生什么事？（大卫王和约翰王子没有谈话过）</p>
<p>克劳狄斯王想见大卫王和朱莉公主。</p>
<h3 id="黑桃王国的命运"><a href="#黑桃王国的命运" class="headerlink" title="黑桃王国的命运"></a>黑桃王国的命运</h3><p>贾马拉女伯爵想见戴安娜王后、大卫王和莎拉王后。其中的一位在压力之下是个脆弱的突破点。</p>
<p>如果贾马拉女伯爵在试探过戴安娜王后、大卫王和莎拉王后之后和所罗门王谈话，会发生什么？</p>
<p>所罗门王和约翰王子需要和对方谈话，并与戴安娜王后和凯瑟琳王后谈话。</p>
<p>如果所罗门王与赫拉女王见面两次后，和莎拉王后进行了谈话，会发生什么…</p>
<h3 id="红心王国的故事"><a href="#红心王国的故事" class="headerlink" title="红心王国的故事"></a>红心王国的故事</h3><p>如果乔治公爵和赫拉女王整个峰会都待在一起会发生什么事？</p>
<p>如果莎拉王后和亨利王谈话，然后然后和赫拉女王见面，并且她们两位都与乔治公爵对话，会发生什么？</p>
<p>赫拉女王托贾马拉女伯爵调查亨利王、约翰王子和乔治公爵。</p>
<p>也许克劳狄斯王、朱莉公主和大卫王会鼓励亨利王做出新的尝试。</p>
<h3 id="梅花王国的阴谋"><a href="#梅花王国的阴谋" class="headerlink" title="梅花王国的阴谋"></a>梅花王国的阴谋</h3><p>如果整个峰会期间，克劳狄斯王和乔治公爵都被安排在一起，会发生什么事？</p>
<p>如果克劳狄斯王和凯瑟琳见面，然后向大卫王或贾马拉女伯爵抱怨对方，会发生什么？对了，必须有另一个步骤…</p>
<p>如果凯瑟琳王后和乔治公爵整个峰会期间都待在一块会发生什么事？</p>
<h3 id="方片王国的审判"><a href="#方片王国的审判" class="headerlink" title="方片王国的审判"></a>方片王国的审判</h3><p>大卫王想同所罗门王和莎拉王后和平谈判，但是他也许需要向乔治公爵寻求帮助。</p>
<p>如果戴安娜王后无法付清乔治公爵索要的钱款，会发生什么？</p>
<h3 id="年轻的人儿"><a href="#年轻的人儿" class="headerlink" title="年轻的人儿"></a>年轻的人儿</h3><p>如果克劳狄斯王和大卫王全程都被安排在一块会发生什么？</p>
<p>为约翰王子和朱莉公主向富有的贵族寻求帮助。</p>
<p>如果乔治公爵和约翰王子及朱莉公主相处时间相同，会发生什么？</p>
<p>约翰王子似乎有个工作机会。他应该与他的母亲和克劳狄斯王对话。所罗门王应该和乔治公爵谈谈。</p>
<p>黑桃王国的国王和王后以及梅花王国的王后和女伯爵似乎对朱莉公主有兴趣。</p>
<h3 id="外来者"><a href="#外来者" class="headerlink" title="外来者"></a>外来者</h3><p>如果整个峰会期间，莎拉王后和凯瑟琳王后都被安排在一块，会发生什么？</p>
<p>凯瑟琳王后与贾马拉女伯爵一道，需要从大卫王那里拿到花园钥匙，并从乔治公爵那里拿到魔法玫瑰。</p>
<p>赫拉女王想见大卫王、亨利王、约翰王子和凯瑟琳王后。</p>
<h2 id="每天开始时的反应"><a href="#每天开始时的反应" class="headerlink" title="每天开始时的反应"></a>每天开始时的反应</h2><h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><ol>
<li>战争没通过，红心女王会表示满意；否则，红心女王会表示不高兴。</li>
<li>满意值大于等于6，红心女王会满意；没过半但大于等于0，红心女王会表现得中性；否则，会生气。</li>
<li>红心女王会对水果塔丢失而感到生气。</li>
</ol>
<h3 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h3><ol>
<li>魔法通过，红心女王满意。</li>
<li>满意值大于等于12，红心女王会满意；大于等于0，中性；反之，生气。</li>
<li>继续生气水果塔。</li>
</ol>
<h3 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h3><ol>
<li>贸易没通过，会满意。</li>
<li>满意值大于等于18，会高兴；大于等于0，中性；反之，生气。</li>
<li>继续生气水果塔。</li>
</ol>
<h2 id="每天活动安排的影响"><a href="#每天活动安排的影响" class="headerlink" title="每天活动安排的影响"></a>每天活动安排的影响</h2><p>满意值（satisfaction）初始为0</p>
<p>投票值初始：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>战争</th>
<th>魔法</th>
<th>贸易</th>
<th>边境</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>接下来每天的表格种：</p>
<ol>
<li><p>表格中空白表示这个组合只有对话，没有满意值和投票值的变化</p>
</li>
<li><p>表格中-表示该值不存在或者有对称组合，比如<code>（所罗门，莎拉）</code>和<code>（莎拉，所罗门）</code>是同一个组合，前者写了影响，后者就是-了</p>
</li>
</ol>
<p>除了这些表格以外，每个人对应的活动项目，如果是喜欢，则满意值+1，厌恶，则满意值-1，无感则无变化</p>
<p>任意两个角色组合的初始值为1，每安排到一起一次，该组合的值+1，第四次不会增加（例如，KCQC表示克劳狄斯和凯瑟琳的组合，在结局判定时，KCQC=1表示没有安排在一起过，KCQC=2表示安排了一次，KCQC=3表示两次，KCQC=4表示三次，KCQC=5表示四次；此外有一些组合，代码里没有在第四次的时候+1，也就是说=4表示3次或4次，不过对于最后判定没有影响。）</p>
<h3 id="人物组合的影响"><a href="#人物组合的影响" class="headerlink" title="人物组合的影响"></a>人物组合的影响</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>-</td>
<td>组合第1次时，所罗门的秘密曝光</td>
<td>组合第1次时，所罗门和戴安娜的秘密曝光</td>
<td></td>
<td></td>
<td>组合第1次时，如果贾马拉和莎拉、大卫、戴安娜都组合过1次，贾马拉的秘密曝光</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>组合第1次时，莎拉的秘密曝光，</td>
<td></td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
<td>组合第2次时，凯瑟琳的秘密曝光</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>组合第1次时，约翰和朱莉的秘密曝光</td>
<td>组合第4次时，亨利的秘密曝光</td>
<td></td>
<td>组合第1次时，约翰和朱莉的秘密曝光</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>组合第4次时，满意值减10</td>
<td>组合第4次时，<code>talkaboutclubs == 1 and kingconvinced == 0</code>不成立时，乔治的秘密曝光</td>
<td>组合第1次时，克劳狄斯的秘密曝光；组合第4次时，大卫的秘密曝光</td>
<td></td>
<td>组合第3次时，乔治的秘密曝光</td>
<td>组合第4次时，亨利的秘密曝光</td>
<td>组合第4次时，满意值减10</td>
<td>组合第1次且魔法没通过时，乔治的秘密曝光</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>组合第1次，凯瑟琳的秘密曝光</td>
<td></td>
<td></td>
<td></td>
<td>组合第4次时，凯瑟琳的秘密曝光</td>
<td></td>
<td></td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td>组合第2次时，贾马拉和戴安娜的秘密都曝光</td>
<td></td>
<td></td>
<td></td>
<td>组合第2次时，乔治的秘密曝光</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td>组合第4次时，如果<code>dianahaspayment!=0</code>，亨利的秘密曝光</td>
<td></td>
<td>组合第1次时，戴安娜的秘密曝光</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>组合第4次时，约翰和朱莉的秘密曝光</td>
<td></td>
<td>组合第1次时，约翰和朱莉的秘密曝光</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第一天（战争）"><a href="#第一天（战争）" class="headerlink" title="第一天（战争）"></a>第一天（战争）</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>-</td>
<td>KS投票值 1 满意值-1</td>
<td>满意值+1</td>
<td>满意值-1</td>
<td>满意值+1</td>
<td>JC投票值 0</td>
<td>KS投票值 1 KD投票值 1 满意值-1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>-</td>
<td>-</td>
<td>JS投票值 1 满意值-1</td>
<td>满意值+1</td>
<td>QC投票值 1 满意值-1</td>
<td>JC投票值 0 满意值-1</td>
<td>满意值-1</td>
<td>空</td>
<td>JD投票值 1 满意值+1</td>
<td>KH投票值 1 满意值+1</td>
<td>满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JS投票值 1 满意值+1</td>
<td>QC投票值 1 满意值+1</td>
<td>JC投票值 1</td>
<td>满意值+1</td>
<td>QD投票值 1 满意值+1</td>
<td>JD投票值 1 满意值+1</td>
<td>KH投票值 1 满意值+1</td>
<td>QH投票值 1 满意值+1</td>
<td>JS投票值 1</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>QC投票值 1; 满意值-1</td>
<td>JC投票值 1 满意值+1</td>
<td>KD投票值 1</td>
<td>QD投票值 1</td>
<td>JD投票值 1</td>
<td>KH投票值 1 满意值-1</td>
<td>满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 0 满意值+1</td>
<td>空</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>空</td>
<td>QC投票值 1 满意值+1</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 1 满意值-1</td>
<td>JC投票值 0</td>
<td>JC投票值 0</td>
<td>JC投票值 0</td>
<td>JC投票值 0</td>
<td>JC投票值 1 满意值-1</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>空</td>
<td>空</td>
<td>满意值+1</td>
<td>JH投票值 0</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>QD投票值 1</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>JD投票值 1</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>满意值+1</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JH投票值 0 满意值+1</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第二天（魔法）"><a href="#第二天（魔法）" class="headerlink" title="第二天（魔法）"></a>第二天（魔法）</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>-</td>
<td>满意值-1</td>
<td>JS投票值 0 满意值+1</td>
<td>满意值-1</td>
<td>满意值+1</td>
<td>JC投票值 1</td>
<td>满意值-1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>-</td>
<td>-</td>
<td>JS投票值 0 满意值-1</td>
<td>空</td>
<td>满意值-1</td>
<td>JC投票值 0 满意值-1</td>
<td>满意值-1</td>
<td>空</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值-1</td>
<td>JH投票值 1</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>QC投票值 0 满意值+1</td>
<td>JC投票值 0</td>
<td>私奔flag+1 满意值+1</td>
<td>QD投票值 0 满意值+1</td>
<td>JD投票值 0 满意值+1</td>
<td>JS投票值 0 满意值+1</td>
<td>QH投票值 0 满意值+1</td>
<td></td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>QC投票值 0 满意值-1</td>
<td>JC投票值 0 满意值+1</td>
<td>空</td>
<td>QD投票值 0</td>
<td>JD投票值 0</td>
<td>满意值-1</td>
<td>QH投票值 0 满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 1 满意值+1</td>
<td>QC投票值 0</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>空</td>
<td>JH投票值 1 满意值+1</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 1 满意值-1</td>
<td>JC投票值 0 JD投票值 0（这里看对话应该是JC投票值 1 QD投票值 0，怀疑是写错了）</td>
<td>JC投票值 0 JD投票值 0</td>
<td>JC投票值 1</td>
<td>JC投票值 1</td>
<td>JC投票值 0</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>QD投票值 0</td>
<td>JD投票值 0</td>
<td>KH投票值 0</td>
<td>QH投票值 0</td>
<td>空</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>QD投票值 0</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>QH投票值 0 JD投票值 0 满意值+1</td>
<td>JD投票值 0</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>满意值+1</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JH投票值 0 QH投票值 0 满意值+1</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第三天（贸易）"><a href="#第三天（贸易）" class="headerlink" title="第三天（贸易）"></a>第三天（贸易）</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>-</td>
<td>满意值-1</td>
<td>JS投票值 0 满意值+1</td>
<td>KC投票值 0 满意值-1</td>
<td>满意值+1</td>
<td>JC投票值 0</td>
<td>KD投票值 0 满意值-1</td>
<td>满意值+1</td>
<td>JD投票值 0 满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>-</td>
<td>-</td>
<td>JS投票值 0 满意值-1</td>
<td>KC投票值 0</td>
<td>满意值-1</td>
<td>JC投票值 1 满意值-1</td>
<td>KD投票值 0 满意值-1</td>
<td>空</td>
<td>JD投票值 0 满意值+1</td>
<td>满意值+1</td>
<td>满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JS投票值 1 满意值+1</td>
<td>JS投票值 0 满意值+1</td>
<td>JS投票值 1</td>
<td>私奔flag+1 满意值+1 JS投票值 1</td>
<td>JS投票值 1 满意值+1</td>
<td>JS投票值 1 满意值+1</td>
<td>JS投票值 0 满意值+1</td>
<td>JS投票值 0 满意值+1</td>
<td>JS投票值 1</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>QC投票值 1 满意值-1</td>
<td>满意值+1</td>
<td>空</td>
<td>空</td>
<td>空</td>
<td>KC投票值 0 满意值-1</td>
<td>KC投票值 0 满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>QC投票值 1 满意值+1</td>
<td>空</td>
<td>QC投票值 1 满意值+1</td>
<td>JD投票值 0 满意值+1</td>
<td>空</td>
<td>空</td>
<td>JH投票值 0 满意值+1</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值-1</td>
<td>JC投票值 1</td>
<td>JC投票值 1</td>
<td>KH投票值 1</td>
<td>JC投票值 1</td>
<td>JC投票值 1 满意值-1</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>空</td>
<td>KH投票值 1</td>
<td>KD投票值 0</td>
<td></td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>QD投票值 0 满意值+1</td>
<td>空</td>
<td>JH投票值 1</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JD投票值 0 满意值+1</td>
<td>JD投票值 0  满意值+1</td>
<td>JD投票值 1</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>KH投票值 1 满意值+1</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第四天（边境）"><a href="#第四天（边境）" class="headerlink" title="第四天（边境）"></a>第四天（边境）</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>黑桃国王所罗门</th>
<th>黑桃王后莎拉</th>
<th>黑桃王子约翰</th>
<th>梅花国王克劳狄斯</th>
<th>梅花王后凯瑟琳</th>
<th>梅花女伯爵贾马拉</th>
<th>方片国王大卫</th>
<th>方片王后戴安娜</th>
<th>方片公主朱莉</th>
<th>红心国王亨利</th>
<th>红心女王赫拉</th>
<th>红心公爵乔治</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑桃国王所罗门</td>
<td>-</td>
<td>KS投票值 0 满意值-1</td>
<td>KS投票值 0 JS投票值 0 满意值+1</td>
<td>KS投票值 0 满意值-1</td>
<td>满意值+1</td>
<td>JC投票值 0 KS投票值 0 满意值-1</td>
<td>KS投票值 0 KD投票值 0 满意值-1</td>
<td>KS投票值 0 QD投票值 0  满意值+1</td>
<td>满意值+1</td>
<td>KH投票值 0 KS投票值 0 满意值+1</td>
<td>满意值+1</td>
<td>KS投票值 0</td>
</tr>
<tr>
<td>黑桃王后莎拉</td>
<td>-</td>
<td>-</td>
<td>JS投票值 0 满意值-1</td>
<td>满意值+1</td>
<td>满意值-1</td>
<td>JC投票值 1 满意值-1</td>
<td>KD投票值 0 满意值-1</td>
<td>QD投票值 0</td>
<td>满意值+1</td>
<td>KH投票值 0 满意值+1</td>
<td>满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>黑桃王子约翰</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JS投票值 0 满意值+1</td>
<td>私奔flag+1 满意值+1</td>
<td>JS投票值 0</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>JS投票值 0</td>
</tr>
<tr>
<td>梅花国王克劳狄斯</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值-1</td>
<td>满意值+1</td>
<td>KD投票值 0</td>
<td>QD投票值 0</td>
<td>空</td>
<td>KH投票值 0 满意值-1</td>
<td>满意值-1</td>
<td>满意值+1</td>
</tr>
<tr>
<td>梅花王后凯瑟琳</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 1 满意值+1</td>
<td>空</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>空</td>
<td>满意值+1</td>
</tr>
<tr>
<td>梅花女伯爵贾马拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>JC投票值 0 满意值-1</td>
<td>QD投票值 0</td>
<td>JC投票值 1</td>
<td>JC投票值 0 KH投票值 0</td>
<td>JC投票值 1</td>
<td>满意值-1</td>
</tr>
<tr>
<td>方片国王大卫</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>空</td>
<td>空</td>
<td>满意值+1</td>
<td>空</td>
</tr>
<tr>
<td>方片王后戴安娜</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
<td>QD投票值 0</td>
</tr>
<tr>
<td>方片公主朱莉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
<td>满意值+1</td>
<td>空</td>
</tr>
<tr>
<td>红心国王亨利</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>空</td>
<td>KH投票值 0 满意值+1</td>
</tr>
<tr>
<td>红心女王赫拉</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>满意值+1</td>
</tr>
<tr>
<td>红心公爵乔治</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h2 id="每晚投票"><a href="#每晚投票" class="headerlink" title="每晚投票"></a>每晚投票</h2><p>如果大于等于7票，就通过；小于等于5票，就不通过；恰好是6票，柴郡猫投票。</p>
<p>柴郡猫投票的结果：战争不通过；魔法通过；贸易自由；开放边境通过。</p>
<h2 id="最终结局"><a href="#最终结局" class="headerlink" title="最终结局"></a>最终结局</h2><p>”皇室成员聚集在一起，这是他们最后一个可以互相交流的晚上了。“</p>
<p>以下结局在条件不冲突的情况下可同时达成。</p>
<h3 id="炸脖龙结局"><a href="#炸脖龙结局" class="headerlink" title="炸脖龙结局"></a>炸脖龙结局</h3><p>结局1：克劳狄斯与所罗门、莎拉、戴安娜、赫拉各组合过一次</p>
<p>分支1：约翰和大卫组合过两次及以上</p>
<p>约翰王子杀了龙，然后大卫王提议约翰继位当梅花的国王。</p>
<p>分支2：不满足分支1的条件</p>
<p>大卫王杀了龙，但是龙死前划破他的衣服，他自己被龙诅咒的事实也被发现了，于是只能放弃王位，朱莉继位。</p>
<p>结局2：克劳狄斯与大卫组合过两次、与朱莉组合过两次</p>
<p>克劳狄斯变成龙，抢走朱莉，约翰王子和他父亲一起去营救。</p>
<h3 id="贾马拉结局"><a href="#贾马拉结局" class="headerlink" title="贾马拉结局"></a>贾马拉结局</h3><p>结局1：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成）炸脖龙结局1的分支2没有达成（朱莉没继位）</p>
<p>要求：贾马拉与戴安娜、大卫各组合过1次，与莎拉组合过2次</p>
<p>戴安娜坦白她当初参与刺杀贾马拉的事情，贾马拉在其的帮助下找到了另外两个当初刺杀她的人（大卫和莎拉），并把他们用魔法锁起来了。</p>
<p>结局2：贾马拉与所罗门第一次组合时，已经与戴安娜、大卫、莎拉各组合过1次</p>
<p>要求：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 炸脖龙结局1的分支2没有达成（朱莉没继位）</p>
<p>贾马拉在所罗门的帮助下找到当初刺杀自己的三个人，并把他们用魔法锁起来了。同时为了感谢和补偿所罗门，他俩结婚了。</p>
<h3 id="黑桃结局"><a href="#黑桃结局" class="headerlink" title="黑桃结局"></a>黑桃结局</h3><p>结局1：所罗门逃离了莎拉的控制</p>
<p>炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算） 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王）</p>
<p>要求：这个条件实在太复杂了我不想思考了…</p>
<p>结局2：所罗门和莎拉相互洗脑（他发现了她对蘑菇上瘾）</p>
<p>要求：所罗门和莎拉第2次组合时，所罗门和赫拉已经组合2次了。</p>
<h3 id="约翰和朱莉的结局"><a href="#约翰和朱莉的结局" class="headerlink" title="约翰和朱莉的结局"></a>约翰和朱莉的结局</h3><p>结局1：朱莉与克劳迪斯订婚，凯瑟琳离婚了</p>
<p>要求：克劳狄斯与大卫组合4次，炸脖龙结局1的分支2没有达成（朱莉没继位） 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王） 且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算）</p>
<p>结局2：俩人私奔</p>
<p>要求：这个条件很多种组合懒得写了（是要约翰和朱莉凑够至少4份钱，给钱的一共有9种情况） 或 炸脖龙结局1的分支2达成（朱莉继位） 或 炸脖龙结局1的分支1达成（约翰继位），且 炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 克劳狄斯与大卫组合少于4次</p>
<p>该结局三个分支：</p>
<ol>
<li>炸脖龙结局1的分支2达成（朱莉继位）</li>
<li>炸脖龙结局1的分支1达成（约翰继位）</li>
<li>不符合前两条</li>
</ol>
<p>结局3：俩人相爱</p>
<p>要求：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成）, 炸脖龙结局1的分支1没有达成（约翰没继位）,炸脖龙结局1的分支2没有达成（朱莉没继位）, 约翰与乔治组合2次， 且 朱莉与乔治组合2次， 且 这个条件很多种组合懒得写了（是要约翰和朱莉没凑够4份钱，给钱的一共有9种情况）</p>
<h3 id="红心结局"><a href="#红心结局" class="headerlink" title="红心结局"></a>红心结局</h3><p>结局1：亨利被谋杀， 赫拉和乔治私奔</p>
<p>要求：赫拉与乔治组合4次</p>
<p>结局2：赫拉和乔治的私情曝光，触发女王死亡结局（见下文）</p>
<p>要求：<code>affairrevealed == 2</code> 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王）且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算）</p>
<p>结局3：亨利偷水果塔的事情曝光</p>
<p>要求：<code>investigatedJCJS == 1 and investigatedJCKH == 1 and investigatedJCJH == 1</code></p>
<h3 id="其他结局"><a href="#其他结局" class="headerlink" title="其他结局"></a>其他结局</h3><p>结局1：乔治和克劳狄斯政变，触发女王死亡结局（见下文）</p>
<p>要求：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 炸脖龙结局1的分支2没有达成（朱莉没继位） 且 炸脖龙结局1的分支1没有达成（约翰没继位）, 且 克劳狄斯与乔治组合4次， 且 魔法没通过</p>
<p>结局2：戴安娜被赶走</p>
<p>要求：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 炸脖龙结局1的分支2没有达成（朱莉没继位） 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王） 且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算）, 且<code>dianablackmail != 0</code></p>
<p>结局3：约翰去梅花王国居住</p>
<p>要求：克劳狄斯没有与所罗门、莎拉、戴安娜、赫拉各组合过一次 且 炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且 克劳狄斯与大卫组合不到4次，且 这个条件很多种组合懒得写了（是要约翰和朱莉没凑够4份钱，给钱的一共有9种情况）,且 所罗门与乔治组合至少1次， 且莎拉与约翰组合至少1次， 且克劳狄斯与约翰组合至少1次</p>
<p>结局4：朱莉被训练为先知</p>
<p>要求：克劳狄斯没有与所罗门、莎拉、戴安娜、赫拉各组合过一次 且 炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） 且克劳狄斯与大卫组合不到4次 且 这个条件很多种组合懒得写了（是要约翰和朱莉没凑够4份钱，给钱的一共有9种情况） 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王） 且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算）, 且 朱莉与凯瑟琳、贾马拉、所罗门、莎拉各组合1次</p>
<p>结局5：黑桃和方片休战</p>
<p>要求：炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成）且 炸脖龙结局1的分支2没有达成（朱莉没继位） 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王） 且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算，且 大卫与所罗门、莎拉、乔治 都至少组合1次</p>
<p>结局6：克劳狄斯和凯瑟琳婚姻咨询</p>
<p>要求：<code>johnarmed == 0</code> 且 炸脖龙结局中的结局2没有达成（”克劳狄斯与大卫组合过两次、与朱莉组合过两次“没有达成） and 炸脖龙结局1的分支2没有达成（朱莉没继位）且克劳狄斯与大卫组合不到4次, <code>kingconvinced == 1 and queenconvinced == 1</code></p>
<p>结局7：红心王国开公共图书馆</p>
<p>要求：赫拉与乔治没有组合4次，且克劳狄斯与亨利组合至少1次，且大卫与亨利组合至少1次，且约翰与亨利组合至少1次，且 <code>investigatedJCKH == 0</code></p>
<h3 id="外来者结局"><a href="#外来者结局" class="headerlink" title="外来者结局"></a>外来者结局</h3><p>结局1：凯瑟琳和乔治一起跑了</p>
<p>要求：凯瑟琳与乔治组合4次</p>
<p>结局2：凯瑟琳和爱丽丝出现，赫拉心脏病发作，触发女王死亡结局（见下文）</p>
<p>要求：凯瑟琳和莎拉组合4次 且 贾马拉结局的结局1没达成（贾马拉没回去当黑桃女王）且 贾马拉与所罗门第一次组合时没有与戴安娜、大卫、莎拉各组合过1次（贾马拉没有与所罗门组合过也算）</p>
<p>结局3：凯瑟琳和爱丽丝跑了</p>
<p>要求：<code>therapy == 0</code>，<code>solomonthief == 2 and magicrose == 1</code></p>
<p>结局4：赫拉发现了爱丽丝，爱丽丝被杀了</p>
<p>要求：<code>solomonthief != 2 and magicrose != 1</code>,大卫与赫拉组合1次 且 亨利与赫拉组合1次 且 约翰与赫拉组合1次 且 凯瑟琳与赫拉组合1次</p>
<h3 id="兔子结局"><a href="#兔子结局" class="headerlink" title="兔子结局"></a>兔子结局</h3><p>满意值&gt;=48:</p>
<p>分支1：战争和自由贸易没通过，魔法和开放边境通过了</p>
<p>分支2：战争和自由贸易通过了，魔法和开放边境没通过</p>
<p>分支3：不满足前面两个</p>
<p>满意值&gt;=-19，且&lt;=47：</p>
<p>分支1：战争和自由贸易没通过，魔法和开放边境通过了</p>
<p>分支2：战争和自由贸易通过了，魔法和开放边境没通过</p>
<p>分支3：不满足前面两个</p>
<p>满意值&lt;=-20</p>
<p>分支1：战争和自由贸易没通过，魔法和开放边境通过了</p>
<p>分支2：不满足上面那个</p>
<h3 id="女王死亡结局"><a href="#女王死亡结局" class="headerlink" title="女王死亡结局"></a>女王死亡结局</h3><p>根据满意值不同，兔子可能会失业。</p>
<h3 id="世界结局"><a href="#世界结局" class="headerlink" title="世界结局"></a>世界结局</h3><p><code>war == 0 and magic == 0 and trade == 0 and borders == 0</code></p>
<p>“四个议题都被否定了，因此，那年仙境世界什么都没发生。”</p>
<p>“没有战争，人民生活还算太平。但是禁止魔法，贸易不自由，边境封锁，导致许多物资匮乏。”</p>
<p>“这是生活艰苦的一年。”</p>
<p><code>war == 1 and magic == 0 and trade == 0 and borders == 0</code></p>
<p>“这一年，只有战争通过了。对于仙境世界较为弱小的国家来说，生活艰难。”</p>
<p>“你必须大量学习，才能找到在这个全新的世界里生存的办法。”</p>
<p>“未来的走向应该会很有意思…”</p>
<p><code>war == 0 and magic == 1 and trade == 0 and borders == 0</code></p>
<p>“这一年，只有魔法通过了，仙境世界到处都是神奇的动物和植物。”</p>
<p>“这会是奇妙的一年…”</p>
<p><code>war == 0 and magic == 0 and trade == 1 and borders == 0</code></p>
<p>“这一年，只有自由贸易通过了，仙境世界的市场情况像坐过山车紧张刺激。”</p>
<p>“幸运的是，这一年你似乎赚得盆钵体满。”</p>
<p><code>war == 0 and magic == 0 and trade == 0 and borders == 1</code></p>
<p>“这一年，只有边境允许开放，除了四处旅行，没有什么可以打发时间的事可以做。”</p>
<p>“趁着边境开放，你和许多仙境世界的游客一样，四处旅行，欣赏美景。”</p>
<p>“这会是马不停蹄的一年！”</p>
<p><code>war == 1 and magic == 1 and trade == 0 and borders == 0</code></p>
<p>“由于通过了战争和魔法，黑桃王国逐渐站上巅峰地位。”</p>
<p>“你和许多民众都移民到了这处于胜利地位的国家。”</p>
<p>“明年还会不会举行峰会呢？没人说得准。”</p>
<p><code>war == 1 and magic == 0 and trade == 1 and borders == 0</code></p>
<p>“由于通过了战争和自由贸易，梅花王国逐渐站上巅峰地位。”</p>
<p>“红心王国被占领后，你成了胜利国接纳的难民。”</p>
<p>“如果其他国家都被征服了，也许就不会再举办任何峰会了…”</p>
<p><code>war == 1 and magic == 0 and trade == 0 and borders == 1</code></p>
<p>“随着战争和边境的开放，生活发生了翻天覆地的变化。”</p>
<p>“你不得不适应暗无天日的生活，与一群衣衫褴褛的宫殿侍卫和仆人待在一起。”</p>
<p>“明年还有可能再次召开峰会吗？”</p>
<p><code>war == 0 and magic == 1 and trade == 1 and borders == 0</code></p>
<p>“随着魔法和自由贸易的开放，蘑菇交易欣欣向荣。”</p>
<p>“有些蘑菇能让你变大，有些蘑菇能让你变小，还有一些能够增强魔法，似乎每个人都在吃蘑菇。”</p>
<p>“明年还会有人理智犹存，担起组织峰会的大任吗？”</p>
<p><code>war == 0 and magic == 1 and trade == 0 and borders == 1</code></p>
<p>“随着魔法和边界的开放，红心王国的生活顺风顺水。”</p>
<p>“每个人都对你很满意，你也成了茶会必不可少的点心师。”</p>
<p>“希望明年你还能把事情安排得这么好。”</p>
<p><code>war == 0 and magic == 0 and trade == 1 and borders == 1</code></p>
<p>“随着自由贸易和边境的开放，方片王国正在崛起。”</p>
<p>“由于你出色的组织能力，方片王国把你挖走了。”</p>
<p>“也许明年的峰会可以在这里的寒冬宫殿举行。”</p>
<p><code>war == 1 and magic == 1 and trade == 1 and borders == 0</code></p>
<p>“除了边境，其他议题都通过了。四个国家都对国家边境地区格外警戒。”</p>
<p>“对于仙境世界的所有人来说，这是个孤立贫穷的时代。围墙四起，大陆被割据成四个部分。”</p>
<p>“明年，国家之间是否还会有足够的信任，来举行峰会？”</p>
<p><code>war == 1 and magic == 1 and trade == 0 and borders == 1</code></p>
<p>“除了自由贸易，其他议题都通过了。王国陷入一片混乱。”</p>
<p>“没有一处安全之处能够落脚！”</p>
<p>“今年你能不能生存下来都是个问题。”</p>
<p><code>war == 1 and magic == 0 and trade == 1 and borders == 1</code></p>
<p>“除了魔法，其他议题都通过了，日子似乎少了点什么…”</p>
<p>“这一整年，你都躲在地洞里。”</p>
<p>“明年还会有峰会吗？峰会是什么？沟通又是什么？蛤？…”</p>
<p><code>war == 0 and magic == 1 and trade == 1 and borders == 1</code></p>
<p>“除了战争，其他议题都通过了，仙境世界的人民大多誉你为英雄。”</p>
<p>“你成为最知名的人物，久负盛誉，礼物纷至沓来。”</p>
<p>“希望将来的峰会也能进行得像今年这么顺利。”</p>
<p><code>war == 1 and magic == 1 and trade == 1 and borders == 1</code></p>
<p>“所有议题都通过了，仙境世界顿时变得忙碌了起来。”</p>
<p>“由于你的组织能力，你被推上一个举足轻重的职位——红心王国国防部长。”</p>
<p>“虽然已经能看到今年会有多艰难，但是也会很有意思。”</p>
]]></content>
      <categories>
        <category>Renpy</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>仙境之夜</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-8</title>
    <url>/2021/01/06/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-8/</url>
    <content><![CDATA[<h1 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h1><ol>
<li><p><code>flag</code>的作用是对人物或者事件进行标记，可以用在<code>if</code>或<code>trigger</code>或其他类似的地方，而其中人物对应的<code>flag</code>就是<code>character_flag</code>。</p>
</li>
<li><p>我们使用<code>add_character_flag</code>来添加一个人物标记，用<code>remove_character_flag</code>移除一个人物标记。</p>
</li>
<li><p>接下来看一个例子：有两个事件，其中事件1001有2个选项，选项a和b分别会给人物添加两个不同的<code>flag</code>，2个选项都会触发事件1002；而事件1002则有1个选项，根据事件1中的两个<code>flag</code>，该选项会显示不同的内容。那么代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace &#x3D; adventure</span><br><span class="line">adventure.1001 &#x3D; &#123;</span><br><span class="line">    type &#x3D; character_event</span><br><span class="line">	title &#x3D; adventure.1001.t1</span><br><span class="line">	desc &#x3D; adventure.1001.desc</span><br><span class="line">	theme &#x3D; adventure</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; adventure.1001.option.a</span><br><span class="line">		add_character_flag &#x3D; flag_adventure_random_1</span><br><span class="line">		trigger_event &#x3D; adventure.1002</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; adventure.1001.option.b</span><br><span class="line">		add_character_flag &#x3D; flag_adventure_random_2</span><br><span class="line">		trigger_event &#x3D; adventure.1002</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">adventure.1002 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; adventure.1002.t1</span><br><span class="line">	desc &#x3D; adventure.1002.desc1</span><br><span class="line">	theme &#x3D; adventure</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; &#123;</span><br><span class="line">			trigger &#x3D; &#123;has_character_flag &#x3D;flag_adventure_random_1&#125;</span><br><span class="line">			text &#x3D; adventure.1002.option.a</span><br><span class="line">		&#125;</span><br><span class="line">		name &#x3D; &#123;</span><br><span class="line">			trigger &#x3D; &#123;has_character_flag &#x3D; flag_adventure_random_2&#125;</span><br><span class="line">			text &#x3D; adventure.1002.option.b</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>flag</code>的基础用法大致就是这样，除了<code>character_flag</code>也还有其他类型的<code>flag</code>。</p>
</li>
</ol>
<h1 id="modifier"><a href="#modifier" class="headerlink" title="modifier"></a>modifier</h1><ol>
<li><p><code>modifier</code>可以理解为对数值的修正，和特质有点像，但结构和功能简单一些。</p>
</li>
<li><p><code>modifier</code>的基础结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modifer_key &#x3D; &#123;</span><br><span class="line">	icon &#x3D; icon_name	</span><br><span class="line">	# Effects, such as</span><br><span class="line">	# tax_mult &#x3D; 0.25</span><br><span class="line">	# county_opinion_add &#x3D; -30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>icon</code> 的文件名如果以<code>positive</code>或<code>negative</code>结尾，则该<code>modifier</code>的颜色会有相应的变化（指游戏里那行字的颜色），例如<code>diplomacy_positive</code>和<code>diplomacy_negative</code>。</p>
</li>
<li><p>在写好一个<code>modifier</code>之后，我们可以使用<code>add_character_modifier = XXX</code>来给角色添加<code>modifier</code>，使用<code>has_character_modifier = XXX</code>来判断角色是否有该<code>modifier</code>，使用<code>remove_character_character_modifier = XXX</code>来移除一个角色的某个<code>modifier</code>。在添加的时候，可以加时间字段来限制该<code>modifier</code>的持续时间，前面部分中的<code>flag</code>也是同样的用法。</p>
</li>
<li><p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># modifier file</span><br><span class="line">adventure_diplomacy_add_modifier &#x3D; &#123;</span><br><span class="line">	icon &#x3D; diplomacy_positive</span><br><span class="line">	diplomacy &#x3D; 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># event file</span><br><span class="line">trigger &#x3D; &#123;</span><br><span class="line">	has_character_flag &#x3D; flag_adventure_diplomacy</span><br><span class="line">	NOT &#x3D; &#123; has_character_modifier &#x3D; adventure_diplomacy_add_modifier &#125;</span><br><span class="line">&#125;</span><br><span class="line">send_interface_message &#x3D; &#123;</span><br><span class="line">	type &#x3D; adventure_success_type</span><br><span class="line">	add_character_modifier &#x3D; &#123;</span><br><span class="line">		modifier &#x3D; adventure_diplomacy_add_modifier</span><br><span class="line">		years &#x3D; 20</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>modifier</code>的作用是让角色外交+2，在事件中，判断该角色有相应的<code>flag</code>且没有该<code>modifier</code>时，就给角色增加该<code>modifier</code>，且持续20年。</p>
</li>
<li><p>需要注意的是，我们无法在mod中直接修改角色的健康，只能通过<code>trait</code>或者<code>modifier</code>这样的方式来修改；类似地，角色的五个属性值也不能直接通过<code>diplomacy = 1</code>或者<code>add_diplomacy = 1</code>这样的方式来改，而是要通过<code>trait</code>或<code>modifier</code>修正（实际上，一定要改角色的属性值时，可以使用<code>add_diplomacy_skill = 1</code>这样的代码，但是一般不建议这么做，因为这样改完全看不出来数值是因为什么事件发生了变化，也不利于后续取消这个改变）。</p>
</li>
</ol>
<h1 id="customizable-localization"><a href="#customizable-localization" class="headerlink" title="customizable_localization"></a>customizable_localization</h1><ol>
<li><p>起因是想了解如何随机显示出现的文字，例如某事件的标题随机显示。试图使用<code>random_list</code>等方式都没用，在论坛提问以后大佬告诉我可以用<code>customizable_localization</code>来实现。学习了一下大致写法如下。</p>
</li>
<li><p>首先，文件夹路径是<code>Crusader Kings III\game\common\customizable_localization</code>，该文件夹中有很多已经写好的文件。</p>
</li>
<li><p>其次，相关的本地化文件夹路径是<code>Crusader Kings III\game\localization\simp_chinese\custom_localization</code>。</p>
</li>
<li><p>一个普通的<code>customizable_localization</code>文件格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YourCustomLoc &#x3D; &#123;</span><br><span class="line">    type &#x3D; character </span><br><span class="line">    random_valid &#x3D; yes</span><br><span class="line">    text &#x3D; &#123;</span><br><span class="line">        trigger &#x3D; &#123;  </span><br><span class="line">            your_triggers &#x3D; yes</span><br><span class="line">        &#125;</span><br><span class="line">        localization_key &#x3D; title_1</span><br><span class="line">    &#125;</span><br><span class="line">    text &#x3D; &#123;</span><br><span class="line">        trigger &#x3D; &#123;  </span><br><span class="line">            your_triggers &#x3D; no</span><br><span class="line">        &#125;</span><br><span class="line">        localization_key &#x3D; title_2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>type</code>可以有其他选项，具体选项在<code>CUSTOM_LOC_README.txt</code>文件中列出了。</p>
<p><code>random_valid</code>表示随机选，如果去掉这行就不随机了，而是按顺序第一个满足条件的文本。</p>
<p>接下来的<code>text</code>块就是待选的随机文本，其中<code>trigger</code>是该文本的触发条件，如果没有条件则可以不写<code>trigger</code>块。<code>localization_key</code>所对应的文字是在前面第3条提到的路径中。</p>
</li>
<li><p>在使用该随机文本的时候，例如我们要让某事件的标题随机出现，则把该标题所对应的本地化字符串写成<code>&quot;[ROOT.Char.Custom(&#39;YourCustomLoc&#39;)]&quot;</code></p>
</li>
<li><p>具体来看一个例子：</p>
<ol>
<li><p><code>common\customizable_localization\00_test_random_loc.txt</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YourCustomLoc &#x3D; &#123;</span><br><span class="line">    type &#x3D; character</span><br><span class="line">    random_valid &#x3D; yes</span><br><span class="line">    text &#x3D; &#123;</span><br><span class="line">        localization_key &#x3D; title_1</span><br><span class="line">    &#125;</span><br><span class="line">    text &#x3D; &#123;</span><br><span class="line">        localization_key &#x3D; title_2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>localization\simp_chinese\custom_localization\test_random_loc_l_simp_chinese.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> title_1:0 &quot;大胆&quot;</span><br><span class="line"> title_2:0 &quot;善心&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>events\adventure_events\adventure_events.txt</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adventure.1001 &#x3D; &#123;</span><br><span class="line">    type &#x3D; character_event</span><br><span class="line">	title &#x3D; adventure.1001.t1</span><br><span class="line">	desc &#x3D; adventure.1001.desc</span><br><span class="line">	theme &#x3D; adventure</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; adventure.1001.option.a</span><br><span class="line">		add_character_flag &#x3D; flag_adventure_random_1</span><br><span class="line">		trigger_event &#x3D; adventure.1002</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; adventure.1001.option.b</span><br><span class="line">		add_character_flag &#x3D; flag_adventure_random_2</span><br><span class="line">		trigger_event &#x3D; adventure.1002</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; adventure.1001.option.c</span><br><span class="line">		trigger_event &#x3D; adventure.1003</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>localization\simp_chinese\event_localization\adventure\adventure_l_simp_chinese.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> adventure.1001.t1:0 &quot;[ROOT.Char.Custom(&#39;YourCustomLoc&#39;)]&quot;</span><br><span class="line"> adventure.1001.desc:0 &quot;氪金可以获得更好的体验&quot;</span><br><span class="line"> adventure.1001.option.a:0 &quot;我相信上天会为我选择最合适的道路！&quot;</span><br><span class="line"> adventure.1001.option.b:0 &quot;我相信我的能力，命运掌握在我自己手中！&quot;</span><br><span class="line"> adventure.1001.option.c:0 &quot;人的能力是有极限的，我要充钱变强！&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>写好这些文件以后，游戏中通过<code>event adventure.1001</code>触发该事件，可以看到标题会随机显示为<code>大胆</code>或者<code>善心</code>。</p>
</li>
<li><p>类似地，<code>desc</code>部分也可以这样写。此外，除了<code>[ROOT.Char.Custom(&#39;YourCustomLoc&#39;)]</code>这样的写法，也还有其他类型的写法，具体可以参考游戏本体文件中的内容。</p>
</li>
</ol>
</li>
</ol>
<h1 id="message"><a href="#message" class="headerlink" title="message"></a>message</h1><ol>
<li><p><code>message</code>是指游戏右下角弹出的那个信息提示，或者屏幕上半部分的中间弹出的那个横幅。</p>
</li>
<li><p>代码基础结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_message &#x3D; &#123;</span><br><span class="line">	display &#x3D; (feed|toast)		# where to display the message; default: feed</span><br><span class="line">	text &#x3D; some_loc_key			# string to be used in the message; default: same as message key (e.g &quot;my_message&quot; in this example)</span><br><span class="line">	desc &#x3D; some_loc_key			# string that gives more info about what happened</span><br><span class="line">	tooltip &#x3D; some_loc_key		# string to be used for tooltip of type(optional); default: no tooltip</span><br><span class="line">	soundeffect &#x3D; sound_name	# sound effect played when showing the message (optional); default: no sound</span><br><span class="line">	icon &#x3D; &quot;texture.dds&quot;		# icon textures found in gfx\interface\message_icons</span><br><span class="line">	style &#x3D; good&#x2F;bad&#x2F;neutral	# neutral is default, affects the look of message items</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一行的<code>display</code>如果是<code>feed</code>，则信息是右下角的形式；如果是<code>toast</code>，则信息是中间横幅的形式；默认值是<code>feed</code>；</p>
<p>第二行是该信息的标题文本，默认是信息本身的关键字段，例如这里的<code>my_message</code>；</p>
<p>第三行是改信息的描述文本；</p>
<p>接下来是该信息的工具栏提示文本；</p>
<p>最后三行分别是音效、图标和类型，图标的路径在<code>gfx\interface\message_icons</code>，类型的设置会影响信息框的颜色外观。</p>
</li>
<li><p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_message_type &#x3D; &#123;</span><br><span class="line">	display &#x3D; feed</span><br><span class="line">	title &#x3D; &quot;My Title&quot;</span><br><span class="line">	desc &#x3D; &quot;My $EFFECT$&quot;</span><br><span class="line">	tooltip &#x3D; &quot;My Tooltip&quot;</span><br><span class="line">	soundeffect &#x3D; &quot;blah.audio&quot;</span><br><span class="line">	icon &#x3D; &quot;nice.dds&quot;</span><br><span class="line">	style &#x3D; good</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">send_interface_message &#x3D; &#123;</span><br><span class="line">	type &#x3D; my_message_type</span><br><span class="line">	add_gold &#x3D; 50</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<script type="math/tex">EFFECT</script>的写法表示该信息的文本描述是实际造成的效果，比如这里是钱增加50。这样写的一个好处就是，类似的事件可以共用同一个<code>message_type</code>，而不用针对每个事件都写一个新的。上述这个例子所弹出的信息提示如下：</p>
<pre><code>Title = My Title
Description = My Add 50 Gold
Tooltip = My Tooltip
</code></pre></li>
<li><p>第二个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">send_interface_message &#x3D; &#123;</span><br><span class="line">	type &#x3D; my_message_type</span><br><span class="line">	desc &#x3D; &#123;</span><br><span class="line">		desc &#x3D; &quot;My Start Line&quot;</span><br><span class="line">		desc &#x3D; linebreak</span><br><span class="line">		desc &#x3D; &quot;My $EFFECT$&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	title &#x3D; &quot;My Cooler Title&quot;</span><br><span class="line">	tooltip &#x3D; &quot;$DESCRIPTION$&quot;</span><br><span class="line">	add_gold &#x3D; 50</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仍然使用刚才的<code>message_type</code>，但是在调用的时候指定了<code>desc</code>、<code>title</code>和<code>tooltip</code>这3个字段，则输出的信息中的3个字段会替换为指定的内容，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Title &#x3D; My Cooler Title</span><br><span class="line">Description &#x3D; My Start Line \n My Add 50 Gold</span><br><span class="line">Tooltip &#x3D; My Start Line \n My Add 50 Gold</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Strategic Information Revelation in Crowdsourcing Systems Without Verification</title>
    <url>/2020/12/25/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Strategic%20Information%20Revelation%20in%20Crowdsourcing%20Systems%20Without%20Verification/</url>
    <content><![CDATA[<h1 id="Strategic-Information-Revelation-in-Crowdsourcing-Systems-Without-Verification"><a href="#Strategic-Information-Revelation-in-Crowdsourcing-Systems-Without-Verification" class="headerlink" title="Strategic Information Revelation in Crowdsourcing Systems Without Verification"></a>Strategic Information Revelation in Crowdsourcing Systems Without Verification</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ol>
<li>本文研究：无需验证解决方案、激励员工提供高质量解决方案的众包平台</li>
<li>本文假设：信息不对称、平台具有信息优势——平台知道有关workers解决方案的平均准确性的更多信息，可以向workers策略性披露信息。根据平台公开的信息，workers判断自己认真完成任务后所获得的奖励。</li>
<li>workers类型：<ol>
<li>naive workers：完全信任平台公开的信息</li>
<li>strategic workers：基于平台公开信息更新自己的先验信念</li>
</ol>
</li>
<li>本文发现：<ol>
<li>对于naive workers：始终宣布高平均精度</li>
<li>对于strategic workers：有动机宣布低于实际值的平均精度</li>
<li>平台的回报可能减少高精度workers </li>
</ol>
</li>
</ol>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ol>
<li>互联网的发展使得多种在线任务的众包具有可行性。</li>
<li>高质量的众包任务解决方案需要worker付出足够的努力，因此平台需要提供激励；而平台无法获取真实结果验证解决方案时，设计激励方案会很难，进而引出IEWV问题。</li>
<li>IEWV(Information elicitation without verification)：未验证的信息挖掘，大多数研究对称信息场景；而实际上，平台往往有更多信息。</li>
<li>本文采用多数投票方案：如果一个worker与其他workers的大多数解决方案相匹配，他将获得一个一致性奖励。</li>
<li>本文假设平台有一个额外决策：信息披露。该场景中，workers由高精度和低精度的混合构成，平台知道每种类型的数量，而workers不知道。</li>
<li>本文研究：<ol>
<li>平台是否有披露信息的动机</li>
<li>平台是否操纵被披露的信息</li>
<li>平台的最优信息披露策略——&gt;平台如何利用信息不对称</li>
</ol>
</li>
<li>平台与workers之间的交互（三阶段）：<ol>
<li>平台决定信息披露策略</li>
<li>平台决定一致性奖励</li>
<li>workers决定是否努力完成任务以及是否如实报告解决方案</li>
<li>上述三阶段结束后，平台收集workers上报的解决方案并根据三阶段来决定一致性奖励</li>
</ol>
</li>
<li>本文考虑两种类型的workers：<ol>
<li>naive workers：完全相信平台、workers推理平台公开信息是否可靠的能力有限，可以作为基准</li>
<li>strategic workers：不相信平台，有很高推理能力</li>
</ol>
</li>
</ol>
<h3 id="Key-Contributions"><a href="#Key-Contributions" class="headerlink" title="Key Contributions"></a>Key Contributions</h3><ol>
<li>研究IEWV问题的策略性信息披露：非凸问题，但是可以利用特殊结构求最优解</li>
<li>workers的均衡策略：证明workers之间存在多重均衡，在适当的信息披露和报酬设计下，所有workers努力工作并如实报告自己解决方案是其帕累托最优</li>
<li>平台信息披露策略：<ol>
<li>naive workers：始终公布一个与实际值无关的较高的平均准确率</li>
<li>strategic workers：有动机公布一个低于实际值的平均准确率</li>
</ol>
</li>
<li>性能评估：数值实验<ol>
<li>平台报酬增加了workers对高准确率workers数量的先验信念</li>
<li>平台报酬可能会减小高准确率workers的数量</li>
</ol>
</li>
</ol>
<h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><h3 id="Information-Elicitation-Without-Verification-IEWV"><a href="#Information-Elicitation-Without-Verification-IEWV" class="headerlink" title="Information Elicitation Without Verification(IEWV)"></a>Information Elicitation Without Verification(IEWV)</h3><ol>
<li>设计适当的激励</li>
<li>同伴预测</li>
<li>大都假设信息对称</li>
</ol>
<h3 id="Strategic-Information-Revelation"><a href="#Strategic-Information-Revelation" class="headerlink" title="Strategic Information Revelation"></a>Strategic Information Revelation</h3><ol>
<li>不完全信息中的cheap talk问题——假设平台不会说谎</li>
<li>考虑信息获取和揭示代价的劝说博弈——认为信息披露是唯一的决策</li>
</ol>
<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><h3 id="Workers’-Decisions-and-Payoffs"><a href="#Workers’-Decisions-and-Payoffs" class="headerlink" title="Workers’ Decisions and Payoffs"></a>Workers’ Decisions and Payoffs</h3><ol>
<li>任务和workers：<ol>
<li>任务：二值问题，例如判断数学问题求解方案是否正确，解空间<code>{1， -1}</code>，分别表示正确和错误。</li>
<li>workers：$N$个，$x_i^{estimate}$表示第$i$个worker对该任务解的估计值，$x_i^{report}$表示第$i$个worker对该任务解的上报值，这二者可能一样也可能不同。</li>
</ol>
</li>
<li>workers的努力策略：<ol>
<li>worker可以决定是否努力工作，求解准确性和他选择的努力程度有关，努力程度为<code>{0,1}</code>两种。<ol>
<li>努力程度为0时，worker求解准确率为0.5，代价为0，且无法获取关于任务解方案的任何信息（即其估计值为真或假的概率相等）</li>
<li>努力程度为1时，其求解准确率会提高为$p_i$，代价为$c$。</li>
</ol>
</li>
<li>workers的异构：$N$个workers中有$k$个高准确率的worker（准确率为$p_h$）使用集合$N_h$表示；$N-k$个低准确率的worker（准确率为$p_l$），使用集合$N_l$表示。两个准确率值均大于0.5小于1。</li>
</ol>
</li>
<li>worker的上报策略：<ol>
<li>对于不努力的worker：策略唯一，随机上报，用<code>rd</code>表示</li>
<li>对于努力的worker：策略空间<code>{1,-1}</code>，分别表示如实报告和谎报</li>
<li>workers可以共谋，大家都报告1或者-1，但对于在线众包系统，这样的共谋并不现实；平台检测到共谋则会删除该worker，因此认为workers的报告策略是独立的，且只有<code>{rd,1,-1}</code>这三个选项。</li>
<li>$s_i=(e_i,r_i)$表示第$i$个worker的努力策略和报告策略，具体来说$s_i\in S_i=\{(0,rd),(1,1),(1,-1)\}$</li>
</ol>
</li>
<li>一致性奖励：<ol>
<li>报告值和大多数人一样的worker可以得到奖励$R$。</li>
<li>$G_i(s;\epsilon)$表示第$i$个worker收到$R$的概率，其中，$s=(e_i,r_i)$，$\epsilon$是平台策略，在后面进行分析。</li>
</ol>
</li>
<li>worker的收益：$u_i(s;\epsilon,R)=G_i(s;\epsilon)\cdot R-e_i\cdot c$</li>
</ol>
<h3 id="Platform’s-Decisions-and-Payoff"><a href="#Platform’s-Decisions-and-Payoff" class="headerlink" title="Platform’s Decisions and Payoff"></a>Platform’s Decisions and Payoff</h3><ol>
<li><p>平台的信息披露策略：</p>
<ol>
<li><p>平台拥有的信息优势：workers求解准确率的分布，也就是高准确率workers的数量$k$</p>
</li>
<li><p>平台和workers之间非对称信息披露的贝叶斯说服框架：</p>
<ol>
<li><p>平台和workers都不知道$k$，平台需要进行长期信息披露策略：</p>
<ol>
<li><p>平台虽然不知道$k$，但是知道$k$的分布，从而得到先验信念$\mu^{prior}=(\mu_{high}^{prior},\mu_{low}^{prior})$，其中$\mu_{high}^{prior}=Pr(k=k^{high})$，$\mu_{low}^{prior}=Pr(k=k^{low})$。$\mu_{high}^{prior}+\mu_{low}^{prior}=1$，且$k^{high}$和$k^{low}$是$k$的两个可能取值。</p>
</li>
<li><p>这个先验同时也是workers的，大家都一样。</p>
</li>
<li><p>注意，出于简化，上述公式中$k$的分布是两点分布，本方法同样适用于其他分布的情况。</p>
</li>
<li><p>在$k$被发现之前，平台会预定一个信息披露策略（？是否公开——从后文看是公开的，或者说是workers能发现其规律）。</p>
</li>
<li><p>平台可以有多个任务，每个任务有各自对应的$k$，在workers到来之前（也即是在$k$被发现之前），平台会先决定信息披露策略，并承诺会按这个策略执行，从而建立良好信誉。</p>
</li>
<li><p>$\epsilon = (\epsilon^h, \epsilon^l)\in [0,1]^2$：平台的信息披露策略。假设当$k=k^{low}$时，平台宣称$k_p^{anu}=k^{high}$的概率是$\epsilon^h$，而反之，当$k=k^{high}$时，平台宣称$k_p^{anu}=k^{low}$的概率是$\epsilon^l$。</p>
</li>
<li><p>总结一下就是平台会按下列概率决策：</p>
<p>$Pr(k_p^{anu}=k^{high}|k=k^{low})=\epsilon^h$</p>
<p>$Pr(k_p^{anu}=k^{low}|k=k^{low})=1-\epsilon^h$</p>
<p>$Pr(k_p^{anu}=k^{high}|k=k^{high})=1-\epsilon^l$</p>
<p>$Pr(k_p^{anu}=k^{low}|k=k^{high})=\epsilon^l$</p>
<p>即：k有两个取值，一个high，一个low，当真实的k是high时，平台说谎的概率是$\epsilon^l$；当真实的k是low时，平台说谎的概率是$\epsilon^h$。</p>
</li>
</ol>
</li>
<li><p>workers执行任务，平台观察到$k$，workers尚且不知道；</p>
</li>
<li><p>平台依据之前决定的策略公开$k_p^{anu}$，可能和真实$k$不同，平台决定的$\epsilon$会影响workers对$k$的后验信念，从而影响平台的信誉和收益。</p>
</li>
<li><p>workers可以通过重复与平台交互从而了解平台的信息披露策略，也可以通过平台反馈以及信誉系统来了解信息披露策略。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>平台的奖励设计策略：$R$，决定worker均衡收益</p>
</li>
<li><p>平台的收益：准确率和代价之间的均衡</p>
<p>$U_p(\epsilon,R,k;s)=\beta P_a(\epsilon,R,k;s)-E\{R^{tot}(\epsilon,R,k;s)\}$</p>
<ol>
<li>$P_a(\epsilon,R,k;s)$表示workers的任务聚合准确率，使用少数服从多数的规则来计算该概率。</li>
<li>$\beta$表示平台对聚合准确率的估值（从公式上理解感觉更像是说当聚合结果是正确的时候所得到的收益）</li>
<li>$E\{R^{tot}(\epsilon,R,k;s)\}$表示对总的一致性奖励的预期支出（这里的$R^{tot}$是指什么？）</li>
</ol>
</li>
</ol>
<h2 id="SOLVING-THREE-STAGE-MODEL"><a href="#SOLVING-THREE-STAGE-MODEL" class="headerlink" title="SOLVING THREE-STAGE MODEL"></a>SOLVING THREE-STAGE MODEL</h2><p>本章节使用逆向归纳法，仅分析strategic worker。</p>
<h3 id="Worker-Equilibrium-Behaviors-in-Stage-III"><a href="#Worker-Equilibrium-Behaviors-in-Stage-III" class="headerlink" title="Worker Equilibrium Behaviors in Stage III"></a>Worker Equilibrium Behaviors in Stage III</h3><ol>
<li><p>前提：给定平台策略$\epsilon$和$R$，每个worker选择自己的努力程度和报告策略$s_i$来最大化自身收益</p>
</li>
<li><p>worker的信念更新：平台公布$k_p^{anu}$之前，workers有对$k$的先验信念$\mu^{prior}$（是每人一个还是所有worker共用？）</p>
<ol>
<li><p>平台公布$k_p^{anu}$后，workers基于先验信念和平台公布值更新后验信念$\mu_w^{post,str}|k_p^{anu}$，其中$w\in \{high,low\}$。计算如下：</p>
<script type="math/tex; mode=display">
\mu_{high}^{post,str}|k^{high}(\epsilon)=\frac{(1-\epsilon^l)\mu_{high}^{prior}}{(1-\epsilon^l)\mu_{high}^{prior}+\epsilon^h\mu_{low}^{prior}}</script><script type="math/tex; mode=display">
\mu_{low}^{post,str}|k^{high}(\epsilon)=\frac{\epsilon^h\mu_{low}^{prior}}{(1-\epsilon^l)\mu_{high}^{prior}+\epsilon^h\mu_{low}^{prior}}</script><script type="math/tex; mode=display">
\mu_{high}^{post,str}|k^{low}(\epsilon)=\frac{\epsilon^l\mu_{low}^{prior}}{\epsilon^l\mu_{high}^{prior}+(1-\epsilon^h)\mu_{low}^{prior}}</script><script type="math/tex; mode=display">
\mu_{low}^{post,str}|k^{low}(\epsilon)=\frac{(1-\epsilon^h)\mu_{low}^{prior}}{\epsilon^l\mu_{high}^{prior}+(1-\epsilon^h)\mu_{low}^{prior}}</script><p>推导过程用到了<a href="https://zhuanlan.zhihu.com/p/134036707" target="_blank" rel="noopener">贝叶斯公式</a>。</p>
<p>前两行表示平台宣布$k=k^{high}$时，worker对$k$实际值的后验信念；后两行表示平台宣布$k=k^{low}$时，worker对$k$实际值的后验信念。</p>
</li>
<li><p>显然，第一个公式里，随着$\epsilon^h$的增加，workers对k为high的后验信念逐渐减小，也就是说，如果平台在k实际为low时说谎的概率增加，则workers在听到平台说k为high时，会怀疑平台说谎；类似地，在第四个公式中，随着$\epsilon^l$的增加，workers对k为low的后验信念逐渐减小，也就是说，如果平台在k实际为high时说谎的概率增加，则workers在听到平台说k为low时，会怀疑平台，进而减小后验信念。</p>
</li>
</ol>
</li>
<li><p>worker的均衡策略：worker根据后验信念做出是否努力以及是否如实汇报的决策，本文关注对称纳什均衡——相同类型（任务求解准确率）的worker会有相同的决策。</p>
<ol>
<li><p>定义1：</p>
<ol>
<li>$n-SNE$：$(s_i^*=(0,rd), \forall i\in N)$，没有worker会努力和如实报告</li>
<li>$f-SNE$：$(s_i^*=(1,1), \forall i\in N)$， 所有worker都努力和如实报告</li>
<li>$p-SNE$：$(s_i^<em>=(1,1), \forall i\in N_h, s_j^</em>=(0,rd), \forall j\in N_l)$，高准确率的worker会努力和如实报告，低准确率的worker会不努力和随机报告</li>
</ol>
</li>
<li><p>定理1：</p>
<ol>
<li>给定任意$\epsilon\in [0,1]^2$，$R\geq 0$时一定存在一个$n-SNE$.</li>
<li>给定任意$\epsilon\in [0,1]^2$，始终存在阈值$R_f^{str}(\epsilon, k_p^{anu})&gt; 0$，使得当且仅当$R&gt;R_f^{str}(\epsilon,k_p^{anu})$时存在$f-SNE$.</li>
<li>当$\epsilon\in \Phi=\{\epsilon\in [0,1]^2|condition (11) \}$成立时，存在两个阈值$0&lt;R_{pl}^{str}(\epsilon,k_p^{anu})\leq R_{ph}^{str}(\epsilon, k_p^{anu})$，使得当且仅当$R_{pl}^{str}(\epsilon,k_p^{anu})\leq R \leq R_{ph}^{str}(\epsilon, k_p^{anu})$时，存在$p-SNE$. $condition (11)$如下：</li>
</ol>
<script type="math/tex; mode=display">
\frac{2p_h-1}{2p_l-1}(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}-1}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}-1}^{majority})\geq \mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority} \tag{11}</script><p>​        在该公式中，$P_{k^{high}-1}^{majority}$是指：当$k^{high}-1$个高准确率workers决定采取策略$(1,1)$且剩下的其他workers都决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>​        $P_{k^{low}-1}^{majority}$是指：当$k^{low}-1$个高准确率workers决定采取策略$(1,1)$且剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>​        $P_{k^{high}}^{majority}$是指：$k^{high}$个高准确率worker决定采取策略$(1,1)$，剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>​        $P_{k^{low}}^{majority}$是指：$k^{low}$个高准确率worker决定采取策略$(1,1)$，剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>​        这个公式算起来很复杂，它表达的场景是：当选择努力时，高准确率worker相信他们更有可能拿到奖励（而不是低准确率worker），也就是说高准确率worker认为自己是大多数的那部分。反之，当这个公式不满足时，高准确率worker会觉得自己拿到奖励的概率很低，从而使得高准确率worker的期望收益很低。此时，高准确率worker不会努力，而是选择降低成本，进而不存在$p-SNE$。</p>
</li>
</ol>
</li>
<li><p>推论1：</p>
<ol>
<li><p>对于一个固定的$\epsilon^l$，如果$k_p^{anu}=k^{high}$，则定理1中的$R_f^{str}(\epsilon,k_p^{anu})$和$R_{pl}^{str}(\epsilon,k_p^{anu})$随$\epsilon^h$增加而增加；反之，如果$k_p^{anu}=k^{low}$，则这两个都随$\epsilon^h$增加而减小。</p>
<p>说明：如果平台更喜欢把$k_p^{anu}$谎报成$k^{high}$（也就是说在$k^{low}$时说谎），那么为了达成$f-SNE$和$p-SNE$，平台需要提供更高报酬（也就是更大的$R$）。分析原因：这种情况会让workers觉得实际的$k$并不是$k^{high}$而是$k^{low}$，也就是说$\mu_{high}^{post,str}|k^{high}(\epsilon)$会减小，因此通过多数一致获得的奖励会减少，而为了激励workers，平台就需要提高奖励，从而提高workers的期望收益。</p>
</li>
<li><p>对于一个固定的$\epsilon^h$，如果$k_p^{anu}=k^{high}$，则定理1中的$R_f^{str}(\epsilon,k_p^{anu})$和$R_{pl}^{str}(\epsilon,k_p^{anu})$随$\epsilon^l$增加而增加；反之，如果$k_p^{anu}=k^{low}$，则这两个都随$\epsilon^l$增加而减小。</p>
<p>说明：如果平台更喜欢把$k_p^{anu}$谎报成$k^{low}$（也就是说在$k^{high}$时说谎），那么为了达成$f-SNE$和$p-SNE$，平台也一样需要提高报酬来激励。这里的推导可以看前面workers更新后验信念那里的公式来理解。</p>
</li>
<li><p>对于适当的$\epsilon$和$R$，定理1中的几个不同的$SNE$可以共存。</p>
</li>
</ol>
</li>
<li><p>定理2：帕累托最优：对于任意给定$\epsilon$和$R$，workers之间存在一个帕累托最优均衡解。</p>
<p>本文假设当多个均衡解共存时，workers会选择帕累托最优。</p>
</li>
</ol>
<h3 id="Platform-Reward-Design-in-Stage-II"><a href="#Platform-Reward-Design-in-Stage-II" class="headerlink" title="Platform Reward Design in Stage II"></a>Platform Reward Design in Stage II</h3><p>这一部分分析对于给定的$\epsilon$，平台观察$k$并决定$R$，从而在第三阶段达到帕累托最优。</p>
<ol>
<li><p>定义2：$z\in \{n,f,p\}$表示均衡解索引</p>
<ol>
<li><p>$P_z(k)$：均衡$z-SNE$的任务聚合准确率</p>
</li>
<li><p>$E\{R_z^{tot}(\epsilon,k,k_p^{anu})\}$：均衡$z-SNE$的总期望一致性奖励</p>
</li>
<li><p>$B_z(\epsilon,k,k_p^{anu})$：对于每单位$R$，均衡解从$n-SNE$提升到$z-SNE$所带来的平均准确率的提升，计算方式如下：</p>
<script type="math/tex; mode=display">
B_z(\epsilon,k,k_p^{anu})=\frac{P_z(k)-P_n(k)}{E\{R_z^{tot}(\epsilon,k,k_p^{anu})\}}</script></li>
</ol>
</li>
</ol>
<ol>
<li><p>定理3：</p>
<ol>
<li><p>如果$(11)$成立且$B_p(\epsilon,k,k_p^{anu})&gt;B_f(\epsilon,k,k_p^{anu})$，则平台的最优奖励为：</p>
<script type="math/tex; mode=display">
R^*=\left\{
\begin{aligned}
&0, &if \ \ \beta<\frac{1}{B_p(\epsilon,k,k_p^{anu})}\\
&R_{pl}^{str}(\epsilon,k_p^{anu}), &if\ \ \frac{1}{B_p(\epsilon,k,k_p^{anu})} \leq \beta<\widetilde\beta(\epsilon,k,k_p^{anu}) \\
&R_{f}^{str}(\epsilon,k_p^{anu}), &if\ \ \beta\geq \widetilde\beta(\epsilon,k,k_p^{anu})
\end{aligned}
\right.</script><p>其中，$\widetilde\beta(\epsilon,k,k_p^{anu})=\frac{E\{R_f^{tot}(\epsilon,k,k_p^{anu})-E\{R_p^{tot}(\epsilon,k,k_p^{anu})}{P_f(k)-P_p(k)}$</p>
</li>
<li><p>如果$(11)$不成立或者$B_p(\epsilon,k,k_p^{anu})&lt;B_f(\epsilon,k,k_p^{anu})$，则平台的最优奖励为：</p>
<script type="math/tex; mode=display">
R^*=\left\{
\begin{aligned}
&0, &if \ \ \beta<\frac{1}{B_f(\epsilon,k,k_p^{anu})}\\
&R_{f}^{str}(\epsilon,k_p^{anu}), &if\ \ \beta\geq \frac{1}{B_f(\epsilon,k,k_p^{anu})}
\end{aligned}
\right.</script><p>注意，$(11)$是达到$p-SNE$所必须的条件。</p>
</li>
</ol>
</li>
<li><p>定理3说明了：</p>
<ol>
<li>如果$p-SNE$存在，且它比$f-SNE$的单位收益准确率提升更高，且平台的估值$\beta$是温和的，平台会通过选择$R^*=R_{pl}^{str}(\epsilon,k_p^{anu})$引出$p-SNE$作为第三阶段的帕累托均衡来最大化自己的收益。</li>
<li>如果$p-SNE$不存在，或者它比$f-SNE$的单位收益准确率提升低，那么$p-SNE$对平台而言就不是最好的均衡解。当$\beta$很大时，平台会通过选择$R^*=R_f^{str}(\epsilon,k_p^{anu})$引出$f-SNE$作为第三阶段的帕累托最优。</li>
</ol>
</li>
</ol>
<h3 id="Platform-Information-Revelation-in-Stage-I"><a href="#Platform-Information-Revelation-in-Stage-I" class="headerlink" title="Platform Information Revelation in Stage I"></a>Platform Information Revelation in Stage I</h3><p>这一部分讨论平台的信息披露策略。在该阶段中，平台决定自己的信息披露策略$\epsilon = (\epsilon^h,\epsilon^l)\in[0,1]^2$，并预测自己在第二阶段中的$R$和workers在第三阶段中的帕累托均衡。</p>
<p>重复一下前文的符号表示：</p>
<blockquote>
<p>$\epsilon = (\epsilon^h, \epsilon^l)\in [0,1]^2$：平台的信息披露策略。假设当$k=k^{low}$时，平台宣称$k_p^{anu}=k^{high}$的概率是$\epsilon^h$，而反之，当$k=k^{high}$时，平台宣称$k_p^{anu}=k^{low}$的概率是$\epsilon^l$。</p>
<p>总结一下就是平台会按下列概率决策：</p>
<p>$Pr(k_p^{anu}=k^{high}|k=k^{low})=\epsilon^h$</p>
<p>$Pr(k_p^{anu}=k^{low}|k=k^{low})=1-\epsilon^h$</p>
<p>$Pr(k_p^{anu}=k^{high}|k=k^{high})=1-\epsilon^l$</p>
<p>$Pr(k_p^{anu}=k^{low}|k=k^{high})=\epsilon^l$</p>
<p>即：k有两个取值，一个high，一个low，当真实的k是high时，平台说谎的概率是$\epsilon^l$；当真实的k是low时，平台说谎的概率是$\epsilon^h$。</p>
</blockquote>
<ol>
<li><p>定理4：对平台而言，设置为$\epsilon^h=1,\epsilon^l=0$并不总是最优解。</p>
<p>换言之，宣称$k_p^{anu}=k^{high}$并不总是最好的，具体分析如下：</p>
<p>首先，复习内容：$k$的真实值影响第2阶段中的奖励设计，而平台对$k$的宣称值$k_p^{anu}$影响第3阶段中workers的行为。考虑一下4种情况：</p>
<ol>
<li>Case $(h,h)$: $k=k^{high}$ 且 $k_p^{anu}=k^{high}$，出现概率$Q_{h,h}(\epsilon)=\mu_{high}^{prior}(1-\epsilon^l)$</li>
<li>Case $(h,l)$: $k=k^{high}$ 且 $k_p^{anu}=k^{low}$，出现概率$Q_{h,l}(\epsilon)=\mu_{high}^{prior}\epsilon^l$</li>
<li>Case $(l,h)$: $k=k^{low}$ 且 $k_p^{anu}=k^{high}$，出现概率$Q_{l,h}(\epsilon)=\mu_{low}^{prior}\epsilon^h$</li>
<li>Case $(l,l)$: $k=k^{low}$ 且 $k_p^{anu}=k^{low}$，出现概率$Q_{l,l}(\epsilon)=\mu_{low}^{prior}(1-\epsilon^h)$</li>
</ol>
<p>固定$\epsilon^l$，平台的期望收益为：</p>
<script type="math/tex; mode=display">
E\{U_p(\epsilon^h)\}=Q_{h,h}(\epsilon^h)U_{h,h}(\epsilon^h)+Q_{h,l}(\epsilon^h)U_{h,l}(\epsilon^h)+Q_{l,h}(\epsilon^h)U_{l,h}(\epsilon^h)+Q_{l,l}(\epsilon^h)U_{l,l}(\epsilon^h)</script><p>$U_{h,h}$表示在Case $(h,h)$的情况下，平台在第2阶段最优化奖励值后的最大收益。其他几个U也是类似的含义。</p>
<p>接下来分析期望收益随披露策略的变化趋势。</p>
</li>
<li><p>引理1：</p>
<ol>
<li>$U_{h,h}(\epsilon^h),U_{l,h}(\epsilon^h),Q_{l,l}(\epsilon^h)$随$\epsilon^h$增加而减小。</li>
<li>$U_{h,l}(\epsilon^h),U_{l,l}(\epsilon^h),Q_{l,h}(\epsilon^h)$随$\epsilon^h$增加而增加。</li>
</ol>
<p>分析：$Q_{l,l}(\epsilon^h)$和$Q_{l,h}(\epsilon^h)$随$\epsilon^h$的变化从定义即可看出。接下来用Case $(h,h)$ 中的 $U_{h,h}(\epsilon^h)$作为例子来分析。在推论1中可知，随$\epsilon^h$增加，平台需要支付更大的奖励$R$来激励workers，而这会减小平台的收益。其他几个U也是类似的分析思路。</p>
<p>而由于$E\{U_p(\epsilon^h)\}$的几部分单调性不同，因此无法直接分析出平台收益随$\epsilon^h$的变化趋势。同样的，$E\{U_p(\epsilon^l)\}$也无法分析变化趋势。从而得出定理4的结论。</p>
</li>
</ol>
<p>具体的平台披露策略因为太复杂了，所以没法分析，在实验部分进行了数值实验。</p>
<h2 id="NUMERICAL-RESULTS"><a href="#NUMERICAL-RESULTS" class="headerlink" title="NUMERICAL RESULTS"></a>NUMERICAL RESULTS</h2><p>这一部分进行数值实验，研究两类workers：策略型和天真型，天真型的符号表达沿用前文中策略型的，只是把$str$改成了$nai$，具体如下：</p>
<script type="math/tex; mode=display">
\left\{
\begin{aligned}
\mu_{high}^{post,nai}|k^{high}=\mu_{low}^{post,nai}|k^{low}=1\\
\mu_{high}^{post,nai}|k^{low}=\mu_{low}^{post,nai}|k^{high}=0\\
\end{aligned}
\right.</script><p>接下来的实验结果说明：平台始终向天真的工人宣布高平均工人准确率是最佳的（也就是$k=k^{high}$），但对策略型工人来说并非如此。我们还显示了一个反直觉的结果，表明平台的收益随高准确率workers的准确率提高而提高，随高准确率workers的数量提高而减小。</p>
<h3 id="Impact-of-Worker-Characteristics"><a href="#Impact-of-Worker-Characteristics" class="headerlink" title="Impact of Worker Characteristics"></a>Impact of Worker Characteristics</h3><p>这一部分研究高准确率workers的准确率$p_h$对平台最优收益、workers总收益（所有workers的收益和）和社会福利（平台收益+workers收益）的影响。</p>
<p>参数：workers数量$N=100$，高准确率workers的准确率$p_h\in(0.7,0.8),step=0.02$，低准确率workers的准确率$p_l=0.6$，对$k$的先验信念$\mu_{high}^{prior}=0.7,\mu_{low}^{prior}=0.3$，$k$的取值$k^{low}=20,k^{high}\in\{50,70\}$，workers努力的成本$c=1$，平台对聚合准确的估值$\beta=1000$。</p>
<p>分析图像：</p>
<ol>
<li>平台收益随$p_h$增加而增加，对于某些$p_h$随$k^{high}$增加（指从50变成70）而减小。</li>
<li>天真的workers给平台带来的收益更高。</li>
<li>workers收益可能随$p_h$增加而减小。</li>
<li>社会财富随$p_h$增加而增加。</li>
</ol>
<h3 id="Impact-of-Worker-Prior-Belief"><a href="#Impact-of-Worker-Prior-Belief" class="headerlink" title="Impact of Worker Prior Belief"></a>Impact of Worker Prior Belief</h3><p>这一部分研究先验信念对平台最优收益、workers总收益和平台披露策略的影响。</p>
<p>参数：workers数量$N=100$，高准确率workers的准确率$p_h=0.75$，低准确率workers的准确率$p_l=0.6$，对$k$的先验信念$\mu_{high}^{prior}\in\{0.01,0.2,0.4,0.6,0.8,0.99\}$，$k$的取值$k^{low}=20,k^{high}\in\{50,70\}$，workers努力的成本$c=1$，平台对聚合准确的估值$\beta=1000$。</p>
<p>分析图像：</p>
<ol>
<li>平台收益随先验$\mu_{high}^{prior}$增加而增加。</li>
<li>策略型workers的聚合收益随先验$\mu_{high}^{prior}$增加而减小，天真型workers的聚合收益与先验$\mu_{high}^{prior}$无关。</li>
<li>面对天真型workers，平台始终宣称$k=k^{high}$是最优的；面对策略型workers则不是这样。</li>
<li>面对策略型workers时，平台的最优$\epsilon^{h}$随先验$\mu_{high}^{prior}$增加而减小，最优$\epsilon^{l}$随先验$\mu_{high}^{prior}$增加而增加。</li>
</ol>
<h2 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h2><ol>
<li>策略性信息披露问题——非凸规划</li>
<li>naive workers：总是公开一个较高的平均准确率</li>
<li>strategic workers：收益和平台信用的平衡，有动机宣布一个低于实际值的平均准确率</li>
<li>平台报酬可能减少高准确率workers的数量</li>
<li>未来工作：<ol>
<li>多维workers异质性</li>
<li>考虑信息披露的代价（获取信息所产生的成本）</li>
</ol>
</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/134036707" target="_blank" rel="noopener">贝叶斯公式</a></li>
</ol>
<h2 id="我的分析"><a href="#我的分析" class="headerlink" title="我的分析"></a>我的分析</h2><h3 id="第三阶段workers均衡解定理1"><a href="#第三阶段workers均衡解定理1" class="headerlink" title="第三阶段workers均衡解定理1"></a>第三阶段workers均衡解定理1</h3><p>要用到的字母表达：</p>
<p>$P_{k^{high}-1}^{majority}$是指：当$k^{high}-1$个高准确率workers决定采取策略$(1,1)$且剩下的其他workers都决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>$P_{k^{low}-1}^{majority}$是指：当$k^{low}-1$个高准确率workers决定采取策略$(1,1)$且剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>$P_{k^{high}}^{majority}$是指：$k^{high}$个高准确率worker决定采取策略$(1,1)$，剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>$P_{k^{low}}^{majority}$是指：$k^{low}$个高准确率worker决定采取策略$(1,1)$，剩下的其他workers决定采取策略$(0,rd)$时，$N-1$个workers的解决方案中的大多数是正确的概率（也就是多数一致方案是正确的概率）</p>
<p>$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)$和$\mu_{low}^{post,str}|k_p^{anu}(\epsilon)$是高质量workers的数量的后验概率</p>
<p>我增加的字母表达：$P^{00}$表示高低质量都采取$(0,rd)$时多数一致方案是正确的概率，$P^{01}$表示高质量采取$(0,rd)$低质量采取$(1,-1)$…类似的，可以把workers策略组合的所有概率表达都写出来，上标左边的数字表示高质量workers的策略，右边的数字表示低质量workers的策略，数字012分别表示策略$(0,rd),(1,-1),(1,1)$。</p>
<p>显然，$P^{00}=0.5$，$P^{20}=\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority}$</p>
<p>本文假设相同质量的workers会采取相同的策略，也就是说，高低质量的workers的策略组合一共有9种，我们列出收益矩阵：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>(0,rd)</th>
<th>(1,-1)</th>
<th>(1,1)</th>
</tr>
</thead>
<tbody>
<tr>
<td>(0,rd)</td>
<td>$(0.5R, 0.5R)$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(1,-1)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(1,1)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h4 id="低质量workers选-0-rd"><a href="#低质量workers选-0-rd" class="headerlink" title="低质量workers选$(0,rd)$"></a>低质量workers选$(0,rd)$</h4><ol>
<li>高质量workers选$(0,rd)$，所有workers的答案是正确和错误的概率都是0.5，因此大家的收益都是$0.5R$，没有支出。</li>
<li>高质量workers选$(1,1)$，高质量workers正确的概率是$p_h$，低质量workers正确的概率是0.5，多数一致方案正确的概率是$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority}$，</li>
<li>高质量workers选$(1,-1)$，高质量workers正确的概率是$1-p_h$，低质量workers正确的概率是0.5，多数一致方案正确的概率是$P^{10}$。</li>
</ol>
<h4 id="低质量workers选-1-1"><a href="#低质量workers选-1-1" class="headerlink" title="低质量workers选$(1,-1)$"></a>低质量workers选$(1,-1)$</h4><ol>
<li>高质量workers选$(0,rd)$，高质量workers正确的概率是0.5，低质量workers正确的概率是$1-p_l$，多数一致方案正确的概率是$P^{01}$。</li>
<li>高质量workers选$(1,1)$，高质量workers正确的概率是$p_h$，低质量workers正确的概率是$1-p_l$，多数一致方案正确的概率是$P^{21}$。</li>
<li>高质量workers选$(1,-1)$，高质量workers正确的概率是$1-p_h$，低质量workers正确的概率是$1-p_l$，多数一致方案正确的概率是$P^{11}$。</li>
</ol>
<h4 id="低质量workders选-1-1"><a href="#低质量workders选-1-1" class="headerlink" title="低质量workders选$(1,1)$"></a>低质量workders选$(1,1)$</h4><ol>
<li>高质量workers选$(0,rd)$，高质量workers正确的概率是0.5，低质量workers正确的概率是$p_l$，多数一致方案正确的概率是$P^{02}$。</li>
<li>高质量workers选$(1,1)$，高质量workers正确的概率是$p_h$，低质量workers正确的概率是$p_l$，多数一致方案正确的概率是$P^{22}$。</li>
<li>高质量workers选$(1,-1)$，高质量workers正确的概率是$1-p_h$，低质量workers正确的概率是$p_l$，多数一致方案正确的概率是$P^{12}$。</li>
</ol>
<p>这里看起来是把每一个都列出来，然后比较大小找均衡解。</p>
<h4 id="Condition-11-的推导"><a href="#Condition-11-的推导" class="headerlink" title="$Condition(11)$的推导"></a>$Condition(11)$的推导</h4><p>在$p-SNE$的情况下，高准确率的worker采取策略$(1,1)$，低准确率的worker采取策略$(0,rd)$。</p>
<p>对于一个高质量worker，该workers努力时得到正确答案概率：$p_h$，得到错误答案概率：$1-p_h$。</p>
<p>其他workers中，高质量workers的数量$k$为$k^{high}-1$或者$k^{low}-1$，且对应的概率分别是两个后验概率$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)$和$\mu_{low}^{post,str}|k_p^{anu}(\epsilon)$，而这两种情况下其他workers的多数一致方案是正确和错误的概率分别是$P_{k^{high}-1}^{majority}$和$P_{k^{low}-1}^{majority}$，即可得：</p>
<p>其他workers的多数一致方案是正确的概率：$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}-1}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}-1}^{majority}$，</p>
<p>其他workers的多数一致方案是错误的概率：$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{high}-1}^{majority})+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{low}-1}^{majority})$</p>
<p>一个努力且如实报告的高质量worker得到收益的概率为：</p>
<script type="math/tex; mode=display">
p_h(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}-1}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}-1}^{majority})+(1-p_h)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{high}-1}^{majority})+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{low}-1}^{majority})) \tag{1}</script><p>对于一个低质量worker而言，该workers努力时得到正确答案概率：$p_l$，得到错误答案概率：$1-p_l$，其他workers中，高质量workers的数量$k$为$k^{high}$或者$k^{low}$，且对应的概率分别是两个后验概率$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)$和$\mu_{low}^{post,str}|k_p^{anu}(\epsilon)$，而这两种情况下其他workers的多数一致方案是正确和错误的概率分别是$P_{k^{high}}^{majority}$和$P_{k^{low}}^{majority}$，即可得：</p>
<p>其他workers的多数一致方案是正确的概率：$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority}$，</p>
<p>其他workers的多数一致方案是错误的概率：$\mu_{high}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{high}}^{majority})+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{low}}^{majority})$</p>
<p>一个努力且如实报告的低质量worker得到收益的概率为：</p>
<script type="math/tex; mode=display">
p_l(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority})+(1-p_l)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{high}}^{majority})+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)(1-P_{k^{low}}^{majority})) \tag{2}</script><p>公式(1)大于公式(2)所推导出的公式和论文中的$condition(11)$不一样，暂时没想到其他的思路。</p>
<p>这里推导出的是：</p>
<script type="math/tex; mode=display">
(1-p_h)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)+\mu_{low}^{post,str}|k_p^{anu}(\epsilon))+(2p_h-1)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}-1}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}-1}^{majority})\geq \\
(1-p_l)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)+\mu_{low}^{post,str}|k_p^{anu}(\epsilon))+(2p_l-1)(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority})</script><p>论文里的11是：</p>
<script type="math/tex; mode=display">
\frac{2p_h-1}{2p_l-1}(\mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}-1}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}-1}^{majority})\geq \mu_{high}^{post,str}|k_p^{anu}(\epsilon)P_{k^{high}}^{majority}+\mu_{low}^{post,str}|k_p^{anu}(\epsilon)P_{k^{low}}^{majority} \tag{11}</script><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><ol>
<li>均衡解和阈值是怎么算出来的完全不懂</li>
<li>实验部分是怎么算最优平台披露策略$\epsilon^h,\epsilon^l$</li>
<li>图2(b)中增加的那段没有解释</li>
<li>$k^{high}=50$和$k^{high}=70$只有两个值是否能充分说明变化趋势（这个不重要）</li>
<li>社会财富的增加是否与平台数值过大有关（这个也不重要）</li>
<li>多数一致投票的时候，如果两边一样怎么处理（这个还不重要）</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>crowdsourcing</tag>
        <tag>game theory</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-7</title>
    <url>/2020/12/24/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-7/</url>
    <content><![CDATA[<h1 id="On-Action"><a href="#On-Action" class="headerlink" title="On_Action"></a>On_Action</h1><p>在前面学习到的事件是由玩家在游戏中通过决议而触发的，但有时候我们会希望实现一些自动触发的事件，比如一年触发一次、五年触发一次等，这个时候就需要使用<code>on_action</code>了。</p>
<p>在<a href="https://likun1208.github.io/2020/11/08/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-4/">ck3mod制作笔记-4</a>中，我们提到过这个东西。它可以理解成一种编码，当游戏中有对应编码的事件发生时，就会执行<code>on_action</code>代码块中的内容，比如当角色结婚时，<code>on_marriage</code>部分的内容就会被触发。游戏本体的相关代码存放在<code>Crusader Kings III\game\common\on_action</code>文件夹中，可以看到有很多很多选项。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><code>_on_actions.info</code>文件中说明了一个<code>on_action</code>代码块的写法，这里简要翻译和介绍一下。</p>
<p>首先，一个<code>on_action</code>的基础结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">on_action_name &#x3D; &#123;</span><br><span class="line">	trigger &#x3D; &#123;</span><br><span class="line">		trigger_conditions &#x3D; yes</span><br><span class="line">	&#125;</span><br><span class="line">	weight_multiplier &#x3D; &#123;</span><br><span class="line">		base &#x3D; 1</span><br><span class="line">		modifier &#x3D; &#123;</span><br><span class="line">			add &#x3D; 1</span><br><span class="line">			trigger_conditions &#x3D; yes</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	events &#x3D; &#123;</span><br><span class="line">		event_id_1</span><br><span class="line">		delay &#x3D; &#123; days &#x3D; 365 &#125;</span><br><span class="line">		event_id_2</span><br><span class="line">		delay &#x3D; &#123; months &#x3D; &#123; 6 12 &#125; &#125;</span><br><span class="line">		event_id_3</span><br><span class="line">	&#125;</span><br><span class="line">	random_events &#x3D; &#123;</span><br><span class="line">		chance_to_happen &#x3D; 25</span><br><span class="line">		chance_of_no_event &#x3D; &#123;</span><br><span class="line">			value &#x3D; 0</span><br><span class="line">			if &#x3D; &#123;</span><br><span class="line">				limit &#x3D; &#123; trigger_conditions &#x3D; yes &#125;</span><br><span class="line">				add &#x3D; 10</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		100 &#x3D; event_id_1</span><br><span class="line">		200 &#x3D; event_id_2</span><br><span class="line">		100 &#x3D; 0</span><br><span class="line">	&#125;</span><br><span class="line">	first_valid &#x3D; &#123;</span><br><span class="line">		event_id_1</span><br><span class="line">		event_id_2</span><br><span class="line">		fallback_event_without_trigger</span><br><span class="line">	&#125;</span><br><span class="line">	on_actions &#x3D; &#123;</span><br><span class="line">		on_action_1</span><br><span class="line">		on_action_2</span><br><span class="line">		on_action_3</span><br><span class="line">	&#125;</span><br><span class="line">	random_on_actions &#x3D; &#123;</span><br><span class="line">		100 &#x3D; on_action_1</span><br><span class="line">		200 &#x3D; on_action_2</span><br><span class="line">		100 &#x3D; 0</span><br><span class="line">	&#125;</span><br><span class="line">	first_valid_on_action &#x3D; &#123;</span><br><span class="line">		on_action_1</span><br><span class="line">		on_action_2</span><br><span class="line">	&#125;</span><br><span class="line">	effect &#x3D; &#123;</span><br><span class="line">		effects &#x3D; yes</span><br><span class="line">	&#125;</span><br><span class="line">	fallback &#x3D; another_on_action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>第一部分<code>trigger</code>是这个<code>on_action</code>的触发条件，如果一个<code>on_action</code>被游戏中的事件触发，而该<code>on_action</code>的<code>trigger</code>条件不满足，则无事发生。例如我们写一个<code>on_action</code>设定角色结婚后立刻获得1000金币，但是在<code>trigger</code>中限制该角色需要年龄低于30，则一个60岁角色的结婚事件触发该<code>on_action</code>后，不会获得金币。</li>
<li>第二部分是对该<code>on_action</code>权重的修正，这个权重是用于其他<code>on_action</code>的随机<code>on_action</code>列表（这个列表会在下面介绍），比如我们有3个<code>on_action</code>，分别是<code>on_action_1, on_action_2, on_action_3</code>，其中后两个在第一个的随机<code>on_action</code>列表中，这意味着当<code>on_action_1</code>触发时，<code>on_action_2</code>和<code>on_action_3</code>会以一定概率触发，概率由它们在列表中的权重决定，权重的计算方式在前面介绍过，而这里的<code>weight_multiplier</code>就是对该权重值的修正。</li>
<li>第三部分表示该<code>on_action</code>触发时会发生的事件列表，事件们在满足自身触发条件（<code>trigger</code>）的情况下，会从上到下按顺序逐一发生。这一部分中可以使用<code>delay</code>来控制事件之间的间隔，表示上一个事件发生多久后再继续进行下一个事件。<code>delay</code>可以是<code>days</code>，也可以是<code>months</code>和<code>years</code>，且这3者的值可以是形如<code>{6 12}</code>这样的随机列表，具体到游戏中会从大括号的值里挑一个，注意这两个数字之间没有逗号。上述代码中的这段例子就是当<code>on_action</code>触发时，先立刻发生<code>event_id_1</code>，等365天后会发生<code>event_id_2</code>，接着等6个月或12个月会发生<code>event_id_3</code>。</li>
<li>第四部分<code>random_events</code>是随机事件列表，<code>on_action</code>发生时，会从该列表中根据权值随机挑选事件发生，会且只会挑一个。其中的<code>chance_to_happen</code>是基础权值，比如这里是25。<code>chance_of_no_event</code>是可以格式化为脚本值的条目，出于性能原因独立于<code>chance_to_happen</code>，只有当<code>chance_to_happen</code>为真时，该值会被考虑。接下来的列表就是会被挑选的事件列表，其中形如<code>100 = 0</code>这样的条目，是指有一定概率没有任何事件发生，这个设置是为了避免玩家通过让随即列表中的其他事件都不满足触发条件，从而触发稀有事件。</li>
<li>第五部分<code>first_valid</code>选取触发器返回 true 的第一个事件。</li>
<li><code>on_action</code>除了规定发生什么事件以外，也可以规定触发哪些<code>on_action</code>，接下来的第六、第七和第八部分和前面的<code>events, random_events, first_valid</code>很像，它们分别是该<code>on_action</code>会触发的其他<code>on_action</code>列表、随机<code>on_action</code>列表和<code>first_valid on_action</code>列表，前面第二部分的权重就是在这里用的。</li>
<li>接着的<code>effect</code>这里先不说明，因为我还没学。</li>
<li>最后<code>fallback</code>有点类似于编程语言中的函数返回值，它表示该<code>on_action</code>定义的返回<code>on_action</code>。如果没有事件/on_actions由该<code>on_action</code>触发，则该返回<code>on_action</code>会被调用。注意，要避免创建无限的返回循环，否则游戏可能会被阻止推进时间。</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在这一部分中，我们写一个很基础朴素的<code>on_action</code>，来略微了解一下。</p>
<ol>
<li><p>首先我们要完成一个如下<code>on_action</code>：当角色结婚时，弹出第一个事件，1天后弹出第2个事件，10天或15天后弹出第3个事件，3个事件就很随意了。</p>
</li>
<li><p>那么首先，我们先写3个事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace &#x3D; test_action</span><br><span class="line">test_action.1001 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; test_action.1001.t</span><br><span class="line">	desc &#x3D; test_action.1001.desc</span><br><span class="line">	theme &#x3D; stewardship</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; test_action.1001.option.a</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; test_action.1001.option.b</span><br><span class="line">		trigger_event &#x3D; give_money.1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_action.1002 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; test_action.1002.t</span><br><span class="line">	desc &#x3D; test_action.1002.desc</span><br><span class="line">	theme &#x3D; stewardship</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; test_action.1002.option.a</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_action.1003 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; test_action.1003.t</span><br><span class="line">	desc &#x3D; test_action.1003.desc</span><br><span class="line">	theme &#x3D; stewardship</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; test_action.1003.option.a</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意，<code>namespace</code>一定要写对（也就是数字id前面的字符串），不能写成别的，不然就找不到这些事件了。</p>
<p>一个反例就是一开始我没注意，namespace写成了test，于是无论怎么搞都只会触发这个文件中的最后一个事件（test_action.1003）。</p>
<p>事件对应的文本文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> test_action.1001.t:0 &quot;测试&quot;</span><br><span class="line"> test_action.1001.desc:0 &quot;测试一下action。&quot;</span><br><span class="line"> test_action.1001.option.a:0 &quot;好耶！&quot;</span><br><span class="line"> test_action.1001.option.b:0 &quot;来点钱呗！&quot;</span><br><span class="line"></span><br><span class="line"> test_action.1002.t:0 &quot;测试2&quot;</span><br><span class="line"> test_action.1002.desc:0 &quot;测试一下多个事件。&quot;</span><br><span class="line"> test_action.1002.option.a:0 &quot;嗯嗯！&quot;</span><br><span class="line"></span><br><span class="line">  test_action.1003.t:0 &quot;测试3&quot;</span><br><span class="line">  test_action.1003.desc:0 &quot;测试一下delay。&quot;</span><br><span class="line">  test_action.1003.option.a:0 &quot;加油！&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备好事件以后，就可以开始写<code>on_action</code>文件了。根据需求，我们的<code>on_action</code>应该是<code>on_marriage</code>，其中只包含<code>events</code>块。内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">on_marriage &#x3D; &#123;</span><br><span class="line">	events &#x3D; &#123;</span><br><span class="line">		test_action.1001</span><br><span class="line">		delay &#x3D; &#123; days &#x3D; 1 &#125;</span><br><span class="line">		test_action.1002</span><br><span class="line">		delay &#x3D; &#123; days &#x3D; &#123; 10 15 &#125; &#125;</span><br><span class="line">		test_action.1003</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来检查一下代码结构，看每个文件是否都在其对应的地方，我的代码结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- common</span><br><span class="line">	- on_action</span><br><span class="line">		test_on_action.txt</span><br><span class="line">- events</span><br><span class="line">	test_action_events.txt</span><br><span class="line">- localization</span><br><span class="line">	-simp_chinese</span><br><span class="line">		-event_localization</span><br><span class="line">			test_action_l_simp_chinses.yml</span><br></pre></td></tr></table></figure>
<p>实际上文件名并不严格要求按这个来，文件层级也不是特别严格，比如events里再套一层文件夹也没关系。</p>
<p>此外，<code>test_action_events</code>事件中某个选项会触发之前写过的<code>give_money_events</code>，这个事件和其相关文件在此就不列出了。</p>
</li>
<li><p>接下来进游戏加载mod，可以看到如下效果：</p>
<p>结婚当天（9月23日）触发第一个事件</p>
<p><img src="https://i.loli.net/2020/12/25/24QNcT3LekhHtpA.png" alt="image-20201225205736201"></p>
</li>
</ol>
<p>一天后（9月24日）触发第二个事件</p>
<p><img src="https://i.loli.net/2020/12/25/yA7d2Hzn9tMolkp.png" alt="image-20201225205913496"></p>
<p>15天后（10月8日）触发第3个事件</p>
<p><img src="https://i.loli.net/2020/12/25/PeXHlhZViFoK5zM.png" alt="image-20201225210107079"></p>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><p>除了一些游戏本身已经写好的<code>on_action</code>以外，我们也可以自己写<code>on_action</code>，并在决议、事件或其他会触发<code>on_action</code>的时候调用，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">trigger_event &#x3D; &#123;</span><br><span class="line">	on_action &#x3D; on_action_name</span><br><span class="line">	days&#x2F;months&#x2F;years &#x3D; X  	# 可选项，可以没有</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="现有的on-action"><a href="#现有的on-action" class="headerlink" title="现有的on_action"></a>现有的<code>on_action</code></h2><p>在这一部分中我整理列出了游戏本体中的一系列<code>on_action</code>的名称和触发条件（其实是根据名称猜的，所以可能有错），具体效果就不说明了。（实在是太多了……）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类别（文件名）</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">结盟（alliance_on_actions）</td>
<td style="text-align:center">on_alliance_added</td>
<td style="text-align:center">结成同盟</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_alliance_removed</td>
<td style="text-align:center">同盟到期移除</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_alliance_broken</td>
<td style="text-align:center">同盟破裂</td>
</tr>
<tr>
<td style="text-align:center">军队（army_on_actions）</td>
<td style="text-align:center">on_army_monthly</td>
<td style="text-align:center">玩家拥有的军队每30天自动触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_county_occupied</td>
<td style="text-align:center">当一个county完全被占领时触发，如果是被province owner重新占领则不触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_siege_completion</td>
<td style="text-align:center">当围攻完成时触发，如果是被province owner重新占领则不触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_siege_looting</td>
<td style="text-align:center">当围攻掠夺某一土地时触发（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_army_enter_province</td>
<td style="text-align:center">军队进入一个province时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_raid_action_start</td>
<td style="text-align:center">突袭发生时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_raid_action_completion</td>
<td style="text-align:center">突袭结束时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_raid_action_weekly</td>
<td style="text-align:center">突袭过程中每7天触发一次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_raid_loot_delivered</td>
<td style="text-align:center">当袭击者返回自己的领土并存入战利品时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_defeat_raid_army</td>
<td style="text-align:center">当突袭失败且战利品被盗时触发（？）</td>
</tr>
<tr>
<td style="text-align:center">战争（battle_on_actions）</td>
<td style="text-align:center">on_battle_owner_battle_end</td>
<td style="text-align:center">战争结束时，对战争双方触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_commander_battle_end</td>
<td style="text-align:center">战争结束时，对战争双方指挥官触发</td>
</tr>
<tr>
<td style="text-align:center">生日（birthday）</td>
<td style="text-align:center">on_birthday</td>
<td style="text-align:center">每个生日触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_specific_birthday</td>
<td style="text-align:center">几个特殊年龄的生日触发（3、6、10、15、16）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_birthday_childhood</td>
<td style="text-align:center">未成年且可以受教育的年龄触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_graceful_aging_birthday</td>
<td style="text-align:center">这个没注释，我也没看懂</td>
</tr>
<tr>
<td style="text-align:center">人物等级（character_levels）</td>
<td style="text-align:center">on_piety_level_gain</td>
<td style="text-align:center">信仰等级提升时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_piety_level_loss</td>
<td style="text-align:center">信仰等级降低时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_prestige_level_gain</td>
<td style="text-align:center">声望等级提升时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_prestige_level_loss</td>
<td style="text-align:center">声望等级降低时触发</td>
</tr>
<tr>
<td style="text-align:center">孩子出生（child_birth_on_actions）</td>
<td style="text-align:center">on_birth_mother</td>
<td style="text-align:center">生娃时对孩他妈触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_birth_father</td>
<td style="text-align:center">生娃时对孩他爸触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_birth_real_father</td>
<td style="text-align:center">生娃时对亲生父亲触发（只在亲生父亲和法理父亲不一样时触发）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_birth_child</td>
<td style="text-align:center">对新生儿触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_pregnancy_mother</td>
<td style="text-align:center">对怀孕状态的母亲触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_pregnancy_father</td>
<td style="text-align:center">对怀孕状态的父亲触发（<strong>这不是指男性怀孕</strong>）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_pregnancy_ended_mother</td>
<td style="text-align:center">怀孕结束时对母亲触发</td>
</tr>
<tr>
<td style="text-align:center">儿童时期（childhood_on_actions）</td>
<td style="text-align:center">child_personality_gain</td>
<td style="text-align:center">儿童性格特质等的获得</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">childhood_ongoing</td>
<td style="text-align:center">儿童时期触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_3rd_birthday</td>
<td style="text-align:center">3岁触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_6th_birthday</td>
<td style="text-align:center">6岁触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_10th_birthday</td>
<td style="text-align:center">10岁触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_15th_birthday</td>
<td style="text-align:center">15岁触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_16th_birthday</td>
<td style="text-align:center">16岁触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_action_add_sexuality</td>
<td style="text-align:center">获得性取向后触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_birthday_education_events</td>
<td style="text-align:center">教育事件触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">childhood_education_boost</td>
<td style="text-align:center">检查儿童是否需要教育</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">childhood_education</td>
<td style="text-align:center">教育事件的触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">childhood_education_patronage</td>
<td style="text-align:center">patronage-forcused或者scholarly 配偶会给儿童教育加分，这个赞助我没理解是什么意思，scholarly应该是指学识属性高</td>
</tr>
<tr>
<td style="text-align:center">战斗（combat_on_actions）</td>
<td style="text-align:center">on_combat_end_winner</td>
<td style="text-align:center">对打赢了的一方触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_combat_end_loser</td>
<td style="text-align:center">对打输了的一方触发</td>
</tr>
<tr>
<td style="text-align:center">内阁（councillor_on_actions）</td>
<td style="text-align:center">on_leave_council</td>
<td style="text-align:center">内阁成员辞职时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_fired_from_council</td>
<td style="text-align:center">领主从内阁解雇该角色时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">organize_the_levies_marshal_task_side_effects</td>
<td style="text-align:center">军事统帅任务事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">train_commanders_success_effect</td>
<td style="text-align:center">训练指挥官成功事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">train_commanders_marshal_task_side_effects</td>
<td style="text-align:center">训练指挥官军事统帅事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_increase_control_side_effects</td>
<td style="text-align:center">增强控制力任务事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_foreign_affairs_side_effects</td>
<td style="text-align:center">外交事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_domestic_affairs_side_effects</td>
<td style="text-align:center">国内事务列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_integrate_title_side_effects</td>
<td style="text-align:center">合并头衔事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_fabricate_claim_success_effect</td>
<td style="text-align:center">伪造宣称成功事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_collect_taxes_side_effects</td>
<td style="text-align:center">收税事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_develop_county_side_effects</td>
<td style="text-align:center">发展事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_promote_culture_side_effects</td>
<td style="text-align:center">文化事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_religious_relations_side_effects</td>
<td style="text-align:center">宗教关系事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_convert_side_effects</td>
<td style="text-align:center">转变文化事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_fabricate_claim_side_effects</td>
<td style="text-align:center">伪造宣称事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_support_schemes_side_effects</td>
<td style="text-align:center">支持密谋事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_disrupt_schemes_side_effects</td>
<td style="text-align:center">打断密谋事件列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_find_secrets_outcome</td>
<td style="text-align:center">寻找秘密的结果</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_find_secrets_reveal_selection</td>
<td style="text-align:center">揭示秘密选择列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">task_find_secrets_side_effects</td>
<td style="text-align:center">寻找秘密事件列表</td>
</tr>
<tr>
<td style="text-align:center">伯爵领（county_on_actions）</td>
<td style="text-align:center">on_county_faith_change</td>
<td style="text-align:center">伯爵领改信时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_county_culture_change</td>
<td style="text-align:center">伯爵领改文化时触发</td>
</tr>
<tr>
<td style="text-align:center">宫廷（court_maintenance_on_actions）</td>
<td style="text-align:center">on_join_court</td>
<td style="text-align:center">角色加入宫廷时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_leave_court</td>
<td style="text-align:center">角色离开宫廷时触发</td>
</tr>
<tr>
<td style="text-align:center">廷臣宾客（courtier_guest_management_on_actions）</td>
<td style="text-align:center">on_courtier_decided_to_move_to_pool</td>
<td style="text-align:center">廷臣打算离开时针对该廷臣触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_courtier_ready_to_move_to_pool</td>
<td style="text-align:center">廷臣准备好离开时针对该廷臣触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_guest_arrived_from_pool</td>
<td style="text-align:center">宾客到达时针对该宾客触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_guest_ready_to_move_to_pool</td>
<td style="text-align:center">宾客准备好离开时针对宾客触发</td>
</tr>
<tr>
<td style="text-align:center">文化（culture_on_actions）</td>
<td style="text-align:center">on_culture_era_changed</td>
<td style="text-align:center">文化区域改变时对该文化触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_character_culture_change</td>
<td style="text-align:center">角色改文化时对该角色触发</td>
</tr>
<tr>
<td style="text-align:center">死亡（death）</td>
<td style="text-align:center">on_death</td>
<td style="text-align:center">死亡时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_natural_death_second_chance</td>
<td style="text-align:center">角色即将自然死亡，但通过脚本获得第二次生命时触发</td>
</tr>
<tr>
<td style="text-align:center">宗族（dynasty_on_actions）</td>
<td style="text-align:center">on_dynasty_created</td>
<td style="text-align:center">建立宗族时触发</td>
</tr>
<tr>
<td style="text-align:center">游戏开始（game_start）</td>
<td style="text-align:center">on_game_start</td>
<td style="text-align:center">游戏开局一系列历史信息生成后触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_game_start_after_lobby</td>
<td style="text-align:center">进入游戏后触发，主要是和游戏规则相关的内容</td>
</tr>
<tr>
<td style="text-align:center">健康（health_on_actions）</td>
<td style="text-align:center">yearly_health_pulse</td>
<td style="text-align:center">每年的健康事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">disease_outbreak_pulse</td>
<td style="text-align:center">随机生病触发事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wounded_recovery_pulse</td>
<td style="text-align:center">伤口恢复触发事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit_suicide</td>
<td style="text-align:center">决议自杀触发</td>
</tr>
<tr>
<td style="text-align:center">骑士团（holy_order_on_actions）</td>
<td style="text-align:center">on_holy_order_new_lease</td>
<td style="text-align:center">骑士团获得领地（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_holy_order_hired</td>
<td style="text-align:center">骑士团被雇佣</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_holy_order_destroyed</td>
<td style="text-align:center">骑士团被解散</td>
</tr>
<tr>
<td style="text-align:center">骑士（knight_on_actions）</td>
<td style="text-align:center">on_knight_combat_pulse</td>
<td style="text-align:center">战争中每天针对骑士触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_commander_combat_pulse</td>
<td style="text-align:center">战争中每天对指挥官触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_commander_combat_finished</td>
<td style="text-align:center">战争后对指挥官触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_army_combat_finished</td>
<td style="text-align:center">战争后对每个参战军队触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">varangian_ongoing</td>
<td style="text-align:center">针对Varangian guard触发</td>
</tr>
<tr>
<td style="text-align:center">婚姻（marriage_concubinage）</td>
<td style="text-align:center">on_marriage</td>
<td style="text-align:center">结婚时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_divorce</td>
<td style="text-align:center">离婚时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_concubinage</td>
<td style="text-align:center">角色成为他人侧室时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_concubinage_end</td>
<td style="text-align:center">角色不当侧室时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_betrothal_broken</td>
<td style="text-align:center">婚约破裂时触发</td>
</tr>
<tr>
<td style="text-align:center">监狱（prison_on_actions）</td>
<td style="text-align:center">on_imprison</td>
<td style="text-align:center">被抓时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_release_from_prison</td>
<td style="text-align:center">被放时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">quarterly_prison_maintenance_pulse</td>
<td style="text-align:center">住监狱过程中触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">dungeon_ongoing</td>
<td style="text-align:center">关地牢过程中触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">house_arrest_ongoing</td>
<td style="text-align:center">软禁时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">escape_from_prison</td>
<td style="text-align:center">试图逃出监狱时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">escape_from_prison_success</td>
<td style="text-align:center">成功逃出监狱时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">escape_from_prison_failure</td>
<td style="text-align:center">逃跑失败触发</td>
</tr>
<tr>
<td style="text-align:center">领地（realm_maintenance_on_actions）</td>
<td style="text-align:center">realm_maintenance_quarterly_pulse</td>
<td style="text-align:center">当领主的过程中随机触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">in_debt_county_corruption_pulse</td>
<td style="text-align:center">负债时增加腐败</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">low_control_pulse</td>
<td style="text-align:center">控制力较低时触发（会增加腐败）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">high_countrol_pulse</td>
<td style="text-align:center">高控制力时触发（移除腐败）（这里的countrol真的没问题吗…）</td>
</tr>
<tr>
<td style="text-align:center">宗教（religion_on_actions）</td>
<td style="text-align:center">on_faith_created</td>
<td style="text-align:center">创建信仰时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_faith_conversion</td>
<td style="text-align:center">转变信仰时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_character_faith_change</td>
<td style="text-align:center">人物改信时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_faith_monthly</td>
<td style="text-align:center">每种信仰每个月触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">faith_holy_order_land_acquisition_pulse</td>
<td style="text-align:center">骑士团信仰</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">faith_heresy_events_pulse</td>
<td style="text-align:center">异端事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">faith_fervor_events_pulse</td>
<td style="text-align:center">宗教热情事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pagan_conversion_pulse</td>
<td style="text-align:center">异教徒转变事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_potential_great_holy_war_invalidation</td>
<td style="text-align:center">圣战目标无效时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_great_holy_war_invalidation</td>
<td style="text-align:center">上一个没找到新目标时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_great_holy_war_countdown_end</td>
<td style="text-align:center">圣战开始的倒计时为0时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_great_holy_war_participant_replaced</td>
<td style="text-align:center">圣战中角色被替换时触发</td>
</tr>
<tr>
<td style="text-align:center">规则（ruler_designer）</td>
<td style="text-align:center">on_ruler_designer_finished</td>
<td style="text-align:center">新人物设计好后触发（应该是指那个自定义统治者属性的玩法）</td>
</tr>
<tr>
<td style="text-align:center">秘密（secret_on_actions）</td>
<td style="text-align:center">secrets_ongoing</td>
<td style="text-align:center">处理秘密事件时触发</td>
</tr>
<tr>
<td style="text-align:center">压力应对决策（主要是不同特质会有特殊事件）（stress_coping_decisions_on_actions）</td>
<td style="text-align:center">stress_loss_drunkard</td>
<td style="text-align:center">酒鬼减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_hashishiyah</td>
<td style="text-align:center">瘾君子减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_rakish</td>
<td style="text-align:center">放荡者减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_reclusive</td>
<td style="text-align:center">隐居减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_irritable</td>
<td style="text-align:center">烦躁减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_flagellant</td>
<td style="text-align:center">自鞭笞者减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_profligate</td>
<td style="text-align:center">挥霍减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_improvident</td>
<td style="text-align:center">缺乏远见者减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_contrite</td>
<td style="text-align:center">懊悔减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_comfort_eater</td>
<td style="text-align:center">食以慰藉减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_inappetetic</td>
<td style="text-align:center">没有食欲减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_journaller</td>
<td style="text-align:center">写日记者减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_confider</td>
<td style="text-align:center">倾诉者减压时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_loss_athletic</td>
<td style="text-align:center">健身减压时触发</td>
</tr>
<tr>
<td style="text-align:center">压力（stress_on_actions）</td>
<td style="text-align:center">stress_pulse</td>
<td style="text-align:center">暂时忽略，注释说这个块可能会被删</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_stress_level_reduced</td>
<td style="text-align:center">压力等级降低时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_stress_level_1</td>
<td style="text-align:center">压力等级变为1时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_stress_level_2</td>
<td style="text-align:center">压力等级变为2时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_stress_level_3</td>
<td style="text-align:center">压力等级变为3时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_stress_level_4</td>
<td style="text-align:center">压力等级变为4时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_1_event</td>
<td style="text-align:center">压力达到1级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_2_event</td>
<td style="text-align:center">压力达到2级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_3_event</td>
<td style="text-align:center">压力达到3级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_1_event_prison</td>
<td style="text-align:center">角色在监狱中，压力达到1级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_2_event_prison</td>
<td style="text-align:center">角色在监狱中，压力达到2级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stress_threshold_level_3_event_prison</td>
<td style="text-align:center">角色在监狱中，压力达到3级阈值时触发</td>
</tr>
<tr>
<td style="text-align:center">头衔（title_on_actions）</td>
<td style="text-align:center">on_title_destroyed</td>
<td style="text-align:center">头衔被销毁时对头衔持有者触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_title_gain</td>
<td style="text-align:center">头衔获得时对该头衔的新持有者触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_title_gain_inheritance</td>
<td style="text-align:center">继承头衔时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_title_gain_usurpation</td>
<td style="text-align:center">篡夺头衔时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_title_lost</td>
<td style="text-align:center">失去头衔时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_explicit_claim_gain</td>
<td style="text-align:center">获得宣称时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_explicit_claim_lost</td>
<td style="text-align:center">失去宣称时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_rank_up</td>
<td style="text-align:center">头衔改变使角色升级时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_rank_down</td>
<td style="text-align:center">头衔改变使角色降级时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_vassal_gained</td>
<td style="text-align:center">得到封臣时触发</td>
</tr>
<tr>
<td style="text-align:center">特质（traits_on_actions）</td>
<td style="text-align:center">assign_trait_events</td>
<td style="text-align:center">到新压力等级时获取特质</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">assign_trait_ai_on_action</td>
<td style="text-align:center">AI随机获取特质的触发系统</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">assign_trait_on_action</td>
<td style="text-align:center">获取特殊特质</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ongoing_trait_events</td>
<td style="text-align:center">持有特殊特质时触发</td>
</tr>
<tr>
<td style="text-align:center">教程（tutorial）</td>
<td style="text-align:center">on_game_start_with_tutorial</td>
<td style="text-align:center">用教程开局时触发</td>
</tr>
<tr>
<td style="text-align:center">战争（war_on_actions）</td>
<td style="text-align:center">on_war_transferred</td>
<td style="text-align:center">战争中防御者改变时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_join_war_as_secondary</td>
<td style="text-align:center">角色作为战争的次要攻击者/次要防御者时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_war_started</td>
<td style="text-align:center">战争开始时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_war_won_attacker</td>
<td style="text-align:center">攻方赢得战争时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_war_won_defender</td>
<td style="text-align:center">守方赢得战争时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_war_white_peace</td>
<td style="text-align:center">战争无条件和平时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_war_invalidated</td>
<td style="text-align:center">战争无效时触发</td>
</tr>
<tr>
<td style="text-align:center">体重（weight_on_actions）</td>
<td style="text-align:center">on_weight_changed</td>
<td style="text-align:center">体重改变时触发（会触发一系列前面健康中的on_action）</td>
</tr>
<tr>
<td style="text-align:center">巫师（witch_on_actions）</td>
<td style="text-align:center">convert_to_witchcraft_failure_outcome</td>
<td style="text-align:center">转巫师失败时触发</td>
</tr>
<tr>
<td style="text-align:center">年度（yearly_on_actions）</td>
<td style="text-align:center">yearly_global_pulse</td>
<td style="text-align:center">每年1月1日触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">yearly_playable_pulse</td>
<td style="text-align:center">每年固定时间对可玩角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">three_year_playable_pulse</td>
<td style="text-align:center">每3年对可玩角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">five_year_playable_pulse</td>
<td style="text-align:center">每5年对可玩角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">quarterly_playable_pulse</td>
<td style="text-align:center">每季度对可玩角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">random_yearly_playable_pulse</td>
<td style="text-align:center">每年随机日期对可玩角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">random_yearly_everyone_pulse</td>
<td style="text-align:center">每年随机日期对所有角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">five_year_everyone_pulse</td>
<td style="text-align:center">每5年对所有角色触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">three_year_pool_pulse</td>
<td style="text-align:center">每3年对穷人触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">prison_maintenance_pulse</td>
<td style="text-align:center">角色监狱里关着人时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ai_character_pulse</td>
<td style="text-align:center">对AI触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_yearly_events</td>
<td style="text-align:center">每年随机日期触发</td>
</tr>
<tr>
<td style="text-align:center">活动-宴会（activities/feast_on_actions）</td>
<td style="text-align:center">feast_main_event_selection</td>
<td style="text-align:center">选择宴会主事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">feast_start_events</td>
<td style="text-align:center">宴会开始触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">feast_default_event_selection</td>
<td style="text-align:center">默认宴会主事件中对参与者触发的事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">feast_default_host_event_selection</td>
<td style="text-align:center">默认宴会主事件中对举办者触发的事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">feast_default_fallback</td>
<td style="text-align:center">宴会默认的返回事件</td>
</tr>
<tr>
<td style="text-align:center">活动-打猎（activities/hunt_on_actions）</td>
<td style="text-align:center">hunt_start_events</td>
<td style="text-align:center">打猎开始时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">hunt_random_pulse</td>
<td style="text-align:center">打猎过程中随机触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">hunt_end_pulse</td>
<td style="text-align:center">打猎结束触发</td>
</tr>
<tr>
<td style="text-align:center">活动-朝圣（activities/pilgrimage_on_actions）</td>
<td style="text-align:center">pilgrimage_setup</td>
<td style="text-align:center">朝圣开始</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pilgrimage_journey_events</td>
<td style="text-align:center">朝圣过程中触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">hajj_journey_events</td>
<td style="text-align:center">伊斯兰朝圣过程中触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pilgrimage_journey_event_fallback</td>
<td style="text-align:center">朝圣默认的返回事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pilgrimage_destination_events</td>
<td style="text-align:center">朝圣目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">hajj_destination_events</td>
<td style="text-align:center">伊斯兰目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">christian_destination_events</td>
<td style="text-align:center">基督徒目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">jewish_destination_events</td>
<td style="text-align:center">犹太人目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">muslim_destination_events</td>
<td style="text-align:center">穆斯林目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">hindu_destination_events</td>
<td style="text-align:center">印度教目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">buddhist_destination_events</td>
<td style="text-align:center">佛教徒目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">jain_destination_events</td>
<td style="text-align:center">耆那教目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">zoroastrian_destination_events</td>
<td style="text-align:center">拜火教目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">norse_destination_events</td>
<td style="text-align:center">挪威人目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">tengri_destination_events</td>
<td style="text-align:center">腾格里目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pagan_destination_events</td>
<td style="text-align:center">无信仰者目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pilgrimage_generic_destination_events</td>
<td style="text-align:center">普通目的地事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pilgrimage_return_events</td>
<td style="text-align:center">朝圣后返回事件</td>
</tr>
<tr>
<td style="text-align:center">生活方式-外交（lifestyles/diplomacy_lifestyle_on_actions）</td>
<td style="text-align:center">diplomacy_lifestyle_progress_pulse</td>
<td style="text-align:center">外交生活事件，一年触发4次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_lifestyle_ongoing_events</td>
<td style="text-align:center">外交生活中的事件（包括了下面几个）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_lifestyle_common_events</td>
<td style="text-align:center">外交生活中的普通事件（2年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_lifestyle_uncommon_events</td>
<td style="text-align:center">外交生活中的不普通事件（10年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_lifestyle_rare_events</td>
<td style="text-align:center">外交生活中的稀有事件（30年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_lifestyle_unavailable_events</td>
<td style="text-align:center">外交生活中的不可能事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_foreign_special_1010_court_visit_events</td>
<td style="text-align:center">外交事件链1</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">diplomacy_foreign_special_1010_court_visit_interesting_relation_spy_outcome_events</td>
<td style="text-align:center">外交事件链2</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commission_epic_ongoing</td>
<td style="text-align:center">制作家族史诗事件</td>
</tr>
<tr>
<td style="text-align:center">生活方式-普通（lifestyles/general_lifestyle_on_actions）</td>
<td style="text-align:center">on_perks_refunded</td>
<td style="text-align:center">玩家改生活方式时退还技能触发</td>
</tr>
<tr>
<td style="text-align:center">生活方式-谋略（lifestyles/intrigue_lifestyle_on_actions）</td>
<td style="text-align:center">intrigue_lifestyle_progress_pulse</td>
<td style="text-align:center">谋略生活事件，一年触发4次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">intrigue_lifestyle_ongoing_events</td>
<td style="text-align:center">谋略生活中的事件（包括了下面几个）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">intrigue_lifestyle_common_events</td>
<td style="text-align:center">谋略生活中的普通事件（2年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">intrigue_lifestyle_uncommon_events</td>
<td style="text-align:center">谋略生活中的不普通事件（10年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">intrigue_lifestyle_rare_events</td>
<td style="text-align:center">谋略生活中的稀有事件（30年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">intrigue_lifestyle_unavailable_events</td>
<td style="text-align:center">谋略生活中的不可能事件</td>
</tr>
<tr>
<td style="text-align:center">生活方式-学识（lifestyles/learning_lifestyle_on_actions）</td>
<td style="text-align:center">learning_lifestyle_progress_pulse</td>
<td style="text-align:center">学识生活事件，一年触发4次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learning_lifestyle_ongoing_events</td>
<td style="text-align:center">学识生活中的事件（包括了下面几个）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learning_lifestyle_common_events</td>
<td style="text-align:center">学识生活中的普通事件（2年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learning_lifestyle_uncommon_events</td>
<td style="text-align:center">学识生活中的不普通事件（10年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learning_lifestyle_rare_events</td>
<td style="text-align:center">学识生活中的稀有事件（30年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learning_lifestyle_unavailable_events</td>
<td style="text-align:center">学识生活中的不可能事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">book_translation_story_events</td>
<td style="text-align:center">翻译书事件（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">mystic_communion_side_effect_events</td>
<td style="text-align:center">神秘圣餐事件（？不确定）</td>
</tr>
<tr>
<td style="text-align:center">生活方式-军事（lifestyles/martial_lifestyle_on_actions）</td>
<td style="text-align:center">martial_lifestyle_progress_pulse</td>
<td style="text-align:center">军事生活事件，一年触发4次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">martial_lifestyle_ongoing_events</td>
<td style="text-align:center">军事生活中的事件（包括了下面几个）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">martial_lifestyle_common_events</td>
<td style="text-align:center">军事生活中的普通事件（2年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">martial_lifestyle_uncommon_events</td>
<td style="text-align:center">军事生活中的不普通事件（10年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">martial_lifestyle_rare_events</td>
<td style="text-align:center">军事生活中的稀有事件（30年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">martial_lifestyle_unavailable_events</td>
<td style="text-align:center">军事生活中的不可能事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">horse_riding_accident_outcome</td>
<td style="text-align:center">骑马意外事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">search_for_troops_event_selection</td>
<td style="text-align:center">搜索部队事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learn_commander_trait_offer</td>
<td style="text-align:center">获得指挥官特质的机会</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learn_commander_trait_test</td>
<td style="text-align:center">获得指挥官特质的测试</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learn_commander_trait_success</td>
<td style="text-align:center">成功获得指挥官特质</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">learn_commander_trait_failure</td>
<td style="text-align:center">未能获得指挥官特质</td>
</tr>
<tr>
<td style="text-align:center">生活方式-管理（lifestyles/stewardship_lifestyle_on_actions）</td>
<td style="text-align:center">stewardship_lifestyle_progress_pulse</td>
<td style="text-align:center">管理生活事件，一年触发4次</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_ongoing_events</td>
<td style="text-align:center">管理生活中的事件（包括了下面几个）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_common_events</td>
<td style="text-align:center">管理生活中的普通事件（2年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_uncommon_events</td>
<td style="text-align:center">管理生活中的不普通事件（10年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_rare_events</td>
<td style="text-align:center">管理生活中的稀有事件（30年1次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_unavailable_events</td>
<td style="text-align:center">管理生活中的不可能事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">map_painting_event_selection</td>
<td style="text-align:center">绘制地图选项</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">map_painting_outcome</td>
<td style="text-align:center">绘制地图结果</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_road_building_chain</td>
<td style="text-align:center">修路事件链</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_road_building_events</td>
<td style="text-align:center">修路事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_domesday</td>
<td style="text-align:center">末日审判事件（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_lifestyle_domesday_end</td>
<td style="text-align:center">默认审判结束事件（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_duty_special_2000_mediation_stage_1</td>
<td style="text-align:center">调解事件阶段1（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_duty_special_2000_mediation_stage_2</td>
<td style="text-align:center">调解事件阶段2（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">stewardship_duty_special_2000_mediation_background_events</td>
<td style="text-align:center">调解背景事件（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">sell_titles_side_effect_events</td>
<td style="text-align:center">买卖头衔副作用事件</td>
</tr>
<tr>
<td style="text-align:center">关系-主教（relations/bishop_on_actions）</td>
<td style="text-align:center">bishop_ongoing</td>
<td style="text-align:center">有主教时随机触发</td>
</tr>
<tr>
<td style="text-align:center">关系-父母（relations/parent_on_actions）</td>
<td style="text-align:center">parent_ongoing</td>
<td style="text-align:center">有父母时随机触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">parent_meddling_outcome</td>
<td style="text-align:center">父母干涉的结果</td>
</tr>
<tr>
<td style="text-align:center">关系-关系（relations/relation_on_actions）</td>
<td style="text-align:center">relation_upgrade_quarterly_pulse</td>
<td style="text-align:center">关系升级事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_quarterly_pulse</td>
<td style="text-align:center">恋人事件（一季度一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_ongoing</td>
<td style="text-align:center">恋人事件（一年一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_ongoing_fallback</td>
<td style="text-align:center">恋人事件的返回</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_ongoing_distance</td>
<td style="text-align:center">异地恋事件（一年一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_ongoing_distance_fallback</td>
<td style="text-align:center">异地恋事件返回</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lover_status_changes</td>
<td style="text-align:center">恋爱状态改变</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_set_relation_lover</td>
<td style="text-align:center">有恋人时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_remove_relation_lover</td>
<td style="text-align:center">失去恋人时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">friendship_quarterly_pulse</td>
<td style="text-align:center">朋友事件（一季度一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">friendship_status_changes</td>
<td style="text-align:center">朋友状态改变</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">friendship_ongoing</td>
<td style="text-align:center">朋友事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_set_relation_friend</td>
<td style="text-align:center">得到朋友</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_remove_relation_friend</td>
<td style="text-align:center">失去朋友（只和关系破裂有关，不会因为朋友凉了而触发）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_death_relation_friend</td>
<td style="text-align:center">朋友去世</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">rival_quarterly_pulse</td>
<td style="text-align:center">仇敌事件（一季度一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">rival_relation_changes</td>
<td style="text-align:center">仇敌改变事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">rivalry_ongoing</td>
<td style="text-align:center">仇敌事件（一年一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">rivalry_ongoing_fallback</td>
<td style="text-align:center">仇敌事件返回</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_set_relation_rival</td>
<td style="text-align:center">得到仇敌</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_remove_relation_rival</td>
<td style="text-align:center">失去仇敌</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">mentor_student_quarterly_pulse</td>
<td style="text-align:center">师生事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">mentor_student_relation_changes</td>
<td style="text-align:center">师生关系改变</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_remove_relation_guardian</td>
<td style="text-align:center">解除监护人时对被监护人触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_death_relation_guardian</td>
<td style="text-align:center">有监护人的被监护人死亡时，对被监护人触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_remove_relation_ward</td>
<td style="text-align:center">解除监护人时对监护人触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_death_relation_ward</td>
<td style="text-align:center">有被监护人的监护人死亡时，对监护人触发</td>
</tr>
<tr>
<td style="text-align:center">关系-兄弟（relations/sibling_on_actions）</td>
<td style="text-align:center">sibling_quarterly_pulse</td>
<td style="text-align:center">兄弟事件（一季度一次）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">sibling_statuses</td>
<td style="text-align:center">兄弟状态</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ongoing_sibling</td>
<td style="text-align:center">兄弟事件</td>
</tr>
<tr>
<td style="text-align:center">关系-配偶（relations/spouse_on_actions）</td>
<td style="text-align:center">spouse_ongoing</td>
<td style="text-align:center">配偶事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">spouse_councillor_default_on_action</td>
<td style="text-align:center">配偶内阁事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">court_politics_setup</td>
<td style="text-align:center">接下来的几个应该都是指配偶和内阁其他人的互动事件，不太确定，因此不写了。</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">court_politics_task_on_action</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">chivalry_setup</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">chivalry_task_on_action</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">court_intrigue_setup</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">court_intrigue_task_on_action</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">manage_domain_setup</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">manage_domain_task_on_action</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">patronage_setup</td>
<td style="text-align:center">配偶赞助开始</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">patronage_task_on_action</td>
<td style="text-align:center">配偶赞助任务</td>
</tr>
<tr>
<td style="text-align:center">关系-封臣（relations/vassal_on_actions）</td>
<td style="text-align:center">on_vassal_become_powerful</td>
<td style="text-align:center">封臣变强力时触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">vassal_ongoing</td>
<td style="text-align:center">有封臣时触发</td>
</tr>
<tr>
<td style="text-align:center">计谋-绑架（schemes/abduct_on_actions）</td>
<td style="text-align:center">abduct_setup</td>
<td style="text-align:center">绑架开始</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">standard_abduct_method_setup</td>
<td style="text-align:center">绑架方式（？没绑架过，不清楚流程）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">abduct_succeeded</td>
<td style="text-align:center">绑架成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">abduct_failed</td>
<td style="text-align:center">绑架失败</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">abduct_ongoing</td>
<td style="text-align:center">绑架进行中</td>
</tr>
<tr>
<td style="text-align:center">计谋-拉拢（schemes/befriend_on_actions）</td>
<td style="text-align:center">befriend_ongoing</td>
<td style="text-align:center">交友进行中</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_dislike_ongoing</td>
<td style="text-align:center">和不喜欢的人交友</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_rival_ongoing</td>
<td style="text-align:center">和仇敌交友</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_critical_success</td>
<td style="text-align:center">交友成功关键点（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_success</td>
<td style="text-align:center">交友成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_failure</td>
<td style="text-align:center">交友失败</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">befriend_critical_failure</td>
<td style="text-align:center">交友失败关键点（？不确定）</td>
</tr>
<tr>
<td style="text-align:center">计谋-宣称权位（schemes/claim_throne_on_actions）</td>
<td style="text-align:center">claim_throne_setup</td>
<td style="text-align:center">宣称开始</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">standard_claim_throne_method_setup</td>
<td style="text-align:center">宣称方法</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">claim_throne_succeeded</td>
<td style="text-align:center">宣称成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">claim_throne_failed</td>
<td style="text-align:center">宣称失败</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">claim_throne_ongoing</td>
<td style="text-align:center">宣称进行中</td>
</tr>
<tr>
<td style="text-align:center">计谋-廷臣（schemes/court_on_actions）</td>
<td style="text-align:center">court_ongoing</td>
<td style="text-align:center">廷臣事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">court_outcome</td>
<td style="text-align:center">廷臣事件结果</td>
</tr>
<tr>
<td style="text-align:center">计谋-私奔（schemes/elope_on_actions）</td>
<td style="text-align:center">elope_ongoing</td>
<td style="text-align:center">私奔进行时</td>
</tr>
<tr>
<td style="text-align:center">计谋-牵制（schemes/fabricate_hook_on_actions）</td>
<td style="text-align:center">abricate_hook_method_success_outcome</td>
<td style="text-align:center">伪造牵制成功结果</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">fabricate_hook_ongoing</td>
<td style="text-align:center">伪造牵制进行中</td>
</tr>
<tr>
<td style="text-align:center">计谋-谋杀（schemes/murder_on_actions）</td>
<td style="text-align:center">murder_method_selection</td>
<td style="text-align:center">（dbq这部分我懒得写了…）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">infant_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">child_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">incapable_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">dungeon_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">house_arrest_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">standard_murder_method_selection</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_setup</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_save_roll</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_save_response</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_succeeded</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_failed</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murder_ongoing</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">计谋-勾引（schemes/seduce_on_actions）</td>
<td style="text-align:center">seduce_ongoing_milestone_1</td>
<td style="text-align:center">勾引阶段1</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">seduce_ongoing_milestone_2</td>
<td style="text-align:center">勾引阶段2</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">seduce_success</td>
<td style="text-align:center">勾引成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">seduce_generic_success</td>
<td style="text-align:center">勾引成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">seduce_failure</td>
<td style="text-align:center">勾引失败</td>
</tr>
<tr>
<td style="text-align:center">计谋-拉拢（schemes/sway_on_actions）</td>
<td style="text-align:center">sway_success</td>
<td style="text-align:center">拉拢成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">sway_failure</td>
<td style="text-align:center">拉拢失败</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">sway_ongoing</td>
<td style="text-align:center">拉拢进行时</td>
</tr>
<tr>
<td style="text-align:center">周期故事-猫（story_cycles/story_cycle_cat_on_actions）</td>
<td style="text-align:center">ongoing_cat_events</td>
<td style="text-align:center">有猫时触发的事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">story_cycle_cat_pet_decision_on_actions</td>
<td style="text-align:center">决议养猫</td>
</tr>
<tr>
<td style="text-align:center">周期故事-狗（story_cycles/story_cycle_dog_on_actions）</td>
<td style="text-align:center">ongoing_dog_events</td>
<td style="text-align:center">有狗时触发事件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">story_cycle_dog_pet_decision_on_actions</td>
<td style="text-align:center">决议养狗</td>
</tr>
<tr>
<td style="text-align:center">周期故事-打猎神秘动物（story_cycle_hunt_mystical_animal_on_actions）</td>
<td style="text-align:center">ongoing_hunt_mystical_animal_events</td>
<td style="text-align:center">打猎时的神秘动物</td>
</tr>
<tr>
<td style="text-align:center">周期故事-谋杀系列（story_cycles/story_cycle_murders_at_court_on_actions）</td>
<td style="text-align:center">murders_at_court_events</td>
<td style="text-align:center">谋杀系列事件（就是那个很奇怪可怕的发现尸体等等一系列事件）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">murders_at_court_confrontation</td>
<td style="text-align:center">最终结果</td>
</tr>
<tr>
<td style="text-align:center">周期故事-宴会？（story_cycles/story_cycle_party_baron_on_actions）</td>
<td style="text-align:center">party_baron_events</td>
<td style="text-align:center">看本地化文件是宴会上的事情，不知道这个要怎么解释</td>
</tr>
<tr>
<td style="text-align:center">周期故事-农民（story_cycles/story_cycle_peasant_affair_on_actions）</td>
<td style="text-align:center">peasant_affair_shows_up_at_court</td>
<td style="text-align:center">农民来时触发（？不确定）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">peasant_affair_looking_for_peasant</td>
<td style="text-align:center">寻找农民</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">peasant_affair_peasant_at_court</td>
<td style="text-align:center">农民来找你时触发（比如想让你认个儿子）</td>
</tr>
<tr>
<td style="text-align:center">周期故事-重建罗马（story_cycles/story_cycle_roman_restoration_on_actions）</td>
<td style="text-align:center">on_action_roman_restoration_pulse</td>
<td style="text-align:center">重建罗马触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">on_action_orthodox_pentarchy_pulse</td>
<td style="text-align:center">拜占庭恢复五大牧首区</td>
</tr>
<tr>
<td style="text-align:center">周期故事-受尊敬的领主（story_cycles/story_cycle_statecraft_lifestyle_respected_liege_on_actions）</td>
<td style="text-align:center">ongoing_respected_liege_events</td>
<td style="text-align:center">受尊敬的领主（这块代码还没写，是空的）</td>
</tr>
<tr>
<td style="text-align:center">周期故事-战马（story_cycles/story_cycle_warhorse_on_actions）</td>
<td style="text-align:center">ongoing_warhorse_events</td>
<td style="text-align:center">有战马时随机触发</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">breed_warhorse</td>
<td style="text-align:center">战马繁殖事件</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode记录-1</title>
    <url>/2020/12/21/Leetcode%E8%AE%B0%E5%BD%95-1/</url>
    <content><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">链接</a></p>
<p>给定一个整数数组<code>nums</code>和一个整数目标值<code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,3], target &#x3D; 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>2 &lt;= <code>nums.length</code> &lt;= 103</li>
<li>-109 &lt;= <code>nums[i]</code> &lt;= 109</li>
<li>-109 &lt;= <code>target</code> &lt;= 109</li>
<li>只会存在一个有效答案</li>
</ol>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    * returnSize=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> result[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numsSize<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;numsSize; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[j]==target)&#123;</span><br><span class="line">                result[<span class="number">0</span>]=i;</span><br><span class="line">                result[<span class="number">1</span>]=j;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><ol>
<li>指针没学好，所以其实还是没懂为什么一开始要指定<code>* returnSize=2;</code></li>
<li>是最普通的遍历判断是否正确的过程，没有什么复杂算法</li>
<li>第3行如果不用静态数组，则最后返回的时候数组生命周期就结束了，会返回一个空数组</li>
<li>还有一些同样思路的代码写法，但是输出的时候不对，总是输出<code>]</code>，猜测和OJ系统的gcc有关，暂且不管</li>
</ol>
<h2 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h2><p><a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/" target="_blank" rel="noopener">参考链接</a></p>
<ol>
<li><p>哈希表（C语言的哈希表代码略长，所以改用python）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        hashtable = dict()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target - num], i]</span><br><span class="line">            hashtable[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
</li>
<li><p>首尾递进查找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sorted_id = sorted(range(len(nums)), key=<span class="keyword">lambda</span> k: nums[k])</span><br><span class="line">        head = <span class="number">0</span></span><br><span class="line">        tail = len(nums) - <span class="number">1</span></span><br><span class="line">        sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]]</span><br><span class="line">        <span class="keyword">while</span> sum_result != target:</span><br><span class="line">            <span class="keyword">if</span> sum_result &gt; target:</span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> sum_result &lt; target:</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">            sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]]</span><br><span class="line">        <span class="keyword">return</span> [sorted_id[head], sorted_id[tail]]</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-6</title>
    <url>/2020/12/16/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-6/</url>
    <content><![CDATA[<h1 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h1><h2 id="基础格式"><a href="#基础格式" class="headerlink" title="基础格式"></a>基础格式</h2><ol>
<li><p>特质相关的文件有两个，第一个是对特质的说明，存放在文件夹<code>Crusader Kings III\game\common\traits</code>中，文件名为<code>00_traits.txt</code>，同目录下有一个<code>_traits.info</code>是说明怎么写特质；第二个是本地化文本文件，<code>Crusader Kings III\game\localization\simp_chinese\traits_l_simp_chinese.yml</code>，其他语言的也是类似路径。</p>
</li>
<li><p>目前游戏里有277个特质，在<a href="https://ck3.parawikis.com/wiki/%E7%89%B9%E8%B4%A8" target="_blank" rel="noopener">wiki</a>中已经有人整理过特质的分类和效果等信息。</p>
</li>
<li><p>从<code>_traits.info</code>中我们可以看到，一个特质<code>trait_&lt;key&gt;</code>对应的描述在本地化文本中应该是<code>trait_&lt;key&gt;_desc</code>，而默认图标是<code>gfx/interface/icons/traits/&lt;trait&gt;.dds</code>文件。</p>
</li>
<li><p>特质默认加给玩家角色，也就是<code>root</code>。</p>
</li>
<li><p>显然，一个最基础的特质<code>test_trait</code>由3部分组成：</p>
<ol>
<li><p>特质图标：<code>gfx/interface/icons/traits/test_trait.dds</code></p>
</li>
<li><p>特质内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test_trait &#x3D; &#123;</span><br><span class="line">	index &#x3D; 278</span><br><span class="line">	desc &#x3D; &#123;</span><br><span class="line">		first_valid &#x3D; &#123;</span><br><span class="line">			triggered_desc &#x3D; &#123;</span><br><span class="line">				trigger &#x3D; &#123;</span><br><span class="line">					NOT &#x3D; &#123; exists &#x3D; this &#125;</span><br><span class="line">				&#125;</span><br><span class="line">				desc &#x3D; trait_test_trait_desc</span><br><span class="line">			&#125;</span><br><span class="line">			desc &#x3D; trait_test_trait_character_desc</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特质文本描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> # test traits</span><br><span class="line"> trait_test_trait:0 &quot;XXX&quot;</span><br><span class="line"> trait_test_trait_desc:0 &quot;XXX&quot;</span><br><span class="line"> trait_test_trait_character_desc:0 &quot;XXX&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要注意的是，在特质内容中，为了保证触发特效时该角色是存在的，我们需要进行<code>first_valid</code>来验证<code>Root</code>存在。</p>
</li>
<li><p>文本描述中，如果需要出现角色的名字，可以通过<code>[ROOT.GetCharacter.GetFirstNameNoTooltip]</code>来获取角色名。</p>
</li>
</ol>
</li>
<li><p>当我们按照上一条中，准备好对应的图标，并在mod文件夹中建立了<code>traits</code>文件夹和相应的特质文件，以及本地化内容也新建了文件，就会得到如下文件结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- test</span><br><span class="line">	- common</span><br><span class="line">		- traits</span><br><span class="line">			01_traits.txt</span><br><span class="line">	- gfx</span><br><span class="line">		- interface</span><br><span class="line">			- icons</span><br><span class="line">				- traits</span><br><span class="line">					test_trait.dds</span><br><span class="line">	- localization</span><br><span class="line">		- simp_chinese</span><br><span class="line">			- traits_test_l_simp_chinese.yml</span><br><span class="line">	descriptor.mod</span><br></pre></td></tr></table></figure>
<p>需要注意的是，特质文件和本地化文件的文件名本身并不是很重要，但是如果和CK3官方的那俩文件重名，则需要把那两个文件中的内容也原封不动复制过来，否则本身自带的特质就会都没法用。</p>
</li>
<li><p>准备好一系列文件以后，打开游戏通过<code>add_traits</code>指令增加特质，就可以看到对应的特质了。</p>
</li>
</ol>
<h2 id="一些具体设置"><a href="#一些具体设置" class="headerlink" title="一些具体设置"></a>一些具体设置</h2><ol>
<li>除了上述的文本描述以外，特质还可以增加很多具体设置，例如对角色的影响、获取的触发条件等等。以下内容是对<code>_traits.info</code>文件的翻译。</li>
<li><code>health</code>：表示该特质对健康的修正，例如在特质身心俱悉（<code>whole_of_body</code>）中，有一条<code>health = 0.5</code>，表示有该特质的角色健康+0.5。</li>
<li><code>fertility</code>：表示该特质对生育力的修正百分比，例如还是身心俱悉中，有一条<code>fertility = 0.2</code>表示该角色的生育力+25%。</li>
<li><code>inherit_chance</code>：表示该特质遗传给孩子的概率，例如特质梅毒<code>great_pox</code>中有一条<code>inherit_chance = 10</code>，表示遗传概率是10%。</li>
<li><code>birth</code>：表示有百分之多少的人会带着这个特质出生。</li>
<li><code>random_creation</code>：表示有百分之多少的人会带着这个特质被创造出来。和出生不一样的是，创造是指通过命令行生成和修改人物。不过根据检索，<code>00_traits</code>文件里的<code>birth</code>和<code>random_creation</code>都是一起出现的，且值相等。</li>
<li><code>triggered_opinion</code>：这一条应该是针对角色好感度修正特质的触发器，它包括以下内容：<ol>
<li><code>opinion_modifier</code>：修正的好感度类型</li>
<li><code>parameter</code>：要检查的布尔值参数</li>
<li><code>check_missing</code>：检查参数是否没设置（或设置为 false），而不是设置为 true</li>
<li><code>same_faith</code>：相同信仰</li>
<li><code>same_dynasty</code>：相同宗族</li>
<li><code>ignore_opinion_value_if_same_trait</code>：设置为<code>yes</code>的时候，会对有相同特质的角色不进行好感度修正，但是惩罚理由还在</li>
<li><code>male_only</code>和<code>female_only</code>很显然分别是仅限男性和仅限女性</li>
</ol>
</li>
<li><code>compatibility</code>：这是用于<code>compatibility_modifier</code>和<code>trait_compatibility</code>这两个触发器的，是检查特质持有者与列出的特质的兼容性。感觉是指获取某一特质后，再获取其他特质的概率会受这个列表值的修正。具体怎么用还不太明白，之后补充。</li>
<li><code>parent_inheritance_sex</code>：可以是<code>male/female/all</code>，表示该特质可以从父亲/母亲/双亲继承。</li>
<li><code>child_inheritance_sex</code>：值同上，表示该特质可以遗传给男孩/女孩/所有孩子。</li>
<li><code>genetic</code>：默认是<code>no</code>，如果被设置为<code>yes</code>，则表示特征可以是非活动状态。子级可以从活动和非活动父特征中继承该特征。活动特征继承为 100% 的机会，非活动特征为 50% 的机会。如果从父母两个成功继承该特征，则该特征将变为活动状态。如果仅从一个父级继承，则它是非活动状态。（可以理解成生物学基因的隐性显性）。</li>
<li><code>inherit_from_real_father</code>：是否可以从亲生父亲那里继承，其实不太懂这个和前面<code>parent_inheritance_sex</code>有什么不一样的。</li>
<li><code>enables_inbred</code>：概括来说这个标志为<code>yes</code>时意味着这个特质是近亲繁殖的。</li>
<li><code>good</code>：特质标识为好的（默认值是<code>no</code>，表示坏的）。</li>
<li><code>genetic_constraint_all</code>：这种遗传约束将在获得特征时应用。</li>
<li><code>forced_portrait_age_index</code>：年龄索引，可以设置多个，但是我还不知道年龄索引是什么东西，以后补充。</li>
<li><code>portrait_extremity_shift</code>：这个值是一个表示百分比的小数，角色获得对应特质时，每个变形基因都会按这个百分比向 0 或 1 移动，具体是0还是1看基因本身接近哪个，比如该值为0.25， 基因值为0.4，则0.4将向0偏移0.25，从而变成0.3。</li>
<li><code>ugliness_portrait_extremity_shift</code>：和上一条一样，但是获得此特质时，与角色最极端的单一特征（在公共/基因中定义）相关的每个变形基因都会按此百分比向 0 或 1 移动。关于这里的特征、基因等词还不太了解，以后再补充。</li>
<li><code>immortal</code>：设置为<code>yes</code>后，获得该特质的角色会停止视觉老化，使角色对自然死亡免疫。仍然可以被脚本杀死。生育能力将匹配视觉年龄。可以使用<code>set_immortal_age</code>更改视觉年龄。</li>
<li><code>physical, health_trait, fame</code>：这三个设置为<code>yes</code>则分别表示该特质是和物理、健康、名誉相关。</li>
<li><code>trait_exclusive_if_realm_contains</code>：这个值是<code>{}</code>，大括号里可以填东西，表示随机分配给指挥官时考虑的地形类型列表。只有当指挥官的文化包含具有列表中指定的地形类型之一的省时，才分配/考虑这些特征。</li>
<li><code>blocks_from_claim_inheritance</code>：设置为<code>yes</code>时，有该特质的角色无法继承头衔宣称。</li>
<li><code>blocks_from_claim_inheritance_from_dynasty</code>：同上，设置为<code>yes</code>时，有该特质的角色无法从宗族成员那里继承头衔宣称。</li>
<li><code>shown_in_ruler_designer</code>：默认是<code>yes</code>，设置为<code>yes</code>时，可以在自定义角色的那个地方的特质列表中看到该特质。</li>
<li><code>ruler_designer_cost</code>：默认是0，同上，是指自定义角色时该特质消耗的点数。</li>
<li><code>valid_sex</code>：可以是<code>all/male/female</code>，默认是<code>all</code>，表示该特质可以由什么性别的角色获得。</li>
</ol>
<h2 id="如何使角色得到特质"><a href="#如何使角色得到特质" class="headerlink" title="如何使角色得到特质"></a>如何使角色得到特质</h2><p>和命令行一样，在<code>mod</code>里需要角色获取特质的时候，<code>add_trait = trait_ID</code>即可。</p>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-5</title>
    <url>/2020/11/08/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-5/</url>
    <content><![CDATA[<h1 id="条件式"><a href="#条件式" class="headerlink" title="条件式"></a>条件式</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>条件式的基本结构和CK2里一样，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if &#x3D; &#123;</span><br><span class="line">	limit &#x3D; &#123;</span><br><span class="line">		# 条件</span><br><span class="line">	&#125;</span><br><span class="line">	# 符合条件时执行的指令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实条件式不仅限于if语句，在其他地方也会出现这样<code>limit = ...</code>的句式，用来表示执行指令的条件。</p>
<p>接下来沿用之前的例子，将送钱的事件写一个条件式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace &#x3D; give_money</span><br><span class="line">give_money.1 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; give_money.1.t</span><br><span class="line">	desc &#x3D; give_money.1.desc</span><br><span class="line">	theme &#x3D; stewardship</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.a</span><br><span class="line">		add_gold &#x3D; 1000</span><br><span class="line">		add_prestige &#x3D; -500</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.b</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.c</span><br><span class="line">		if &#x3D; &#123;</span><br><span class="line">			limit &#x3D; &#123;</span><br><span class="line">				gold &gt;1000</span><br><span class="line">			&#125;</span><br><span class="line">			remove_short_term_gold &#x3D; 1000</span><br><span class="line">			add_prestige &#x3D; 500</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，现在第三个选项是有条件执行的，当金币大于1000时，会执行减少金钱增加虔诚的指令，而金币不足则不会执行。具体到游戏中，界面如下图，当右上角金币只有26的时候，第三个选项是没有直接影响；而金币超过1000时，则第三个选项变成了扣钱换虔诚。</p>
<p><img src="https://i.loli.net/2020/12/05/nUe1ExpMmFwiJgr.png" alt="image-20201205211819919"></p>
<p><img src="https://i.loli.net/2020/12/05/EMmug4AC7KRUFrS.png" alt="image-20201205212017719"></p>
<h2 id="增加分支"><a href="#增加分支" class="headerlink" title="增加分支"></a>增加分支</h2><p>在一些情况下，我们需要表达“如果满足条件，则执行A指令；反之，则执行B指令”，这种情况就不能简单地用上面的结构来实现，而是使用else语句，具体结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if &#x3D; &#123;</span><br><span class="line">	limit &#x3D; &#123;</span><br><span class="line">		# 条件</span><br><span class="line">	&#125;</span><br><span class="line">	# 符合条件时执行的指令</span><br><span class="line">&#125;</span><br><span class="line">else &#x3D; &#123;</span><br><span class="line">	# 不符合条件时执行的指令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如我们希望，当金钱不够1000时加200虔诚，不扣钱，那就如下改写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option &#x3D; &#123;</span><br><span class="line">	name &#x3D; give_money.1.option.c</span><br><span class="line">	if &#x3D; &#123;</span><br><span class="line">		limit &#x3D; &#123;</span><br><span class="line">			gold &gt;1000</span><br><span class="line">		&#125;</span><br><span class="line">		remove_short_term_gold &#x3D; 1000</span><br><span class="line">		add_prestige &#x3D; 500</span><br><span class="line">	&#125;</span><br><span class="line">	else &#x3D; &#123;</span><br><span class="line">		add_prestige &#x3D; 200</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体效果如下图，当金币够1000时，和前面一样；而金币不够1000时，则只有加200虔诚。</p>
<p><img src="https://i.loli.net/2020/12/05/42FCzK9NsnlEhZ5.png" alt="image-20201205213507855"></p>
<p><img src="https://i.loli.net/2020/12/05/VbFYSnlX19IqHAp.png" alt="image-20201205213724688"></p>
<ul>
<li>需要补充说明的是，CK2中没有else语句，而是通过增加break来实现分支的；相反，CK3中无法通过break来实现分支。</li>
</ul>
<h1 id="随机性结果"><a href="#随机性结果" class="headerlink" title="随机性结果"></a>随机性结果</h1><p>当我们希望某个选项的结果随机出现的时候，就需要用到<code>Random</code>，它有以下两种用法：</p>
<ol>
<li><p>该选项有一定概率得到某种结果，或者无事发生：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">random &#x3D; &#123;</span><br><span class="line">	chance &#x3D; 概率值</span><br><span class="line">	选项结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，我们将之前的事件中的第二个选项修改成如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option &#x3D; &#123;</span><br><span class="line">	name &#x3D; give_money.1.option.b</span><br><span class="line">	random &#x3D; &#123;</span><br><span class="line">		chance &#x3D; 50</span><br><span class="line">		add_gold &#x3D; 1000</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个选项很容易理解，有50%的概率得到1000金币，游戏中的截图如下：</p>
<p><img src="https://i.loli.net/2020/12/10/GLtuAOkoBDZ4S8h.png" alt="image-20201210193754167"></p>
<p>顺带一提，明明是50%的概率，我却直到第5次才获得1000……</p>
</li>
<li><p>更多情况我们会希望得到多个随机结果，这时就要用<code>Random_list</code>，结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">random_list &#x3D; &#123;</span><br><span class="line">	概率1 &#x3D; &#123;</span><br><span class="line">		第一个结果</span><br><span class="line">	&#125;</span><br><span class="line">	概率2 &#x3D; &#123;</span><br><span class="line">		第二个结果</span><br><span class="line">	&#125;</span><br><span class="line">	概率3 &#x3D; &#123;</span><br><span class="line">		第三个结果</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种结构下，每个情况的触发概率并不是直接的百分比，而是该选项值占所有概率总和的百分比，具体来说，比如（30，30，15）这样的组合中，第一个选项的概率并不是30%，而是30/75，也就是40%。</p>
<p>我们再将刚才的事件进行如下修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option &#x3D; &#123;</span><br><span class="line">	name &#x3D; give_money.1.option.b</span><br><span class="line">	random_list &#x3D; &#123;</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			add_gold &#x3D; 1000</span><br><span class="line">		&#125;</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			add_gold &#x3D; 100</span><br><span class="line">		&#125;</span><br><span class="line">		15 &#x3D; &#123;</span><br><span class="line">			remove_short_term_gold &#x3D; 200</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样修改后，游戏中的截图如下：</p>
<p><img src="https://i.loli.net/2020/12/10/T1wtGmAWIkvqrCo.png" alt="image-20201210194729366"></p>
</li>
</ol>
<h2 id="有触发的随机性条件"><a href="#有触发的随机性条件" class="headerlink" title="有触发的随机性条件"></a>有触发的随机性条件</h2><p>虽然到目前为止还没学触发（Trigger），但大致意思应该能看懂，和前面if语句中的limit有点像。</p>
<p>如果某个随机选项有触发条件，那么当满足条件时，该选项的概率值才会参与计算，例如下面这个事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option &#x3D; &#123;</span><br><span class="line">	name &#x3D; give_money.1.option.b</span><br><span class="line">	random_list &#x3D; &#123;</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			trigger &#x3D; &#123;</span><br><span class="line">				gold &gt; 1000</span><br><span class="line">			&#125;</span><br><span class="line">			add_gold &#x3D; 1000</span><br><span class="line">		&#125;</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			add_gold &#x3D; 100</span><br><span class="line">		&#125;</span><br><span class="line">		15 &#x3D; &#123;</span><br><span class="line">			remove_short_term_gold &#x3D; 200</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当金币不足1000时，可以看到游戏中截图如下：</p>
<p><img src="https://i.loli.net/2020/12/10/EkoGJDMLstROlY5.png" alt="image-20201210195304419"></p>
<p>而当金币够1000时，事件就变成了：</p>
<p><img src="https://i.loli.net/2020/12/10/mp8YdqW7IS1R2vZ.png" alt="image-20201210195404539"></p>
<h2 id="修改随机权重"><a href="#修改随机权重" class="headerlink" title="修改随机权重"></a>修改随机权重</h2><p>有时候我们希望某个随机结果的权重根据不同的条件而发生改变，例如前面的事件中，同样是得到1000金币，我们希望根据不同的管理值会有不同的概率。这样的效果我们可以使用<code>modifier</code>来实现，具体事件代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option &#x3D; &#123;</span><br><span class="line">	name &#x3D; give_money.1.option.b</span><br><span class="line">	random_list &#x3D; &#123;</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			trigger &#x3D; &#123;</span><br><span class="line">				gold &gt; 1000</span><br><span class="line">			&#125;</span><br><span class="line">			modifier &#x3D; &#123;</span><br><span class="line">				add &#x3D; stewardship</span><br><span class="line">			&#125;</span><br><span class="line">			add_gold &#x3D; 1000</span><br><span class="line">		&#125;			</span><br><span class="line">		30 &#x3D; &#123;</span><br><span class="line">			add_gold &#x3D; 100</span><br><span class="line">		&#125;</span><br><span class="line">		15 &#x3D; &#123;</span><br><span class="line">			remove_short_term_gold &#x3D; 200</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的含义就是，该选项有3个随机结果，分别是金币+1000，金币+100，金币-200，其概率组合是（30+管理值，30，15）。</p>
<p>那么在游戏中我们可以看到，该角色管理值是8，对应的事件如下：</p>
<p><img src="https://i.loli.net/2020/12/10/htkEOdT9qS3xBQY.png" alt="image-20201210203011631"></p>
<p>需要注意的是，不能直接把类似stewardship这样的词放到概率值那里，如果我们希望直接用stewardship当概率，则应该按下面的形式来写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">random_list &#x3D; &#123;</span><br><span class="line">	0 &#x3D; &#123;</span><br><span class="line">		modifier &#x3D; &#123;</span><br><span class="line">			add &#x3D; stewardship</span><br><span class="line">		&#125;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，我尝试给modifier加trigger或者if语句，都失败了，可能它只能单独出现吧。</p>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-4</title>
    <url>/2020/11/08/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-4/</url>
    <content><![CDATA[<h1 id="事件模组"><a href="#事件模组" class="headerlink" title="事件模组"></a>事件模组</h1><p><a href="https://ck3.paradoxwikis.com/Event_modding" target="_blank" rel="noopener">链接</a></p>
<h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>事件在<code>events</code>文件夹下的<code>.txt</code>文件中。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>整体结构与<a href="https://ck2.paradoxwikis.com/Event_modding" target="_blank" rel="noopener">CK2</a>的事件很相似，但是对语法进行了一些调整，并增加了大量额外的功能，其中许多功能是可选的。此处将介绍每个事件所必须的部分，并在稍后部分中单独介绍其他内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">example.1 &#x3D; &#123;</span><br><span class="line">	desc &#x3D; example.1.desc</span><br><span class="line">	</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; example.1.a</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写好该mod并加载，即可在游戏中的控制台输入<code>event triggers [example.1]</code>来触发该事件。</p>
<h3 id="ID和命名空间"><a href="#ID和命名空间" class="headerlink" title="ID和命名空间"></a>ID和命名空间</h3><p>ID是事件独一无二的标志。</p>
<h3 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h3><p>这些是确定事件种类和外观的顶级变量。它们具有有限的值集。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Flag</th>
<th>Meaning</th>
<th>Possible values</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>事件类型，决定root的范围。</td>
<td>* character_event none (when an event doesn’t use the root scope at all)</td>
</tr>
<tr>
<td>hidden</td>
<td>如果设置为true，则该事件不会显示出来，只会在后台触发。可用于执行与玩家不立即相关的维护事件。</td>
<td>true, false</td>
</tr>
</tbody>
</table>
</div>
<h2 id="画像"><a href="#画像" class="headerlink" title="画像"></a>画像</h2><h3 id="画像位置"><a href="#画像位置" class="headerlink" title="画像位置"></a>画像位置</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Portrait Position</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>left_portrait</td>
<td>出现在事件场景的左边。</td>
</tr>
<tr>
<td>right_portrait</td>
<td>出现在事件场景的右边。</td>
</tr>
<tr>
<td>lower_left_portrait</td>
<td>出现在事件场景的左下方。</td>
</tr>
<tr>
<td>lower_center_portrait</td>
<td>出现在事件场景的中下方。</td>
</tr>
<tr>
<td>lower_right_portrait</td>
<td>出现在事件场景的右下方。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">example_event.1001 &#x3D; &#123;</span><br><span class="line">	left_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; ROOT # 无论是什么角色，都显示在此事件窗口位置，显示所选的动画。</span><br><span class="line">		animation &#x3D; fear # 请注意，具有某些遗传特征（例如，巨人主义、侏儒主义）的角色更改其角色模型具有不同的动画，如果将其中一个动画分配给没有该模型的角色，则可能会发生崩溃。</span><br><span class="line">	&#125;</span><br><span class="line">	right_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; ROOT</span><br><span class="line">		animation &#x3D; scheme</span><br><span class="line">	&#125;</span><br><span class="line">	lower_left_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; ROOT</span><br><span class="line">	&#125;</span><br><span class="line">	lower_center_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; ROOT</span><br><span class="line">	&#125;</span><br><span class="line">	lower_right_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; ROOT</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段mod所对应的事件如下图所示。</p>
<p><img src="https://i.loli.net/2020/11/08/GlaYmiW15KjkUzF.png" alt="img"></p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Animation</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>happiness</td>
<td>dismissal</td>
<td>prison_dungeon</td>
<td>admiration</td>
</tr>
<tr>
<td>disgust</td>
<td>schadenfreude</td>
<td>stress</td>
<td>personality_compassionate</td>
</tr>
<tr>
<td>pain</td>
<td>ecstasy</td>
<td>fear</td>
<td>rage</td>
</tr>
<tr>
<td>anger</td>
<td>flirtation_left</td>
<td>shame</td>
<td>boredom</td>
</tr>
<tr>
<td>shock</td>
<td>worry</td>
<td>scheme</td>
<td>personality_bold</td>
</tr>
<tr>
<td>personality_callous</td>
<td>personality_irrational</td>
<td>personality_content</td>
<td>flirtation</td>
</tr>
<tr>
<td>disbelief</td>
<td>personality_cynical</td>
<td>personality_rational</td>
<td>personality_dishonorable</td>
</tr>
<tr>
<td>idle</td>
<td>paranoia</td>
<td>personality_vengeful</td>
<td>disapproval</td>
</tr>
<tr>
<td>sick</td>
<td>beg</td>
<td>personality_zealous</td>
<td>newborn</td>
</tr>
<tr>
<td>love</td>
<td>sadness</td>
<td>personality_honorable</td>
<td>personality_forgiving</td>
</tr>
<tr>
<td>personality_greedy</td>
<td>personality_coward</td>
<td>severelyinjured</td>
<td>severelywounded</td>
</tr>
<tr>
<td>war_attacker</td>
<td>war_defender</td>
<td>war_over_win</td>
<td>grief</td>
</tr>
</tbody>
</table>
</div>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Theme</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>abduct_scheme</td>
<td>alliance</td>
<td>bastardy</td>
<td>battle</td>
</tr>
<tr>
<td>befriend_scheme</td>
<td>claim_throne_scheme</td>
<td>corruption</td>
<td>crown</td>
</tr>
<tr>
<td>culture_change</td>
<td>death</td>
<td>default</td>
<td>diplomacy</td>
</tr>
<tr>
<td>diplomacy_family_focus</td>
<td>diplomacy_foreign_affairs_focus</td>
<td>diplomacy_majesty_focus</td>
<td>dread</td>
</tr>
<tr>
<td>dungeon</td>
<td>dynasty</td>
<td>education</td>
<td>fabricate_hook_scheme</td>
</tr>
<tr>
<td>faith</td>
<td>family</td>
<td>feast_activity</td>
<td>friend_relation</td>
</tr>
<tr>
<td>friendly</td>
<td>generic_intrigue_scheme</td>
<td>healthcare</td>
<td>hunt_activity</td>
</tr>
<tr>
<td>hunting</td>
<td>intrigue</td>
<td>intrigue_intimidation_focus</td>
<td>intrigue_skulduggery_focus</td>
</tr>
<tr>
<td>intrigue_temptation_focus</td>
<td>learning</td>
<td>learning_medicine_focus</td>
<td>learning_scholarship_focus</td>
</tr>
<tr>
<td>learning_theology_focus</td>
<td>love</td>
<td>lover_relation</td>
<td>marriage</td>
</tr>
<tr>
<td>martial</td>
<td>martial_authority_focus</td>
<td>martial_chivalry_focus</td>
<td>martial_strategy_focus</td>
</tr>
<tr>
<td>medicine</td>
<td>mental_break</td>
<td>mental_health</td>
<td>murder_scheme</td>
</tr>
<tr>
<td>party</td>
<td>pet</td>
<td>physical_health</td>
<td>pilgrimage_activity</td>
</tr>
<tr>
<td>pregnancy</td>
<td>prison</td>
<td>realm</td>
<td>recovery</td>
</tr>
<tr>
<td>rival_relation</td>
<td>romance_scheme</td>
<td>secret</td>
<td>seduce_scheme</td>
</tr>
<tr>
<td>seduction</td>
<td>skull</td>
<td>stewardship</td>
<td>stewardship_domain_focus</td>
</tr>
<tr>
<td>stewardship_duty_focus</td>
<td>stewardship_wealth_focus</td>
<td>sway_scheme</td>
<td>unfriendly</td>
</tr>
<tr>
<td>vassal</td>
<td>war</td>
<td>witchcraft</td>
</tr>
</tbody>
</table>
</div>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Background</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>alley_day</td>
<td>alley_night</td>
<td>armory</td>
<td>army_camp</td>
</tr>
<tr>
<td>battlefield</td>
<td>bedchamber</td>
<td>burning_building</td>
<td>corridor_day</td>
</tr>
<tr>
<td>corridor_night</td>
<td>council_chamber</td>
<td>courtyard</td>
<td>docks</td>
</tr>
<tr>
<td>dungeon</td>
<td>farmland</td>
<td>feast</td>
<td>gallows</td>
</tr>
<tr>
<td>garden</td>
<td>market</td>
<td>market_east</td>
<td>market_india</td>
</tr>
<tr>
<td>market_tribal</td>
<td>market_west</td>
<td>physicians_study</td>
<td>sitting_room</td>
</tr>
<tr>
<td>study</td>
<td>tavern</td>
<td>temple</td>
<td>temple_church</td>
</tr>
<tr>
<td>temple_generic</td>
<td>temple_mosque</td>
<td>temple_scope</td>
<td>terrain</td>
</tr>
<tr>
<td>terrain_activity</td>
<td>terrain_scope</td>
<td>throne_room</td>
<td>throne_room_east</td>
</tr>
<tr>
<td>throne_room_india</td>
<td>throne_room_mediterranean</td>
<td>throne_room_scope</td>
<td>throne_room_tribal</td>
</tr>
<tr>
<td>throne_room_west</td>
<td>wilderness</td>
<td>wilderness_desert</td>
<td>wilderness_forest</td>
</tr>
<tr>
<td>wilderness_forest_pine</td>
<td>wilderness_mountains</td>
<td>wilderness_scope</td>
<td>wilderness_steppe</td>
</tr>
</tbody>
</table>
</div>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>当选择好背景后，对应的环境也会被自动选择，但如果有必要可以自行指定覆盖。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Environment</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>environment_body</td>
<td>environment_council</td>
<td>environment_cw_east_main</td>
</tr>
<tr>
<td>environment_cw_east_spouse</td>
<td>environment_cw_east_throneroom_main</td>
<td>environment_cw_east_throneroom_spouse</td>
</tr>
<tr>
<td>environment_cw_india_main</td>
<td>environment_cw_india_spouse</td>
<td>environment_cw_india_throneroom_main</td>
</tr>
<tr>
<td>environment_cw_india_throneroom_spouse</td>
<td>environment_cw_mediterranean_main</td>
<td>environment_cw_mediterranean_spouse</td>
</tr>
<tr>
<td>environment_cw_mediterranean_throneroom_main</td>
<td>environment_cw_mediterranean_throneroom_spouse</td>
<td>environment_cw_tavern</td>
</tr>
<tr>
<td>environment_cw_tavern_spouse</td>
<td>environment_cw_tribal_main</td>
<td>environment_cw_tribal_spouse</td>
</tr>
<tr>
<td>environment_cw_west</td>
<td>environment_cw_west_spouse</td>
<td>environment_event_alley</td>
</tr>
<tr>
<td>environment_event_alley_day</td>
<td>environment_event_armory</td>
<td>environment_event_battlefield</td>
</tr>
<tr>
<td>environment_event_bedchamber</td>
<td>environment_event_church</td>
<td>environment_event_corridor_day</td>
</tr>
<tr>
<td>environment_event_courtyard</td>
<td>environment_event_desert</td>
<td>environment_event_docks</td>
</tr>
<tr>
<td>environment_event_dungeon</td>
<td>environment_event_farms</td>
<td>environment_event_feast</td>
</tr>
<tr>
<td>environment_event_forest</td>
<td>environment_event_forest_pine</td>
<td>environment_event_gallows</td>
</tr>
<tr>
<td>environment_event_garden</td>
<td>environment_event_genericcamp</td>
<td>environment_event_market_east</td>
</tr>
<tr>
<td>environment_event_market_tribal</td>
<td>environment_event_market_west</td>
<td>environment_event_mosque</td>
</tr>
<tr>
<td>environment_event_mountains</td>
<td>environment_event_sittingroom</td>
<td>environment_event_standard</td>
</tr>
<tr>
<td>environment_event_steppe</td>
<td>environment_event_study</td>
<td>environment_event_study_physician</td>
</tr>
<tr>
<td>environment_event_tavern</td>
<td>environment_event_temple</td>
<td>environment_event_throne_room_west</td>
</tr>
<tr>
<td>environment_frontend_east_heir</td>
<td>environment_frontend_east_main</td>
<td>environment_frontend_east_secondary</td>
</tr>
<tr>
<td>environment_frontend_india_heir</td>
<td>environment_frontend_india_main</td>
<td>environment_frontend_india_secondary</td>
</tr>
<tr>
<td>environment_frontend_mediterranean_heir</td>
<td>environment_frontend_mediterranean_main</td>
<td>environment_frontend_mediterranean_secondary</td>
</tr>
<tr>
<td>environment_frontend_tribal_heir</td>
<td>environment_frontend_tribal_main</td>
<td>environment_frontend_tribal_secondary</td>
</tr>
<tr>
<td>environment_frontend_west_heir</td>
<td>environment_frontend_west_main</td>
<td>environment_frontend_west_secondary</td>
</tr>
<tr>
<td>environment_head</td>
<td>environment_hud</td>
<td>environment_portrait_editor</td>
</tr>
<tr>
<td>environment_shoulders</td>
<td>environment_standard</td>
<td>environment_torso</td>
</tr>
<tr>
<td>environment_war_overview</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>是使事件工作的附加内容。</p>
<h3 id="on-trigger-fail"><a href="#on-trigger-fail" class="headerlink" title="on_trigger_fail"></a>on_trigger_fail</h3><p>当触发器失败时运行该项。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>解释一个描述如何由多个字符串组成，例如<code>first_valid</code>和所有其他选项。</p>
<h3 id="即时模块"><a href="#即时模块" class="headerlink" title="即时模块"></a>即时模块</h3><p>该代码块中的内容会在事件触发时立即执行，甚至早于标题、描述和画像的渲染等等。一般用于设置变量和保存范围，或想要实现无玩家控制的功能影响。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>事件中的选项可以由用户选择。每个事件可以有任意数量的选项，包括无选项（一个典型的例子就是隐藏事件）。每个选项在主事件中如下定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">example.1 &#x3D; &#123;</span><br><span class="line">	[...]</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		# option info</span><br><span class="line">	&#125;</span><br><span class="line">	[...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下列表格介绍了<code>option</code>块中的可选关键字：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Key</th>
<th>Required</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>Yes</td>
<td>Points to a localization key for the event option button text.</td>
<td>name=example.1.a</td>
</tr>
<tr>
<td>(effects)</td>
<td>No</td>
<td>Any <a href="https://ck3.paradoxwikis.com/Effect" target="_blank" rel="noopener">effects</a> that the option may have can be written directly in the <code>option</code> block.</td>
<td>play_music_cue = mx_cue_banquet</td>
</tr>
<tr>
<td>trigger</td>
<td>No</td>
<td>Defines a <a href="https://ck3.paradoxwikis.com/Trigger" target="_blank" rel="noopener">trigger</a> that has to be fulfilled for the option to be valid and thus available to the user. Not to be confused with the <a href="https://ck3.paradoxwikis.com/Event_modding#Trigger" target="_blank" rel="noopener">main event trigger</a>.</td>
<td><code>trigger = { has_trait = shy }</code></td>
</tr>
<tr>
<td>show_as_unavailable</td>
<td>No</td>
<td>If the option is invalid, but this trigger is, the option will be  shown, but disabled. This behavior is also influenced by the  EVENT_OPTIONS_SHOWN_HIDE_UNAVAILABLE define.</td>
<td><code>show_as_unavailable = { short_term_gold &lt; medium_gold_value }</code></td>
</tr>
<tr>
<td>highlight_portrait</td>
<td>No</td>
<td>Highlights the event portrait of this character while this option is hovered. This is in addition to the automatic highlighting when  hovering an event option that has an effect that affects portrait  characters.</td>
<td>highlight_portrait = scope:custom</td>
</tr>
</tbody>
</table>
</div>
<h3 id="结束后"><a href="#结束后" class="headerlink" title="结束后"></a>结束后</h3><p>该代码块描述了事件发生后运行的内容。</p>
<h3 id="部件"><a href="#部件" class="headerlink" title="部件"></a>部件</h3><p>有什么类型的小部件。</p>
<h2 id="On-actions"><a href="#On-actions" class="headerlink" title="On_actions"></a>On_actions</h2><p>这部分wiki上是不完整的，先不详细写了。</p>
<p>该部分分为两类：On_actions from Code和On_actions Not from Code（即from script）</p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>这部分wiki也不完整，以后有了在写。</p>
<p>分为两部分：触发事件 和 技术与设计模式。</p>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>Echarts的配置</title>
    <url>/2020/10/31/Echarts%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>今天发现了一个可以用在markdown的前端画图js，<a href="https://echarts.apache.org/zh/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts" target="_blank" rel="noopener">ECharts</a>。在hexo的next主题中使用它需要进行一些配置。</p>
<a id="more"></a>
<p>首先需要说明的是，hexo的网页渲染方式有ejs和swig两种。</p>
<p>对于ejs方式的主题，直接在主题目录下的<code>layout\_partial\head.ejs</code>中加入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://echarts.baidu.com/dist/echarts.common.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>在博客站点文件的命令行中执行<code>npm install hexo-tag-echarts --save</code>即可。</p>
<p>而对于swig方式的主题要复杂一些。</p>
<ol>
<li><p>下载ECharts的js文件：<a href="https://echarts.apache.org/zh/download.html" target="_blank" rel="noopener">下载链接</a></p>
</li>
<li><p>然后在<code>next\layout\</code>文件夹下，找到<code>_layout.swig</code>文件，并用文本查看器打开，在下面代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;main id=<span class="string">"main"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main-inner"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content-wrap"</span>&gt;</span><br><span class="line">      &lt;div id=<span class="string">"content"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">        &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;% include '_third-party/</span>duoshuo-hot-articles.swig<span class="string">' %&#125;</span></span><br><span class="line"><span class="string">      &#123;% include '</span>_partials/comments.swig<span class="string">' %&#125;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &#123;% if theme.sidebar.display !== '</span>remove<span class="string">' %&#125;</span></span><br><span class="line"><span class="string">      &#123;% block sidebar %&#125;&#123;% endblock %&#125;</span></span><br><span class="line"><span class="string">    &#123;% endif %&#125;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/main&gt;</span></span><br></pre></td></tr></table></figure>
<p>的<strong>前面</strong>添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- echarts --&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/echarts.common.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>保存退出。</p>
</li>
<li><p>在博客站点文件的命令行中执行<code>npm install hexo-tag-echarts --save</code>。</p>
</li>
</ol>
<p>到此为止就可以了，新建一个markdown文件，把下列代码放进去就可以看到本页最下面的echarts示例了。（直接复制粘贴，<strong>不要</strong>放代码块里）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% echarts 400 &#39;85%&#39; %&#125;</span><br><span class="line">&#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">        text: &quot;某站点用户访问来源&quot;,</span><br><span class="line">        subtext: &quot;ECharts示例&quot;,</span><br><span class="line">        x: &quot;center&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">        trigger: &quot;item&quot;,</span><br><span class="line">        formatter: &quot;&#123;a&#125; &lt;br&#x2F;&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    legend: &#123;</span><br><span class="line">        orient: &quot;vertical&quot;,</span><br><span class="line">        x: &quot;left&quot;,</span><br><span class="line">        data: [&quot;直接访问&quot;, &quot;邮件营销&quot;, &quot;联盟广告&quot;, &quot;视频广告&quot;, &quot;搜索引擎&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    toolbox: &#123;</span><br><span class="line">        show: true,</span><br><span class="line">        feature: &#123;</span><br><span class="line">            mark: &#123;</span><br><span class="line">                show: true</span><br><span class="line">            &#125;,</span><br><span class="line">            dataView: &#123;</span><br><span class="line">                show: true,</span><br><span class="line">                readOnly: true</span><br><span class="line">            &#125;,</span><br><span class="line">            restore: &#123;</span><br><span class="line">                show: true</span><br><span class="line">            &#125;,</span><br><span class="line">            saveAsImage: &#123;</span><br><span class="line">                show: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    calculable: true,</span><br><span class="line">    series: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: &quot;访问来源&quot;,</span><br><span class="line">            type: &quot;pie&quot;,</span><br><span class="line">            radius: &quot;55%&quot;,</span><br><span class="line">            center: [&quot;50%&quot;, &quot;60%&quot;],</span><br><span class="line">            data: [</span><br><span class="line">                &#123;</span><br><span class="line">                    value: 335,</span><br><span class="line">                    name: &quot;直接访问&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    value: 310,</span><br><span class="line">                    name: &quot;邮件营销&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    value: 234,</span><br><span class="line">                    name: &quot;联盟广告&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    value: 135,</span><br><span class="line">                    name: &quot;视频广告&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    value: 1548,</span><br><span class="line">                    name: &quot;搜索引擎&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endecharts %&#125;</span><br></pre></td></tr></table></figure>
<div id="echarts2508" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts2508'));
        // 指定图表的配置项和数据
        var option = {
    title: {
        text: "某站点用户访问来源",
        subtext: "ECharts示例",
        x: "center"
    },
    tooltip: {
        trigger: "item",
        formatter: "{a} <br/>{b} : {c} ({d}%)"
    },
    legend: {
        orient: "vertical",
        x: "left",
        data: ["直接访问", "邮件营销", "联盟广告", "视频广告", "搜索引擎"]
    },
    toolbox: {
        show: true,
        feature: {
            mark: {
                show: true
            },
            dataView: {
                show: true,
                readOnly: true
            },
            restore: {
                show: true
            },
            saveAsImage: {
                show: true
            }
        }
    },
    calculable: true,
    series: [
        {
            name: "访问来源",
            type: "pie",
            radius: "55%",
            center: ["50%", "60%"],
            data: [
                {
                    value: 335,
                    name: "直接访问"
                },
                {
                    value: 310,
                    name: "邮件营销"
                },
                {
                    value: 234,
                    name: "联盟广告"
                },
                {
                    value: 135,
                    name: "视频广告"
                },
                {
                    value: 1548,
                    name: "搜索引擎"
                }
            ]
        }
    ]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-3</title>
    <url>/2020/10/05/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-3/</url>
    <content><![CDATA[<p>接下来是事件和决议的简单写法。</p>
<a id="more"></a>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="一些文件说明"><a href="#一些文件说明" class="headerlink" title="一些文件说明"></a>一些文件说明</h2><ol>
<li><p>首先在<code>...\Crusader Kings III\game\common\event_themes</code>文件夹中，可以看到<code>00_event_themes.txt</code>文件，里面记录了游戏中的事件主题，不同的主题会有不同的图标、音乐和背景。</p>
</li>
<li><p>其次在<code>...\Crusader Kings III\game\common\event_backgrounds</code>文件夹中，可以看到<code>01_event_backgrounds.txt</code>文件，里面记录了上一条提到的背景对应的信息，包括图片、环境和氛围，例如对于<code>event_background = study</code>的事件主题而言，它的背景信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">study &#x3D; &#123;</span><br><span class="line">	background &#x3D; &#123;</span><br><span class="line">		reference &#x3D; &quot;gfx&#x2F;interface&#x2F;illustrations&#x2F;event_scenes&#x2F;study.dds&quot;</span><br><span class="line">		environment &#x3D; &quot;environment_event_study&quot;</span><br><span class="line">		ambience &#x3D; &quot;event:&#x2F;SFX&#x2F;Events&#x2F;Backgrounds&#x2F;office_workplace&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来在<code>...\Crusader Kings III\game\events</code>文件夹中，可以看到大量事件的具体说明，其中的<code>_events.info</code>文件介绍了事件格式。</p>
</li>
</ol>
<h2 id="事件格式"><a href="#事件格式" class="headerlink" title="事件格式"></a>事件格式</h2><ol>
<li><p>以勒索事件为例来分析事件格式，勒索事件一共有3种：勒索被拒绝、勒索某人造成恐惧、被勒索带来压力。</p>
<p>这里分析第一种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blackmail.0001 &#x3D; &#123;</span><br><span class="line">	title &#x3D; blackmail.0001.t</span><br><span class="line">	desc &#x3D; blackmail.0001.desc</span><br><span class="line">	theme &#x3D; intrigue</span><br><span class="line">	left_portrait &#x3D; &#123;</span><br><span class="line">		character &#x3D; scope:recipient</span><br><span class="line">		animation &#x3D; dismissal</span><br><span class="line">	&#125;</span><br><span class="line">	# TODO_CD: Add a check that the secret has not yet been exposed</span><br><span class="line">	immediate &#x3D; &#123;</span><br><span class="line">		play_music_cue &#x3D; mx_cue_murder</span><br><span class="line">	&#125;</span><br><span class="line">	after &#x3D; &#123; remove_variable &#x3D; currently_blackmailing &#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; blackmail.0001.a</span><br><span class="line">		scope:target &#x3D; &#123;</span><br><span class="line">			expose_secret &#x3D; root</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; blackmail.0001.b</span><br><span class="line">		scope:target &#x3D; &#123;</span><br><span class="line">			disable_exposure_by &#x3D; root</span><br><span class="line">		&#125;</span><br><span class="line">		ai_chance &#x3D; &#123;</span><br><span class="line">			factor &#x3D; 0</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>title</code>和<code>desc</code>两个字段对应的内容可以在文本文件（<code>...\Crusader Kings III\game\localization\simp_chinese\event_localization\blackmail_events_l_simp_chinese.yml</code>）中看到；</p>
<p><code>theme</code>是<code>intrigue</code>，在之前的事件主题中可以找到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">intrigue &#x3D; &#123;</span><br><span class="line">	icon &#x3D; &#123;</span><br><span class="line">		reference &#x3D; &quot;gfx&#x2F;interface&#x2F;icons&#x2F;event_types&#x2F;type_intrigue.dds&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	sound &#x3D; &#123;</span><br><span class="line">		reference &#x3D; &quot;event:&#x2F;SFX&#x2F;Events&#x2F;Themes&#x2F;sfx_event_theme_type_intrigue&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	background &#x3D; &#123;</span><br><span class="line">		event_background &#x3D; corridor_night</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说该事件出现时会有如上图标音乐和背景。</p>
<p>接下来<code>left_portrait</code>是说事件发生时左边的人物形象，这里还可以根据需要设置<code>right_portrait, lower_left_portrait, lower_center_portrait, lower_right_portrait</code>。</p>
<p><code>immediate</code>和<code>after</code>根据字面意思来理解应该是指事件发生时和发生后所触发的效果。</p>
<p>接下来两个<code>option</code>表示这个事件有两个选项，分别对应的文字是<code>blackmail.0001.a</code>和<code>blackmail.0001.b</code>，对应的结果是暴露用来勒索的秘密和放弃勒索。</p>
</li>
<li><p>事件的写法还涉及很多东西，之后再继续看，然后先看看决议。</p>
</li>
</ol>
<h1 id="决议"><a href="#决议" class="headerlink" title="决议"></a>决议</h1><ol>
<li>决议文件存放在<code>...\Crusader Kings III\game\common\decisions</code>中，同样有一个<code>_decisions.info</code>来说明决议的大致格式。</li>
<li>决议的格式和事件其实大同小异，就不记录了。</li>
</ol>
<h1 id="一个基础尝试"><a href="#一个基础尝试" class="headerlink" title="一个基础尝试"></a>一个基础尝试</h1><p>我希望做一个决议，通过决议触发一个事件，而该事件有3个选项，分别是</p>
<ol>
<li>消耗500威望给我1000金钱；</li>
<li>无事发生；</li>
<li>消耗1000金钱给我500威望。</li>
</ol>
<p>那么首先新建一个mod文件夹，它的路径是<code>C:\Users\LiKun\Documents\Paradox Interactive\Crusader Kings III\mod\test</code>，需要注意的是，在<code>C:\Users\LiKun\Documents\Paradox Interactive\Crusader Kings III\mod</code>文件夹里同时会出现一个<code>test.mod</code>，它指向我们mod的路径，内容是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version&#x3D;&quot;0.0&quot;</span><br><span class="line">tags&#x3D;&#123;</span><br><span class="line">	&quot;Historical&quot;</span><br><span class="line">&#125;</span><br><span class="line">name&#x3D;&quot;test&quot;</span><br><span class="line">supported_version&#x3D;&quot;1.1.*&quot;</span><br><span class="line">path&#x3D;&quot;C:&#x2F;Users&#x2F;LiKun&#x2F;Documents&#x2F;Paradox Interactive&#x2F;Crusader Kings III&#x2F;mod&#x2F;test&quot;</span><br></pre></td></tr></table></figure>
<p>接下来，我们在mod文件夹中按照游戏本体那样逐层建立所需要的文件夹，这里一定要严格弄清楚所有路径。建立好的文件夹和文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- test</span><br><span class="line">	- common</span><br><span class="line">		- decisions</span><br><span class="line">			give_money_decision.txt</span><br><span class="line">	- events</span><br><span class="line">		- give_money_events</span><br><span class="line">			give_money_events.txt</span><br><span class="line">	- localization</span><br><span class="line">		- simp_chinese</span><br><span class="line">			- event_localization</span><br><span class="line">				give_money_l_simp_chinese.yml</span><br><span class="line">			decisions_test_l_simp_chinese.yml</span><br><span class="line">	descriptor.mod</span><br></pre></td></tr></table></figure>
<p>我首先写的是事件，也就是<code>give_money_events.txt</code>，该文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace &#x3D; give_money</span><br><span class="line"></span><br><span class="line">give_money.1 &#x3D; &#123;</span><br><span class="line">	type &#x3D; character_event</span><br><span class="line">	title &#x3D; give_money.1.t</span><br><span class="line">	desc &#x3D; give_money.1.desc</span><br><span class="line">	theme &#x3D; stewardship</span><br><span class="line">	left_portrait &#x3D; root</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.a</span><br><span class="line">		add_gold &#x3D; 1000</span><br><span class="line">		add_prestige &#x3D; -500</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.b</span><br><span class="line">	&#125;</span><br><span class="line">	option &#x3D; &#123;</span><br><span class="line">		name &#x3D; give_money.1.option.c</span><br><span class="line">		remove_short_term_gold &#x3D; 1000</span><br><span class="line">		add_prestige &#x3D; 500</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是非常简单的格式，一共3个选项，没有任何触发限制。其中<code>title, desc, name</code>等需要替换成文字的地方，之后在文本文件会增加内容。</p>
<p>需要注意的是，这里用<code>add_gold</code>增加金钱，用<code>remove_short_term_gold</code>减少金钱，是因为我发现<code>add_gold = -1000</code>根本不会生效，查了一下现成的和金钱有关的事件文档，发现用的是<code>remove_short_term_gold</code>，但这个句式到底是什么意思目前也不是很确定。</p>
<p>接下来写决议文件<code>give_money_decision.txt</code>，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">give_money_decision &#x3D; &#123;</span><br><span class="line">	picture &#x3D; &quot;gfx&#x2F;interface&#x2F;illustrations&#x2F;decisions&#x2F;decision_personal_religious.dds&quot;</span><br><span class="line">	desc &#x3D; give_money_decision_desc</span><br><span class="line">	is_valid_showing_failures_only &#x3D; &#123;</span><br><span class="line">		is_available_adult &#x3D; yes</span><br><span class="line">	&#125;</span><br><span class="line">	effect &#x3D; &#123;</span><br><span class="line">		custom_tooltip &#x3D; give_money_decision_effect_tooltip</span><br><span class="line">		trigger_event &#x3D; give_money.1</span><br><span class="line">	&#125;</span><br><span class="line">	ai_check_interval &#x3D; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里增加了需要成年人的限制，<code>custom_tooltip = give_money_decision_effect_tooltip</code>是指效果区域会显示<code>give_money_decision_effect_tooltip</code>所对应的文字，而<code>trigger_event = give_money.1</code>表示确认该决议后，会触发事件<code>give_money.1</code>。</p>
<p>事件和决议都写好以后，就开始完成文本内容，首先是决议文本<code>decisions_test_l_simp_chinese.yml</code>，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> give_money_decision:0 &quot;我好穷啊&quot;</span><br><span class="line"> give_money_decision_tooltip:0 &quot;收点钱。&quot;</span><br><span class="line"> give_money_decision_desc:0 &quot;想要钱吗？&quot;</span><br><span class="line"> give_money_decision_effect_tooltip:0 &quot;点击按钮一键收钱。&quot;</span><br><span class="line"> give_money_decision_confirm:0 &quot;当然&quot;</span><br></pre></td></tr></table></figure>
<p>完成这部分内容后，该决议在游戏中的效果就是</p>
<p><img src="https://i.loli.net/2020/10/06/HQoYAK7JVivqI62.png" alt="image-20201006221530141"></p>
<p>相应的，事件文本也是一样的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l_simp_chinese:</span><br><span class="line"> give_money.1.t:0 &quot;给我打钱！&quot;</span><br><span class="line"> give_money.1.desc:0 &quot;神说要有钱。&quot;</span><br><span class="line"> give_money.1.option.a:0 &quot;好，我喜欢！&quot;</span><br><span class="line"> give_money.1.option.b:0 &quot;不了不了。&quot;</span><br><span class="line"> give_money.1.option.c:0 &quot;你这是看不起我！&quot;</span><br></pre></td></tr></table></figure>
<p>游戏中的效果是</p>
<p><img src="https://i.loli.net/2020/10/06/MWy7KlRpa1wA4kN.png" alt="image-20201006221637015"></p>
<p>把文件们都保存好，就完成了第一个基础mod了。</p>
<p>补充一个重要说明，文件的编码格式非常重要，统一采用UTF-8-BOM编码，不然会出问题。</p>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-2</title>
    <url>/2020/10/04/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<p>这次了解一下决议和事件的图标相关的事情。</p>
<a id="more"></a>
<h1 id="关于图片"><a href="#关于图片" class="headerlink" title="关于图片"></a>关于图片</h1><ol>
<li>游戏中出现的过场图、背景图、事件图标等等基本存放在<code>...\Crusader Kings III\game\gfx\interface</code>文件夹中，比如<code>...\interface\bookmarks</code>里存着开场选人物时的界面贴图，而<code>...\interface\illustrations</code>文件夹里则存着很多尺寸大一些的图（例如过场图、决议说明界面的图等等）；</li>
<li>这些贴图都是dds格式，不同使用场景的贴图有不同尺寸，可以给PS装dds插件然后打开查看；</li>
<li>以决议为例，代码段落中会有<code>picture</code>这个选项，例如<code>create_cadet_branch_decision</code>中的是<code>picture = &quot;gfx/interface/illustrations/decisions/decision_dynasty_house.dds&quot;</code>，如果要自己写决议，或者想把某个决议的图像修改成其他样式，就在这里进行替换，注意dds文件的尺寸等；</li>
<li>开场<code>bookmarks</code>的贴图和上面的不太一样，经过反复分析我发现，在bookmarks文件（<code>...\Crusader Kings III\game\common\bookmarks\00_bookmarks.txt</code>）中，预设的六个是<code>bm_867_northmen</code>、<code>bm_867_adventurers</code>等等，而在<code>...\Crusader Kings III\game\gfx\interface\bookmarks</code>中存在和这些名字相同的六个dds文件，每个可选的人物也类似，总之是dds文件的名字要和bookmarks文件里设定的选项保持一致，这样游戏里会自动对应起来。</li>
<li>图片暂时就先看到这里。</li>
</ol>
<h1 id="关于文本"><a href="#关于文本" class="headerlink" title="关于文本"></a>关于文本</h1><ol>
<li><p>游戏中出现的文本存放在<code>...\Crusader Kings III\game\localization</code>文件夹中，每个语言有一个文件夹；</p>
</li>
<li><p>每个文本文件是<code>.yml</code>格式的，可以用记事本的编辑器打开修改；</p>
</li>
<li><p>文本内容格式是：<code>文本名称:0 &quot;text&quot;</code>，这其中的0也见过写成1的，目前不知道是什么区别，也许和路径有关吧。文本名称的命名有固定格式，比如bookms的命名方式是<code>bm_year_bookmarkname</code>，而对应的描述则是<code>bm_year_bookmarkname_desc</code>，如下是一个例子；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bm_1066_conqueror:0 &quot;Norman England&quot;</span><br><span class="line">bm_1066_conqueror_desc:0 &quot;William has defeated the Anglo-Saxon king Harold at the Battle of Hastings and is crowned king of England, starting an age of Norman rule over the kingdom.&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用的时候，注意名称的统一即可，例如：</p>
<p>在common文件夹的决议文件中，成立葡萄牙的决议如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">form_portugal_decision &#x3D; &#123;</span><br><span class="line">	picture &#x3D; &quot;gfx&#x2F;interface&#x2F;illustrations&#x2F;decisions&#x2F;decision_dynasty_house.dds&quot;</span><br><span class="line">	major &#x3D; yes</span><br><span class="line">	ai_check_interval &#x3D; 60</span><br><span class="line">	desc &#x3D; form_portugal_decision_desc</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>那么对应的文本内容则是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">form_portugal_decision:0 &quot;成立葡萄牙&quot;</span><br><span class="line">form_portugal_decision_desc:0 &quot;一旦我控制了伊比利亚半岛的西海岸，我就能成立葡萄牙王国，并且建立自己独特的文化。&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>目前先看到这里，还有很多问题之后再说。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>ck3mod制作笔记-1</title>
    <url>/2020/10/03/ck3mod%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<p>首先新建一个mod文件。</p>
<a id="more"></a>
<h1 id="新建Mod"><a href="#新建Mod" class="headerlink" title="新建Mod"></a>新建Mod</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li>启动器里找到mod新建会自动生成相关文件；</li>
<li>也可以文档里找到<code>...\Paradox Interactive\Crusader Kings III\mod</code>文件夹（如果没有就新建），新建<code>test.mod</code>文件，用随便什么编辑器打开，输入一系列内容并保存。</li>
</ol>
<h2 id="test-mod文件"><a href="#test-mod文件" class="headerlink" title="test.mod文件"></a><code>test.mod</code>文件</h2><ol>
<li><p>启动器生成的该文件基础内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version&#x3D;&quot;0.0&quot;</span><br><span class="line">tags&#x3D;&#123;</span><br><span class="line">	&quot;Historical&quot;</span><br><span class="line">&#125;</span><br><span class="line">name&#x3D;&quot;test&quot;</span><br><span class="line">supported_version&#x3D;&quot;1.0.3&quot;</span><br><span class="line">path&#x3D;&quot;C:&#x2F;Users&#x2F;LiKun&#x2F;Documents&#x2F;Paradox Interactive&#x2F;Crusader Kings III&#x2F;mod&#x2F;test&quot;</span><br></pre></td></tr></table></figure>
<p><code>version</code>和<code>supported_version</code>自己可以看着改。</p>
</li>
<li><p>可以附加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">picture &#x3D; 图像文件名</span><br></pre></td></tr></table></figure>
<p>指定mod开场图片。</p>
</li>
<li><p>ck2可以设定<code>replace_path</code>，覆盖文件夹中的所有内容，ck3是否可以还没试过，之后看看。</p>
</li>
</ol>
<h2 id="common文件夹"><a href="#common文件夹" class="headerlink" title="common文件夹"></a><code>common</code>文件夹</h2><ol>
<li><p>正常来说ck3游戏本体内容不在上面那个文档里，而在其他安装路径，比如<code>C:\Program 1\Steam\steamapps\common\Crusader Kings III</code>，在这个文件夹中的<code>...\game\common</code>文件夹中存放着很多游戏相关文件，接下来试图逐一分析。</p>
</li>
<li><p>文件夹里有很多文件夹和一个<code>achievement_groups.txt</code>，这个txt文件内容看上去是对成就进行分组，分为<code>very_easy_achievements</code>, <code>easy_achievements</code>, <code>medium_achievements</code>, <code>hard_achievements</code>, <code>very_hard_achievements</code>，文件夹中的第一个是<code>achievements</code>，包括<code>standard_achievements.txt</code>和<code>msgrdk_achievements.json</code>。</p>
<ol>
<li><p><code>standard_achievements.txt</code>中的内容格式是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">成就名 &#x3D; &#123;</span><br><span class="line">	possible &#x3D; &#123;</span><br><span class="line">		# 成就起始条件</span><br><span class="line">	&#125;</span><br><span class="line">	happened &#x3D; &#123;</span><br><span class="line">		custom_description &#x3D; &#123;</span><br><span class="line">			# 成就达成要求</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<ol>
<li><p><code>msgrdk_achievements.json</code>看起来是给每个成就映射了一个数字编号，总共55个。</p>
</li>
<li><p>目前对成就这部分很不熟悉，可能有理解错的内容。</p>
</li>
</ol>
<ol>
<li><p><code>activities</code>文件夹，这里看上去是五个主要活动的说明，这五个都是决议里的，但应该不是决议。</p>
<ol>
<li><p><code>_activities.info</code> 说明了具体格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name_of_activity &#x3D; &#123;</span><br><span class="line">	expiration_days &#x3D; X 			# default number of days after an activity is started to it&#39;s expiration</span><br><span class="line">	days_until_auto_start &#x3D; X 		# number of days from an activity is spawned until it&#39;s started (regardless of if participants have arrived or not)</span><br><span class="line">	valid &#x3D; trigger					# checked daily on the activity scope</span><br><span class="line">	on_spawn &#x3D; effect 				# executed on the activity when spawned</span><br><span class="line">	on_activate &#x3D; effect			# executed on the activity when started (all invitations replied to or auto started)</span><br><span class="line">	on_complete &#x3D; effect			# executed on the activity when completed through complete_activity &#x3D; yes (ignored if complete_activity &#x3D; no)</span><br><span class="line">	on_expire &#x3D; effect				# executed on the activity when expiring from timeout</span><br><span class="line">	on_participant_death			# executed on the dying character during death, activity set as scope:activity</span><br><span class="line">	on_invalidated &#x3D; effect			# executed on the activity when failing the valid trigger	</span><br><span class="line">	solo &#x3D; yes						# marks the activity as a solo activity (no guests)</span><br><span class="line">	has_activity_window &#x3D; yes		# determines if a certain activity should show a window or not</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来结合其他几个具体文件来理解。</p>
</li>
<li><p><code>00_activity_feast.txt</code> 宴会：</p>
<ol>
<li><p><code>expiration_days = 300</code> 持续300天</p>
</li>
<li><p><code>has_activity_window = yes</code> 有事件窗口</p>
</li>
<li><p><code>days_until_auto_start = 20</code> 默认20天后开始</p>
</li>
<li><p><code>frame = 2</code></p>
</li>
<li><p><code>color = { 0.853906 0.867188 0.105469 1 }</code></p>
</li>
<li><pre><code>valid = {
        activity_owner = {
            is_alive = yes
            is_imprisoned = no
        }
    }
</code></pre><p>宴会期间每天检查召开宴会的人活着且没被关起来。</p>
</li>
<li><p><code>on_spawn</code>这段很长，大致是宴会事件生成时同时执行的内容，主要是设置潜在宾客列表<code>potential_guests</code>。这段有个<code>if</code>语句，提到条件和配偶有关，没配偶似乎是会随机初始化一个配偶，没太看懂这个设计。</p>
</li>
<li><p><code>on_activate</code> 也很长，大致是宴会事件开始时触发的，如果没人来，就结束这个事件，<code>feast.2003</code>可能就是结束宴会的意思；如果有人来，给召开宴会的人选关键事件，再从宾客里选人参与到这个事件中，这里提到<code>reveler（狂欢者？）</code>会得到两点不知道是生活方式还是生活经验的奖励。而作为客人，<code>reveler（狂欢者？）</code>会得到一点，此外针对所有客人，会移除宴会邀请的拦截器（？这里还得之后再看）。</p>
</li>
<li><p><code>on_complete</code> 宴会结束时，主人和封臣似乎会有什么互动，每个参与者的目标体重（？）会改变。</p>
</li>
<li><p><code>on_expire</code> 宴会到期以后会触发<code>feast.2002</code>。注释说这个不应出现，只是作为异常记录。</p>
</li>
<li><p><code>on_participant_death</code>是空的。</p>
</li>
<li><p><code>on_invalidated</code> 失效的情况？</p>
</li>
</ol>
</li>
<li><p><code>00_activity_hunt.txt</code> 打猎：</p>
<ol>
<li>和刚才的宴会不同，这里有<code>solo = yes</code>，说明可以一个人打猎。</li>
<li><code>frame</code>和<code>color</code>暂时还是不太理解。</li>
<li>这里的很多限制都要求是健康成年人。</li>
</ol>
</li>
<li><p><code>00_activity_meditation.txt</code> 冥想：</p>
<ol>
<li>同样可以一个人进行。</li>
</ol>
</li>
<li><p>看上去冥想是宗教决议中的一个：<code>religious_decision.0211</code></p>
</li>
<li><p><code>00_activity_pilgrimage.txt</code> 朝圣：因为没看懂就没什么能说的。</p>
</li>
<li><p><code>00_activity_witch_ritual.txt</code> 巫术仪式：</p>
<ol>
<li>其实也没看懂，看起来是可以搞巫术仪式的，但是限制有点多。</li>
<li>似乎是有个宴会，参加宴会的可以为所欲为，还会有不一样的音乐（？<code>play_music_cue = &quot;mx_cue_sacredrite&quot;</code>）。</li>
<li>这里提到的事件有<code>witch.3003</code> <code>witch.3010</code> <code>witch.3098</code>。</li>
</ol>
</li>
<li><p>补充一下：从<code>event</code>文件夹的内容来看，官方没搞冥想和巫术仪式，以后可能会有吧。</p>
</li>
</ol>
</li>
<li><p><code>ai_goaltypes</code>文件夹和<code>ai_war_stances</code>，这俩看名字是和AI设定有关的。</p>
<ol>
<li><code>ai_goaltypes</code>文件夹里只有<code>00_testgoals.txt</code>，内容相当于是空的，可能是留着做mod用。</li>
<li><code>ai_war_stances</code>文件夹里有<code>_ai_war_stances.info</code>和<code>00_ai_war_stances.txt</code>：<ol>
<li><code>_ai_war_stances.info</code>说明了战争立场格式，注释说无法添加新的或者删除现有的，但是都能改。</li>
<li>这里设定的是AI战争时的目标优先级，优先级范围是1-1000，有一个战争目标列表。</li>
<li>有一个变量<code>enemy_unit_priority</code>，这个值目前设置为100，是指对于战力不到该AI一半的敌军单位，战争优先级数字会增加100，该值的影响似乎会随着敌军单位战力的增长而降低，当敌军战力和该AI战力一样的时候这个值就被看作0。</li>
<li><code>00_ai_war_stances.txt</code>是具体的优先级设定，分为进攻方和防御方：<ol>
<li>作为进攻方的AI，在进攻时作战优先级由高到低：目标省（<code>wargoal_province</code> 500）、敌军所在地（<code>enemy_unit_province</code> 300 这个翻译我猜的，可能不对）、敌军首都（<code>enemy_capital_province</code> 150）、敌军省（<code>enemy_province</code> 100）、敌军盟友省（<code>enemy_ally_province</code> 75）、首都（<code>capital_province</code> 50）、普通省（<code>province</code> 25）、保卫战争目标省（<code>defend_wargoal_province</code> 5）。</li>
<li>作为进攻方的AI，在防御时会优先找敌军所在地（<code>enemy_unit_province</code> 500），其次才是战争目标省（<code>wargoal_province</code> 300），其他和刚才一样。</li>
<li>作为防御方，也有和上面一样的两部分。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><code>bookmark_portraits</code>文件夹看上去是存了游戏命令行里生成的外貌数据。</p>
</li>
<li><p><code>bookmark</code>文件夹中有<code>00_bookmarks.txt</code>，这里存了游戏开局可以选的剧本数据，一共6个时代（3个867和3个1066），设定了起止时间和可选的几个角色以及角色们的相关数据。</p>
</li>
<li><p>后面还有好多好多文件夹，等以后用到了再看吧……</p>
</li>
</ol>
]]></content>
      <categories>
        <category>CK3</category>
      </categories>
      <tags>
        <tag>游戏相关</tag>
        <tag>ck3</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>使用算法和数据结构解决问题-1</title>
    <url>/2020/09/28/%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-1/</url>
    <content><![CDATA[<h1 id="第一章-前言"><a href="#第一章-前言" class="headerlink" title="第一章 前言"></a>第一章 前言</h1><h2 id="1-1-目标"><a href="#1-1-目标" class="headerlink" title="1.1 目标"></a>1.1 目标</h2><ol>
<li><p>回顾计算机科学、编程和解决问题的想法。</p>
</li>
<li><p>理解“抽象”及其在解决问题的过程中发挥的作用。</p>
</li>
<li><p>理解和实现抽象数据类型的概念。</p>
</li>
<li><p>复习 <code>Python</code> 编程语言。</p>
</li>
</ol>
<h2 id="1-2-开始"><a href="#1-2-开始" class="headerlink" title="1.2 开始"></a>1.2 开始</h2><p>自从第一台通过贴片电缆和开关来传达人与机器之间指令的电子计算机问世以来，我们对编程的思考方式已经发生了许多变化。与社会的许多方面一样，计算机技术的变化为计算机科学家提供了越来越多的工具和平台来练习他们的技术，更快的处理器、高速网络和大型内存容量等进步也为计算机科学家带来必须面对的复杂性。在这飞速发展的过程中，仍然有一些基本原则保持不变。计算科学关注于使用计算机来解决问题。</p>
<p>无疑，你花了相当长的时间（真的吗？）学习解决问题的基础知识，并且对读懂问题并开发解决方案充满信心。你还了解到编程通常很难（并不），大规模问题的复杂性和求解方案的复杂性往往会掩盖与求解过程相关的基本思想。</p>
<p>本章强调了其余部分内容的两个重要方面。首先，它回顾了计算机科学以及算法和数据结构研究必须符合的框架，特别是我们需要研究这些主题的原因，以及理解这些主题如何帮助我们更好地解决问题。其次，我们复习一下<code>Python</code>编程语言。虽然我们无法提供详细、详尽的参考，但我们将为将在其余各章中出现的基本构造和想法提供实例和解释。</p>
<h2 id="1-3-什么是计算科学"><a href="#1-3-什么是计算科学" class="headerlink" title="1.3 什么是计算科学"></a>1.3 什么是计算科学</h2><p>可能是由于名称中包含了”计算机“一词，计算科学通常很难定义。如你所知，计算科学并不仅仅是对计算机的研究。尽管计算机作为学科中的工具发挥了重要的支持作用，但它们仅仅是工具。</p>
<p>计算科学是对求解问题过程中的问题、求解过程以及解决方案的研究，针对给定问题，计算科学家的目标是设计算法——这是解决任何可能出现的问题的指令所对应的分布说明列表。算法帮助我们解决问题的有限过程，是解决方案。</p>
<p>我们可以认为计算科学就是研究算法，然而，我们必须注意，一些可能无解的问题也会被包含进来。虽然证明这种说法超出了本文的范围，但一些无解问题对于研究计算科学的人而言很重要。通过包含两种类型的问题，我们可以通过以下方式来定义计算科学：计算科学对问题解决方案的研究，以及对无解问题的研究。</p>
<p>”<strong>可计算</strong>“一词再描述问题和解决方案时也很常见。我们说，如果存在一个算法来解决问题，则该问题是可计算的。计算科学的另一种定义是：对可计算和不可计算的问题的研究、对算法存在性与不存在性的研究。在任何情况下，你都会注意到”计算机“一词没有出现，解决方案与机器是独立的。</p>
<p>因为它涉及到问题求解过程，所以计算科学也是<strong>抽象</strong>的研究。抽象使我们能够以分离逻辑和物理的方式来看代问题和解决方案。我们使用一个常见的例子来熟悉这一基本思想。</p>
<p>想象你今天可能开到学校或公司的汽车（我没车）。作为一个司机、汽车的用户，为了用车实现目的，你与汽车之间发生了一些交互，你进车、插钥匙、启动、换档、刹车、加速和转向以便驾驶。从抽象的角度来看，我们可以说你看到了汽车的逻辑视角。为了将你从一个地方送到另一个地方，你使用了汽车设计者所提供的函数，这些函数有时被称为<strong>接口</strong>。</p>
<p>另一方面，修理汽车的机械师则持有不同的观点。她不仅需要知道如何开车，还需要知道执行所有我们认为理所当然的函数的全部细节。她需要理解发动机的工作原理、变速箱如何换档、如何控制温度等等。这被称为物理视角——”引擎盖下的细节“。</p>
<p>在我们使用计算机时也发生了同样的事情。大多数人在不了解原理的情况下使用计算机来编写文档、发送和接收电子邮件、浏览网页、播放音乐、存储图像和玩游戏，他们从逻辑或者用户的视角来看计算机。而计算科学家、程序员、技术支持人员和系统管理员对计算机的看法则有很大不同，他们必须知道操作系统如何工作、如何配置网络协议以及如何编写控制功能的各种脚本，他们必须能够控制底层细节，而用户则只是简单想象这些。</p>
<p>这两个例子的共同点在于，抽象的用户（有时也被称为客户端）并不需要了解详细信息，而只需要知道接口的工作方式。接口是用户与底层复杂系统的通信方式。我们可以来看另一个抽象的例子：<code>Python</code>中的<code>math</code>模块。当我们导入该模块后，就可以实现如下计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.sqrt(<span class="number">16</span>)</span><br><span class="line"><span class="number">4.0</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这是<strong>过程抽象(procedural abstraction)</strong>的示例。我们不一定知道平方根是如何计算的，但我们知道函数的调用以及如何使用它。如果我们正确执行导入，我们可以假定函数将为我们提供正确的结果。我们知道有人实现了平方根问题的解决方案，但我们并不关心是如何实现的，只需要知道如何使用它。这有时称为进程的”黑盒”视图。我们简单地将接口描述为：函数的名称、需要什么（参数）以及将返回什么，而具体内容则隐藏在接口中，如图1.1。</p>
<center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="https://i.loli.net/2020/11/06/UwFpIlg9mroSa8i.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图1.1 过程抽象</div> </center>

<h3 id="1-3-1-什么是编程"><a href="#1-3-1-什么是编程" class="headerlink" title="1.3.1 什么是编程"></a>1.3.1 什么是编程</h3><p><strong>编程</strong>是将算法编码为符号（编程语言）从而使其可以在计算机上执行的过程。尽管存在许多编程语言和许多不同类型的计算机，但重要的第一步是提出解决方案，没有算法就没有程序。</p>
<p>计算机科学不是编程的研究，然而编程是计算机科学家工作的一个重要部分。编程通常是我们为解决方案创建的表示。因此，这种语言表示和创建过程成为学科的基本部分。</p>
<p>算法根据表示问题实例所需的数据和产生预期结果所需的步骤集来描述问题的解决方案。编程语言必须提供一种符号方式来表示进程和数据。为此，语言提供了控件构造和数据类型。</p>
<p>控件构造允许以方便而明确的方式表示算法步骤。算法至少需要执行顺序处理、决策选择和重复控制迭代的构造（注：简单来说就是顺序、选择、循环）。只要编程语言提供这些基本语句，它就可以用于算法表示。</p>
<p>计算机中的所有数据项都表示为二进制数字字符串。为了给这些字符串赋予意义，我们需要有<strong>数据类型</strong>。数据类型为此二进制数据提供解释，以便我们可以从与所解决的问题有意义的术语中分析数据。这些低级的内置数据类型（有时称为基元数据类型）为算法开发提供了构建基块。</p>
<p>例如，大多数编程语言为整数提供了数据类型，计算机内存中的二进制数字字符串可以解释为整数，并给出我们通常与整数关联的典型含义（例如 23、654 和 -19）。此外，数据类型还提供数据项可以参与的操作的说明，对于整数，加法、减法和乘法等操作是通用的。我们期望该数字类型的数据可以参与这些算术运算。</p>
<p>我们经常遇到的困难是，问题及其解决方法非常复杂。这些简单的语言所提供的构造和数据类型虽然肯定足以表示复杂的解决方案，但往往会使我们再处理问题的过程中处于不利地位。我们需要控制这种复杂性和协助创建解决方案的方法。</p>
<h3 id="1-3-2-为什么要学习数据结构和抽象数据类型"><a href="#1-3-2-为什么要学习数据结构和抽象数据类型" class="headerlink" title="1.3.2 为什么要学习数据结构和抽象数据类型"></a>1.3.2 为什么要学习数据结构和抽象数据类型</h3><p>为了管理问题的复杂性和解决问题的过程，计算机科学家们使用抽象，使他们能够专注于”大局”，而不会迷失在细节中。通过创建问题域的模型，我们能够利用更好、更高效的问题求解过程。这些模型允许我们以与问题本身更加一致的方式来描述我们的算法将处理的数据。</p>
<p>在前文中，我们提到过程抽象是一个隐藏特定函数的详细信息的过程，以允许用户或客户端在非常高的级别上查看它。现在，我们把注意力转向一个类似的想法，即<strong>数据抽象</strong>。<strong>抽象数据类型</strong>（有时称为<strong>ADT</strong>）是对我们如何查看数据及其允许操作的逻辑描述，我们并不关心如何实现该数据类型。这意味着我们只关心数据所代表的是什么，而不关心数据是如何构造的。通过提供这种抽象级别，我们围绕数据创建封装，其理念是，在用户视图中，通过封装将实现过程的详细信息隐藏起来，这被称为信息隐藏。</p>
<p>图 1.2 显示了抽象数据类型及其操作方式的图片。用户使用抽象数据类型指定的操作与接互。抽象数据类型是用户与之交互的 shell。实现过程被隐藏在更深的一层，而用户并不关心实现过程的详细信息。</p>
<center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="https://i.loli.net/2020/11/12/iqCUNtAdfyQEM16.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图1.2 抽象数据类型</div> </center>

<p>抽象数据类型的实现（通常称为数据结构）要求我们使用一些编程构造和基元数据类型的集合提供数据的物理视图。正如我们前面所讨论的，这两个视图的分离将使我们能够在无需说明模型实际构建的细节的情况下，定义我们问题的复杂数据模型，它提供了<strong>实现独立性</strong>的数据视图。由于实现抽象数据类型通常有很多不同的方法，因此这种实现独立性允许程序员切换实现过程的详细信息，而无需更改数据用户与其交互的方式，用户可以继续专注于解决问题的过程。</p>
<h3 id="1-3-3-为什么要学习算法"><a href="#1-3-3-为什么要学习算法" class="headerlink" title="1.3.3 为什么要学习算法"></a>1.3.3 为什么要学习算法</h3><p>计算机科学家通过经验学习，通过看到别人解决问题和自己解决问题来学习。接触不同的问题解决技术，并了解不同的算法是如何设计的，这有助于我们面对下一个具有挑战性的问题。通过思考许多不同的算法，我们可以开始开发模式识别，以便下次出现类似的问题时，可以更好地解决它。</p>
<p>算法通常彼此大不相同，例如前文中的<code>sqrt</code>示例，完全有可能有许多不同的方法来具体实现计算平方根的函数。某种算法使用的资源可能比另一种算法少很多，而某种算法可能需要10倍的时间才能返回结果。我们希望有一些办法来比较这两种解决方案，即使它们都是有效方案，一种也许会比另一种更好。我们可能会认为一种方法更高效，或者运行得更快或使用更少的内存。当我们研究算法时，我们可以学习分析技术，这些分析技术使我们能够仅根据解决方案自身的特点进行比较和对比，而不是基于用于实现它们的程序或计算机的特性。</p>
<p>在最坏的情况下，我们可能有一个难以解决的棘手问题，这意味着没有算法可以在实际的时间内解决问题。能够区分那些有解决办法的问题、没有解决办法的问题和存在解决方案但需要太多时间或其他资源才能合理工作的问题是很重要的。</p>
<p>我们往往需要确定和决定解决方案之间的权衡，作为计算机科学家，除了解决问题的能力外，我们还需要了解和理解解决方案的评估技术。最后，往往有很多方法可以解决问题。找到一个解决方案，然后决定它是否是好的，是我们将不断重复完成的任务。</p>
<h2 id="1-4-基础Python复习"><a href="#1-4-基础Python复习" class="headerlink" title="1.4 基础Python复习"></a>1.4 基础Python复习</h2><p>在本节中，我们将回顾编程语言 Python，并提供上一节中想法的一些更详细的示例。如果你是 Python 的初学者，或者发现需要有关任何内容的更多信息，我们建议你参考诸如<code>Python Language Reference</code>或<code>Python Tutorial</code>这样的资源。在这里我们的目标是重新认识Python语言，并加强一些后几章中的核心概念。</p>
<p>Python 是一种现代、易于学习、面向对象的编程语言。它有一组强大的内置数据类型和易于使用的控件构造。由于 Python 是一种解释性语言，因此只需查看和描述交互式会话，就可以了解它。你应该记得，解释器在提示<code>&gt;&gt;&gt;</code>时显示操作，然后评估您提供的 Python 构造。例如下面这段代码展示了提示、打印功能、结果和下一个提示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"Algorithms and Data Structures"</span>)</span><br><span class="line">Algorithms <span class="keyword">and</span> Data Structures</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-1-从数据开始"><a href="#1-4-1-从数据开始" class="headerlink" title="1.4.1 从数据开始"></a>1.4.1 从数据开始</h3>]]></content>
      <categories>
        <category>Problem Solving with Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>blender学习记录-4</title>
    <url>/2020/08/13/blender%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-4/</url>
    <content><![CDATA[<p>在这里记录一些学到的技巧。</p>
<a id="more"></a>
<ol>
<li>对边缘倒角（ctrl+B）可以让边缘变得平滑</li>
<li>通过细分线段+连接两个点的方式把一些不合适的平面分成两个合适的四边形</li>
<li>要做一个凹下去或者凸起的圆柱形效果时，先挤出（E）一点，再挤出完整长度，最后再继续挤出一点，这样在表面细分以后的效果就还是圆柱</li>
<li>要在一个平面开一个圆洞时，先找好圆心（两条线十字交叉的点），选中这个点然后倒角（ctrl+B），这里要勾选“仅顶点”，或者用ctrl+shift+B这个快捷键倒角，然后选2段，再把轮廓调小（大概0.2左右的样子），让它形状圆一些，最后球形化（alt+shift+S），把系数调最大（1），这样加个细分修改器就是标准圆形了。需要掏洞或者做圆柱的时候可以参考第3条来挤出。</li>
<li>安装md3插件的情况下，物体模式下直接ctrl+3可以方便地细分。</li>
</ol>
]]></content>
      <categories>
        <category>blender</category>
      </categories>
      <tags>
        <tag>随便学学</tag>
      </tags>
  </entry>
  <entry>
    <title>blender学习记录-3</title>
    <url>/2020/08/11/blender%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-3/</url>
    <content><![CDATA[<p>第二课是建模型相关操作</p>
<p>开始学材质，感觉会比之前的内容有意思。</p>
<a id="more"></a>
<ol>
<li>漫射材质：光照会均匀分布在物体表面，适合粗糙的材质，比如毛发、布料等。</li>
<li>反射材质：会反射周围景观，降低粗糙度就会反射得清楚一些，类似镜子。</li>
<li>透射材质：玻璃水晶等，降低粗糙度会更透明，不同物体有不同折射率，可以查表填对应的数值。</li>
<li>发光材质：就是普通的发光</li>
<li>修改alpha模式可以做玻璃罩的效果</li>
</ol>
]]></content>
      <categories>
        <category>blender</category>
      </categories>
      <tags>
        <tag>随便学学</tag>
      </tags>
  </entry>
  <entry>
    <title>python+sklearn+keras+lstm回归预测问题</title>
    <url>/2020/07/24/python-sklearn-keras-lstm%E5%9B%9E%E5%BD%92%E9%A2%84%E6%B5%8B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>因为接到了股票价格预测的任务，所以开始研究怎么写代码。实际上代码是网上现成的，并不需要自己研究算法和网络结构，复制粘贴再重新组合一下就好，所以难度不大。之前做过sklearn的分类问题，现在做回归，思路是差不多的。</p>
<a id="more"></a>
<p>具体场景是：给定某时间段内的股票价格数据，预测接下来的走势；用同样的算法预测其他股票，看准确率是否有变化；老师的想法是对比国内外市场的差异，看是否在机器学习算法中也有体现。</p>
<h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><p>这里先列一下所有导入的包，可能有一些实际没用上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> style</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing, svm</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime <span class="keyword">as</span> date</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> neighbors</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> ensemble</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> ExtraTreeRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">import</span> quandl</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="comment">#from pandas_datareader import data</span></span><br><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line"><span class="comment"># 下面这几个是lstm用的</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Dense, Dropout, LSTM</span><br></pre></td></tr></table></figure>
<h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><ol>
<li><p>使用quandl获取数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> quandl</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">start = date(<span class="number">2000</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">end = date.today()</span><br><span class="line">quandl.ApiConfig.api_key = <span class="string">"gEyzpvmpXReFE8Z8TEps"</span></span><br><span class="line">stock_df = pd.DataFrame(quandl.get(<span class="string">"WIKI/GOOGL"</span>, start_date=start, end_date=end))</span><br></pre></td></tr></table></figure>
<p>第一行导入包；</p>
<p>第二行第三行设置要获取的数据时间范围</p>
<p>第四行设置api_key，这里是需要到quandl官网注册账户，注册好以后会得到这个key，可以用免费数据。注册的时候分为3步，填名字邮箱密码啥的，第三步的时候会需要点一个人机验证的东西才能注册成功，如果没出现人机验证且无法点注册的按钮，说明需要翻墙。</p>
<p>第五行通过<code>quandl.get()</code>函数可以得到所需数据，转成<code>pandas</code>格式方便后续分析。这里的<code>WIKI/GOOGL</code>是谷歌的股票数据在quandl网站上的代码，不过我看不懂那个网站，不清楚要怎么找其他公司和时间的数据，所以暂时就先只用这个了。</p>
</li>
<li><p>通过tushare和pandas_datareader这两个模块也可以获取数据，此外还有其他相关网站。</p>
</li>
<li><p>发现pandas_datareader实际上不太行，查了一下找到了新的数据，数据来源是雅虎财经：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line">start_date = <span class="string">"2000-01-01"</span></span><br><span class="line">end_date = <span class="string">"2018-12-01"</span></span><br><span class="line">stock_df = yf.download(tickers = <span class="string">"MCD"</span>, start = start_date, end = end_date)</span><br></pre></td></tr></table></figure>
<p>这里<code>start_date</code>和<code>end_date</code>也可以写成前面<code>date(2000,1,1)</code>的样子，<code>tickers</code>的参数是可以百度到的股票代码，如果是上海的就是<code>600673.SS</code>这种代码后面加<code>.SS</code>，深圳是<code>.SZ</code>，香港是<code>.HK</code>，美国就是那串字母本身，此外，香港的代码查到的都是五位数，但是在这里要把最高位的0去掉，只用四位数。</p>
<p><code>yf.download</code>会直接返回<code>pandas</code>的<code>dataframe</code>结构，方便后续处理。</p>
<p>和前面那个<code>quandl</code>的比起来，简单了很多，但是有时候会运行很慢，等十几分钟也不出结果。</p>
</li>
</ol>
<h2 id="sklearn的普通方法"><a href="#sklearn的普通方法" class="headerlink" title="sklearn的普通方法"></a>sklearn的普通方法</h2><ol>
<li><p>把预测要用的数据列提取出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_df = stock_df[[<span class="string">'Open'</span>, <span class="string">'High'</span>, <span class="string">'Low'</span>, <span class="string">'Close'</span>, <span class="string">'Volume'</span>]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里使用过去一天的数据来预测当天的收盘价，因此要新建一列来存下一天的收盘价作为机器学习的目标值<code>y</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_df[<span class="string">'object'</span>] = stock_df[<span class="string">'Close'</span>].shift(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>把除了目标列以外的其他数据单独提出来作为<code>X</code>，并做标准化处理，然后去掉最后一行（因为最后一行没有下一天的目标值，所以没法用）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.array(stock_df.drop([<span class="string">'object'</span>], <span class="number">1</span>))</span><br><span class="line">X = preprocessing.scale(X)</span><br><span class="line">X = X[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>把目标列提出来作为<code>y</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_df.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line">y = np.array(stock_df[<span class="string">'object'</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>划分训练集和测试集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_train, x_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>把要用的模型都准备好</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">models = []</span><br><span class="line">models.append((<span class="string">'DecisionTree'</span>, tree.DecisionTreeRegressor()))</span><br><span class="line">models.append((<span class="string">'LR'</span>, linear_model.LinearRegression()))</span><br><span class="line">models.append((<span class="string">'KNN'</span>, neighbors.KNeighborsRegressor()))</span><br><span class="line">models.append((<span class="string">'RF'</span>, ensemble.RandomForestRegressor(n_estimators=<span class="number">20</span>)))</span><br><span class="line">models.append((<span class="string">'ABR'</span>, ensemble.AdaBoostRegressor(n_estimators=<span class="number">50</span>)))</span><br><span class="line">models.append((<span class="string">'SVM'</span>, svm.SVR(gamma=<span class="string">'auto'</span>)))</span><br><span class="line">models.append((<span class="string">'GBRT'</span>, ensemble.GradientBoostingRegressor(n_estimators=<span class="number">100</span>)))</span><br><span class="line">models.append((<span class="string">'Bagging'</span>, BaggingRegressor()))</span><br><span class="line">models.append((<span class="string">'ExtraTree'</span>, ExtraTreeRegressor()))</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历所有模型，在训练集上10折交叉验证并输出模型评价，在测试集上计算均方根误差</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name, model <span class="keyword">in</span> models:</span><br><span class="line">    scores = cross_val_score(model, x_train, y_train, cv=<span class="number">10</span>, scoring=<span class="literal">None</span>)</span><br><span class="line">    print(<span class="string">'%s: %f (%f)'</span> % (name, scores.mean(), scores.std()))</span><br><span class="line">    model.fit(x_train, y_train)</span><br><span class="line">    <span class="comment">#print(model.score(x_test, y_test))</span></span><br><span class="line">    y_predict = model.predict(x_test)</span><br><span class="line">    print(<span class="string">'RMSE: '</span>, np.sqrt(metrics.mean_squared_error(y_test,y_predict)))</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来要随便选个模型画图看看</p>
<ol>
<li><p>选模型并用训练集训练模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf = ensemble.GradientBoostingRegressor(n_estimators=<span class="number">100</span>)</span><br><span class="line">clf.fit(x_train, y_train)</span><br></pre></td></tr></table></figure>
</li>
<li><p>从所有的X中，选取后30%，用模型预测结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index = len(X)*<span class="number">7</span>//<span class="number">10</span></span><br><span class="line">predict_x = X[index:]</span><br><span class="line">predict_y = clf.predict(predict_x)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在原本的<code>dataframe</code>中新建一列来存这个预测结果，这样后面画图能直接用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_df[<span class="string">'Predict'</span>] = np.nan			<span class="comment">#新建一列并初始化为空值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> predict_y:						<span class="comment">#遍历预测结果</span></span><br><span class="line">    stock_df[<span class="string">'Predict'</span>][index] = i		<span class="comment">#从预测的第一个数开始填值</span></span><br><span class="line">    index += <span class="number">1</span>							<span class="comment">#移动到下一个值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>画图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(stock_df[<span class="string">'Close'</span>], label=<span class="string">'Close'</span>, color=<span class="string">'deepskyblue'</span>)	<span class="comment">#实际值</span></span><br><span class="line">stock_df[<span class="string">'Predict'</span>].plot()										<span class="comment">#预测值</span></span><br><span class="line">plt.legend(loc=<span class="number">4</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Date'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Price'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="lstm"><a href="#lstm" class="headerlink" title="lstm"></a>lstm</h2><ol>
<li><p>预处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_df[<span class="string">'Date'</span>] = stock_df.index</span><br><span class="line">data = stock_df.sort_index(ascending=<span class="literal">True</span>, axis=<span class="number">0</span>)</span><br><span class="line">new_data = pd.DataFrame(index=range(<span class="number">0</span>, len(stock_df)), columns=[<span class="string">'Date'</span>, <span class="string">'Close'</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(data)):</span><br><span class="line">    new_data[<span class="string">'Date'</span>][i] = data[<span class="string">'Date'</span>][i]</span><br><span class="line">    new_data[<span class="string">'Close'</span>][i] = data[<span class="string">'Close'</span>][i]</span><br><span class="line"><span class="comment"># setting index</span></span><br><span class="line">new_data.index = new_data.Date</span><br><span class="line">new_data.drop(<span class="string">'Date'</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>这样的结果就是把日期和收盘价单独提出来了</p>
</li>
<li><p>划分训练集和测试集，是7:3划分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataset = new_data.values</span><br><span class="line">t_len = len(dataset)*<span class="number">7</span>//<span class="number">10</span></span><br><span class="line">train = dataset[<span class="number">0</span>:t_len, :]</span><br><span class="line">valid = dataset[t_len:, :]</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理训练集数据，lstm会利用过去一段时间的数据，这里设置为过去60天</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#标准化处理</span></span><br><span class="line">scaler = MinMaxScaler(feature_range=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">scaled_data = scaler.fit_transform(dataset)</span><br><span class="line"><span class="comment">#定义列表存放数据</span></span><br><span class="line">x_train, y_train = [], []</span><br><span class="line"><span class="comment">#对于每一天的y，x的值都是过去60天的收盘价</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">60</span>, len(train)):</span><br><span class="line">    x_train.append(scaled_data[i - <span class="number">60</span>:i, <span class="number">0</span>])</span><br><span class="line">    y_train.append(scaled_data[i, <span class="number">0</span>])</span><br><span class="line"><span class="comment">#把x的格式改成训练需要的格式</span></span><br><span class="line">x_train, y_train = np.array(x_train), np.array(y_train)</span><br><span class="line">x_train = np.reshape(x_train, (x_train.shape[<span class="number">0</span>], x_train.shape[<span class="number">1</span>], <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立和训练lstm模型，这里训练50轮，实际上感觉100轮和50轮没什么差别；这里用了4层lstm，但实际上感觉一层就够了。在训练时用均方根误差作为指标。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create and fit the LSTM network</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(units=<span class="number">50</span>, return_sequences=<span class="literal">True</span>, input_shape=(x_train.shape[<span class="number">1</span>], <span class="number">1</span>)))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(LSTM(units = <span class="number">50</span>, return_sequences = <span class="literal">True</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(LSTM(units = <span class="number">50</span>, return_sequences = <span class="literal">True</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(LSTM(units=<span class="number">50</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.compile(loss=<span class="string">'mean_squared_error'</span>, optimizer=<span class="string">'adam'</span>)</span><br><span class="line">model.fit(x_train, y_train, epochs=<span class="number">50</span>, batch_size=<span class="number">32</span>, verbose=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这些lstm模型用的激活函数是默认的<code>tanh</code>，然后训练时会有错误信息，据一些人说是可以忽略的，参见<a href="https://github.com/tensorflow/tensorflow/issues/30263" target="_blank" rel="noopener">链接</a>。如果把激活函数改成<code>sigmoid</code>，就没报错了，但是发现训练结果格外不好，不清楚是我操作问题还是这个激活函数就不合适。总之暂且先用<code>tanh</code>。</p>
</li>
<li><p>准备测试集，这里和训练集一样，往前倒60个数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputs = new_data[len(new_data) - len(valid) - <span class="number">60</span>:].values</span><br><span class="line">inputs = inputs.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">inputs = scaler.transform(inputs)</span><br><span class="line">X_test, Y_test = [], []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">60</span>, inputs.shape[<span class="number">0</span>]):</span><br><span class="line">    X_test.append(inputs[i - <span class="number">60</span>:i, <span class="number">0</span>])</span><br><span class="line">X_test = np.array(X_test)</span><br><span class="line">X_test = np.reshape(X_test, (X_test.shape[<span class="number">0</span>], X_test.shape[<span class="number">1</span>], <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>用训练好的lstm模型对测试集进行测试并把值改回标准化前的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">closing_price = model.predict(X_test)</span><br><span class="line">closing_price = scaler.inverse_transform(closing_price)</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出均方根误差</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rms &#x3D; np.sqrt(np.mean(np.power((valid - closing_price), 2)))</span><br><span class="line">print(rms)</span><br></pre></td></tr></table></figure>
</li>
<li><p>和sklearn一样的画图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train = new_data[:t_len]</span><br><span class="line">valid = new_data[t_len:]</span><br><span class="line">valid[<span class="string">'Predictions'</span>] = closing_price</span><br><span class="line">plt.plot(train[<span class="string">'Adj. Close'</span>], color=<span class="string">'deepskyblue'</span>, label = <span class="string">'Adj. Close'</span>)</span><br><span class="line">plt.plot(valid[<span class="string">'Adj. Close'</span>], color=<span class="string">'deepskyblue'</span>)</span><br><span class="line">plt.plot(valid[<span class="string">'Predictions'</span>], label = <span class="string">'Predict'</span>)</span><br><span class="line">plt.legend(loc=<span class="number">4</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Date'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Price'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><ol>
<li>之后有空的时候再增加这些算法的理论介绍</li>
<li>回归和分类的代码结构差不多，只是函数名称和模型评价指标不太一样，关于评价指标可以参考<a href="https://scikit-learn.org/stable/modules/model_evaluation.html#the-scoring-parameter-defining-model-evaluation-rules" target="_blank" rel="noopener">这个</a>。</li>
</ol>
]]></content>
      <categories>
        <category>无分类项</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>sklearn</tag>
        <tag>keras</tag>
        <tag>lstm</tag>
        <tag>回归</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-N-in-One: A Novel Location-Based-Service</title>
    <url>/2020/07/18/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-N-in-One-A-Novel-Location-Based-Service/</url>
    <content><![CDATA[<h1 id="新的LBS系统"><a href="#新的LBS系统" class="headerlink" title="新的LBS系统"></a>新的LBS系统</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ol>
<li>现有LBS基于单一POI，而现实里用户需要多POI的LBS</li>
<li>本文将单一POI的LBS扩展为使用单个查询请求多个POI的LBS</li>
</ol>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ol>
<li>场景：用户希望同时查询某地点附近的多个兴趣点（例如饭店和KTV都需要）</li>
<li>和单兴趣点推荐的差别：要综合考虑多个兴趣点的评价和距离以及用户需求，例如吃完饭去KTV这种场景就需要推荐的饭店和KTV近一些</li>
<li>本文实现的功能：<ol>
<li>Ranking mode（排序模式）：根据每个兴趣点的评价和兴趣点之间的距离，提供一个按评分排序的列表中的前K个兴趣点组合</li>
<li>Service area mode（服务区模式）：找出一个包含了最多兴趣点的矩形区域</li>
</ol>
</li>
<li>挑战性：<ol>
<li>受限于兴趣点之间的距离，实现”N-in-One”与单纯找N个相互独立的兴趣点并不同；</li>
<li>服务区模式可能会有木桶效应问题：返回的聚类结果可能因为有一个或多个热门兴趣点被排除。</li>
</ol>
</li>
<li>本文提出：<ol>
<li>排序模式：基于平面扫描算法，垂直线从右往左扫描兴趣点区域，遇到兴趣点时回溯和已经记录的兴趣点匹配，以查找最优K聚类；为实现回溯过程中的POI匹配，引入“可查看网络”；</li>
<li>服务区模式：引入“瓶颈值”来描述 POI 的重复使用数，使用计算几何来识别给定大小的矩形，该矩形可以覆盖尽可能多的最佳Q群集，同时减少木桶效应。</li>
</ol>
</li>
<li>本文组织结构：<ol>
<li>第二部分、第三部分分别介绍排序模式和服务区模式</li>
<li>第四部分仿真实验</li>
<li>第五部分相关研究</li>
<li>第六部分总结</li>
</ol>
</li>
</ol>
<h2 id="“N-IN-ONE”-LBS-IN-THE-RANKING-MODE"><a href="#“N-IN-ONE”-LBS-IN-THE-RANKING-MODE" class="headerlink" title="“N-IN-ONE” LBS IN THE RANKING MODE"></a>“N-IN-ONE” LBS IN THE RANKING MODE</h2><h3 id="Metric-to-Evaluate-a-POI-Cluster"><a href="#Metric-to-Evaluate-a-POI-Cluster" class="headerlink" title="Metric to Evaluate a POI Cluster"></a>Metric to Evaluate a POI Cluster</h3><p>POI聚类$\Pi=\{p_1,…,p_N\}$，其中$p_j$是第$j$个兴趣点位置</p>
<p><strong>定义1</strong>  POI聚类的直径：覆盖该聚类所有兴趣点的最小圆直径</p>
<p><strong>定义2</strong>  POI聚类的中心：覆盖该聚类所有兴趣点的最小圆圆心</p>
<p>最小圆问题：直径取决于聚类中距离最远的两点之间的距离上限</p>
<p><strong>评估函数：</strong></p>
<script type="math/tex; mode=display">
R(\Pi)=\sum_{j=1}^{N}\alpha_je_j-\beta D(\Pi)-\gamma d(\Pi,c)</script><p>其中，$e_j$是对该聚类内第$j$个兴趣点的评估值，$\alpha_j$是对应的权重；$D(\Pi)$是聚类的直径，体现了聚类的离散程度，$\beta$是对应的权重；$d(\Pi,c)$是当前位置$c$到聚类中心的距离，$\gamma$是对应权重。所有权重由用户自己决定。</p>
<h3 id="Overview-of-Our-Algorithm-for-the-Ranking-Mode"><a href="#Overview-of-Our-Algorithm-for-the-Ranking-Mode" class="headerlink" title="Overview of Our Algorithm for the Ranking Mode"></a>Overview of Our Algorithm for the Ranking Mode</h3><p>用户兴趣区域内有$n$个POI，集合表示为$\Omega$，$||\Omega||=n$</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>所有POI根据x坐标升序排列（即标号大的POI出现在右边）</li>
<li>垂直线从右向左扫描兴趣区域</li>
<li>当垂直线扫到了某个POI，算法会检查之前找到的POI聚类，并将该POI加到之前的聚类中形成新聚类，聚类中所有元素的POI类型在任何时刻都不同</li>
<li>基于新聚类，更新最优K结果</li>
<li>当兴趣区域内的POI都被扫描过时，上述过程结束，最终的最优K结果被推送给用户</li>
</ol>
<p><strong>关键问题</strong>：扫描到一个POI时，如何从之前的POI集合中高效识别那些需要被回溯的</p>
<p><strong>解决方法</strong>：引入可视网络的概念，$N=(\Omega,E)$，$\Omega$是兴趣点集合，E是可视线集合</p>
<p>可视线：由扫描到的POI及其可视点之一决定。当扫描到某个POI $P_i$时，算法根据其可视线回溯L层邻近POI</p>
<p>L层邻近POI：可视网络中，比$P_i$扫描得早、且从$P_i$出发可通过最多L个可视线到达的POI</p>
<p>采用递归方法，整体分为两步：</p>
<ol>
<li>构建可视网络</li>
<li>移动和回溯</li>
</ol>
<h3 id="Constructing-the-Viewable-Network"><a href="#Constructing-the-Viewable-Network" class="headerlink" title="Constructing the Viewable Network"></a>Constructing the Viewable Network</h3><p>构建可视网络的思路大致是：从右向左扫描点（也就是从最后一个点开始），每扫描到一个点就看它右边是否有没被挡住可以直接相连的点，如果有就连起来，这样一直扫到最左边的点（也就是第一个点），网络就构建好了。</p>
<p>实际上这个网络扫描的方向并不一定要这样，也可以从左往右。</p>
<p>时间复杂度的分析和证明省略。</p>
<h3 id="Searching-Heterogeneous-POIs"><a href="#Searching-Heterogeneous-POIs" class="headerlink" title="Searching Heterogeneous POIs"></a>Searching Heterogeneous POIs</h3><ol>
<li>总共有$n$个兴趣点</li>
<li>兴趣点异构，总共有$j$个类型</li>
<li>有$j$个异构兴趣点的聚类的集合记作$G_j$，而$G_1$是有$n$个聚类的集合，其中每个聚类都包含一个兴趣点</li>
<li>垂直线从第$n-j+1$个点开始扫描，L层邻接POI集合最多有$j$个POI，这也是构建包含j-1个异构兴趣点的聚类的最小兴趣点编号</li>
<li>整个算法递归地根据$G_{j-1}$计算$G_j$，具体过程如下：<ol>
<li>每当扫描到一个兴趣点$P_i$时，遍历$G_{j-1}$中的聚类，如果某个聚类属于$P_i$的L层邻接POI集合，则把该聚类加到一个新集合$S_{i,j-1}$中</li>
<li>第一步中的聚类遍历结束后，遍历得到的集合$S_{i,j-1}$中的聚类，如果$P_i$和这个聚类异构，则把$P_i$和这个聚类组成的集合加到集合$G_j$中</li>
<li>继续用同样的思路扫描兴趣点$P_{i-1}$，这样循环直到$P_1$被扫描完</li>
<li>最终得到$G_j$作为异构兴趣点聚类</li>
</ol>
</li>
</ol>
<p>复杂度分析省略。</p>
<h3 id="Searching-the-Best-K-Results-in-the-Ranking-Mode"><a href="#Searching-the-Best-K-Results-in-the-Ranking-Mode" class="headerlink" title="Searching the Best K Results in the Ranking Mode"></a>Searching the Best K Results in the Ranking Mode</h3><p>算法1构建可视网络得到的可视线记作$E$；算法2寻找异构兴趣点聚类的集合记作$G_{N-1}$（它包括所有具有N-1个异构兴趣点的聚类）；兴趣点$P_i$的L层邻接兴趣点记作$L_i$。</p>
<ol>
<li>从第$i=n-N+1$个兴趣点开始，从右向左扫描所有兴趣点</li>
<li>遍历$G_{N-1}$中的聚类，如果聚类属于$L_i$，则把聚类加到一个新集合$S_{i,N-1}$中</li>
<li>遍历新集合$S_{i,N-1}$中的聚类，如果$P_i$和聚类异构，则把$P_i$和这个聚类组成的集合插入到列表B中，插入顺序按聚类的评价降序</li>
<li>如果列表B中的元素个数大于K，则删去最后一个元素</li>
<li>继续扫描第$i-1$个兴趣点，执行相同的操作，直到扫描到$P_1$</li>
</ol>
<p>复杂度分析省略。</p>
<h2 id="“N-IN-ONE”-LBS-IN-THE-SERVICE-AREA-MODE"><a href="#“N-IN-ONE”-LBS-IN-THE-SERVICE-AREA-MODE" class="headerlink" title="“N-IN-ONE” LBS IN THE SERVICE AREA MODE"></a>“N-IN-ONE” LBS IN THE SERVICE AREA MODE</h2><p>服务区：给定长宽的矩形区域，该区域内的兴趣点密度最大，且所有兴趣点都属于最优Q聚类</p>
<p>矩形区域的权重受三个因素影响：</p>
<ol>
<li>矩形覆盖的最优兴趣点聚类个数</li>
<li>矩形内的兴趣点聚类评分</li>
<li>兴趣点聚类的分布</li>
</ol>
<p><strong>定义3.1</strong>  如果一个兴趣点聚类$\Pi$的中心在某区域$\Gamma$内，则称该聚类在该区域内。</p>
<p>就此将聚类视作其中心点，将该问题转变为<code>maximizing range sum</code>（最大子序列？）</p>
<p>当一个兴趣点属于多个聚类时，我们称它被多个聚类复用了。这种情况如果该兴趣点不可用，则会导致区域内大量聚类都不可用，这不好。</p>
<p><strong>定义3.2</strong>  一个矩形区域内聚类集合的瓶颈值$B$是指，该区域内被复用次数最多的兴趣点所对应的复用次数。</p>
<p><strong>定义3.3</strong>  矩形的权重由该区域内聚类的评分和该区域的瓶颈值决定，计算公式如下：</p>
<script type="math/tex; mode=display">
W(C)=\varepsilon\sum_{\Pi\in C}R(\Pi)-\eta B</script><p>其中，$\varepsilon$和$\eta$都是常数系数。</p>
<p>找服务区的算法流程：</p>
<p>复杂度分析省略。</p>
<h2 id="PERFORMANCE-EVALUATION"><a href="#PERFORMANCE-EVALUATION" class="headerlink" title="PERFORMANCE EVALUATION"></a>PERFORMANCE EVALUATION</h2><h3 id="Performance-Evaluation-Based-on-Synthetic-Data"><a href="#Performance-Evaluation-Based-on-Synthetic-Data" class="headerlink" title="Performance Evaluation Based on Synthetic Data"></a>Performance Evaluation Based on Synthetic Data</h3><h3 id="Performance-Evaluation-Based-on-Real-World-Data"><a href="#Performance-Evaluation-Based-on-Real-World-Data" class="headerlink" title="Performance Evaluation Based on Real-World Data"></a>Performance Evaluation Based on Real-World Data</h3><p>实验部分不看了，省略。</p>
<h2 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h2><p>当前LBS领域的热点研究：基于位置信息的推荐系统，尤其是兴趣点推荐</p>
<ol>
<li>潜在Dirichlet分配（LDA）</li>
<li>朴素贝叶斯</li>
<li>地理概率分析框架，策略性地考虑多个因素</li>
<li>动态聚类算法识别运动轨迹</li>
</ol>
<p>路线推荐同样热门</p>
<ol>
<li>分析用户交通路线来得到两地之间最受欢迎的路线</li>
<li>基于集体知识的路线推荐框架</li>
<li>候选-生成-验证策略得到K近邻轨迹</li>
<li>KNN+更多因素的分析</li>
<li>LIT前缀挖掘算法</li>
<li>网络优化问题</li>
<li>轨迹大数据</li>
</ol>
<p>本文和上述内容的共同点：给用户返回多个POI</p>
<p>不同点：本文侧重查询，是LBS的基础服务；上述侧重推荐，是LBS的衍生服务</p>
<p>本文的创新性：现有LBS的基础服务不涉及多POI查询，本文针对基础服务进行了改进</p>
<h2 id="CONCLUSION-AND-FUTURE-WORK"><a href="#CONCLUSION-AND-FUTURE-WORK" class="headerlink" title="CONCLUSION AND FUTURE WORK"></a>CONCLUSION AND FUTURE WORK</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>LBS</tag>
        <tag>POI</tag>
      </tags>
  </entry>
  <entry>
    <title>blender学习记录-2</title>
    <url>/2020/07/07/blender%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-2/</url>
    <content><![CDATA[<p>第二课是建模型相关操作</p>
<a id="more"></a>
<p>我发现了，blender入门教程其实就是教快捷键。</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">进入编辑模式</td>
<td style="text-align:center">TAB</td>
</tr>
<tr>
<td style="text-align:center">切换选择模式</td>
<td style="text-align:center">W</td>
</tr>
<tr>
<td style="text-align:center">环选，例如点竖线会把横着一圈选中，而点横线会把竖着的一圈选中</td>
<td style="text-align:center">alt+左键</td>
</tr>
<tr>
<td style="text-align:center">连选</td>
<td style="text-align:center">ctrl</td>
</tr>
<tr>
<td style="text-align:center">多选（这个和上一个刚好和windows系统的操作相反）</td>
<td style="text-align:center">shift</td>
</tr>
<tr>
<td style="text-align:center">全选</td>
<td style="text-align:center">A</td>
</tr>
<tr>
<td style="text-align:center">取消全选</td>
<td style="text-align:center">双击A</td>
</tr>
<tr>
<td style="text-align:center">挤出</td>
<td style="text-align:center">E</td>
</tr>
<tr>
<td style="text-align:center">环切，环切确认的时候滚动滚轮可以一次切好几个</td>
<td style="text-align:center">ctrl+R</td>
</tr>
<tr>
<td style="text-align:center">倒角</td>
<td style="text-align:center">ctrl+B</td>
</tr>
<tr>
<td style="text-align:center">内插面</td>
<td style="text-align:center">I（进编辑模式，双击I会有不太一样的效果，但是我说不清是什么样的）</td>
</tr>
<tr>
<td style="text-align:center">环切</td>
<td style="text-align:center">ctrl+R</td>
</tr>
<tr>
<td style="text-align:center">偏移环切线</td>
<td style="text-align:center">ctrl+shift+R</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>blender</category>
      </categories>
      <tags>
        <tag>随便学学</tag>
      </tags>
  </entry>
  <entry>
    <title>typora图床功能设置</title>
    <url>/2020/07/07/typora%E5%9B%BE%E5%BA%8A%E5%8A%9F%E8%83%BD%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>终于不用自己上传github然后再复制链接到markdown了！</p>
<a id="more"></a>
<ol>
<li><p>打开typora，文件—&gt;偏好设置—&gt;图像，然后按照下图设置：</p>
<p><img src="https://pic3.zhimg.com/80/v2-2f7c965687ee0689ced4a80a608599be_1440w.jpg" alt="img"></p>
</li>
<li><p>设置好以后点下载或更新，下载更新结束以后，浏览器打开<a href="https://sm.ms/home/apitoken" target="_blank" rel="noopener">smms</a>并注册账号和登录，注册的时候要填用户名和邮箱，登录的时候不是邮箱登录而是用户名登录；</p>
</li>
<li><p>注册并登录以后打开<a href="https://sm.ms/home/apitoken" target="_blank" rel="noopener">新链接</a>，secret token那里是空的，点下面的generate secret token，会得到一串字符，如下图：</p>
<p><img src="https://pic2.zhimg.com/80/v2-f8e838a39e52ef233bca3c190af483f1_1440w.jpg" alt="img"></p>
</li>
<li><p>回到刚才的typora，还是图像那里，打开配置文件，如果要选应用程序就找记事本之类的编辑器；</p>
</li>
<li><p>把下面的代码复制粘贴进去和保存：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"picBed"</span>: &#123;</span><br><span class="line">    <span class="attr">"uploader"</span>: <span class="string">"smms"</span>, <span class="comment">// 代表当前的默认上传图床为 SM.MS,</span></span><br><span class="line">    <span class="attr">"smms"</span>: &#123;</span><br><span class="line">      <span class="attr">"token"</span>: <span class="string">"这里面的token换成你上个页面的申请的token"</span> <span class="comment">//一定要换</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"picgoPlugins"</span>: &#123;&#125; <span class="comment">// 为插件预留</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>到此为止就好了，还是在图像那里，点验证图片上传选项，可以验证一下有没有问题。</p>
</li>
</ol>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/137310314" target="_blank" rel="noopener">知乎链接</a></p>
]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>blender学习记录-1</title>
    <url>/2020/07/06/blender%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-1/</url>
    <content><![CDATA[<p>因为种种原因，我决定培养个兴趣爱好，于是开始学blender。</p>
<a id="more"></a>
<p>第一课是移动旋转缩放的操作。</p>
<h2 id="快捷键记录"><a href="#快捷键记录" class="headerlink" title="快捷键记录"></a>快捷键记录</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">视角旋转</td>
<td style="text-align:center">鼠标中键按着拖动</td>
</tr>
<tr>
<td style="text-align:center">视角缩放</td>
<td style="text-align:center">滚动鼠标滚轮</td>
</tr>
<tr>
<td style="text-align:center">视角平移</td>
<td style="text-align:center">shift+鼠标中键按着拖动</td>
</tr>
<tr>
<td style="text-align:center">物体移动</td>
<td style="text-align:center">G</td>
</tr>
<tr>
<td style="text-align:center">物体缩放</td>
<td style="text-align:center">S</td>
</tr>
<tr>
<td style="text-align:center">物体旋转</td>
<td style="text-align:center">R</td>
</tr>
<tr>
<td style="text-align:center">物体删除</td>
<td style="text-align:center">Delete或者X</td>
</tr>
<tr>
<td style="text-align:center">撤销操作</td>
<td style="text-align:center">Ctrl+Z</td>
</tr>
<tr>
<td style="text-align:center">插入关键帧</td>
<td style="text-align:center">I</td>
</tr>
<tr>
<td style="text-align:center">新建各种物体</td>
<td style="text-align:center">shift+A</td>
</tr>
<tr>
<td style="text-align:center">进入/退出编辑模式</td>
<td style="text-align:center">TAB（需要安装M3工具）</td>
</tr>
<tr>
<td style="text-align:center">新建一条边（存疑）</td>
<td style="text-align:center">Ctrl+R</td>
</tr>
<tr>
<td style="text-align:center">进入面模式</td>
<td style="text-align:center">3（不是小键盘的那个）</td>
</tr>
<tr>
<td style="text-align:center">选中某条竖线所在的横面</td>
<td style="text-align:center">alt+左键点击</td>
</tr>
<tr>
<td style="text-align:center">复制物体</td>
<td style="text-align:center">shift+D</td>
</tr>
<tr>
<td style="text-align:center">平面细分</td>
<td style="text-align:center">Ctrl+3</td>
</tr>
<tr>
<td style="text-align:center">打开切换视图面板，可以插入智能摄像机，还可以锁定视图</td>
<td style="text-align:center">pagedown（需要安装M3工具）</td>
</tr>
<tr>
<td style="text-align:center">进入摄像机视图</td>
<td style="text-align:center">0（小键盘的那个，没小键盘就得改设置或者鼠标点视图按钮）</td>
</tr>
<tr>
<td style="text-align:center">选多个物体</td>
<td style="text-align:center">按住shift左键点物体们</td>
</tr>
<tr>
<td style="text-align:center">物体组合</td>
<td style="text-align:center">Ctrl+P 最后一个被选中的是父物体</td>
</tr>
<tr>
<td style="text-align:center">进入/退出四视图</td>
<td style="text-align:center">Ctrl+alt+Q</td>
</tr>
<tr>
<td style="text-align:center">进入各种视图</td>
<td style="text-align:center">~</td>
</tr>
<tr>
<td style="text-align:center">开/关工具栏</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">快捷键进入移动旋转缩放后在坐标轴操作</td>
<td style="text-align:center">分别按XYZ</td>
</tr>
<tr>
<td style="text-align:center">快捷键进入移动旋转缩放后在某平面操作</td>
<td style="text-align:center">按shift+锁定不变的那个轴</td>
</tr>
<tr>
<td style="text-align:center">物体位置角度缩放归0</td>
<td style="text-align:center">alt+G/R/S</td>
</tr>
<tr>
<td style="text-align:center">打开变换面板</td>
<td style="text-align:center">Ctrl+A</td>
</tr>
</tbody>
</table>
</div>
<h2 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h2><p>学着<a href="https://www.bilibili.com/video/BV1T4411N7GE?p=5" target="_blank" rel="noopener">这个</a>做的</p>
<p>我好困啊懒得写了</p>
]]></content>
      <categories>
        <category>blender</category>
      </categories>
      <tags>
        <tag>随便学学</tag>
      </tags>
  </entry>
  <entry>
    <title>Combinatorial Multi-Armed Bandit Based Unknown Worker Recruitment in Heterogeneous Crowdsensing</title>
    <url>/2020/07/05/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Combinatorial%20Multi-Armed%20Bandit%20Based%20Unknown%20Worker%20Recruitment%20in%20Heterogeneous%20Crowdsensing/</url>
    <content><![CDATA[<p>今天的我真的超级难过了。但是再难过也没用，看看论文好了，希望等月底能好点。</p>
<a id="more"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ol>
<li>本文研究问题：异构群智感知系统（也就是众包）中对未知worker的招募</li>
<li>本文场景：requester招募workers收集某城市交通路口一段时间内的交通数据，整个收集过程分为多轮，每轮包含一些和地点有关的任务，对应一个交通路口。每个任务有权重，表示重要性。每个worker能做一个或多个任务，且不同worker能做的任务可能不一样。worker会告诉平台自己能做的任务和期望收到的费用。worker完成任务的质量服从未知分布。</li>
<li>本文目的：设计worker招聘方案，在给定预算的情况下，最大限度提高总任务完成质量。</li>
<li>本文面临的挑战：平台不知道worker的质量分布</li>
<li>本文解决挑战的方法：让worker先完成一些任务，然后从任务结果里学习worker的质量，最后从中找最好的worker，简单来说分为exploration和exploitation。本文需要平衡这两个过程，从而实现目标（这么看一开始被完成的那些任务就被牺牲了）。</li>
<li>本文将上述问题概括为组合多臂老虎机模型（ Combinatorial Multi Armed Bandit），并且说和现存的CMAB模型都不一样；然后本文用扩展的上置信界算法（Upper Confidence Bound）。多臂老虎机模型我之前听说过，但是完全不了解，所以要先查一下。</li>
<li>本文贡献：<ol>
<li>介绍了这个场景并把它概括为多臂老虎机</li>
<li>用UCB来解决这个问题</li>
<li>研究了扩展问题：worker质量和期望收费都不知道的场景</li>
<li>做了仿真实验，分析了性能</li>
</ol>
</li>
</ol>
<h2 id="Combinatorial-Multi-Armed-Bandit"><a href="#Combinatorial-Multi-Armed-Bandit" class="headerlink" title="Combinatorial Multi Armed Bandit"></a>Combinatorial Multi Armed Bandit</h2><ol>
<li>实质是未知概率情况下的选择问题，比如赌博</li>
<li>具体来说，重复一个选择过程，每次有k个选项或动作可供选择，每次选择一个动作后会获得相应的奖励。目标是为了最大化k次后的奖励。选项对应的收益服从某种未知概率分布，对于实验者本人而言是黑箱，因此需要采取各种可能的方式来最大化收益。</li>
<li>基础思路：每一轮根据之前的结果更新对收益的期望，期望计算方法为[之前采取该选项所得到的所有收益]/[之前采取过该选项的次数]，也就是平均每次得到的收益；只要时间够长，这个算出来的期望就会接近真实收益。</li>
</ol>
<h2 id="System-model-and-problem"><a href="#System-model-and-problem" class="headerlink" title="System model and problem"></a>System model and problem</h2><ol>
<li><p>字母符号表示：</p>
<p>|               名称               |                             含义                             |<br>| :———————————————: | :—————————————————————————————: |<br>|                t                 |                       当前轮数，第t轮                        |<br>|                N                 |                N个workers的集合，第i个worker                 |<br>|                M                 |                   M个任务的集合，第j个任务                   |<br>|                B                 |                             预算                             |<br>|              $w_j$               |            第j个任务的权重，所有权重加起来的和是1            |<br>|                L                 |              每个worker会向平台提交L个任务候选               |<br>|      $p_i^l=<M_i^l,c_i^l>$       | 第i个worker提交的第l个选项，其中$M_i^l$表示该worker的任务候选集合，$c_i^l$表示收费 |<br>| $c_i^l=\varepsilon_i f(|M_i^l|)$ | $\varepsilon_i$是收费参数，不同worker不一样，比如有的worker设备特别棒，这个参数就会大一点，参数是已知公开（先验）的，本文也考虑了未知的情况；$f()$是单调增函数，意思是任务完成越多收益越大，是已知公开的，且大家都一样；c的取值被规范化到0和1之间 |<br>|     $P_i=\{p_i^l|1&lt;=l&lt;=L\}$      |                  第i个worker提交的选项集合                   |<br>|        $P=U_{i\in N}P_i $        |                         所有选项集合                         |<br>|      $q_{i,j}^t|j\in M_i^l$      | 非负随机量，范围在0和1之间，表示第i个worker在第t轮完成第j个任务的任务质量，服从某种未知分布，期望是$q_i$，期望也未知 |<br>|          $P^t\subset P$          |            第t轮中平台对所有workers所选的选项集合            |<br>|          $p_i^l\in P^t$          |            第t轮平台对第i个worker选了其第l个选项             |<br>|            $u^j(P^t)$            | 第t轮采用方案$P^t$时的第j个任务的最终质量（所有完成任务结果中最好的那个） |<br>|             $u(P^t)$             | 第t轮采用方案$P^t$时所有任务的最终质量和，也就是上一个符号乘权重再加起来 |<br>|            $n_i^l(t)$            |               第i个worker的第l个选项被选的次数               |<br>|             $n_i(t)$             |                  第i个worker被学习过的次数                   |<br>|       $\overline{q}_i(t)$        |             截至到第t轮学习到的第i个worker的质量             |</p>
<p>需要注意：虽然worker可以提交L个任务候选，但是每一轮只能最终完成一个选项，这里假设$c_i^1$到$c_i^L$是从小到大排的，也就是说最后一个的收费最高，且实际中，c的取值一般和M的长度（就是任务数量）正相关。</p>
<ul>
<li>这里有个奇怪的问题，我以为每个选项就是单独一个任务，然后c是对应的收费，但是看起来每个选项是任务集合，然后c是收费，也就是说比如有5个任务用abcde表示，某个worker的选项就会是{a,b,收费3}{b,c,d,收费5}{a,c,d,e,收费10}，这样看起来好奇怪。希望后面有解释。</li>
<li>虽然这样的设定有点别扭，不过解释是说：每一轮每个worker完成$|M_i^l|$个任务，也就会学习到到$|M_i^l|$个任务质量，就是说任务质量会被学习$|M_i^l|$次，这和传统CMAB不一样。</li>
<li>每轮每个worker最多定一个选项（也可以不选）</li>
</ul>
</li>
<li><p>要研究的问题：给定预算，每轮招募K个workers，使得所有轮中完成的所有任务的权重加起来最大。</p>
</li>
<li><p>数学模型：</p>
<p>目标函数最大化：$E[\sum_{t\geq1}u(P^t) ]$    所有轮下来总期望收益最大</p>
<p>约束：$\sum_{t\geq1}\sum_{p_i^l\in P^t}c_i^l\leq B$    花费不超过预算</p>
<p>​            $|P^t|=K \  for\ \forall t&gt;1$    每一轮都招K个workers，不多不少</p>
<p>​            $\sum_{l=1}^LI\{p_i^l\in P^t\}\leq 1$    每个worker的选项最多一个</p>
</li>
</ol>
<h2 id="Algorithm-Design"><a href="#Algorithm-Design" class="headerlink" title="Algorithm Design"></a>Algorithm Design</h2><ol>
<li><p>本文模型：K臂的组合多臂赌博机</p>
</li>
<li><p>本文方法：</p>
<ol>
<li>扩展的上置信界算法（UCB）学习任务质量</li>
<li>增加了对最大化权重的考虑</li>
<li>每轮用贪心算法招K个workers：最大化任务质量和招募费用的比（单位费用的任务质量最大化）</li>
</ol>
<h3 id="原本的UCB算法"><a href="#原本的UCB算法" class="headerlink" title="原本的UCB算法"></a>原本的UCB算法</h3><ol>
<li>总的来说就是估计置信区间</li>
<li>我们认为真实的那个未知概率或者说收益是p，而根据尝试和计算推断出的概率是$\widetilde{p}$，这两个概率之间存在差值，即：$\widetilde{p}-\Delta \leq p \leq \widetilde{p}+\Delta$，这个范围就是置信区间，算法的目的就是通过一次次尝试缩小置信区间</li>
<li>该算法的流程是在所有臂里找$\widetilde{p}+\Delta$最大的那个，根据一系列完全没看的数学定理，$\Delta=\sqrt{2\ln T /n}$，T是目前进行过的轮数，n是这个臂已经被选过的次数，每一轮执行完会更新数据。具体来说，$\widetilde{p}$最大，选这个选项的收益就越大，而$\Delta$越大，这个选项之前被选中的次数就越小。</li>
<li>总结一下就是会考虑每个臂已经估计过的历史记录，尽可能去探索次数较少和收益较高的臂，兼顾收益和探索。</li>
</ol>
<h3 id="本文的算法"><a href="#本文的算法" class="headerlink" title="本文的算法"></a>本文的算法</h3><ol>
<li>在第t轮中，若第i个worker的第l个选项被选中，则$n_i^l(t)=n_i^l(t-1)+1$（就是比上一轮的多1），反之则保持上一轮的值不变</li>
<li>$n_i(t)$的值是第t轮时的第i个worker每个选项的$n_i^l(t)$和该选项任务数（也就是$|M_i^l|$）相乘，然后所有的加起来，表示第i个worker的质量被学习过的次数</li>
<li>用普通的总值/总次数更新worker的质量（$\overline {q}_i(t)$），用不太一样的UCB平衡探索和收益（$\widehat{q}_i (t)$）</li>
<li>每一轮都是最大化权重*$\widehat{q}_i (t)$，也就是根据之前结果的信息推断出的最大收益</li>
</ol>
<h3 id="本文的流程"><a href="#本文的流程" class="headerlink" title="本文的流程"></a>本文的流程</h3><ol>
<li>最一开始，对于每个worker平台都让他去完成候选列表中的第一个任务（就是最便宜的那个）,由此初始化$n_i^l(t)$、$n_i(t)$、$\overline{q}_i(t)$。</li>
<li>接下来的每一轮中，都以最大化单位费用的收益增长为目的来选择K个worker和它们的任务，也就是说([选择这个任务选项的收益]-[选之前的收益])/[选这个任务的开销]，要找使得这个式子最大的那个任务选项。要注意这一步中，当某个worker已经被选了任务，那他的其他选项都不会再被考虑</li>
<li>第t轮的K个worker选好以后，开始各自完成任务，做完以后平台计算任务质量，由此更新$n_i^l(t)$、$n_i(t)$、$\overline{q}_i(t)$、$\widehat{q}_i (t)$。同时，目前为止的所有轮获得的收益也更新了，平台根据预算还剩多少决定是否进行下一轮。</li>
</ol>
<h3 id="算法性能分析"><a href="#算法性能分析" class="headerlink" title="算法性能分析"></a>算法性能分析</h3><ol>
<li>实质是01背包问题</li>
<li>经过一系列我还没看的计算，该算法复杂度是$O(NLK^3\ln \tau(B))$</li>
</ol>
</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol>
<li><p>扩展问题场景：所有worker的质量和收费都未知，收费未知是指$c_i^l=\varepsilon_i f(|M_i^l|)$这个公式里的参数$\varepsilon_i$未知，公式里的函数$f()$是公开的。具体来说，在第t轮，worker的任务已经选定后，worker根据当前电量、环境、网络等估计一个第t轮的收费参数$\varepsilon_i^t$，该值在0和1之间，且有下限$\varepsilon_{min}$，所有轮的$\varepsilon_i^t$独立同分布，分布未知，期望是$\varepsilon_i$。</p>
</li>
<li><p>每一轮开始时，首先是平台选worker和任务，然后是worker报价，接着平台算一下预算够不够，不够的话就结束，反之就进入做任务的环节，之后的流程和上一部分一样。</p>
</li>
<li><p>问题在于：$\varepsilon_i$也需要学习，而且每一轮会被学习一次，这和之前的任务质量不太一样。</p>
<h3 id="本文方法"><a href="#本文方法" class="headerlink" title="本文方法"></a>本文方法</h3><ol>
<li>新增一个符号表示：$m_i(t)=\sum_{l=1}^Ln_i^l(t)$，表示$\varepsilon_i$目前被学习过的次数（第i个worker的所有选项目前被选过的次数）</li>
<li>新增另一个符号表示：$\overline \varepsilon_i (t) $，计算方法和前面p那个类似，也是[在此之前的值*在此之前的次数+这次的值]/[在此之前的次数+1]</li>
<li>同样也新增了$\widehat  \varepsilon_i (t)$，和前面的一样</li>
<li>把之前那个目标函数里的费用部分用这里新的符号改写然后化简，但是这里化简以后的没看懂（问了一下作者，是从regret部分分析出来的，然后又看了看之前没看的证明，发现是证明部分分析的）</li>
<li>于是整个流程就和之前的一模一样，只是目标函数换了</li>
<li>算法性能分析和前面一样，还没看，感觉不重要</li>
</ol>
</li>
</ol>
<h2 id="Performance-Evaluation"><a href="#Performance-Evaluation" class="headerlink" title="Performance Evaluation"></a>Performance Evaluation</h2><ol>
<li>实验部分对平台的介绍格外简单，用的公开数据集，这部分没什么能说的</li>
<li>实验主要关注：期望质量和期望费用（就是前面计算的俩参数）</li>
<li>实验内容是和另一种常用的CMAB的算法做对比</li>
<li>针对第一个算法：分析了预算的影响（500-1000），招募工人数K的变化（得出K小一些更好，但是意味着要来更多轮），用均匀分布作为例子对比了准确率</li>
<li>针对第二个算法：估计了质量和预算的关系，改变工人数之后的性能（和上一个不太一样了）</li>
</ol>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ol>
<li>没啥总结的，这个论文就这样了</li>
<li>之后有时间就看看性能证明那里，不过个人觉得十有八九是已有证明改编的</li>
<li>看了一点证明，还没完全看懂，大致了解思路了，不过不打算继续看了……</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>crowdsourcing</tag>
        <tag>Combinatorial Multi Armed Bandit</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-重构比特币费率市场</title>
    <url>/2020/07/05/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-%E9%87%8D%E6%9E%84%E6%AF%94%E7%89%B9%E5%B8%81%E8%B4%B9%E7%8E%87%E5%B8%82%E5%9C%BA/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程期末作业</title>
    <url>/2020/06/13/python%E8%AF%BE%E7%A8%8B%E6%9C%9F%E6%9C%AB%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<p>实际上在这之前还有两课讲<code>scikit</code>库，不过没作业，就不整理内容了。</p>
<a id="more"></a>
<h1 align = "center">北京师范大学2019～2020学年第二学期期末大作业</h1>
<h1 align = "center">（研究生）</h1>

<p><strong>课程名称：</strong><u>Python编程之美</u>   &nbsp;&emsp;&emsp;&emsp; <strong>任课教师姓名：</strong><u>邓擎琼</u></p>
<p><strong>总分</strong>：<u>40</u>   </p>
<p><strong>院 系：</strong><u>人工智能学院</u> &nbsp;&emsp;&emsp;&emsp; <strong>年级：</strong><u>2019级</u></p>
<p><strong>姓 名：</strong><u>李琨</u>   &nbsp;&emsp;&emsp;&emsp; <strong>学 号：</strong><u>201931210003</u></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">题号</th>
<th style="text-align:center">第一题</th>
<th style="text-align:center">第二题</th>
<th style="text-align:center">第三题</th>
<th style="text-align:center">第四题</th>
<th style="text-align:center">第五题</th>
<th style="text-align:right">总分</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">得分</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p><strong>阅卷教师（签字）：</strong><u> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp;</u></p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><ol>
<li>读入北京历史天气数据（北京天气.xlsx）；  <font color='red'>分值：3</font><br>或者：从<a href="http://www.tianqihoubao.com/lishi/beijing.html" target="_blank" rel="noopener">http://www.tianqihoubao.com/lishi/beijing.html</a><br>网站上通过爬虫把北京2011年-至今的天气数据爬下来，并保存为Excel文件；  <font color='red'>分值：10</font></li>
<li>读入北京空气质量数据（北京空气质量.xlsx），并把该数据和第1步中得到的北京天气数据进行融合，得到一个同时包含天气和空气质量的表格数据，保存为Excel文件；   <font color='red'>分值：5</font></li>
<li>对2011-2019年的每一年，统计这一年中白天为晴、雨、多云、阴、雪、雾霾、扬沙的天数，并绘制成饼图；    <font color='red'>分值：4</font></li>
<li>对2014-2019年的每一年，统计这一年中持续1天污染的次数、持续2天污染的次数、持续3天污染的次数、持续4天污染的次数和持续5天及以上有污染的次数，把所有年份的统计结果绘制成一幅柱状图；    <font color='red'>分值：6</font></li>
<li>在北京历史天气和空气质量数据的基础上，根据当天的天气情况以及前两天的天气及空气质量情况，预测当天的空气质量等级，要求至少比较两种算法，从中选出较优的算法并确定最优超参数（如果算法有超参数的话） 。  <font color='red'>分值：15</font></li>
</ol>
<h2 id="承诺："><a href="#承诺：" class="headerlink" title="承诺："></a>承诺：</h2><p>本人承诺本程序是自己编写的，没有抄袭。</p>
<h3 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h3><p>首先列出所有用到的库，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> requests.compat <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures, StandardScaler</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OrdinalEncoder, OneHotEncoder, LabelEncoder</span><br></pre></td></tr></table></figure>
<ol>
<li>考虑到题目中有画图的要求，而内容有中文，因此先将<code>plt</code>的字体改为中文字体。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><ol>
<li><p>首先分析天气数据的<a href="http://www.tianqihoubao.com/lishi/beijing.html" target="_blank" rel="noopener">网页链接</a>，该页面并不直接包含天气数据，而是包含了指向每个月天气数据的链接，因此需要先从该页面把所有月份的链接提取出来。经过分析可知，该页面所有链接都在<code>class_=&quot;box pcity&quot;</code>的<code>div</code>块中，是<code>a</code>标签，因此可以通过以下函数来获取所有链接，该函数将所有链接存放在一个列表中并返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_href</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：获取所有天气链接</span></span><br><span class="line"><span class="string">    参数：无</span></span><br><span class="line"><span class="string">    返回值：href_list 所有天气链接的列表</span></span><br><span class="line"><span class="string">    使用方式：list = get_href()</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 设置网页链接和head等信息</span></span><br><span class="line">    url = <span class="string">'http://www.tianqihoubao.com/lishi/beijing.html'</span></span><br><span class="line">    head = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36'</span>&#125;</span><br><span class="line">    <span class="comment"># 获取网页文件并分析</span></span><br><span class="line">    html = requests.get(url, headers=head)</span><br><span class="line">    bsObj = BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">    <span class="comment"># 找到所有天气链接所在区块</span></span><br><span class="line">    allLinks = bsObj.find_all(<span class="string">'div'</span>, class_=<span class="string">"box pcity"</span>)</span><br><span class="line">    href_list = []</span><br><span class="line">    <span class="comment"># 提取所有链接并存入列表返回</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> allLinks[:<span class="number">10</span>]:</span><br><span class="line">        aLink = i.find_all(<span class="string">'a'</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> aLink:</span><br><span class="line">            href = urljoin(url, j[<span class="string">'href'</span>])</span><br><span class="line">            href_list.append(href)</span><br><span class="line">    <span class="keyword">return</span> href_list</span><br></pre></td></tr></table></figure>
</li>
<li><p>得到所有链接的列表后，遍历该列表即可访问每个月的天气数据网页，分析这些网页可以发现，天气数据存放在<code>table</code>中，每一行的标签为<code>tr</code>，每一项的标签为<code>td</code>，而一行有四项，分别是日期、天气、温度、风力风向，其中第一行是表格头，因此可以从表格的第二行（第二个<code>tr</code>）开始遍历，获取所有<code>td</code>的内容（是一个长度为4的列表），将内容逐一处理再存放在列表中。遍历完成后即可得到所有天气数据，我将这些数据存放在列表中并返回，函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis_href</span><span class="params">(href_list)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：分析处理天气链接里的数据</span></span><br><span class="line"><span class="string">    参数：href_list 天气链接列表</span></span><br><span class="line"><span class="string">    返回值：lists 所有处理后的天气数据，格式为[日期、天气、温度、风力风向]</span></span><br><span class="line"><span class="string">    使用方式：lists = analysis_href(href_list)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 设置head</span></span><br><span class="line">    head = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36'</span>&#125;</span><br><span class="line">    lists = []</span><br><span class="line">    <span class="comment"># 遍历所有链接</span></span><br><span class="line">    <span class="keyword">for</span> href <span class="keyword">in</span> href_list:</span><br><span class="line">        <span class="comment"># 获取网页文件并分析</span></span><br><span class="line">        html = requests.get(href, headers=head)</span><br><span class="line">        bsObj = BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">        <span class="comment"># 找到天气数据所在的表格</span></span><br><span class="line">        table = bsObj.find(<span class="string">"table"</span>).find_all(<span class="string">"tr"</span>)</span><br><span class="line">        <span class="comment"># 从表格第二行开始提取数据（第一行是表格的head）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> table[<span class="number">1</span>:]:</span><br><span class="line">            content = i.find_all(<span class="string">"td"</span>)</span><br><span class="line">            <span class="comment"># 提取日期并去除多余的空格和换行符等</span></span><br><span class="line">            date = content[<span class="number">0</span>].text.replace(</span><br><span class="line">                <span class="string">" "</span>, <span class="string">""</span>).replace(<span class="string">'\n'</span>, <span class="string">''</span>).replace(<span class="string">'\r'</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="comment"># 提取天气并去除多余的空格和换行符等</span></span><br><span class="line">            weather = content[<span class="number">1</span>].text.replace(<span class="string">" "</span>, <span class="string">""</span>).replace(</span><br><span class="line">                <span class="string">" "</span>, <span class="string">""</span>).replace(<span class="string">'\n'</span>, <span class="string">''</span>).replace(<span class="string">'\r'</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="comment"># 提取温度并去除多余的空格和换行符等</span></span><br><span class="line">            temperature = content[<span class="number">2</span>].text.strip().replace(</span><br><span class="line">                <span class="string">" "</span>, <span class="string">""</span>).replace(<span class="string">'\n'</span>, <span class="string">''</span>).replace(<span class="string">'\r'</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="comment"># 提取风力风向并去除多余的空格和换行符等</span></span><br><span class="line">            wind = content[<span class="number">3</span>].text.strip().replace(</span><br><span class="line">                <span class="string">" "</span>, <span class="string">""</span>).replace(<span class="string">'\n'</span>, <span class="string">''</span>).replace(<span class="string">'\r'</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="comment"># 将提取的数据存入列表</span></span><br><span class="line">            lists.append([date, weather, temperature, wind])</span><br><span class="line">    <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>
</li>
<li><p>在得到天气数据的列表后，需要将该列表数据写入excel文件，我先将列表转为<code>numpy</code>数组，再将该数组转为<code>DataFrame</code>，并把索引设置为<code>日期</code>列，这时就可以用<code>pandas</code>的库函数将所有内容写入<code>excel</code>文件了，函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_excel</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：将数据写入excel文件</span></span><br><span class="line"><span class="string">    参数：filename 文件名</span></span><br><span class="line"><span class="string">    返回值：无</span></span><br><span class="line"><span class="string">    使用方式：write_excel("weather.xlsx")</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 调用分析网页的函数获取所有天气数据所在列表</span></span><br><span class="line">    a = np.array(analysis_href(get_href()))</span><br><span class="line">    <span class="comment"># 将天气数据列表转为DateFrame</span></span><br><span class="line">    DF = pd.DataFrame(a, columns=[<span class="string">'日期'</span>, <span class="string">'天气'</span>, <span class="string">'温度'</span>, <span class="string">'风力风向'</span>])</span><br><span class="line">    <span class="comment"># 将索引设置为日期列，去除原本的索引序号</span></span><br><span class="line">    DF.set_index(<span class="string">'日期'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 将数据写入excel文件</span></span><br><span class="line">    DF.to_excel(filename)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在主函数中通过调用<code>write_excel()</code>即可得到天气数据文件，完成第一题。</p>
</li>
</ol>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><ol>
<li><p>首先读取天气数据和空气质量数据，并将<code>日期</code>列设置为<code>datetime</code>格式的索引，以便后续分析。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">df_weather = pd.read_excel(<span class="string">'weather.xlsx'</span>, <span class="string">'Sheet1'</span>, header=<span class="number">0</span>)</span><br><span class="line">df_air = pd.read_excel(<span class="string">'北京空气质量.xlsx'</span>, <span class="string">'Sheet1'</span>, header=<span class="number">0</span>)</span><br><span class="line">df_weather[<span class="string">'日期'</span>] = pd.to_datetime(df_weather[<span class="string">'日期'</span>], format=<span class="string">"%Y年%m月%d日"</span>)</span><br><span class="line">df_weather.set_index(<span class="string">'日期'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df_air[<span class="string">'日期'</span>] = pd.to_datetime(df_air[<span class="string">'日期'</span>], format=<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">df_air.set_index(<span class="string">'日期'</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来通过<code>pandas</code>的库函数即可将两个<code>DataFrame</code>按日期融合起来，因为两个表格中的日期并没有完全一致，所以去除了不一致的日期。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_merge = pd.merge(df_weather, df_air, on=<span class="string">'日期'</span>)</span><br><span class="line">df_merge.index = df_merge.index.date</span><br></pre></td></tr></table></figure>
</li>
<li><p>将该<code>DataFrame</code>写入<code>excel</code>文件，完成第二题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_merge.to_excel(<span class="string">'merge.xlsx'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><ol>
<li><p>分析天气数据，可以看出白天天气和夜晚天气通过<code>/</code>分隔，因此首先通过<code>split()</code>函数得到白天天气。</p>
</li>
<li><p>由于数据源本身的问题，有个别天气是无效的（是<code>-</code>符号），因此要删去这些数据。</p>
</li>
<li><p>得到白天天气后，还需要将该天气转换为题目中提到的几个类别中的一个，例如“小雨”要转换为“雨”。值得注意的是，”雨夹雪“天气我算作雨天而不是雪天。</p>
</li>
<li><p>上述处理天气数据的函数如下，该函数返回处理好的天气数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_weather_data</span><span class="params">(df_weather)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：处理天气数据以便后续绘图</span></span><br><span class="line"><span class="string">    参数：df_weather 初始天气数据</span></span><br><span class="line"><span class="string">    返回值：df_weather 处理好的天气数据</span></span><br><span class="line"><span class="string">    使用方式：df_weather = process_weather_data(df_weather)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 分离出白天天气</span></span><br><span class="line">    df_weather[<span class="string">'白天天气'</span>] = df_weather[<span class="string">'天气'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'/'</span>)[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 删去无效数据</span></span><br><span class="line">    df_weather = df_weather.drop(df_weather[df_weather[<span class="string">'白天天气'</span>] == <span class="string">'-'</span>].index)</span><br><span class="line">    <span class="comment"># 统一雨天数据</span></span><br><span class="line">    df_weather.loc[(df_weather[<span class="string">'白天天气'</span>] == <span class="string">'小雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'中雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'大雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'暴雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'阵雨'</span>) | ( df_weather[<span class="string">'白天天气'</span>] == <span class="string">'小到中雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'中到大雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'雷阵雨'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'雨夹雪'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雨'</span></span><br><span class="line">    <span class="comment"># 统一雪天数据</span></span><br><span class="line">    df_weather.loc[(df_weather[<span class="string">'白天天气'</span>] == <span class="string">'小雪'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'中雪'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'大雪'</span>) | ( df_weather[<span class="string">'白天天气'</span>] == <span class="string">'小到中雪'</span>) | (df_weather[<span class="string">'白天天气'</span>] == <span class="string">'中到大雪'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雪'</span></span><br><span class="line">    <span class="comment"># 统一扬沙天气</span></span><br><span class="line">    df_weather.loc[df_weather[<span class="string">'白天天气'</span>] == <span class="string">'浮尘'</span>, <span class="string">'白天天气'</span>] = <span class="string">'扬沙'</span></span><br><span class="line">    <span class="comment"># 统一雾霾天气</span></span><br><span class="line">    df_weather.loc[(df_weather[<span class="string">'白天天气'</span>] == <span class="string">'雾'</span>) | ( df_weather[<span class="string">'白天天气'</span>] == <span class="string">'霾'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雾霾'</span></span><br><span class="line">    <span class="keyword">return</span> df_weather</span><br></pre></td></tr></table></figure>
</li>
<li><p>对处理好的数据按年分组，再遍历分组结果，可以得到每一年的数据，由于题目要求2011年至2019年，因此当遍历到2020年时终止循环。</p>
</li>
<li><p>对每一年的数据按白天天气这一列分组，统计分组的<code>size</code>，即可得到每种天气的天数，在此基础上可以绘制图像。上述分组并统计绘图的函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weather_pie</span><span class="params">(df_weather)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：根据处理好的天气数据画饼状图</span></span><br><span class="line"><span class="string">    参数：df_weather 处理好的天气数据</span></span><br><span class="line"><span class="string">    返回值：无</span></span><br><span class="line"><span class="string">    使用方式：weather_pie(df_weather)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 按年份分组</span></span><br><span class="line">    weather_group_y = df_weather.groupby(df_weather.index.year)</span><br><span class="line">    <span class="comment"># 对每年进行循环</span></span><br><span class="line">    <span class="keyword">for</span> n, g <span class="keyword">in</span> weather_group_y:</span><br><span class="line">        <span class="comment"># 不需要2020的数据</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2020</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 按白天天气分组</span></span><br><span class="line">        weather_group = g.groupby(g[<span class="string">'白天天气'</span>]).size()</span><br><span class="line">        <span class="comment"># 输出分组结果</span></span><br><span class="line">        print(str(n)+<span class="string">'年天气天数统计如下：'</span>)</span><br><span class="line">        print(weather_group)</span><br><span class="line">        <span class="comment"># 画饼图并保存</span></span><br><span class="line">        weather_group.name = <span class="string">''</span></span><br><span class="line">        weather_group.plot.pie(startangle=<span class="number">90</span>)</span><br><span class="line">        plt.title(<span class="string">''</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">        plt.savefig(<span class="string">'weather-pie-of-'</span>+str(n), dpi=<span class="number">300</span>)</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>在主函数中调用<code>weather_pie()</code>，参数为第二题中读取的天气数据，完成第三题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">weather_pie(process_weather_data(df_weather))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><ol>
<li><p>针对每一年的数据，首先根据空气质量等级区分开有污染和无污染，为了方便，我新增一列存储污染情况，将所有无污染的数据设置为0，有污染的设置为1。</p>
</li>
<li><p>同样是数据源的问题，个别数据的空气质量等级是无，属于无效数据，因此我删去这些数据。</p>
</li>
<li><p>接下来统计持续污染天数，这里参考了<a href="https://www.zhihu.com/question/41265794" target="_blank" rel="noopener">知乎</a>。具体方法是首先找到污染情况不同的坐标，该坐标就是持续同一污染状态的终点，而上一次持续的终点也是下一次持续的起点，因此可以得到一个存储了持续污染情况天数的表格，再从该表格中取出污染情况为1的部分，并进行分组统计，即可得到这一年持续<code>n</code>天污染的统计结果。需要注意的是，因为题目要求最高统计5天及以上，这里要把持续天数超过5天的也改为5。</p>
</li>
<li><p>由于这一题并不是每一年画一个图，而是所有数据一起画图，因此这里最后要把得到的统计结果转置，存储为行名是年份、列名是污染持续天数的新<code>DataFrame</code>，并返回。上述处理过程的函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_air_data</span><span class="params">(df, year)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：处理空气污染数据</span></span><br><span class="line"><span class="string">    参数：df 初始空气污染数据</span></span><br><span class="line"><span class="string">    返回值：df3 处理好的空气污染数据</span></span><br><span class="line"><span class="string">    使用方式：df_air = process_air_data(df_air)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 统一污染</span></span><br><span class="line">    df.loc[(df[<span class="string">'质量等级'</span>] == <span class="string">'轻度污染'</span>) | (df[<span class="string">'质量等级'</span>] == <span class="string">'中度污染'</span>) | (</span><br><span class="line">        df[<span class="string">'质量等级'</span>] == <span class="string">'重度污染'</span>) | (df[<span class="string">'质量等级'</span>] == <span class="string">'严重污染'</span>), <span class="string">'污染'</span>] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 统一无污染</span></span><br><span class="line">    df.loc[(df[<span class="string">'质量等级'</span>] == <span class="string">'优'</span>) | (df[<span class="string">'质量等级'</span>] == <span class="string">'良'</span>), <span class="string">'污染'</span>] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 删去无效数据</span></span><br><span class="line">    df = df.drop(df[df[<span class="string">'质量等级'</span>] == <span class="string">'无'</span>].index)</span><br><span class="line">    <span class="comment"># 找污染数字相同的位置</span></span><br><span class="line">    pos, = np.where(np.diff(df[<span class="string">'污染'</span>]))</span><br><span class="line">    <span class="comment"># 定位连续污染和连续无污染的起止点</span></span><br><span class="line">    start, end = np.insert(pos+<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), np.append(pos, len(df)<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># 计算污染状态的持续天数</span></span><br><span class="line">    df2 = pd.DataFrame(&#123;<span class="string">'污染'</span>: df[<span class="string">'污染'</span>][start], <span class="string">'持续天数'</span>: end-start+<span class="number">1</span>&#125;)</span><br><span class="line">    <span class="comment"># 从连续天数的表格中提取是污染的</span></span><br><span class="line">    df3 = df2.loc[df2[<span class="string">'污染'</span>] == <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 连续天数大于5的统一变成5，方便下一步分组统计画图</span></span><br><span class="line">    df3.loc[df3[<span class="string">'持续天数'</span>] &gt; <span class="number">5</span>, <span class="string">'持续天数'</span>] = <span class="number">5</span></span><br><span class="line">    <span class="comment"># 按持续天数分组计数，并将计数结果存为DateFrame</span></span><br><span class="line">    df3 = df3.groupby(df3[<span class="string">'持续天数'</span>]).size().reset_index(name=str(year))</span><br><span class="line">    <span class="comment"># 重置index</span></span><br><span class="line">    df3.set_index(<span class="string">'持续天数'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 转置行列，方便后续合并分组结果和画图</span></span><br><span class="line">    df3 = pd.DataFrame(df3.values.T, index=df3.columns, columns=[<span class="string">'1天'</span>, <span class="string">'2天'</span>, <span class="string">'3天'</span>, <span class="string">'4天'</span>, <span class="string">'5天及以上'</span>])</span><br><span class="line">    <span class="keyword">return</span> df3</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来是画图函数，该函数将合并了所有年份的数据绘制为条形图，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pollution_bar</span><span class="params">(df)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：按处理好的空气污染数据画柱状图</span></span><br><span class="line"><span class="string">    参数：df 处理好的空气污染数据</span></span><br><span class="line"><span class="string">    返回值：无</span></span><br><span class="line"><span class="string">    使用方式：pollution_bar(df_air)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    df.plot.bar()</span><br><span class="line">    plt.title(<span class="string">'2014年至2019年持续污染天数柱状图'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'天数'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'出现次数'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.xticks(rotation=<span class="number">0</span>)</span><br><span class="line">    plt.savefig(<span class="string">'pollution-bar'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后要在主函数中将原始的空气污染数据按年分组，并对分组结果逐一调用<code>process_air_data()</code>，再将得到的持续污染天数的数据合并起来，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">air_group_y = df_air.groupby(df_air.index.year)</span><br><span class="line">df_air_processed = process_air_data(air_group_y.get_group(<span class="number">2014</span>), <span class="number">2014</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2015</span>, <span class="number">2020</span>):</span><br><span class="line">    df_air_processed = pd.concat([df_air_processed, process_air_data(air_group_y.get_group(i), i)])</span><br></pre></td></tr></table></figure>
</li>
<li><p>对处理好的数据调用<code>pollution_bar()</code>绘制条形图，参数是第二题中读取的空气污染数据，完成第四题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pollution_bar(df_air_processed)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><ol>
<li><p>分析题目要求，”<strong>根据当天的天气情况以及前两天的天气及空气质量情况，预测当天的空气质量等级</strong>“，而天气情况包括天气、温度和风力风向，因此需要进行以下处理。</p>
</li>
<li><p>首先将白天和晚上的天气、风力风向和最高最低温度分离出来，这三个数据都是以<code>/</code>为分隔，因此可以用<code>split()</code>来完成。这里要注意，温度数据的最后一位是摄氏度的标记，因此要去掉，只保留前面的数字。</p>
</li>
<li><p>接下来分离风力和风向，这里的规律并不明显，但总体而言可以用<code>风</code>字作为分隔符来提取，并在之后的处理中将相同含义但不同表示的字符串合并起来。</p>
</li>
<li><p>天气、风力和风向的数据都是字符串，而其它数据则是数字，由于<code>scikit</code>处理的数据都是数字，因此这里需要对字符串进行特征提取和编码，最初我尝试用<code>DictVectorizer</code>来做，但是这样出来的矩阵略大，而结果准确率也略低，因此决定在这里直接用字典和<code>mapping()</code>将字符串转数字。需要注意的是，在这里我把<code>西南偏南</code>和<code>西南</code>算作同一类，用相同的数字表示。另一方面，上一步中分离出的风力数据，如<code>向≤3级</code>、<code>&lt;3级</code>、<code>1-2级</code>等这些显然是同一个含义的也算作一类，用相同的数字表示。</p>
</li>
<li><p>由于天气种类很多，而其中有一些属于同一类，如果不合并相同类别的数据，会对之后的模型训练造成影响，因此按第三题的方法将所有天气统一，并转为数字表示。</p>
</li>
<li><p>质量等级也是字符串，因此采用同样的方法进行转换。转换结束后，原本的天气、风力风向等等数据就可以删除了。</p>
</li>
<li><p>由于预测还用到了前两天的天气和空气质量情况，因此要把前两天的数据逐一增加到当天数据中，作为新的一列保存，之后要删除无效数据。</p>
</li>
<li><p>由于预测时并没有用到当天的空气质量情况，因此要把当天的空气质量数据都删除，只保留空气质量等级这一列作为训练模型的<code>target</code>。</p>
</li>
<li><p>至此，所有数据已经转为数字类型，并剔除不需要的数据，接下来需要进行标准化，并返回标准化之后的数组，该数组第一列是<code>target</code>，剩下数据是训练用数据。上述数据处理过程为如下函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_predict_data</span><span class="params">(df)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：处理天气和空气数据，方便后续训练</span></span><br><span class="line"><span class="string">    参数：df 初始合并好的天气+空气数据</span></span><br><span class="line"><span class="string">    返回值：df 处理好的数据</span></span><br><span class="line"><span class="string">    使用方式：predict_array = process_predict_data(df)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 划分天气、风力、风向和温度</span></span><br><span class="line">    df[<span class="string">'白天天气'</span>] = df[<span class="string">'天气'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'/'</span>)[<span class="number">0</span>])</span><br><span class="line">    df[<span class="string">'夜晚天气'</span>] = df[<span class="string">'天气'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'/'</span>)[<span class="number">1</span>])</span><br><span class="line">    df[<span class="string">'白天风力风向'</span>] = df[<span class="string">'风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'/'</span>)[<span class="number">0</span>])</span><br><span class="line">    df[<span class="string">'夜晚风力风向'</span>] = df[<span class="string">'风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'/'</span>)[<span class="number">1</span>])</span><br><span class="line">    df[<span class="string">'最高温度'</span>] = df[<span class="string">'温度'</span>].map(<span class="keyword">lambda</span> x: int(x.split(<span class="string">'/'</span>)[<span class="number">0</span>][:<span class="number">-1</span>]))</span><br><span class="line">    df[<span class="string">'最低温度'</span>] = df[<span class="string">'温度'</span>].map(<span class="keyword">lambda</span> x: int(x.split(<span class="string">'/'</span>)[<span class="number">1</span>][:<span class="number">-1</span>]))</span><br><span class="line">    df[<span class="string">'白天风力'</span>] = df[<span class="string">'白天风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'风'</span>)[<span class="number">0</span>])</span><br><span class="line">    df[<span class="string">'白天风向'</span>] = df[<span class="string">'白天风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'风'</span>)[<span class="number">1</span>])</span><br><span class="line">    df[<span class="string">'夜晚风力'</span>] = df[<span class="string">'夜晚风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'风'</span>)[<span class="number">0</span>])</span><br><span class="line">    df[<span class="string">'夜晚风向'</span>] = df[<span class="string">'夜晚风力风向'</span>].map(<span class="keyword">lambda</span> x: x.split(<span class="string">'风'</span>)[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 风向转数字</span></span><br><span class="line">    wind_map_1 = &#123;<span class="string">'无持续'</span>: <span class="number">0</span>, <span class="string">'东'</span>: <span class="number">1</span>, <span class="string">'南'</span>: <span class="number">2</span>, <span class="string">'西'</span>: <span class="number">3</span>, <span class="string">'北'</span>: <span class="number">4</span>, <span class="string">'东北'</span>: <span class="number">5</span>, <span class="string">'东南'</span>: <span class="number">6</span>, <span class="string">'西北'</span>: <span class="number">7</span>, <span class="string">'西南'</span>: <span class="number">8</span>, <span class="string">'西南偏南'</span>: <span class="number">8</span>&#125;</span><br><span class="line">    df[<span class="string">'白天风力'</span>] = df[<span class="string">'白天风力'</span>].map(wind_map_1)</span><br><span class="line">    df[<span class="string">'夜晚风力'</span>] = df[<span class="string">'夜晚风力'</span>].map(wind_map_1)</span><br><span class="line">    <span class="comment"># 风力转数字</span></span><br><span class="line">    wind_map_2 = &#123;<span class="string">'向≤3级'</span>: <span class="number">0</span>, <span class="string">'&lt;3级'</span>: <span class="number">0</span>, <span class="string">'1-2级'</span>: <span class="number">0</span>, <span class="string">'≤3级'</span>: <span class="number">0</span>, <span class="string">'向&lt;3级'</span>: <span class="number">0</span>, <span class="string">'向3-4级'</span>: <span class="number">1</span>, <span class="string">'3-4级'</span>: <span class="number">1</span>, <span class="string">'3～4级'</span>: <span class="number">1</span>, <span class="string">'3～4级'</span>: <span class="number">1</span>, <span class="string">'4'</span>: <span class="number">1</span>, <span class="string">'4-5级'</span>: <span class="number">1</span>, <span class="string">'4～5级'</span>: <span class="number">1</span>, <span class="string">'5～6级'</span>: <span class="number">2</span>, <span class="string">'5-6级'</span>: <span class="number">2</span>, <span class="string">'6-7级'</span>: <span class="number">2</span>&#125;</span><br><span class="line">    df[<span class="string">'白天风向'</span>] = df[<span class="string">'白天风向'</span>].map(wind_map_2)</span><br><span class="line">    df[<span class="string">'夜晚风向'</span>] = df[<span class="string">'夜晚风向'</span>].map(wind_map_2)</span><br><span class="line">    <span class="comment"># 删去不需要的列</span></span><br><span class="line">    df = df.drop(<span class="string">'天气'</span>, axis=<span class="number">1</span>).drop(<span class="string">'温度'</span>, axis=<span class="number">1</span>).drop(<span class="string">'风力风向'</span>, axis=<span class="number">1</span>).drop(<span class="string">'白天风力风向'</span>, axis=<span class="number">1</span>).drop(<span class="string">'夜晚风力风向'</span>, axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 删去无效数据</span></span><br><span class="line">    df = df.drop(df[df[<span class="string">'质量等级'</span>] == <span class="string">'无'</span>].index)</span><br><span class="line">    <span class="comment"># 统一雨天数据</span></span><br><span class="line">    df.loc[(df[<span class="string">'白天天气'</span>] == <span class="string">'小雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'中雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'大雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'暴雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'阵雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'小到中雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'中到大雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'雷阵雨'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'雨夹雪'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雨'</span></span><br><span class="line">    df.loc[(df[<span class="string">'夜晚天气'</span>] == <span class="string">'小雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'中雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'大雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'暴雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'阵雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'小到中雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'中到大雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'大到暴雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'雷阵雨'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'雨夹雪'</span>), <span class="string">'夜晚天气'</span>] = <span class="string">'雨'</span></span><br><span class="line">    <span class="comment"># 统一雪天数据</span></span><br><span class="line">    df.loc[(df[<span class="string">'白天天气'</span>] == <span class="string">'小雪'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'中雪'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'大雪'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'小到中雪'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'中到大雪'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雪'</span></span><br><span class="line">    df.loc[(df[<span class="string">'夜晚天气'</span>] == <span class="string">'小雪'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'中雪'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'大雪'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'小到中雪'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'中到大雪'</span>), <span class="string">'夜晚天气'</span>] = <span class="string">'雪'</span></span><br><span class="line">    <span class="comment"># 统一扬沙天气</span></span><br><span class="line">    df.loc[df[<span class="string">'白天天气'</span>] == <span class="string">'浮尘'</span>, <span class="string">'白天天气'</span>] = <span class="string">'扬沙'</span></span><br><span class="line">    df.loc[df[<span class="string">'夜晚天气'</span>] == <span class="string">'浮尘'</span>, <span class="string">'夜晚天气'</span>] = <span class="string">'扬沙'</span></span><br><span class="line">    <span class="comment"># 统一雾霾天气</span></span><br><span class="line">    df.loc[(df[<span class="string">'白天天气'</span>] == <span class="string">'雾'</span>) | (df[<span class="string">'白天天气'</span>] == <span class="string">'霾'</span>), <span class="string">'白天天气'</span>] = <span class="string">'雾霾'</span></span><br><span class="line">    df.loc[(df[<span class="string">'夜晚天气'</span>] == <span class="string">'雾'</span>) | (df[<span class="string">'夜晚天气'</span>] == <span class="string">'霾'</span>), <span class="string">'夜晚天气'</span>] = <span class="string">'雾霾'</span></span><br><span class="line">    <span class="comment"># 质量等级转数字</span></span><br><span class="line">    quality_mapping = &#123;<span class="string">'优'</span>: <span class="number">0</span>, <span class="string">'良'</span>: <span class="number">1</span>, <span class="string">'轻度污染'</span>: <span class="number">2</span>, <span class="string">'中度污染'</span>: <span class="number">3</span>, <span class="string">'重度污染'</span>: <span class="number">4</span>, <span class="string">'严重污染'</span>: <span class="number">5</span>&#125;</span><br><span class="line">    df[<span class="string">'质量等级'</span>] = df[<span class="string">'质量等级'</span>].map(quality_mapping)</span><br><span class="line">    <span class="comment"># 天气转数字</span></span><br><span class="line">    weather_mapping = &#123;<span class="string">'晴'</span>: <span class="number">0</span>, <span class="string">'雨'</span>: <span class="number">1</span>, <span class="string">'阴'</span>: <span class="number">2</span>, <span class="string">'雪'</span>: <span class="number">3</span>, <span class="string">'多云'</span>: <span class="number">4</span>, <span class="string">'雾霾'</span>: <span class="number">5</span>, <span class="string">'扬沙'</span>: <span class="number">6</span>&#125;</span><br><span class="line">    df[<span class="string">'白天天气'</span>] = df[<span class="string">'白天天气'</span>].map(weather_mapping)</span><br><span class="line">    df[<span class="string">'夜晚天气'</span>] = df[<span class="string">'夜晚天气'</span>].map(weather_mapping)</span><br><span class="line">    <span class="comment"># 增加昨天和前天的数据</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(df)<span class="number">-2</span>):</span><br><span class="line">        df.ix[i+<span class="number">2</span>, <span class="string">'昨天AQI'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天质量等级'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天PM2.5'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天PM10'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天SO2'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天CO'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天NO2'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天O3_8h'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天白天天气'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天夜晚天气'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天白天风力'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天夜晚风力'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天白天风向'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天夜晚风向'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天最高温度'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'昨天最低温度'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天AQI'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天质量等级'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天PM2.5'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天PM10'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天SO2'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天CO'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天NO2'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天O3_8h'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天白天天气'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天夜晚天气'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天白天风力'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天夜晚风力'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天白天风向'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天夜晚风向'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天最高温度'</span>], df.ix[i+<span class="number">2</span>, <span class="string">'前天最低温度'</span>] = df.ix[i+<span class="number">1</span>, <span class="string">'AQI'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'质量等级'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'PM2.5'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'PM10'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'SO2'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'CO'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'NO2'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'O3_8h'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'白天天气'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'夜晚天气'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'白天风力'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'夜晚风力'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'白天风向'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'夜晚风向'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'最高温度'</span>], df.ix[i+<span class="number">1</span>, <span class="string">'最低温度'</span>], df.ix[i, <span class="string">'AQI'</span>], df.ix[i, <span class="string">'质量等级'</span>], df.ix[i, <span class="string">'PM2.5'</span>], df.ix[i, <span class="string">'PM10'</span>], df.ix[i, <span class="string">'SO2'</span>], df.ix[i, <span class="string">'CO'</span>], df.ix[i, <span class="string">'NO2'</span>], df.ix[i, <span class="string">'O3_8h'</span>], df.ix[i, <span class="string">'白天天气'</span>], df.ix[i, <span class="string">'夜晚天气'</span>], df.ix[i, <span class="string">'白天风力'</span>], df.ix[i, <span class="string">'夜晚风力'</span>], df.ix[i, <span class="string">'白天风向'</span>], df.ix[i, <span class="string">'夜晚风向'</span>], df.ix[i, <span class="string">'最高温度'</span>], df.ix[i, <span class="string">'最低温度'</span>]</span><br><span class="line">    <span class="comment"># 删除无效数据</span></span><br><span class="line">    df = df.dropna(how=<span class="string">'any'</span>)</span><br><span class="line">    <span class="comment"># 删除今天空气数据</span></span><br><span class="line">    df = df.drop(<span class="string">'AQI'</span>, axis=<span class="number">1</span>).drop(<span class="string">'PM2.5'</span>, axis=<span class="number">1</span>).drop(<span class="string">'PM10'</span>, axis=<span class="number">1</span>).drop(</span><br><span class="line">        <span class="string">'SO2'</span>, axis=<span class="number">1</span>).drop(<span class="string">'CO'</span>, axis=<span class="number">1</span>).drop(<span class="string">'NO2'</span>, axis=<span class="number">1</span>).drop(<span class="string">'O3_8h'</span>, axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 数据标准化</span></span><br><span class="line">    ss = StandardScaler()</span><br><span class="line">    predict_array = ss.fit_transform(df)</span><br><span class="line">    <span class="keyword">return</span> predict_array</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理好数据后，就可以开始训练模型。首先用<code>train_test_split()</code>划分训练集和测试集。</p>
</li>
<li><p>接下来建立一个算法列表，该列表包含了几个不同的分类器。</p>
</li>
<li><p>对每一个分类器，用K折交叉判断其在训练集的准确率并输出。</p>
</li>
<li><p>根据输出结果选择最优分类器，测试其在测试集上的性能并输出。</p>
</li>
<li><p>在这里经过对比，选择了LDA分类器。整体训练过程如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_air</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    作用：训练和测试模型</span></span><br><span class="line"><span class="string">    参数：array 处理好的数据集</span></span><br><span class="line"><span class="string">    返回值：无</span></span><br><span class="line"><span class="string">    使用方式：predict_air(array)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 划分训练集和测试集</span></span><br><span class="line">    x = array[:, <span class="number">1</span>:]</span><br><span class="line">    y = array[:, <span class="number">0</span>]</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(</span><br><span class="line">        x, y, test_size=<span class="number">0.7</span>, random_state=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 把备选算法放入列表</span></span><br><span class="line">    models = []</span><br><span class="line">    models.append((<span class="string">'LR'</span>, LogisticRegression(</span><br><span class="line">        solver=<span class="string">'liblinear'</span>, multi_class=<span class="string">'ovr'</span>)))</span><br><span class="line">    models.append((<span class="string">'LDA'</span>, LinearDiscriminantAnalysis()))</span><br><span class="line">    models.append((<span class="string">'KNN'</span>, KNeighborsClassifier()))</span><br><span class="line">    models.append((<span class="string">'CART'</span>, DecisionTreeClassifier()))</span><br><span class="line">    models.append((<span class="string">'NB'</span>, GaussianNB()))</span><br><span class="line">    models.append((<span class="string">'SVM'</span>, SVC(gamma=<span class="string">'auto'</span>)))</span><br><span class="line">    <span class="comment"># 用训练集训练每个模型并评价</span></span><br><span class="line">    results = []</span><br><span class="line">    names = []</span><br><span class="line">    <span class="keyword">for</span> name, model <span class="keyword">in</span> models:</span><br><span class="line">        kfold = StratifiedKFold(n_splits=<span class="number">10</span>, random_state=<span class="number">1</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">        cv_results = cross_val_score(model, x_train, y_train.astype(</span><br><span class="line">            <span class="string">'int'</span>), cv=kfold, scoring=<span class="string">'accuracy'</span>)</span><br><span class="line">        results.append(cv_results)</span><br><span class="line">        names.append(name)</span><br><span class="line">        print(<span class="string">'%s: %f (%f)'</span> % (name, cv_results.mean(), cv_results.std()))</span><br><span class="line">    <span class="comment"># 从上面的输出可知lda准确率最高，因此训练lad模型并输出测试集的准确率</span></span><br><span class="line">    lda = LinearDiscriminantAnalysis()</span><br><span class="line">    lda.fit(x_train, y_train.astype(<span class="string">'int'</span>))</span><br><span class="line">    print(lda.score(x_test, y_test.astype(<span class="string">'int'</span>)))</span><br></pre></td></tr></table></figure>
</li>
<li><p>在主函数中先后调用<code>process_predict_data()</code>和<code>predict_air()</code>，在已知某天天气情况和前两天的天气及空气情况时，也可以调用该模型来预测当天空气质量。完成第五题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">predict = process_predict_data(df_merge)</span><br><span class="line">predict_air(predict)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>好了我终于写完了，这个空气质量预测根本就靠不住，一开始只有准确率只有0.3，用很麻烦的方法处理数据之后才达到现在的0.7。啊写实验报告好累，我总算不用再上课了。希望分数能好点。</p>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode的一系列配置</title>
    <url>/2020/06/06/vscode%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>前段时间忽然开始用vscode，今天配置好了C和C++，现在决定整理一下配置过程。</p>
<a id="more"></a>
<h2 id="安装和外观"><a href="#安装和外观" class="headerlink" title="安装和外观"></a>安装和外观</h2><ol>
<li><p><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VSCode官网</a>下载和安装，这部分应该不会有问题，注意最后添加到path的选项要勾选，不然就要自己去配置环境变量；</p>
</li>
<li><p>中文设置：打开扩展（左边那一列按钮最下面的，默认快捷键是<code>ctrl+shift+x</code>，找一个叫Chinese (Simplified) Language Pack for Visual Studio Code的扩展，安装完成以后重启vscode，界面就变成中文了。如果没变，就按<code>ctrl+shift+p</code>，在出现的框里输入configure display language，然后下拉菜单里选zh-cn就可以了。</p>
</li>
<li><p>主题和图标：在扩展里找喜欢的就可以，据推荐vscode-icons比较好看，我也没研究其他图标。</p>
</li>
<li><p>背景：扩展里找background这个插件（名字就是这个单词），安装以后需要设置一下</p>
<ol>
<li><p><code>文件—&gt;首选项—&gt;设置—&gt;扩展—&gt;Plugin background config.background插件配置</code></p>
</li>
<li><p>打开这个界面以后，有一行字<code>在settings.json中编辑</code>，点一下可以打开settings.json（实际上在其他扩展里也能找到这行字，总之打开settings.json就行）</p>
</li>
<li><p>如果之前什么扩展也没装，也没搞别的配置，那这个文件打开以后应该是只有两行花括号(<code>{}</code>)的，如果之前装了别的，那花括号中间可能会有几行内容，接下来在花括号里面输入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;background.enabled&quot;: true,</span><br><span class="line">   &quot;background.useDefault&quot;: false,</span><br><span class="line">   &quot;background.customImages&quot;:[&quot;file:&#x2F;&#x2F;&#x2F;C:&#x2F;Users&#x2F;LiKun&#x2F;Pictures&#x2F;background.png&quot;],</span><br><span class="line">   &quot;background.style&quot;:&#123;</span><br><span class="line">       &quot;content&quot;:&quot;&#39;&#39;&quot;,</span><br><span class="line">       &quot;pointer-events&quot;:&quot;none&quot;,</span><br><span class="line">       &quot;position&quot;:&quot;absolute&quot;,&#x2F;&#x2F;图片位置</span><br><span class="line">       &quot;width&quot;:&quot;99%&quot;,</span><br><span class="line">       &quot;height&quot;:&quot;99%&quot;,</span><br><span class="line">       &quot;z-index&quot;:&quot;99999&quot;,</span><br><span class="line">       &quot;background.repeat&quot;:&quot;no-repeat&quot;,</span><br><span class="line">       &quot;background-size&quot;:&quot;25%,25%&quot;,&#x2F;&#x2F;图片大小</span><br><span class="line">       &quot;opacity&quot;:0.3 &#x2F;&#x2F;透明度</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>
<p>注意：每一行最后的逗号不要忘了，背景图的路径改成自己的图，我这个设置是背景图出现在右下角的位置，如果有其他需求自己改就行。</p>
</li>
</ol>
</li>
</ol>
<h2 id="latex"><a href="#latex" class="headerlink" title="latex"></a>latex</h2><ol>
<li><p>安装texlive，因为我之前安装过texstudio所以就没再装了，这里要记得环境变量的问题，正常来说安装的时候会自动添加，如果没勾选那就要自己配置；</p>
</li>
<li><p>vscode的扩展里找latex workshop安装，据说安装好就能编译tex文件并生成pdf，不过我还搞了乱七八糟的设置才可以；</p>
</li>
<li><p>设置过程还是打开setting.json，直接输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;latex-workshop.latex.recipes&quot;: [</span><br><span class="line">     &#123;</span><br><span class="line">       &quot;name&quot;: &quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;,</span><br><span class="line">       &quot;tools&quot;: [</span><br><span class="line">         &quot;xelatex&quot;,</span><br><span class="line">         &quot;bibtex&quot;,</span><br><span class="line">         &quot;xelatex&quot;,</span><br><span class="line">         &quot;xelatex&quot;</span><br><span class="line">       ]</span><br><span class="line">     &#125;</span><br><span class="line">   ],</span><br><span class="line">   &quot;latex-workshop.latex.tools&quot;: [</span><br><span class="line">     &#123;</span><br><span class="line">       &quot;name&quot;: &quot;xelatex&quot;,</span><br><span class="line">       &quot;command&quot;: &quot;xelatex&quot;,</span><br><span class="line">       &quot;args&quot;: [</span><br><span class="line">         &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">         &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">         &quot;-file-line-error&quot;,</span><br><span class="line">         &quot;%DOC%&quot;</span><br><span class="line">       ]</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       &quot;name&quot;: &quot;latexmk&quot;,</span><br><span class="line">       &quot;command&quot;: &quot;latexmk&quot;,</span><br><span class="line">       &quot;args&quot;: [</span><br><span class="line">         &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">         &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">         &quot;-file-line-error&quot;,</span><br><span class="line">         &quot;%DOC%&quot;</span><br><span class="line">       ]</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       &quot;name&quot;: &quot;pdflatex&quot;,</span><br><span class="line">       &quot;command&quot;: &quot;pdflatex&quot;,</span><br><span class="line">       &quot;args&quot;: [</span><br><span class="line">         &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">         &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">         &quot;-file-line-error&quot;,</span><br><span class="line">         &quot;%DOC%&quot;</span><br><span class="line">       ]</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       &quot;name&quot;: &quot;bibtex&quot;,</span><br><span class="line">       &quot;command&quot;: &quot;bibtex&quot;,</span><br><span class="line">       &quot;args&quot;: [</span><br><span class="line">         &quot;%DOCFILE%&quot;</span><br><span class="line">       ]</span><br><span class="line">     &#125;</span><br><span class="line">   ],</span><br><span class="line">   &quot;latex-workshop.view.pdf.viewer&quot;: &quot;tab&quot;,</span><br><span class="line">   &quot;editor.wordWrap&quot;: &quot;on&quot;,</span><br><span class="line">   &quot;latex-workshop.synctex.afterBuild.enabled&quot;: true,</span><br><span class="line">   &quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;: &quot;double-click&quot;,</span><br><span class="line">   &quot;[latex]&quot;: &#123;</span><br><span class="line">     &quot;editor.defaultFormatter&quot;: &quot;nickfode.latex-formatter&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;latex-workshop.latex.autoClean.run&quot;: &quot;onBuilt&quot;,</span><br></pre></td></tr></table></figure>
<p>注意：这个文件最外层就一组花括号，不管有多少要设置的东西都在里面加；latex的内容里有一些是在那个设置里可以直接选的，而不是通过这种让人看不懂的代码来设置，例如<code>&quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;: &quot;double-click&quot;</code>这一句的作用是在pdf里双击可以跳转到latex源文件对应的位置，本来默认的是ctrl点击，但是我习惯双击，可以在设置里搜synctex:keybinding然后修改，改了会自动在settings.json 里出现那句话；<code>&quot;editor.wordWrap&quot;: &quot;on&quot;</code>是和latex本身无关的设置，是让编辑器可以自动换行；其他各种设置可以自行百度。</p>
</li>
</ol>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><ol>
<li>扩展里搜python，安装跳出来的第一个就行；</li>
<li>可能和我之前已经安装过python、pycharm等等东西有关，安装插件之后就能编译运行python了。</li>
</ol>
<h2 id="C和C"><a href="#C和C" class="headerlink" title="C和C++"></a>C和C++</h2><ol>
<li>安装mingw，如果之前装过就不必重装了，这里要自己添加环境变量，然后检查有没有装好；</li>
<li>vscode里安装C/C++扩展，可能装好要重启；</li>
<li>打开要写代码的那个文件夹，比如C++文件夹，里面新建一个cpp文件随便写几行；</li>
<li><code>Ctrl+Shift+P</code>输入C/C++，选择“Edit Configurations(UI)”进入配置，这里要选编译器：<code>C:/Program Files/mingw-w64/x86_64-8.1.0-posix-seh-rt_v6-rev0/mingw64/bin/g++.exe</code>，路径改成自己的，还要选IntelliSense 模式，要用gcc-x64；</li>
<li>上一步做好以后，可以看到C++文件夹里多出一个.vscode文件夹，里面有c_cpp_properties.json文件，文件内容是写好的，可以看看，不过不需要修改；</li>
<li>再按<code>Ctrl+Shift+P</code>输入tasks，选择“Tasks:Configure Default Build Task”，再选择“C/C++: g++.exe build active file”，然后.vscode文件夹里就会出现tasks.json，也是写好的，不需要改；</li>
<li>接下来点运行—&gt;启动调试，或者直接按F5，选择C++(GDB/LLDB)，会出现一个launch.json，或者左边那列扩展按钮上面的那个按钮里有个创建launch.json也可以；</li>
<li>上一步的launch.json里可以自己根据需求添加一些配置，或者去网上复制别人的配置，总之我这里是什么也没改就能直接运行；</li>
<li>然后再按F5，就可以运行文件了；</li>
<li>在第4步之后，就可以在vscode里找到终端然后gcc编译运行文件；</li>
<li>默认运行输出信息是在下面的终端，在launch.json里找到”externalConsole”然后把它的false改成true,就可以出现独立的命令行界面来显示信息了。</li>
</ol>
<h2 id="KanBan"><a href="#KanBan" class="headerlink" title="KanBan"></a>KanBan</h2><ol>
<li><p>是最近发现的很好用的一个项目管理方式；</p>
</li>
<li><p>在扩展里搜KanBan，出来的第一个就是它，然后安装；</p>
</li>
<li><p>在扩展说明那里能看到很多可以配置的，我的配置如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">"kanban": </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">&lt;!--配置四个列的名称，因为原本的名称不符合我的需求，所以这么改了--&gt;</span></span><br><span class="line">        "columns": &#123;</span><br><span class="line">          "done": "Others",</span><br><span class="line">          "inProgress": "In Progress",</span><br><span class="line">          "testing": "Done",</span><br><span class="line">          "todo": "TODOs"</span><br><span class="line">        &#125;,</span><br><span class="line">        "openOnStartup": true,   <span class="comment">&lt;!--每次打开vscode的时候，自动打开KanBan标签页--&gt;</span></span><br><span class="line">        "trackTime": true    <span class="comment">&lt;!--打开计时功能，如果在干活前后各点一下，就会记录干了多久--&gt;</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>在搞好以后发现，KanBan文件是存放在项目文件夹的<code>.vscode</code>中，名称是<code>vscode-kanban.json</code>，打开可以看到具体内容。打开不同文件夹时，KanBan文件都是新的，如果想保持同步，就得把最新的文件复制到其他文件夹里，这有点麻烦，所以对着说明文档分析了一下，猜测可以改扩展的源代码里的文件。</p>
</li>
<li><p>具体来说，是找到用户目录里的vscode文件夹中的KanBan文件夹，文件夹名字可能和版本号等有关，比如我的是<code>C:\Users\LiKun\.vscode\extensions\mkloubert.vscode-kanban-1.28.0\</code>，里面有一个<code>out</code>文件夹，打开会发现一些<code>js</code>文件，这些文件都可以按需求改，我需要改的是<code>workspace.js</code>。</p>
</li>
<li><p>打开<code>workspace.js</code>，在一开始定义常量的地方有一个<code>const BOARD_FILENAME</code>，把它的值改成我打算固定存KanBan的绝对路径，例如：<code>const BOARD_FILENAME = &#39;C:/code/.vscode/vscode-kanban.json&#39;;</code></p>
</li>
<li><p>改了之后如果直接保存并在vscode里运行，会提示路径不对，看报错信息是因为程序把上面那个路径和项目文件夹的路径直接拼起来了，显然有问题。回到<code>workspace.js</code>，往下没几行就能看到一个<code>get boardFile()</code>函数，函数内容就是把路径拼起来并作为新路径返回，那么在这里，把拼路径的去掉，直接返回<code>BOARD_FILENAME</code>就可以了，修改之后这个函数如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span> boardFile() &#123;</span><br><span class="line">        <span class="keyword">return</span> vscode.Uri.file(Path.resolve(BOARD_FILENAME));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意这个文件夹里其他东西不能乱改。</p>
</li>
<li><p>到此为止就可以实现所有项目文件共享同一个KanBan了，不过每次更新了以后需要重新改js文件。</p>
</li>
<li><p>用了一段时间发现因为css文件里已经写好了每个模块的功能和交互，所以像我那样改每一块的名字用起来效果不太好，想了想还是改回去了，以后研究一下css文件再改。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>编辑器配置</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-13</title>
    <url>/2020/05/26/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-13/</url>
    <content><![CDATA[<p>这一课讲scipy库。</p>
<p><code>from scipy import some_module</code></p>
<p><code>from scipy.some_module import some_function</code></p>
<a id="more"></a>
<h2 id="linalg模块的使用"><a href="#linalg模块的使用" class="headerlink" title="linalg模块的使用"></a>linalg模块的使用</h2><ol>
<li><p>基本线性代数操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="comment"># 计算矩阵的行列式</span></span><br><span class="line">linalg.det(arr)				</span><br><span class="line"><span class="comment"># output: -2.0</span></span><br><span class="line"><span class="comment"># 计算特征值和特征向量</span></span><br><span class="line">linalg.eig(arr)</span><br><span class="line"><span class="comment"># output: (array([-0.37228132+0.j,  5.37228132+0.j]), array([[-0.82456484, -0.41597356], [ 0.56576746, -0.90937671]]))</span></span><br><span class="line"><span class="comment"># 矩阵求逆</span></span><br><span class="line">linalg.inv(arr)</span><br><span class="line"><span class="comment"># output: array([[-2. ,  1. ], [ 1.5, -0.5]])</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解线性方程组：$Ax=b$，其中A是方阵：<code>solve(A, b)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line">m = <span class="number">500</span></span><br><span class="line">A=np.random.rand(m,m)</span><br><span class="line">b=np.random.rand(m)</span><br><span class="line">x1=linalg.solve(A,b)</span><br><span class="line">x2=np.dot(linalg.inv(A),b)</span><br><span class="line">print(np.allclose(x1,x2))</span><br></pre></td></tr></table></figure>
</li>
<li><p>更一般的线性方程组：$Ax=b$，其中A不是方阵：<code>lstsq(A,q)</code>找最小二乘解</p>
<p>例如：给定四个点<code>(1,6) (2,5) (3,7) (4,10)</code>，找拟合直线<code>y=ax+b</code> 这样的问题可以转化为：矩阵<code>A=[[1,2],[2,1],[3,1],[4,1]]</code> ，<code>b=[6, 5, 7, 10]^T</code>，<code>x=[a,b]^T</code>，求解<code>Ax=b</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line">A = np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">1</span>]])</span><br><span class="line">y = np.array([<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10</span>])</span><br><span class="line">c,resid,rank,sigma=linalg.lstsq(A,y)</span><br><span class="line">print(c, resid, rank, sigma)</span><br><span class="line"><span class="comment"># [1.4 3.5] 4.200000000000003 2 [5.77937881 0.77380911]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其他功能：</p>
<ol>
<li>范数求解: <code>linalg.norm</code></li>
<li>广义逆求解: <code>linalg.pinv, linalg.pinv2</code></li>
<li>矩阵分解：<code>linalg.sva, linalg.lu, linalg.qr</code></li>
</ol>
</li>
</ol>
<h2 id="optimize模块的使用"><a href="#optimize模块的使用" class="headerlink" title="optimize模块的使用"></a>optimize模块的使用</h2><ol>
<li><p>求解带约束条件的函数最小值：<code>minimize(fun, x0[,args, method, jac, hess, bounds, constrains])</code></p>
<ol>
<li><p>fun是目标函数 </p>
</li>
<li><p>x0是初始解 </p>
</li>
<li><p>args：需要传递给fun, jac, hess函数的额外的参数 </p>
</li>
<li><p>method是所选方法：Newton-CG、CG、SLSQP、Nelder-Mead…… </p>
</li>
<li><p>jac: Jacobian矩阵，有些方法需要给出 </p>
</li>
<li><p>hess: Hessian矩阵，有些方法需要给出 </p>
</li>
<li><p>bounds是解的约束范围， L-BFGS-B,TNC,SLSQP,trust-constr支持 </p>
</li>
<li><p>constrains是约束条件，COBYLA, SLSQP, trust-constr支持</p>
<p>例如：$min x1+x2+x3$</p>
<p>$s.t. x_1x_2x_3&gt;25$</p>
<p>​      $x_1^2+x_2^2+x_3^2=40$</p>
<p>​     $1&lt;=x_1, x_2&lt;=5$     $x_3&gt;=4$</p>
<p>$x_0=(3,3,4)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">objective</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constr1</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>]*x[<span class="number">1</span>]*x[<span class="number">2</span>]<span class="number">-25</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constr2</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(x**<span class="number">2</span>)<span class="number">-40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jac</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">bnds=((<span class="number">1</span>,<span class="number">5</span>),(<span class="number">1</span>,<span class="number">5</span>),(<span class="number">4</span>,<span class="literal">None</span>))</span><br><span class="line">cons1=&#123;<span class="string">'type'</span>:<span class="string">'ineq'</span>,<span class="string">'fun'</span>:constr1&#125;</span><br><span class="line">cons2=&#123;<span class="string">'type'</span>:<span class="string">'eq'</span>,<span class="string">'fun'</span>:constr2&#125;</span><br><span class="line">cons=[cons1, cons2]</span><br><span class="line">result=minimize(objective,[<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],method=<span class="string">'SLSQP'</span>,jac=jac,bounds=bnds,constraints=cons)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">#     fun: 9.807034491627501</span></span><br><span class="line"><span class="comment">#     jac: array([1., 1., 1.])</span></span><br><span class="line"><span class="comment"># message: 'Optimization terminated successfully.'</span></span><br><span class="line"><span class="comment">#    nfev: 7</span></span><br><span class="line"><span class="comment">#     nit: 7</span></span><br><span class="line"><span class="comment">#    njev: 7</span></span><br><span class="line"><span class="comment">#  status: 0</span></span><br><span class="line"><span class="comment"># success: True</span></span><br><span class="line"><span class="comment">#       x: array([2.11859914, 2.11859914, 5.5698362 ])</span></span><br><span class="line"><span class="comment"># result.fun可输出最小值，result.x可输出对应的x解</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>minimize是局部最优，basinhopping、shgo等可以求解全局最优</p>
</li>
<li><p>求解非线性方程：<code>root(fun, x0[, args, method, jac])</code></p>
<ol>
<li><p>fun是要求根的方程（组） </p>
</li>
<li><p>x0是初始猜测解 </p>
</li>
<li><p>args是fun以及jac中额外的参数 </p>
</li>
<li><p>method是所选方法： hybr, lm, broyden1/2, anderson, linearmixing, krylov, df-sane 等 </p>
</li>
<li><p>jac: Jacobian矩阵</p>
<p>例如：求解 $f(x)=2x^2+3x-10$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> root</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*x**<span class="number">2</span>+<span class="number">3</span>*x<span class="number">-10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jac</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>*x+<span class="number">3</span></span><br><span class="line"></span><br><span class="line">x=np.linspace(<span class="number">-5</span>,<span class="number">3</span>)</span><br><span class="line">plt.plot(x,func(x))</span><br><span class="line">plt.plot(x,np.zeros(len(x)))</span><br><span class="line"></span><br><span class="line">result1=root(func,<span class="number">-3</span>,method=<span class="string">'hybr'</span>,jac=jac)</span><br><span class="line">result2=root(func,<span class="number">1</span>,method=<span class="string">'lm'</span>,jac=jac)</span><br><span class="line"></span><br><span class="line">print(result1.fun,result2.fun)</span><br><span class="line">print(result1.x, result2.x)</span><br><span class="line"><span class="comment"># [-1.77635684e-15] [0.]</span></span><br><span class="line"><span class="comment"># [-3.10849528] [1.60849528]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>求解非线性方程组：和前面一样，把给定的目标函数和雅可比矩阵写成函数然后运算。</p>
</li>
</ol>
<h2 id="integrate模块的使用"><a href="#integrate模块的使用" class="headerlink" title="integrate模块的使用"></a>integrate模块的使用</h2><ol>
<li><p>根据函数求解积分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> integrate</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">half_circle</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>-x**<span class="number">2</span>)**<span class="number">0.5</span></span><br><span class="line">result = integrate.quad(half_circle, <span class="number">-1</span>, <span class="number">1</span>)	<span class="comment">#积分函数和积分上下限</span></span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># quad是一重积分，dblquad()和tplquad()分别是二重和三重积分</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>根据样本求解积分：分布均匀用<code>romb</code>，不均匀用<code>trapz(order 1), simple(order 2)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.integrate <span class="keyword">import</span> simps</span><br><span class="line">x=np.array([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">y=np.array([<span class="number">1</span>,<span class="number">9</span>,<span class="number">16</span>])</span><br><span class="line">result=simps(y1,x)</span><br><span class="line">print(result)	<span class="comment"># 21.0</span></span><br><span class="line"><span class="comment"># 相当于计算x的2次方在1到4的定积分</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>求解常微分方程：<code>odeint(func, y0, t, args=())</code></p>
<ol>
<li><p>func: 计算微分方程组中每个未知函数的一阶导数值</p>
</li>
<li><p>y0：微分方程组中每个未知函数的初始值</p>
</li>
<li><p>t：需要进行数值求解的时间点 （数值解）</p>
</li>
<li><p>args：计算导数时的其他参数</p>
<p>求解方程以后还可以画好看的函数图像。</p>
<p>这个涉及的数学知识略多，暂时也不用，就先不看例子了</p>
</li>
</ol>
</li>
</ol>
<h2 id="interpolate模块的使用"><a href="#interpolate模块的使用" class="headerlink" title="interpolate模块的使用"></a>interpolate模块的使用</h2><ol>
<li><p>插值：</p>
<ol>
<li>一/二维插值：interp1d/interp2d </li>
<li>多维插值：griddata </li>
<li>其他常用插值：Spline样条插值(spl（曲线）, bispl（曲面）等)、Rbf插值</li>
</ol>
</li>
<li><p><code>interp1d(x, y, kind=&#39;linear‘,……)</code></p>
<ol>
<li>x,y：要插值的数据点，注意x是一个递增序列 </li>
<li>kind：插值的方法：‘linear’, ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’, ‘previous’,  ‘next’等</li>
<li>返回值：一个用于插值的函数，调用这个函数时以新的x为参数 ，会得到对应的y值。</li>
</ol>
</li>
<li><p>一维B样条插值：</p>
<ol>
<li>splrep(x,y,k=3,s,……)：获得一维曲线的B样条表示 </li>
<li>splev(x, tck, der=0,……)：根据B样条表示得到对应数值 </li>
</ol>
<p>呜呜呜我不想看B样条了就这样把</p>
</li>
</ol>
<h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><ol>
<li><p>最小二乘拟合： least_squares(fun, x0, bounds=(-inf, inf), method=‘trf’, args,……) </p>
<ol>
<li><p>fun：计算残差向量(residuals)的函数 </p>
</li>
<li><p>x0：猜测的参数值𝑝0 </p>
</li>
<li><p>bounds：参数𝑝的约束范围，2-tuple：((𝑝i的下限),(𝑝i的上限)) </p>
</li>
<li><p>method： ‘trf’, ‘dogbox’, ‘lm’，其中‘lm’不支持bounds </p>
</li>
<li><p>args：计算fun需要的其他参数，例如样本数据x，y</p>
<p>返回值： </p>
</li>
<li><p>x：求解出来使得S最小的参数𝑝 </p>
</li>
<li><p>fun：对应的残差向量</p>
</li>
</ol>
<p>一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x,p)</span>:</span></span><br><span class="line">    A,k,theta = p</span><br><span class="line">    <span class="keyword">return</span> A*np.sin(<span class="number">2</span>*np.pi*k*x+theta)</span><br><span class="line">x=np.linspace(<span class="number">0</span>,<span class="number">2</span>*np.pi,<span class="number">100</span>)</span><br><span class="line">A,k,theta=<span class="number">10</span>,<span class="number">0.34</span>,np.pi/<span class="number">6</span>	<span class="comment"># 真实数据的函数参数</span></span><br><span class="line">y0=func(x,[A,k,theta])		<span class="comment"># 真实数据</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)			<span class="comment"># 噪声种子</span></span><br><span class="line">y=y0+<span class="number">2</span>*np.random.randn(len(x))	<span class="comment"># 添加噪声后的数据</span></span><br><span class="line"></span><br><span class="line">plt.plot(x,y,<span class="string">"o"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">residuals</span><span class="params">(p,y,x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> y-func(x,p)</span><br><span class="line">p0=[<span class="number">7</span>,<span class="number">0.4</span>,<span class="number">0</span>]</span><br><span class="line">plsq=optimize.least_squares(residuals,p0,args=(y,x))</span><br><span class="line">print(<span class="string">"真实参数："</span>,[A,k,theta])</span><br><span class="line">print(<span class="string">"拟合参数："</span>,plsq.x)</span><br><span class="line">plt.plot(x,func(x,plsq.x))</span><br><span class="line"><span class="comment"># 真实参数： [10, 0.34, 0.5235987755982988]</span></span><br><span class="line"><span class="comment"># 拟合参数： [10.25218748  0.3423992   0.50817423]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>scipy.optimize.curve_fit</code>：实质和最小二乘一样</p>
<p>用法上和least_squares稍有点不同：不用定义误差函数，直接 使用目标函数，且目标函数的各个待优化参数𝑝直接作为函数的参 数传入。</p>
</li>
<li><p>多项式拟合polyfit：</p>
<ol>
<li><p>numpy/scipy.polyfit(x, y, deg,……)： </p>
<ol>
<li>x,y：待拟合的数据 </li>
<li>deg：多项式的次数<br>返回值：<br>p：拟合后的多项式的系数，从<strong>高</strong>位到<strong>低</strong>位</li>
</ol>
</li>
<li>numpy/scipy.polyval(p, x)：计算多项式p在x处的值</li>
</ol>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = np.polyfit(x,y,<span class="number">10</span>)</span><br><span class="line">plt.plot(x,np.polyval(p,x),<span class="string">'k-'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>polynomial模块：</p>
<ol>
<li>拟合：和上面的区别在于，返回的多项式系数是从<strong>低</strong>到<strong>高</strong>的</li>
</ol>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.polynomial <span class="keyword">import</span> polymial <span class="keyword">as</span> P</span><br><span class="line">p2=P.polyfit(x,y,<span class="number">10</span>)</span><br><span class="line">plt.plot(x,P.polyfit(x,p2),<span class="string">'m-'</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>四则运算：<code>P.polyadd(), P.polysub(), P.polymul(), P.polydiv()</code></p>
</li>
<li><p>微分：<code>P.polyder()</code>用来求微分以后的多项式参数，默认是一阶导，加参数就是参数对应的导数</p>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)	<span class="comment"># 1+2x+3x**2+4x**3</span></span><br><span class="line">P.polyder(a)	<span class="comment"># (d/dx)(c)=2+6x+12x**2	</span></span><br><span class="line"><span class="comment"># array([ 2., 6., 12.])</span></span><br><span class="line">P.polyder(a,<span class="number">3</span>)	<span class="comment"># (d**3/dx**3)(c)=24</span></span><br><span class="line"><span class="comment"># array([ 24.])</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>积分：<code>P.polyint(c)</code>  和微分类似的用法</p>
</li>
<li><p>求根：<code>P.polyroots(a)</code> 和微分类似，对多项式求根，返回运算之后的参数</p>
</li>
</ol>
<h2 id="随堂练习"><a href="#随堂练习" class="headerlink" title="随堂练习"></a>随堂练习</h2><p>IBM.csv中保存了2014年以来的IBM股票信息，请读入IBM的收盘价，然后选取其中2019年的数据，之后： （1）假设每天的收盘价可以用之前5天的收盘价的线性组合表示出来，由此建立一个线性模型进行收盘价的预测，求解最佳的线性组合系数，并绘制收盘价以及预测的收盘价的曲线图。 </p>
<p>（2）采用多项式对收盘价进行拟合，尝试不同的多项式次数， 选取其中较优的结果，打印该多项式的各项系数，并绘制多项式曲线以及收盘价散点图。进一步，求解该多项式的转折点， 即一阶导数为0的点（只要实数解），并在多项式曲线上以上三角的标记绘制出来。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>首先是读取csv文件并提取2019年收盘价：</li>
<li>接下来，第一问可以看作是求解线性方程组的系数，<code>y=a*x1+b*x2+c*x3+d*x4+e*x5+f</code>，其中<code>abcdef</code>是待求解参数，<code>x1,x2,x3,x4,x5</code>分别是连续5天的收盘价，而<code>y</code>是第六天收盘价。<ol>
<li>建立存放<code>x</code>的列表；</li>
<li>遍历收盘价列表，把每一组收盘价（连续5个）作为一个列表加到x中，注意这里遍历的终点是倒数第5个，因为再往后就无法凑成连续5个了；</li>
<li>每一行<code>x</code>对应的<code>y</code>都是连续5个收盘价的下一个，也就是第6个收盘价开始，即<code>ibm_2019[5:]</code></li>
<li><code>x</code>和<code>y</code>都要转为<code>np.array</code>，然后用<code>lstsq</code>求解系数并绘制图像即可；</li>
</ol>
</li>
<li>第二问则是多项式拟合，这里我把自变量<code>x</code>设置为<code>1,2,3,...</code>，因变量<code>y</code>就是所有收盘价，然后使用<code>polyfit</code>求解并输出和绘图即可。经过尝试和比较，选择了<code>deg=17</code>。</li>
<li>求解一阶导数为0的点，也就是先对之前的多项式求导得到新多项式，再求解新多项式的根，最后在图像中标注即可。</li>
</ol>
<p>整体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line"><span class="keyword">from</span> numpy.polynomial <span class="keyword">import</span> polynomial <span class="keyword">as</span> P</span><br><span class="line">ibm = pd.read_csv(<span class="string">'IBM.csv'</span>, header=<span class="number">0</span>, index_col=<span class="number">0</span>, parse_dates=<span class="literal">True</span>)</span><br><span class="line">ibm_group = ibm.groupby(ibm.index.year)</span><br><span class="line">ibm_2019 = ibm_group.get_group(<span class="number">2019</span>)[<span class="string">'Close'</span>]</span><br><span class="line">x = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(ibm_2019)<span class="number">-5</span>):</span><br><span class="line">    tmp=[ibm_2019[i],ibm_2019[i+<span class="number">1</span>],ibm_2019[i+<span class="number">2</span>],ibm_2019[i+<span class="number">3</span>],ibm_2019[i+<span class="number">4</span>],<span class="number">1</span>]</span><br><span class="line">    x.append(tmp)</span><br><span class="line">x = np.array(x)</span><br><span class="line">y = np.array(ibm_2019[<span class="number">5</span>:])</span><br><span class="line">c,resid,rank,sigma=linalg.lstsq(x,y)</span><br><span class="line">x_1=np.linspace(<span class="number">1</span>,y.size,y.size)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x_1,y,<span class="string">'x'</span>, x_1,x.dot(c))</span><br><span class="line">x_2=np.linspace(<span class="number">1</span>,len(ibm_2019),len(ibm_2019))</span><br><span class="line">p=P.polyfit(x_2,ibm_2019,<span class="number">17</span>)</span><br><span class="line">print(<span class="string">"多项式系数为："</span>,p)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x_2,ibm_2019,<span class="string">'x'</span>,x_2,P.polyval(x_2,p),<span class="string">'k-'</span>)</span><br><span class="line">p2=P.polyder(p)</span><br><span class="line">root=P.polyroots(p2)</span><br><span class="line">plt.plot(root, P.polyval(root,p),<span class="string">'r^'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-FractalNet的ODE建模</title>
    <url>/2020/05/23/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-BEYOND%20FINITE%20LAYER%20NEURAL%20NETWORKS%20BRIDGING%20DEEP%20ARCHITECTURES%20AND%20NUMERICAL%20DIFFERENTIAL%20EQUATIONS/</url>
    <content><![CDATA[<h1 id="FractalNet的ODE建模"><a href="#FractalNet的ODE建模" class="headerlink" title="FractalNet的ODE建模"></a>FractalNet的ODE建模</h1><p>论文1：BEYOND FINITE LAYER NEURAL NETWORKS: BRIDGING DEEP ARCHITECTURES AND NUMERICAL DIFFERENTIAL EQUATIONS</p>
<p>论文2：FRACTALNET: ULTRA-DEEP NEURAL NETWORKS WITHOUT RESIDUALS</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>OED</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-12</title>
    <url>/2020/05/19/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-12/</url>
    <content><![CDATA[<p>这一课讲Pandas库。</p>
<p><code>import pandas as pd</code></p>
<a id="more"></a>
<h2 id="Pandas初探"><a href="#Pandas初探" class="headerlink" title="Pandas初探"></a>Pandas初探</h2><ol>
<li>读取文件：<code>data = pd.read_excel(filename, index_col=0)</code></li>
<li>取出数据中的一列或一行：<code>data[&#39;学号&#39;], data.loc[1]</code></li>
</ol>
<h2 id="Pandas数据类型"><a href="#Pandas数据类型" class="headerlink" title="Pandas数据类型"></a>Pandas数据类型</h2><h3 id="Series-一维序列"><a href="#Series-一维序列" class="headerlink" title="Series(一维序列)"></a>Series(一维序列)</h3><ol>
<li><p>由index+value组成</p>
</li>
<li><p>通过列表创建Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = pd.Series([<span class="string">'apple'</span>,<span class="string">'peach'</span>])</span><br><span class="line"><span class="comment"># 0	apple</span></span><br><span class="line"><span class="comment"># 1	peach</span></span><br><span class="line">a.index</span><br><span class="line"><span class="comment"># RangeIndex(start=0,stop=2,step=1)</span></span><br><span class="line">a.values</span><br><span class="line"><span class="comment"># array(['apple','peach'],dtype=object)</span></span><br><span class="line">a[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 'peach'</span></span><br><span class="line">a[<span class="number">1</span>]=<span class="number">100</span></span><br><span class="line"><span class="comment"># 原来是peach的地方改成了100</span></span><br><span class="line">a[<span class="number">0</span>:]</span><br><span class="line"><span class="comment"># 整个输出</span></span><br><span class="line">a[[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># 输出0和1</span></span><br><span class="line">a = pd.Series([<span class="string">'apple'</span>,<span class="string">'peach'</span>],index=[<span class="string">'a'</span>,<span class="string">'p'</span>])</span><br><span class="line"><span class="comment"># a    apple</span></span><br><span class="line"><span class="comment"># p    peach</span></span><br><span class="line">a[<span class="string">'a'</span>]</span><br><span class="line"><span class="comment"># 输出索引a对应的value</span></span><br><span class="line">a[<span class="string">'a'</span>]=<span class="string">'lemon'</span></span><br><span class="line"><span class="comment"># 原来的apple改成lemon</span></span><br><span class="line">a[<span class="string">'a'</span>:]</span><br><span class="line"><span class="comment"># 整个输出</span></span><br><span class="line">a[[<span class="string">'a'</span>,<span class="string">'p'</span>]]</span><br><span class="line"><span class="comment"># 输出a和p对应的value</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过字典创建Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'Japan'</span>:<span class="string">'Tokyo'</span>,<span class="string">'S.Korea'</span>:<span class="string">'Seoul'</span>,<span class="string">'China'</span>:<span class="string">'Beijing'</span>&#125;</span><br><span class="line">a = pd.Series(d)</span><br><span class="line"><span class="comment"># Japan        Tokyo</span></span><br><span class="line"><span class="comment"># S.Korea      Seoul</span></span><br><span class="line"><span class="comment"># China      Beijing</span></span><br><span class="line"></span><br><span class="line">indexL=[<span class="string">'China'</span>,<span class="string">'Japan'</span>,<span class="string">'ingapore'</span>,<span class="string">'S.Korea'</span>]</span><br><span class="line">a = pd.Series(d, index=indexL)</span><br><span class="line"><span class="comment"># China       Beijing</span></span><br><span class="line"><span class="comment"># Japan         Tokyo</span></span><br><span class="line"><span class="comment"># ingapore        NaN</span></span><br><span class="line"><span class="comment"># S.Korea       Seoul</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过标量创建Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = pd.Series(<span class="string">'无'</span>)</span><br><span class="line"><span class="comment"># 0    无</span></span><br><span class="line">a = pd.Series(<span class="string">'无'</span>,index=np.arange(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment"># 1    无</span></span><br><span class="line"><span class="comment"># 2    无</span></span><br><span class="line"><span class="comment"># 3    无</span></span><br><span class="line"><span class="comment"># 4    无</span></span><br><span class="line"><span class="comment"># 5    无</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Series的基本运算：</p>
<ol>
<li>和numpy一样，过滤、广播、ufunc等</li>
<li>对齐：对应索引进行运算</li>
<li>频数统计：value_counts()</li>
</ol>
</li>
</ol>
<h3 id="DataFrame-二维表"><a href="#DataFrame-二维表" class="headerlink" title="DataFrame(二维表)"></a>DataFrame(二维表)</h3><ol>
<li><p>共用index的Series的有序集合</p>
</li>
<li><p>从二维数组创建：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = np.array([(<span class="string">'Japan'</span>,<span class="string">'Tokyo'</span>,<span class="number">4000</span>),(<span class="string">'S.Korea'</span>,<span class="string">'Seoul'</span>,<span class="number">1300</span>),(<span class="string">'China'</span>,<span class="string">'Beijing'</span>,<span class="number">9100</span>)])</span><br><span class="line">DF1 = pd.DataFrame(data, columns=[<span class="string">'nation'</span>,<span class="string">'capital'</span>,<span class="string">'GDP'</span>],index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看索引和数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DF1.index</span><br><span class="line">DF1.columns</span><br><span class="line">DF1.values</span><br></pre></td></tr></table></figure>
</li>
<li><p>从字典创建：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dct = &#123;<span class="string">'nation'</span>:[<span class="string">'Japan'</span>,<span class="string">'S.Korea'</span>,<span class="string">'Japan'</span>],<span class="string">'capital'</span>:pd.Series([<span class="string">'Tokyo'</span>,<span class="string">'Seoul'</span>,<span class="string">'Beijing'</span>],index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]),<span class="string">'GDP'</span>:np.array([<span class="number">4900.1300</span><span class="number">.9100</span>],dtype=int)&#125;</span><br><span class="line">DF2=pd.DataFrame(dct)</span><br></pre></td></tr></table></figure>
</li>
<li><p>把某列数据作为index：<code>DF2.set_index(&#39;nation&#39;)</code></p>
</li>
<li><p>修改index/columns：<code>DF2.reindex(index=[&#39;c&#39;,&#39;a&#39;,&#39;b&#39;,&#39;d&#39;])</code></p>
</li>
<li><p>数据选择：</p>
<ol>
<li>取头尾若干行：<code>df.head(行数), df.tail(行数)</code></li>
<li>选择一列：<code>DF2.nation, DF2[&#39;GDP&#39;]</code></li>
<li>选择一行或多行：<code>DF2[0:2], DF2[&#39;a&#39;:&#39;c&#39;]</code>    序号只能是切片，不能是下标</li>
<li><code>loc[index, columns]</code>根据索引对多个轴进行选取</li>
<li>取单个数据：<code>DF2.loc[&#39;c&#39;,&#39;GDP&#39;]</code>或<code>DF2.at[&#39;c&#39;,&#39;GDP&#39;]</code></li>
<li>布尔索引：<ol>
<li>用某列的值来选取数据：<code>DF2[DF2.GDP&gt;3000]</code></li>
<li><code>isin()</code>方法过滤数据：<code>DF2[DF2.nation.isin([&#39;China&#39;,&#39;S.Korea&#39;])]</code></li>
</ol>
</li>
</ol>
</li>
<li><p>增加一列：<code>DF2[&#39;population&#39;]=[130,55,1600]</code></p>
</li>
<li><p>增加行：<code>append(要添加的行)</code>，序号是添加行的name，如果加入参数ignore_index=True，则序号就是数字</p>
</li>
<li><p>删除行列：<code>drop(序号)</code>，根据索引删除行列，默认删行，axis=1是删列</p>
</li>
<li><p>多个DataFrame对象数据拼接：</p>
<ol>
<li><code>pd.concat([p1,p2])</code>，序号是p1和p2各自的序号直接拼起来，是前几行p1，后几行p2；增加参数ignore_index=True，则序号是0、1、2、3这样；增加参数axis=1，则是前几列p1，后几列p2。</li>
<li><code>pd.merge(p1,p3,on=&#39;name&#39;)</code>，把p1和p3中name列相同的部分融合起来，如果是要把所有name都留下，但是只要一列name，则增加参数<code>how=&#39;outer&#39;</code></li>
</ol>
</li>
<li><p>缺失值处理：</p>
<ol>
<li><code>isnull()</code>和<code>notnull()</code>：是否缺失</li>
<li><code>fillna()</code>：补充缺失值</li>
<li><code>dropna()</code>：删除包含缺失值的行或列</li>
</ol>
</li>
<li><p>基本运算：<code>sub,add,mul,div,sum,min,max,mean,std,describe</code>，默认是竖着运算，加axis=1变成横着运算</p>
</li>
<li><p>分组：<code>groupby()</code>、<code>get_group(列名)</code>，也可以进行上一条的基本运算</p>
</li>
<li><p>排序：<code>sort_value(by=&#39;&#39;, ascending=False)</code> 根据by的取值排序，可以是一个字符串<code>by=&#39;成绩&#39;</code>，也可以是多个字符串的列表，<code>by=[&#39;成绩&#39;,&#39;年级&#39;]</code></p>
</li>
</ol>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="csv"><a href="#csv" class="headerlink" title="csv"></a>csv</h3><ol>
<li><code>read_csv()/to_csv()</code>读写csv和txt</li>
<li>加入参数index_col=0可以没有序号</li>
</ol>
<h3 id="excel"><a href="#excel" class="headerlink" title="excel"></a>excel</h3><ol>
<li><p><code>read_excel()/to_excel()</code>读写excel</p>
</li>
<li><p>把几个dataframe写到一个excel文件里的不同sheet中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">writer=pd.ExcelWriter(<span class="string">'atest.xlsx'</span>)</span><br><span class="line">a.to_excel(writer, sheet_name=<span class="string">'Sheet1'</span>)</span><br><span class="line">b.to_excel(writer, sheet_name=<span class="string">'Sheet2'</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">with</span> pd.ExcelWriter(<span class="string">'atest.xlsx'</span>) <span class="keyword">as</span> writer:</span><br><span class="line">    a.to_excel(writer, sheet_name=<span class="string">'Sheet1'</span>)</span><br><span class="line">	b.to_excel(writer, sheet_name=<span class="string">'Sheet2'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取一个exce里的多个sheet</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reader = pd.ExcelWriter(<span class="string">'atest.xlsx'</span>)</span><br><span class="line">df1 = pd.read_excel(reader, <span class="string">'Sheet1'</span>)</span><br><span class="line">df2 = pd.read_excel(reader, <span class="string">'Sheet2'</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">with</span> pd.ExcelWriter(<span class="string">'atest.xlsx'</span>) <span class="keyword">as</span> reader:</span><br><span class="line">    df1 = pd.read_excel(reader, <span class="string">'Sheet1'</span>)</span><br><span class="line">	df2 = pd.read_excel(reader, <span class="string">'Sheet2'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><ol>
<li>matplotlib中的pyplot模块：<code>b.plot()</code>，表格中的一列代表一条线的数据，行名是横坐标，表格内容值是纵坐标，默认是折线图</li>
<li>柱状图：<code>b.plot(kind=&#39;bar&#39;)      b.plot.bar()</code></li>
</ol>
<h2 id="随堂练习"><a href="#随堂练习" class="headerlink" title="随堂练习"></a>随堂练习</h2><p> 读入第三次作业第一部分爬虫得到的 csv文件，之后：</p>
<ol>
<li>绘制浏览次数曲线图；</li>
<li>根据浏览次数进行降序排序，并打印前10篇报道的日期、标题； </li>
<li>求浏览次数为1的报道的链接并打印结果；</li>
<li>统计每一年的报道数量，以及每一年的总的浏览次数，并分别以 柱状图的形式绘制出来；</li>
<li>统计2019年每个月的报道数量并以饼图的形式绘制出来。</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>首先加载库文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来读取csv文件，考虑到后面的几项要求，把日期作为DatetimeIndex的索引比较好：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reports = pd.read_csv(<span class="string">'reportsInfo.csv'</span>, header=<span class="number">0</span>, index_col=<span class="number">0</span>, parse_dates=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一个要求是绘制浏览次数的折线图，因为原本的csv文件时间是先2020年再2019年然后2018年这样倒着来的，所以先重新排序，再取浏览次数那一列的数值来画图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reports.sort_index()[<span class="string">'浏览次数'</span>].plot(linestyle=<span class="string">'-'</span>, linewidth=<span class="number">2</span>, color=<span class="string">'steelblue'</span>)</span><br><span class="line">plt.title(<span class="string">'浏览次数折线图'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'日期'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'浏览次数'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.savefig(<span class="string">'reports_linechart'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据浏览次数降序排序的操作和上一步索引排序差不多，然后切片取前10，用loc定位到标题那一列，输出即可：</p>
<p><code>print(reports.sort_values(by=&#39;浏览次数&#39;, ascending=False)[0:10].loc[:, [&#39;标题&#39;]])</code></p>
</li>
<li><p>筛选浏览次数为1的链接，用下标的方式找即可：</p>
<p><code>print(reports[reports.浏览次数 == 1].链接)</code></p>
</li>
<li><p>统计每年的报道数量，需要先按年来分组，然后得到分组的size，对size画图即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reports_group = reports.groupby(reports.index.year)</span><br><span class="line">reports_group.size().plot.bar()</span><br><span class="line">plt.title(<span class="string">'年报道数量柱状图'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'年份'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'报道数量'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.xticks(rotation=<span class="number">0</span>)</span><br><span class="line">plt.savefig(<span class="string">'reports_bar_1'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计每年的总浏览次数，在上一条分组的基础上对浏览次数那一列求和，然后画图即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reports_group[<span class="string">'浏览次数'</span>].sum().plot.bar()</span><br><span class="line">plt.title(<span class="string">'年浏览次数柱状图'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'年份'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'浏览次数'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.xticks(rotation=<span class="number">0</span>)</span><br><span class="line">plt.savefig(<span class="string">'reports_bar_2'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计2019年每月的报道数量，在之前的分组中可以得到2019的分组，然后对2019部分再按月来分组，得到size，对size画图即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reports_2019 = reports_group.get_group(<span class="number">2019</span>)</span><br><span class="line">reports_2019_month = reports_2019.groupby(reports_2019.index.month).size()</span><br><span class="line">reports_2019_month.name = <span class="string">''</span></span><br><span class="line">reports_2019_month.plot.pie(startangle=<span class="number">90</span>)</span><br><span class="line">plt.title(<span class="string">'2019年每月报道数量饼状图'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.savefig(<span class="string">'reports_pie'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Dynamic Task Pricing in Multi-Requester Mobile Crowd Sensing with Markov Correlated Equilibrium</title>
    <url>/2020/05/14/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Dynamic-Task-Pricing-in-Multi-Requester-Mobile-Crowd-Sensing-with-Markov-Correlated-Equilibrium/</url>
    <content><![CDATA[<h1 id="基于马尔可夫相关均衡的多发包方移动群体感知中的动态任务定价"><a href="#基于马尔可夫相关均衡的多发包方移动群体感知中的动态任务定价" class="headerlink" title="基于马尔可夫相关均衡的多发包方移动群体感知中的动态任务定价"></a>基于马尔可夫相关均衡的多发包方移动群体感知中的动态任务定价</h1><a id="more"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ol>
<li>场景：移动群智感知，多个发包方公开收集群体感知数据，公开定价来吸引workers</li>
<li>问题：<ol>
<li>requestor之间是不完整信息博弈</li>
<li>动态系统中未来的不确定性：未来会有多少workers</li>
</ol>
</li>
<li>解决方案：动态定价—&gt;Markov博弈，长期累积效用最大化，近似最小社会成本</li>
</ol>
<h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><ol>
<li>K个requestors，每个用$r_i$表示，集合是R</li>
<li>$r_i$发布$N_i$个任务，总共有W种类型，每种类型的任务只能由对应类型的worker来完成</li>
<li>$N_{i,w}$表示第i个requestor发布的w类型的任务数量</li>
<li>$R_w$表示发布了w类型任务的requestors</li>
<li>$N_i$表示所有同一个i的$N_{i,w}$，也就是一个requestor发布的所有任务数量</li>
<li>两种场景：<ol>
<li>所有workers同时到达</li>
<li>workers动态到达</li>
</ol>
</li>
</ol>
<p>这篇暂时先不往后看了，师弟组会讲过了</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>crowd sensing</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-11</title>
    <url>/2020/05/12/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-11/</url>
    <content><![CDATA[<p>这一课是matplotlib画图的介绍。</p>
<p><code>import matplotlib.pyplot as plt</code></p>
<a id="more"></a>
<h2 id="基础绘图"><a href="#基础绘图" class="headerlink" title="基础绘图"></a>基础绘图</h2><ol>
<li><p><code>plt.plot([x坐标],[y坐标])</code>设置图像坐标</p>
<p>x坐标如果是<code>[1,2,3,4]</code>这样连贯的，可以省略。</p>
</li>
<li><p><code>plt.show()</code>显示图像，<code>plt.sacefig(&#39;文件名&#39;, dpi=300)</code>保存图像为png文件。</p>
</li>
<li><p>多条曲线：<code>plt.plot(a,a,a,a*2,a,a**2)</code>，<code>a</code>是numpy数组。</p>
</li>
</ol>
<h2 id="设置图像属性"><a href="#设置图像属性" class="headerlink" title="设置图像属性"></a>设置图像属性</h2><ol>
<li>颜色和线宽：<code>plt.plot(x, y, format_string, **kwargs)</code>，其中<code>format_string</code>设定颜色、风格和标记。</li>
<li>坐标轴范围：<ol>
<li>获取坐标范围：<code>xlim(),ylim(),axis()</code></li>
<li>设置坐标范围：<code>xlim(xmin,xmax), ylim(ymin,ymax), axis([xmin,xmax,ymin,ymax])</code></li>
</ol>
</li>
<li>设置坐标轴刻度：<code>plt.xticks(),plt.yticks(0</code>)</li>
<li>设置坐标轴标签和图的题目：<code>xlabel(), ylabel(),title()</code></li>
<li>添加图例：<code>legend()</code></li>
<li>添加文字注释：<code>text()</code></li>
<li>标注：<code>ax.annotate()</code></li>
<li>网格：<code>plt.grid(True)</code>，可以设置颜色、线型等等</li>
</ol>
<h2 id="中文显示问题"><a href="#中文显示问题" class="headerlink" title="中文显示问题"></a>中文显示问题</h2><ol>
<li><code>rc_params()</code>指定字体：<code>matplotlib.rcParams[&#39;font.family&#39;]=&#39;STSong&#39;</code></li>
<li>在用到的地方指定字体：<code>fontproperties=&#39;Kaiti&#39;</code></li>
</ol>
<h2 id="绘制子图"><a href="#绘制子图" class="headerlink" title="绘制子图"></a>绘制子图</h2><ol>
<li><code>subplot(numRows, numCols, plotNum)</code></li>
<li><code>subplot2grid(shape, loc, rowspan=1, colspan=1)</code></li>
<li><code>gridspec.GridSpec()</code>和<code>subplot()</code>结合</li>
</ol>
<h2 id="绘制多个图"><a href="#绘制多个图" class="headerlink" title="绘制多个图"></a>绘制多个图</h2><p><code>figure()</code></p>
<h2 id="常用图标函数"><a href="#常用图标函数" class="headerlink" title="常用图标函数"></a>常用图标函数</h2><ol>
<li>散点图：<code>plt.scatter()</code></li>
<li>柱状图：<code>plt.bar()</code></li>
<li>直方图：<code>plt.hist()</code></li>
<li>饼图：<code>plt.pie()</code></li>
<li>等值线图：<code>plt.contour()</code></li>
<li>极坐标图：<code>plt.plot()</code></li>
<li>矢量场流线图：<code>plt.streamplot()</code></li>
<li>三维绘图：<code>Axes3D(fig)</code>或者<code>fig.add_subplot()</code></li>
</ol>
<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><p> IBM.csv和BABA.csv分别保存了IBM和阿里巴巴股票信息，请读入它们的日期和收盘价，绘制收盘价曲线图，要求：</p>
<ol>
<li>设置横坐标和纵坐标轴标签、图的题目，另外横坐标轴刻度标签为日期；</li>
<li>对每一支股票求最高收盘价和最低收盘价，并在曲线上对这两个点进行标注。</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>导入所需库文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.ticker <span class="keyword">as</span> ticker</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先是读入csv文件，因为日期是字符串，所以这里先统一用字符串的格式读入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ibm = np.loadtxt(<span class="string">"IBM.csv"</span>, dtype=np.str, delimiter=<span class="string">','</span>)</span><br><span class="line">baba = np.loadtxt(<span class="string">"BABA.csv"</span>, dtype=np.str, delimiter=<span class="string">','</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来提取所需数据：日期、收盘价、最高和最低收盘价，这里使用<code>astype()</code>把收盘价从numpy字符串转为numpy浮点数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># IBM</span></span><br><span class="line">date_ibm = ibm[<span class="number">1</span>:, <span class="number">0</span>]</span><br><span class="line">close_ibm = ibm[<span class="number">1</span>:, <span class="number">4</span>].astype(np.float)</span><br><span class="line">close_ibm_u = close_ibm.max()</span><br><span class="line">date_ibm_u = date_ibm[np.where(close_ibm == close_ibm_u)]</span><br><span class="line">close_ibm_l = close_ibm.min()</span><br><span class="line">date_ibm_l = date_ibm[np.where(close_ibm == close_ibm_l)]</span><br><span class="line"><span class="comment"># BABA</span></span><br><span class="line">date_baba = baba[<span class="number">1</span>:, <span class="number">0</span>]</span><br><span class="line">close_baba = baba[<span class="number">1</span>:, <span class="number">4</span>].astype(np.float)</span><br><span class="line">close_baba_u = close_baba.max()</span><br><span class="line">date_baba_u = date_baba[np.where(close_baba == close_baba_u)]</span><br><span class="line">close_baba_l = close_baba.min()</span><br><span class="line">date_baba_l = date_baba[np.where(close_baba == close_baba_l)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>得到数据以后就开始画图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 画曲线</span></span><br><span class="line">plt.plot(date_ibm, close_ibm, color=<span class="string">"green"</span>, linewidth=<span class="number">0.5</span>, label=<span class="string">'IBM'</span>)</span><br><span class="line">plt.plot(date_baba, close_baba, color=<span class="string">"blue"</span>, linewidth=<span class="number">0.5</span>, label=<span class="string">'BABA'</span>)</span><br><span class="line"><span class="comment"># 设置x轴密度和刻度大小方向</span></span><br><span class="line">plt.gca().xaxis.set_major_locator(ticker.MultipleLocator(<span class="number">80</span>))</span><br><span class="line">plt.xticks(rotation=<span class="number">45</span>, size=<span class="number">6</span>)</span><br><span class="line"><span class="comment"># 设置标题和轴标签内容及字体</span></span><br><span class="line">plt.title(<span class="string">'2014年以来IBM和BABA股票收盘价随日期的变换'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'日期'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'收盘价'</span>, fontproperties=<span class="string">'Kaiti'</span>)</span><br><span class="line"><span class="comment"># 设置图例位置</span></span><br><span class="line">plt.legend(loc=<span class="string">'upper center'</span>)</span><br><span class="line"><span class="comment"># 在四个最高最低点加圆圈标记</span></span><br><span class="line">plt.plot(date_ibm_u,close_ibm_u,<span class="string">'ro'</span>,markersize=<span class="number">3</span>)</span><br><span class="line">plt.plot(date_ibm_l,close_ibm_l,<span class="string">'ro'</span>,markersize=<span class="number">3</span>)</span><br><span class="line">plt.plot(date_baba_u,close_baba_u,<span class="string">'ro'</span>,markersize=<span class="number">3</span>)</span><br><span class="line">plt.plot(date_baba_l,close_baba_l,<span class="string">'ro'</span>,markersize=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 给四个最高最低点加文字说明</span></span><br><span class="line">plt.annotate(<span class="string">r'最高'</span>+str(close_ibm_u),color=<span class="string">'r'</span>,xy=(date_ibm_u,close_ibm_u),xytext=(<span class="number">-17</span>,<span class="number">15</span>),textcoords=<span class="string">'offset points'</span>,fontproperties=<span class="string">'Kaiti'</span>,fontsize=<span class="number">5</span>,arrowprops=&#123;<span class="string">'arrowstyle'</span>:<span class="string">'-&gt;'</span>,<span class="string">'color'</span>:<span class="string">'r'</span>&#125;)</span><br><span class="line">plt.annotate(<span class="string">r'最低'</span>+str(close_ibm_l),color=<span class="string">'r'</span>,xy=(date_ibm_l,close_ibm_l),xytext=(<span class="number">-17</span>,<span class="number">-15</span>),textcoords=<span class="string">'offset points'</span>,fontproperties=<span class="string">'Kaiti'</span>,fontsize=<span class="number">5</span>,arrowprops=&#123;<span class="string">'arrowstyle'</span>:<span class="string">'-&gt;'</span>,<span class="string">'color'</span>:<span class="string">'r'</span>&#125;)</span><br><span class="line">plt.annotate(<span class="string">r'最高'</span>+str(close_baba_u),color=<span class="string">'r'</span>,xy=(date_baba_u,close_baba_u),xytext=(<span class="number">-50</span>,<span class="number">6</span>),textcoords=<span class="string">'offset points'</span>,fontproperties=<span class="string">'Kaiti'</span>,fontsize=<span class="number">5</span>,arrowprops=&#123;<span class="string">'arrowstyle'</span>:<span class="string">'-&gt;'</span>,<span class="string">'color'</span>:<span class="string">'r'</span>&#125;)</span><br><span class="line">plt.annotate(<span class="string">r'最低'</span>+str(close_baba_l),color=<span class="string">'r'</span>,xy=(date_baba_l,close_baba_l),xytext=(<span class="number">-50</span>,<span class="number">-6</span>),textcoords=<span class="string">'offset points'</span>,fontproperties=<span class="string">'Kaiti'</span>,fontsize=<span class="number">5</span>,arrowprops=&#123;<span class="string">'arrowstyle'</span>:<span class="string">'-&gt;'</span>,<span class="string">'color'</span>:<span class="string">'r'</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后显示和保存图像：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.tight_layout()</span><br><span class="line">plt.savefig(<span class="string">'homework'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>注意：在一开始的时候可以设置图像尺寸：<code>plt.figure(figsize=(1080/100,520/100),dpi=100)</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-10</title>
    <url>/2020/04/29/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-10/</url>
    <content><![CDATA[<p>这一课是numpy库。</p>
<p><code>import numpy as py</code></p>
<a id="more"></a>
<h2 id="创建数组基本方法："><a href="#创建数组基本方法：" class="headerlink" title="创建数组基本方法："></a>创建数组基本方法：</h2><ol>
<li><p><code>array()</code></p>
<p>python对象转换为数组</p>
</li>
<li><p><code>empty()</code></p>
<p>分配指定大小数组，不初始化</p>
</li>
<li><p><code>zeros()</code>,<code>ones()</code></p>
<p>建立全为0或1的数组</p>
</li>
<li><p><code>eye()</code>,<code>diag()</code></p>
<p>建立对角矩阵</p>
</li>
<li><p><code>arange()</code></p>
<p>初值、终值、步长建立一维数组</p>
</li>
<li><p><code>linspace()</code></p>
<p>初值、终值、元素个数建立一维数组</p>
</li>
<li><p><code>logspace</code></p>
<p>初值、终值、元素个数建立等比数列</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.array((1,2,3,4))</span><br><span class="line">array([1, 2, 3, 4])</span><br><span class="line">b &#x3D; np.array([[1,2,3,4],[4,5,6,7],[7,8,9,10]])</span><br><span class="line">array([[ 1,  2,  3,  4],</span><br><span class="line">       [ 4,  5,  6,  7],</span><br><span class="line">       [ 7,  8,  9, 10]])		</span><br><span class="line">c &#x3D; a.tolist()</span><br><span class="line">[1,2,3,4]</span><br><span class="line">d &#x3D; np.empty((2,2))	#这里数组维数必须是是元组</span><br><span class="line">array([[9.90263869e+067, 9.38159477e-312],</span><br><span class="line">       [0.00000000e+000, 9.38983138e-312]])       </span><br><span class="line">e &#x3D; np.ones((2,2))</span><br><span class="line">array([[1., 1.],</span><br><span class="line">       [1., 1.]])       </span><br><span class="line">f &#x3D; np.diag((2,3,4))</span><br><span class="line">array([[2, 0, 0],</span><br><span class="line">       [0, 3, 0],</span><br><span class="line">       [0, 0, 4]])       </span><br><span class="line">g &#x3D; np.eye(3)</span><br><span class="line">array([[1., 0., 0.],</span><br><span class="line">       [0., 1., 0.],</span><br><span class="line">       [0., 0., 1.]])       </span><br><span class="line">h &#x3D; np.eye(2,3)</span><br><span class="line">array([[1., 0., 0.],</span><br><span class="line">       [0., 1., 0.]])</span><br><span class="line">i &#x3D; np.arange(5,10,1)</span><br><span class="line">array([5, 6, 7, 8, 9])</span><br><span class="line">j &#x3D; np.linspace(5,10,4)</span><br><span class="line">array([ 5.        ,  6.66666667,  8.33333333, 10.        ])</span><br><span class="line">k &#x3D; np.logspace(0,1,5)</span><br><span class="line">array([ 1.        ,  1.77827941,  3.16227766,  5.62341325, 10.        ])</span><br></pre></td></tr></table></figure>
<h2 id="数组的基本属性"><a href="#数组的基本属性" class="headerlink" title="数组的基本属性"></a>数组的基本属性</h2><ol>
<li><code>ndim</code>：数组的维度，也就是有几行</li>
<li><code>shape</code>：数组每维大小，元组形式</li>
<li><code>size</code>：数组里一共多少个元素</li>
<li><code>dtype</code>：数组数据类型</li>
<li><code>itemsize</code>：元素字节数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d1 = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">d2 = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">d3 = np.array([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]],[[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]])</span><br><span class="line">print(d1.ndim, d2.ndim, d3.ndim)		<span class="comment"># 1 2 3</span></span><br><span class="line">print(d1.shape, d2.shape, d3.shape)		<span class="comment"># (6,) (2, 3) (2, 2, 3)</span></span><br></pre></td></tr></table></figure>
<h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><ol>
<li>改变数据类型：astype</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1.7</span>, <span class="number">1.2</span>, <span class="number">1.6</span>])</span><br><span class="line">b = a.astype(int)		<span class="comment"># b = array([1, 1, 1])</span></span><br></pre></td></tr></table></figure>
<h3 id="形状操作"><a href="#形状操作" class="headerlink" title="形状操作"></a>形状操作</h3><ol>
<li><p>reshape</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">b = a.reshape((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># b = array([[1, 2, 3],</span></span><br><span class="line"><span class="comment">#            [4, 5, 6]])</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">10</span></span><br><span class="line"><span class="comment"># a = array([10,  2,  3,  4,  5,  6])</span></span><br><span class="line"><span class="comment"># b = array([[10, 2, 3],</span></span><br><span class="line"><span class="comment">#            [4, 5, 6]])</span></span><br><span class="line">b[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">5</span></span><br><span class="line"><span class="comment"># a = array([5,  2,  3,  4,  5,  6])</span></span><br><span class="line"><span class="comment"># b = array([[5, 2, 3],</span></span><br><span class="line"><span class="comment">#            [4, 5, 6]])</span></span><br><span class="line">c = b.reshape((<span class="number">-1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="comment"># array([[5, 2],</span></span><br><span class="line"><span class="comment">#       [3, 4],</span></span><br><span class="line"><span class="comment">#       [5, 6]])</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>shape：和reshape差不多的用法，<code>a.reshape((-1,2))</code>和<code>a.shape=(-1,2)</code>效果是一样的</p>
</li>
<li><p>resize：同上，<code>a.resize((-1,2))</code>，注意reshape和resize的参数是元组，而shape的参数则不是元组。此外，一般来说reshape有返回值，不对原始多维数组进行修改；resize无返回值，会对原始多维数组进行修改。但其实resize和reshape都可以有返回值，也都可以没有返回值，区别在于，reshape是改变形状而不改变数据量，或者说改变数组维度，如果reshape之后的元素数量和之前的不一致就会报错，但是resize不会，元素多了就去掉，少了就补零。</p>
</li>
<li><p>ravel：扁平化，多维变成一维数组，但是修改ravel之后的元素，<strong>会</strong>导致原始数组的元素跟着变。</p>
</li>
<li><p>flatten：扁平化，多维变成一维数组，修改flatten之后的元素，<strong>不会</strong>导致原始数组的元素跟着变。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">b = a.ravel()	<span class="comment"># b = ([1,2,3,4,5,6])</span></span><br><span class="line">b[<span class="number">0</span>]=<span class="number">99</span></span><br><span class="line"><span class="comment">#a = array([[99,  2,  3],</span></span><br><span class="line"><span class="comment">#           [ 4,  5,  6]])</span></span><br><span class="line">c = a.flatten()  <span class="comment"># c = ([99,  2,  3,  4,  5,  6])</span></span><br><span class="line">c[<span class="number">1</span>]=<span class="number">98</span></span><br><span class="line"><span class="comment">#a = array([[99,  2,  3],</span></span><br><span class="line"><span class="comment">#           [ 4,  5,  6]])</span></span><br></pre></td></tr></table></figure>
<ol>
<li>转置：<code>数组.T</code></li>
</ol>
<h3 id="数组组合"><a href="#数组组合" class="headerlink" title="数组组合"></a>数组组合</h3><ol>
<li><p>hstack：水平</p>
</li>
<li><p>vstack：垂直</p>
</li>
<li><p>concatenate</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">b = np.array([[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]])</span><br><span class="line">c = np.hstack((a,b))</span><br><span class="line"><span class="comment"># [[ 0  1  2  0  2  4]</span></span><br><span class="line"><span class="comment">#  [ 3  4  5  6  8 10]]</span></span><br><span class="line">d = np.vstack((a,b))</span><br><span class="line"><span class="comment"># [[ 0  1  2]</span></span><br><span class="line"><span class="comment">#  [ 3  4  5]</span></span><br><span class="line"><span class="comment">#  [ 0  2  4]</span></span><br><span class="line"><span class="comment">#  [ 6  8 10]]</span></span><br><span class="line">e = np.concatenate((a,b),axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># [[ 0  1  2  0  2  4]</span></span><br><span class="line"><span class="comment">#  [ 3  4  5  6  8 10]]</span></span><br><span class="line">f = np.concatenate((a,b),axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># [[ 0  1  2]</span></span><br><span class="line"><span class="comment">#  [ 3  4  5]</span></span><br><span class="line"><span class="comment">#  [ 0  2  4]</span></span><br><span class="line"><span class="comment">#  [ 6  8 10]]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="数组分割"><a href="#数组分割" class="headerlink" title="数组分割"></a>数组分割</h3><ol>
<li>hsplit：水平</li>
<li>vsplit：垂直</li>
<li>split</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">a1, a2, a3 = np.hsplit(a,<span class="number">3</span>)</span><br><span class="line">b1, b2 = np.vsplit(a,<span class="number">2</span>)</span><br><span class="line">c1, c2 = np.split(a, <span class="number">2</span>, axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># a1 = [[0]</span></span><br><span class="line"><span class="comment">#       [3]]</span></span><br><span class="line"><span class="comment"># a2 = [[1]</span></span><br><span class="line"><span class="comment">#       [4]]</span></span><br><span class="line"><span class="comment"># a3 = [[2]</span></span><br><span class="line"><span class="comment">#       [5]]</span></span><br><span class="line"><span class="comment"># b1 = [[0 1 2]]</span></span><br><span class="line"><span class="comment"># b2 = [[3 4 5]]</span></span><br><span class="line"><span class="comment"># c1 = [[0 1 2]]</span></span><br><span class="line"><span class="comment"># c2 = [[3 4 5]]</span></span><br></pre></td></tr></table></figure>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><ol>
<li><p>切片下标：和列表切片一样，修改切片后的元素会导致原始数组改变</p>
</li>
<li><p>高级下标：</p>
<ol>
<li><p>整数列表/元组作为下标</p>
</li>
<li><p>整数数组作为下标</p>
</li>
<li><p>布尔数组作为下标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">b = a[[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">5</span>,<span class="number">7</span>]]	<span class="comment">#array([10,2,5,3])</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">c = a[np.array([<span class="number">3</span>,<span class="number">3</span>,<span class="number">-3</span>,<span class="number">8</span>])]	<span class="comment">#array([7,7,4,2])</span></span><br><span class="line">d = a[np.array([[<span class="number">3</span>,<span class="number">3</span>,<span class="number">-3</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]])]	<span class="comment">#array([[7,7,4,2],[9,8,7,6]])</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">array([<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line">b = a[np.array([<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">False</span>])]	<span class="comment">#array([5,3])</span></span><br><span class="line">a[np.array([<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">False</span>])] = <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span> </span><br><span class="line"><span class="comment">#array([-1, 4, -2, -3, 1])</span></span><br><span class="line">x = np.random.rand(<span class="number">4</span>)	</span><br><span class="line"><span class="comment"># [0.75217218 0.49197318 0.0754037  0.8145583 ]</span></span><br><span class="line">x &gt; <span class="number">0.5</span></span><br><span class="line"><span class="comment"># [ True False False  True]</span></span><br><span class="line">x[x&gt;<span class="number">0.5</span>]</span><br><span class="line"><span class="comment"># [0.75217218 0.8145583 ]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多维数组：数组不同维数的坐标用<code>,</code>隔开，例如二维数组<code>a</code>，<code>a[0,1]</code>中，0是第一维（行），1是第二维（列），每个维度内可以用切片的方式访问，例如<code>a[0,3:5]</code>和<code>a[:,2]</code>等，也可以用列表或元组下标的方式访问。</p>
<p>下标长度小于数组维数时，剩余的轴对应的下标是<code>:</code> 。</p>
<p> 所有轴的下标形状相同时，得到的数组和下标形状相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组</span></span><br><span class="line"><span class="comment"># 0, 1, 2, 3, 4, 5</span></span><br><span class="line"><span class="comment"># 10,11,12,13,14,15</span></span><br><span class="line"><span class="comment"># 20,21,22,23,24,25</span></span><br><span class="line"><span class="comment"># 30,31,32,33,34,35</span></span><br><span class="line"><span class="comment"># 40,41,42,43,44,45</span></span><br><span class="line"><span class="comment"># 50,51,52,53,54,55</span></span><br><span class="line">a[<span class="number">0</span>, <span class="number">3</span>:<span class="number">5</span>]	<span class="comment"># 第0行第3列和第4列</span></span><br><span class="line"><span class="comment"># array([3,4])</span></span><br><span class="line">a[<span class="number">4</span>:,<span class="number">4</span>:]	<span class="comment"># 第4、5行和第4、5列</span></span><br><span class="line"><span class="comment"># array([[44,45],[54,55]])</span></span><br><span class="line">a[:,<span class="number">2</span>]		<span class="comment"># 第2列</span></span><br><span class="line"><span class="comment"># array([ 2, 12, 22, 32, 42, 52])</span></span><br><span class="line">a[<span class="number">2</span>,:]		<span class="comment"># 第2行</span></span><br><span class="line"><span class="comment"># array([20, 21, 22, 23, 24, 25])</span></span><br><span class="line">a[<span class="number">2</span>::<span class="number">2</span>, ::<span class="number">2</span>]	<span class="comment">#第2行到最后一行，步长2；所有列，步长2</span></span><br><span class="line"><span class="comment"># array([[20, 22, 24], [40, 42, 44]])</span></span><br><span class="line">a[(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)] <span class="comment">#坐标为(0,1)(1,2)(2,3)(3,4)(4,5)的元素</span></span><br><span class="line"><span class="comment"># array([1,12,23,34,45])</span></span><br><span class="line">a[<span class="number">3</span>:,[<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>]]	<span class="comment">#第3行到最后一行，第0、2、5列</span></span><br><span class="line"><span class="comment"># array([[30, 32, 35], [40, 42, 45], [50, 52, 55]]) </span></span><br><span class="line">mask=np.array([<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>], dtype=bool)</span><br><span class="line">a[mask,<span class="number">2</span>]</span><br><span class="line"><span class="comment"># array([2,22,52])</span></span><br><span class="line">a[[<span class="number">1</span>,<span class="number">2</span>]] 	<span class="comment">#相当于a[[1,2],:] </span></span><br><span class="line"><span class="comment"># array([[10, 11, 12, 13, 14, 15], [20, 21, 22, 23, 24, 25]])</span></span><br><span class="line">x=np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">y=np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]]) </span><br><span class="line">a[x]	<span class="comment">#从2维数组变成3维数组</span></span><br><span class="line"><span class="comment"># [[[10 11 12 13 14 15]</span></span><br><span class="line"><span class="comment">#   [20 21 22 23 24 25]]</span></span><br><span class="line"><span class="comment">#  [[30 31 32 33 34 35]</span></span><br><span class="line"><span class="comment">#   [40 41 42 43 44 45]]]</span></span><br><span class="line">a[x,y] 		<span class="comment"># x和y的元素分别作为两个维度的坐标</span></span><br><span class="line"><span class="comment"># x = 1 2</span></span><br><span class="line"><span class="comment">#     3 4</span></span><br><span class="line"><span class="comment"># y = 1 1</span></span><br><span class="line"><span class="comment">#     2 2</span></span><br><span class="line"><span class="comment">#a[x,y]=[a[1][1] a[2][1]</span></span><br><span class="line"><span class="comment">#        a[3][2] a[4][2]]</span></span><br><span class="line"><span class="comment"># = [[11 21]</span></span><br><span class="line"><span class="comment">#    [32 42]]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="ufunc"><a href="#ufunc" class="headerlink" title="ufunc"></a>ufunc</h2><pre><code>  1. 对数组中每个元素进行操作的函数，不需要写for循环
     2. 常用操作：加减乘除取余乘方、比较运算、布尔运算等等
     3. 自定义ufunc： frompyfunc(func, nin, nout)
</code></pre><h3 id="其他函数操作"><a href="#其他函数操作" class="headerlink" title="其他函数操作"></a>其他函数操作</h3><ol>
<li>求和sum</li>
<li>平均值mean/average</li>
<li>方差var</li>
<li>标准差std</li>
<li>中位数median</li>
<li>最值min、max、ptp、argmin、argmax</li>
<li>排序sort、argsort</li>
<li>查找nonzero(a)、where(condition[,x,y])</li>
</ol>
<h3 id="广播（这部分短期内应该用不到，就不写了）"><a href="#广播（这部分短期内应该用不到，就不写了）" class="headerlink" title="广播（这部分短期内应该用不到，就不写了）"></a>广播（这部分短期内应该用不到，就不写了）</h3><ol>
<li>让数组shape相同的操作</li>
<li>orrid对象</li>
<li>mgrid和meshgrid函数</li>
</ol>
<h2 id="文件存取"><a href="#文件存取" class="headerlink" title="文件存取"></a>文件存取</h2><ol>
<li>这部分短期内应该也就读个图像，不看了</li>
</ol>
<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><p>读入图像文件Cat.jpg，并通过numpy的数组操作对图像进行修改，得到下面一系列图像： </p>
<ol>
<li>反色图像：r、g、b为原始像素颜色，则反色后的颜色为255-r、255-g、 255-b </li>
<li>灰度图像： r、g、b为原始像素颜色，变成灰度的公式为： Gray = r<em>0.299 + g</em>0.587 + b*0.114</li>
<li>水平镜像图像：左右交换</li>
<li>垂直镜像图像：上下交换</li>
<li>行和列转置后的图像 </li>
<li>逆时针旋转90°后的图像 </li>
<li>红色/绿色/蓝色通道图像：其余两通道颜色为0, 0</li>
<li>红色通道的颜色替换成红色通道的最大值 </li>
<li>红色/绿色/蓝色通道重新组合，红色变成蓝色，绿色变成红色，蓝色变成绿色 </li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先读入图像：<code>im = np.array(Image.open(&quot;cat.jpg&quot;))</code></p>
<p>其次考虑保存图像，这里写了一个函数，把数组转为图像并按指定名称保存：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveimg</span><span class="params">(img, index)</span>:</span></span><br><span class="line">    img = Image.fromarray(img.astype(<span class="string">'uint8'</span>))</span><br><span class="line">    img.show()</span><br><span class="line">    img.save(<span class="string">'Cat'</span> + index + <span class="string">'.jpg'</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>接下来就是图像处理部分了，考虑到有通道分离的要求，所以先把3个通道的数据提取出来，彩色图像变成数组时，是用三维数组存储的，前两个维度表示行列对应位置的像素值，第三个维度表示颜色通道，这里的通道顺序是rgb（而如果用opencv库的话，就是gbr），也就是说，<code>im[0,0,0]、im[0,0,1]、im[0,0,1]</code>就分别表示左上角那个像素的红色、绿色和蓝色值，这三个值叠加以后的结果就是彩色图像看上去的颜色，因此分离通道后，得到的是3个二维数组，如下：</p>
<p><code>r, g, b = im[:, :, 0], im[:, :, 1], im[:, :, 2]</code></p>
<ol>
<li><p>反色：这里构造一个和<code>im</code>尺寸一致且元素都是255的新数组，用这个新数组减去<code>im</code>即可。</p>
<p><code>im2 = np.ones_like(im) * 255 - im</code></p>
</li>
<li><p>灰度：按照公式对分离出来的r、g、b三个通道进行运算即可。</p>
<p><code>im3 = r * 0.299 + g * 0.587 + b * 0.114</code></p>
</li>
<li><p>水平镜像：每一行的元素逆序</p>
<p>这里是二维数组，也就是说要逆序的是列坐标，所以是第二维逆序</p>
<p><code>im4 = im[:, ::-1]</code></p>
</li>
<li><p>垂直镜像：每一列的元素逆序</p>
<p>同上，第一维逆序</p>
<p><code>im5 = im[::-1]</code></p>
</li>
<li><p>转置：这里的图像是三维数组，所以使用transpose函数来做，简单来说就是原本的第一、二维交换顺序，也就是<code>transpose(0,1,2)—&gt;transpose(1,0,2)</code></p>
<p><code>im6 = im.transpose(1, 0, 2)</code></p>
</li>
<li><p>逆时针90度：矩阵逆时针90度的操作是左乘一个负对角线上均是1、其余都是0的方阵，也就是说，转置矩阵逆序即可</p>
<p><code>im7 = im.transpose(1, 0, 2)[::-1]</code></p>
</li>
<li><p>三通道图像：把其他通道都变成0即可，最后把3个图拼起来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B_im = im.copy()</span><br><span class="line">B_im[:, :, [<span class="number">0</span>, <span class="number">1</span>]] = <span class="number">0</span></span><br><span class="line">G_im = im.copy()</span><br><span class="line">G_im[:, :, [<span class="number">0</span>, <span class="number">2</span>]] = <span class="number">0</span></span><br><span class="line">R_im = im.copy()</span><br><span class="line">R_im[:, :, [<span class="number">2</span>, <span class="number">1</span>]] = <span class="number">0</span></span><br><span class="line">im8 = np.concatenate((R_im, G_im, B_im), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>红色拉满：把红色通道变成255即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">im9 = im.copy()</span><br><span class="line">im9[:, :, <span class="number">0</span>] = <span class="number">255</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通道重组：这里要想明白通道怎么组合，剩下的就很好做了。红色变成蓝色，绿色变成红色，蓝色变成绿色，也就是原本是红色的数值要变成蓝色通道，绿色数值变成红色通道，蓝色数值变成绿色通道，因此通道原本的<code>(0,1,2)</code>变成现在的<code>(1,2,0)</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">im10 = im.copy()</span><br><span class="line">im10 = im10[:, :, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-9</title>
    <url>/2020/04/22/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-9/</url>
    <content><![CDATA[<p>这一课是爬虫。</p>
<a id="more"></a>
<ol>
<li>使用两个库：<ol>
<li>Requests：获取网络数据</li>
<li>BeautifulSoup：分析网络数据</li>
</ol>
</li>
</ol>
<h3 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h3><ol>
<li><p>获取某网址信息：<code>requests.get(url, params=None, **kwargs)</code></p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">html= requests.get(<span class="string">"html://www.bnu.edu.cn"</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'bnu.html'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(html.content)		<span class="comment"># 保存html的内容</span></span><br><span class="line">type(html)		<span class="comment"># requests.models.Response</span></span><br><span class="line">html.url		<span class="comment"># 'https://www.bnu.edu.cn/'</span></span><br><span class="line">html.content	<span class="comment"># 二进制内容</span></span><br><span class="line">html.text		<span class="comment"># 字符串（可能乱码）</span></span><br><span class="line">html.encoding	<span class="comment"># 'ISO-8859-1'</span></span><br><span class="line">html.encoding=<span class="string">'utf-8'</span>  <span class="comment">#修改编码</span></span><br><span class="line">html.request.headers	<span class="comment"># 访问方式： &#123;'User-Agent': 'python-requests/2.22.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive'&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>把访问方式伪装成正常浏览器：</p>
<ol>
<li><p>获取浏览器的访问方式：</p>
<ol>
<li><p>在浏览器中打开链接；</p>
</li>
<li><p>按F12，找到Network；</p>
</li>
<li><p>随便选一个资源点一下（如果一个都没有，就刷新一下网页）；</p>
</li>
<li><p>在Request Headers里找到User-Agent并把整个内容复制出来。</p>
<p><img src="https://github.com/kun-bin/image/blob/master/0422.png?raw=true" alt="示意图"></p>
</li>
</ol>
</li>
<li><p>在代码中做伪装：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">head = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36'</span>&#125;</span><br><span class="line">html = requests.get(<span class="string">"http://www.bnu.edu.cn"</span>, headers=head)</span><br><span class="line">html.request.headers	<span class="comment"># 访问方式变成User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h3><ol>
<li><p>分析页面信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">bsObj = BeautifulSoup(html.content, <span class="string">'lxml'</span>)  <span class="comment">#lxml HTML 解析器：速度快，文档容错能力强</span></span><br><span class="line">type(bsObj)		<span class="comment"># bs4.BeautifulSoup</span></span><br><span class="line">bsObj.title     <span class="comment">#获得html中的title标签: &lt;title&gt;北京师范大学&lt;/title&gt;</span></span><br><span class="line">type(bsObj.title )	<span class="comment"># bs4.element.Tag</span></span><br><span class="line">bsObj.img   <span class="comment">#获得html中的第一个img标签: &lt;img alt="" src="images/logo1.png"/&gt;</span></span><br><span class="line">bsObj.a    <span class="comment">#获得html中的第一个a标签: &lt;a href="https://one.bnu.edu.cn" target="_blank"&gt;信息门户&lt;/a&gt;</span></span><br><span class="line">print(type(bsObj.img), type(bsObj.a ))	<span class="comment"># &lt;class 'bs4.element.Tag'&gt; &lt;class 'bs4.element.Tag'&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取标签信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bsObj.a.get_text()	<span class="comment"># '信息门户'</span></span><br><span class="line">bsObj.a.text		<span class="comment"># '信息门户'</span></span><br><span class="line">bsObj.a.attrs		<span class="comment"># &#123;'href': 'https://one.bnu.edu.cn', 'target': '_blank'&#125;</span></span><br><span class="line">bsObj.a[<span class="string">'href'</span>]		<span class="comment"># 获取a标签的href属性值：'https://one.bnu.edu.cn'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>找到特定标签：<code>find( name , attrs , recursive , text , **kwargs )</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alink=bsObj.find(<span class="string">'a'</span>)   <span class="comment"># 没有属性限定，找到第一个a标签</span></span><br><span class="line">print(alink)			<span class="comment"># &lt;a href="https://one.bnu.edu.cn" target="_blank"&gt;信息门户&lt;/a&gt;</span></span><br><span class="line">blink=bsObj.find(<span class="string">'a'</span>,text=<span class="string">'学部院系'</span>)	<span class="comment"># 限定了属性 text的值</span></span><br><span class="line">print(blink)			<span class="comment"># &lt;a href="xbyx/index.htm"&gt;学部院系&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
<p>找到所有指定标签：<code>find_all( name , attrs , recursive , text , limit, **kwargs )</code>返回列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alink=bsObj.find_all(<span class="string">'a'</span>)</span><br><span class="line">print(alink)	<span class="comment"># 所有a标签的列表</span></span><br><span class="line">blink=bsObj.find_all(<span class="string">"a"</span>, limit=<span class="number">2</span>)	<span class="comment"># 只找前两个a标签</span></span><br><span class="line">print(blink)				<span class="comment"># [&lt;a href="https://one.bnu.edu.cn" target="_blank"&gt;信息门户&lt;/a&gt;, &lt;a href="http://xxgk.bnu.edu.cn/" target="_blank"&gt;信息公开&lt;/a&gt;]</span></span><br><span class="line">clink=bsObj.find_all(<span class="string">'span'</span>, class_=<span class="string">"more01"</span>)	<span class="comment"># class值符合要求的span标签</span></span><br><span class="line">print(clink)		<span class="comment"># [&lt;span class="more01"&gt;&lt;img alt="" src="images/more3.png"/&gt;&lt;/span&gt;, &lt;span class="more01"&gt;&lt;img alt="" src="images/more3.png"/&gt;&lt;/span&gt;, &lt;span class="more01"&gt;&lt;img alt="" src="images/more3.png"/&gt;&lt;/span&gt;, &lt;span class="more01"&gt;&lt;img alt="" src="images/more3.png"/&gt;&lt;/span&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">imglist = bsObj.find_all(<span class="string">'img'</span>, &#123;<span class="string">"src"</span>:re.compile(<span class="string">".+\.jpg"</span>)&#125;)	<span class="comment"># 符合正则表达的标签</span></span><br><span class="line">print(imglist)</span><br><span class="line"></span><br><span class="line">dlink=bsObj.find(<span class="string">'div'</span>, class_=<span class="string">"nav"</span>).find_all(<span class="string">'a'</span>)	<span class="comment"># find和findall结合使用</span></span><br><span class="line">print(dlink)</span><br></pre></td></tr></table></figure>
</li>
<li><p>相对url转绝对url：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> requests.compat <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">url=<span class="string">'https://www.bnu.edu.cn/'</span></span><br><span class="line">blink = urljoin(url, blink[<span class="string">'href'</span>])</span><br><span class="line">print(blink)	<span class="comment"># https://www.bnu.edu.cn/xbyx/index.htm</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>图像相关（img标签）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clink=bsObj.find(<span class="string">'img'</span>)</span><br><span class="line">print(clink)			<span class="comment"># &lt;img alt="" src="images/logo1.png"/&gt;</span></span><br><span class="line">print(clink[<span class="string">'src'</span>])		<span class="comment"># images/logo1.png</span></span><br><span class="line">logo= requests.get(urljoin(url, clink[<span class="string">'src'</span>]), headers=head) <span class="comment">#获得图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">im=Image.open(BytesIO(logo.content))</span><br><span class="line">im.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存图像</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r'D:\2020Python\Ch8\BNU-logo.png'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f: </span><br><span class="line">    f.write(logo.content)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r'D:\2020Python\Ch8\BNU-logo.'</span>+clink[<span class="string">'src'</span>][<span class="number">-3</span>:], <span class="string">'wb'</span>) <span class="keyword">as</span> f: </span><br><span class="line">    f.write(logo.content)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>class</code>标签的访问：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dlink=bsObj.find('span', class="col-md-10")  #class 是关键词，不能这样使用</span><br><span class="line"><span class="comment"># 解决方案1</span></span><br><span class="line">dlink=bsObj.find(<span class="string">'div'</span>, class_=<span class="string">"item-txt01"</span>)</span><br><span class="line">print(dlink)</span><br><span class="line"><span class="comment"># 解决方案2</span></span><br><span class="line">dlink=bsObj.find(<span class="string">'div'</span>, &#123;<span class="string">'class'</span>:<span class="string">'item-txt01'</span>&#125;)</span><br><span class="line">print(dlink.text)</span><br></pre></td></tr></table></figure>
</li>
<li><p>网页源码树状结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clink=bsObj.find(<span class="string">'li'</span>)</span><br><span class="line">clink.parent  <span class="comment">#父节点</span></span><br><span class="line">clink.children  <span class="comment">#孩子节点</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> clink.children:</span><br><span class="line">    print(child)	<span class="comment"># 输出子节点</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> clink.descendants:    <span class="comment">#子孙节点，后代节点</span></span><br><span class="line">    print(child)</span><br><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> clink.next_siblings:  <span class="comment">#兄弟节点</span></span><br><span class="line">    print(sibling)</span><br><span class="line">clink.find_parent(<span class="string">'div'</span>, class_=<span class="string">'nav'</span>)  <span class="comment">#满足class为‘nav’的父节点</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> clink.findChildren(<span class="string">'a'</span>):  <span class="comment">#找到 a标签 孩子</span></span><br><span class="line">    print(child)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="爬取网页所有图片的示例"><a href="#爬取网页所有图片的示例" class="headerlink" title="爬取网页所有图片的示例"></a>爬取网页所有图片的示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#只爬取url网页上的图片，不爬next网页上的图片</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> requests.compat <span class="keyword">import</span> urljoin</span><br><span class="line">url = <span class="string">'http://news.bnu.edu.cn/sj/gysd/index.htm'</span></span><br><span class="line">head = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36'</span>&#125;</span><br><span class="line">html = requests.get(url, headers = head)</span><br><span class="line">bsObj= BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">allLinks = bsObj.find_all(<span class="string">'div'</span>, class_=<span class="string">"grid"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> allLinks:</span><br><span class="line">    imglink = i.find(<span class="string">'img'</span>)[<span class="string">'src'</span>]	</span><br><span class="line">    imglink = urljoin(url, imglink)	<span class="comment"># 图片链接</span></span><br><span class="line">    name = i.find(<span class="string">'h3'</span>).text		<span class="comment"># 图片标题</span></span><br><span class="line">    print(imglink, name)</span><br><span class="line">    img  = requests.get(imglink, headers = head)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">r'D:\2020Python\Ch8\图片/'</span>+name+imglink[<span class="number">-4</span>:], <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(img.content)		<span class="comment"># 保存图片</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#爬取本网页以及下一页的图片</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.compat <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">url=<span class="string">'http://news.bnu.edu.cn/sj/gysd/index.htm'</span></span><br><span class="line">head = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36'</span>&#125;</span><br><span class="line">path=<span class="string">'D:/2020Python/Ch8/光影师大/'</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">    os.mkdir(path)</span><br><span class="line">nexturl=url</span><br><span class="line"><span class="keyword">while</span> nexturl:</span><br><span class="line">    html = requests.get(nexturl, headers=head)</span><br><span class="line">    bsObj=BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">    imgslink=bsObj.find_all(<span class="string">'div'</span>, class_=<span class="string">"grid"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> imgslink:</span><br><span class="line">        imglink=i.find(<span class="string">'img'</span>)[<span class="string">'src'</span>]</span><br><span class="line">        imglink=urljoin(nexturl,imglink)</span><br><span class="line">        name=i.find(<span class="string">'h3'</span>).text</span><br><span class="line">        name=<span class="string">''</span>.join([i <span class="keyword">for</span> i <span class="keyword">in</span> name <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'\\'</span>,<span class="string">'/'</span>,<span class="string">':'</span>,<span class="string">'*'</span>,<span class="string">'?'</span>,<span class="string">'"'</span>,<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'|'</span>]])</span><br><span class="line">        print(imglink, name)        </span><br><span class="line">        img=requests.get(urljoin(nexturl,imglink), headers=head)</span><br><span class="line">        <span class="keyword">with</span> open(path+name+imglink[<span class="number">-4</span>:], <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(img.content)        </span><br><span class="line">    temp=bsObj.find(<span class="string">'a'</span>,class_=<span class="string">"next"</span>)	<span class="comment"># 获取next标签（下一页）</span></span><br><span class="line">    <span class="keyword">if</span> temp:</span><br><span class="line">        nexturl=urljoin(nexturl,temp[<span class="string">'href'</span>])	<span class="comment"># 获取下一页的url</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nexturl=<span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h3><p>抓取北京师范大学中头条关注网站： <a href="http://news.bnu.edu.cn/zx/ttgz/index.htm" target="_blank" rel="noopener">http://news.bnu.edu.cn/zx/ttgz/index.htm</a> 上迄今为止所 有头条关注报道的发表日期、标题、链接以及浏览次数，保存为 一个csv文件，要求使用函数封装。</p>
<p>思路：</p>
<ol>
<li><p>导入所需库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> requests.compat <span class="keyword">import</span> urljoin</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析这个网站，发现了很神奇的一点，该网站一共68页，应该只有第68页没有<code>next</code>标签，但实际上它第67页就没了。如果用保存图像那个例子里的方式访问，则无法访问到第68页，所以考虑写个函数来获取网站一共多少页，然后<code>for</code>循环读网页内容。</p>
<p>经过仔细观察，可以发现网页下面有一个元素用来显示“现在是第几页/总共多少页”，源代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pages "</span>&gt;</span></span><br><span class="line">		   			            页数：<span class="tag">&lt;<span class="name">span</span>&gt;</span>1/68<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">          总数：<span class="tag">&lt;<span class="name">span</span>&gt;</span>680<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">						</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index.htm"</span> <span class="attr">class</span>=<span class="string">"on_pages"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index1.htm"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index2.htm"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index3.htm"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index4.htm"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index5.htm"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index6.htm"</span>&gt;</span>7<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index7.htm"</span>&gt;</span>8<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index8.htm"</span>&gt;</span>9<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index9.htm"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index1.htm"</span> <span class="attr">class</span>=<span class="string">"next"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../../images/pages04.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index10.htm"</span> <span class="attr">class</span>=<span class="string">"end"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../../images/pages05.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因此可以找到<code>class = pages</code> 的<code>div</code>标签，然后获取其中<code>span</code>标签的内容，并截取<code>/</code>符号后面的内容转为数字，即可得到网站页数，写成函数的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page</span><span class="params">(url, head)</span>:</span></span><br><span class="line">    html = requests.get(url, headers=head)</span><br><span class="line">    bsObj = BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">    <span class="keyword">return</span> int(bsObj.find(class_=<span class="string">"pages"</span>).find(<span class="string">'span'</span>).text.split(<span class="string">'/'</span>)[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来可以通过<code>for</code>循环访问每一页，第一页是<code>index.htm</code>，接下来是<code>index1.htm</code>等等，直到最后是<code>index67.htm</code>。</p>
<ol>
<li><p>分析网页源码可知，在每一页中，我们需要提取的内容一定在<code>class = item-info01</code>的标签中，因此使用<code>findall</code>然后遍历得到的标签列表。</p>
</li>
<li><p>分析每个标签源码可知，文章标题出现在<code>h3</code>中，即<code>title = i.find(&#39;h3&#39;).text</code>。</p>
</li>
<li><p>文章链接是<code>a</code>标签的<code>href</code>属性，是相对链接，要转换为绝对链接，不过这里需要注意，有一些文章用了微信链接等站外网页作为内容，因此这些链接是绝对链接，不需要转换。所以要判断一下首字母是否为<code>h</code>。此外，在我们保存的时候，链接后面要加浏览次数，直接用逗号分隔会导致打开csv时链接和浏览次数连在一起，所以链接本身保存时在末尾加个空格。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">link = i.find(<span class="string">'a'</span>)[<span class="string">'href'</span>]</span><br><span class="line"><span class="keyword">if</span> link[<span class="number">0</span>] != <span class="string">'h'</span>:</span><br><span class="line">	link = urljoin(url, link)</span><br><span class="line">link += <span class="string">' '</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>文章时间是<code>class = time</code>的<code>span</code>标签对应的内容，即<code>time = i.find(&#39;span&#39;, class_=&quot;time&quot;).text</code>。</p>
</li>
<li><p>最后是文章浏览次数，这个网站浏览次数是用script做的，所以要跳转到对应链接，然后从新网页里获取浏览次数。对应的相对链接是<code>script</code>标签中的<code>src</code>属性，因此要跳转的新网页是<code>urljoin(url, i.find(&#39;script&#39;)[&#39;src&#39;])</code>，这个网页的内容只有<code>document.write(&#39;31&#39;)</code>这样的字符，所以获取网页内容后提取它17位开始、倒数第3位结束的内容即可得到浏览次数（类型为字符串）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">viewlink = urljoin(url, i.find(<span class="string">'script'</span>)[<span class="string">'src'</span>])</span><br><span class="line">view = BeautifulSoup(requests.get(viewlink).text, <span class="string">'lxml'</span>).text[<span class="number">16</span>:<span class="number">-3</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后把上述内容按顺序加到列表中，然后在整个循环结束后返回列表即可。完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analy</span><span class="params">(page, url, head)</span>:</span></span><br><span class="line">    lists = []</span><br><span class="line">    nexturl = url</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(page):</span><br><span class="line">        html = requests.get(nexturl, headers=head)</span><br><span class="line">        bsObj = BeautifulSoup(html.content, <span class="string">'lxml'</span>)</span><br><span class="line">        allLink = bsObj.find_all(class_=<span class="string">"item-info01"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> allLink:</span><br><span class="line">            title = i.find(<span class="string">'h3'</span>).text</span><br><span class="line">            link = i.find(<span class="string">'a'</span>)[<span class="string">'href'</span>]</span><br><span class="line">            <span class="keyword">if</span> link[<span class="number">0</span>] != <span class="string">'h'</span>:</span><br><span class="line">                link = urljoin(url, link)</span><br><span class="line">            link += <span class="string">' '</span></span><br><span class="line">            time = i.find(<span class="string">'span'</span>, class_=<span class="string">"time"</span>).text</span><br><span class="line">            viewlink = urljoin(url, i.find(<span class="string">'script'</span>)[<span class="string">'src'</span>])</span><br><span class="line">            view = BeautifulSoup(requests.get(viewlink).text, <span class="string">'lxml'</span>).text[<span class="number">16</span>:<span class="number">-3</span>]</span><br><span class="line">            lists.append([time, title, link, view])</span><br><span class="line">        nexturl = urljoin(nexturl, <span class="string">'index'</span> + str(index + <span class="number">1</span>) + <span class="string">'.htm'</span>)</span><br><span class="line">    <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>在得到列表后，根据要求输出csv文件，这部分内容是上一课讲过的，基本没有变化，注意编码要用<code>utf-8-sig</code>，如果用其他编码，保存的中文会乱码；如果只是<code>utf-8</code>没<code>sig</code>，则excel打开时中文会乱码。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writecsv</span><span class="params">(lists)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"reportsInfo.csv"</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>, encoding=<span class="string">'utf-8-sig'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f_csv = csv.writer(f)</span><br><span class="line">        headers = [<span class="string">'日期'</span>, <span class="string">'标题'</span>, <span class="string">'链接'</span>, <span class="string">'浏览次数'</span>]</span><br><span class="line">        f_csv.writerow(headers)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> lists:</span><br><span class="line">            f_csv.writerow(row)</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后是主函数部分，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">head = &#123;</span><br><span class="line">    <span class="string">'user-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36'</span>&#125;</span><br><span class="line">url = <span class="string">'http://news.bnu.edu.cn/zx/ttgz/index.htm'</span></span><br><span class="line">page = page(url, head)</span><br><span class="line">lists = analy(page, url, head)</span><br><span class="line">writecsv(lists)</span><br><span class="line">print(<span class="string">"FIN"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-8</title>
    <url>/2020/04/17/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-8/</url>
    <content><![CDATA[<p>这一课讲文件读写。</p>
<a id="more"></a>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ol>
<li><p>文件类型：文本文件（纯文本、源代码、网页）、二进制文件（图片、word、excel、ppt）</p>
</li>
<li><p>读文本文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">r'/path/to/file'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    s = f.read()</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>这样用<code>with open as</code>可以不用写<code>close</code></p>
</li>
<li><p>open函数：<code>open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code> 返回一个文件对象，是可迭代对象</p>
</li>
<li><p>tell函数：<code>f.tell()</code>返回文件指针当前在的位置</p>
</li>
<li><p>文本文件操作：</p>
<p>以下都是写在<code>with open</code>的代码块里面</p>
<ol>
<li>读文本文件：<ol>
<li><code>f.readline()</code>：读一行，到换行符结束，返回字符串</li>
<li><code>f.read(2)</code>：接着读2个字符，返回字符串</li>
<li><code>f.readlines()</code>：把剩下的都读完，返回列表，每一行作为列表中的一个元素</li>
</ol>
</li>
<li>写文本文件：<ol>
<li><code>f.write</code>：写入字符串，不换行，可以在字符串末尾加<code>\n</code>来实现换行</li>
<li><code>f.writelines</code>：写入列表元素，不换行，可以在要换行的元素末尾加<code>\n</code></li>
</ol>
</li>
<li>文件模式相关：<ol>
<li>用新建文件的模式（<code>x</code>）来open文件，如果存在同名文件，则会报错</li>
<li>用<code>w</code>方式写文件，如果存在同名文件，会清空原有内容再写入</li>
<li>用<code>a</code>方式写文件，存在同名文件的时候，不会清空内容，而是在文件末尾写入新内容</li>
<li>用<code>r+</code>的方式读写文件，默认位置为文件开头，读完以后移到结尾</li>
<li>用<code>w+</code>的方式读写文件，清空文件内容以后读写</li>
<li>用<code>a+</code>的方式读写文件，默认位置是文件末尾</li>
<li>带+的都是可读可写，不带+的则只有读或者写</li>
</ol>
</li>
<li>改变文件读写位置：<code>seek(offset, whence=0)</code>，从whence(0起始，1当前，2末尾)偏移offset个字节。例如<code>f.seek(0)</code>可以把文件指针放到最开始的地方。</li>
<li>字符字节说明：utf-8编码中文3字节英文1字节；gbk编码中文2字节英文1字节</li>
</ol>
</li>
<li><p>二进制文件操作：</p>
<ol>
<li>open函数的打开模式为<code>b</code></li>
</ol>
</li>
<li><p>CSV文件：文本文件</p>
<ol>
<li>由若干条记录组成，每条记录由字段组成，字段间由分 隔符分开，最常见的分隔符是逗号，也可以是制表符、分号等</li>
<li>列表读写：<code>csv.reader</code>和<code>csv.writer</code></li>
<li>字典读写：<code>csv.DictReader</code>和<code>csv.DictWriter</code></li>
<li><code>csv.reader(csvfile, dialect=‘excel’, **fmtparams)</code>：以字符串列表的形式读入文件内容，一行是一个列表<ol>
<li>是可迭代对象，可以通过<code>next</code>访问，比如读完文件先用next把第一行存在标题变量里，再遍历剩下的内容</li>
</ol>
</li>
<li><code>csv.writer(csvfile, dialect=‘excel’, **fmtparams)</code>：把字符串列表写入csv文件，注意先写入标题行，再写入剩下内容</li>
<li><code>csv.DictReader(csvfile, fieldnames=None, restkey=None, restval=None, dialect=‘excel’, *args, **kwds)</code>字典方式读入，标题是key，内容是value<ol>
<li>csv文件没有标题行时，可以设定列表指定标题行，然后<code>csv.DictReader(f,headers)</code>来建立内容和标题一一对应的字典</li>
</ol>
</li>
<li><code>csv.DictWriter(csvfile, fieldnames, restval=‘’, extrsaction=‘raise’, dialect=‘excel’, *args, **kwds)</code> 要指定标题行和内容，在创建csv对象时就指定标题，接下来写入标题，最后写入内容</li>
</ol>
</li>
</ol>
<h3 id="随堂练习"><a href="#随堂练习" class="headerlink" title="随堂练习"></a>随堂练习</h3><ol>
<li><p>读入《Declaration.txt》文件，该文件里存的是一篇英文文章 ，要求把这篇文章中的不重复单词（单词的不同时态以及单复数都 看成是不同的单词）进行排序后写入一个新的txt文件，并要求每行 5个单词，同时注意对齐。</p>
<p>思路：</p>
<ol>
<li><p>使用<code>with open</code>方式读入文件并把其中的单词存入列表；</p>
</li>
<li><p>借助<code>Counter</code>统计词频和排序</p>
</li>
<li><p>把排序之后的列表写入新文件</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 读入文件内容，把单词存入列表并返回</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strtolist</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open (name,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        s = f.read()</span><br><span class="line">    words = re.findall(<span class="string">r'[a-zA-Z]+'</span>,s)</span><br><span class="line">    <span class="keyword">return</span> words</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对列表中的单词按字母顺序排序并返回</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortword</span><span class="params">(words)</span>:</span></span><br><span class="line">    list1 = collections.Counter(words)</span><br><span class="line">    list2 = sorted(list1.items())</span><br><span class="line">    list3 = []</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> list2:</span><br><span class="line">        list3.append(key)</span><br><span class="line">    <span class="keyword">return</span> list3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把列表中的元素按要求写入文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writefile</span><span class="params">(lists)</span>:</span></span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'wordlist.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> lists:</span><br><span class="line">            f.write(<span class="string">'&#123;:&lt;16&#125;'</span>.format(i))</span><br><span class="line">            f.write(<span class="string">'\t'</span>)</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                f.write(<span class="string">'\n'</span>)</span><br><span class="line">                </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    words = strtolist(<span class="string">'Declaration.txt'</span>)</span><br><span class="line">    lists = sortword(words)</span><br><span class="line">    writefile(lists)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>读入存有姓名和成绩的 成绩单.csv 文件，计算最终加权成绩（ 小数点后保留两位，三个成绩的权重分别为0.22,0.18,0.6），并 把该成绩追到到原有信息中，保存为一个新的csv文件。</p>
<p>思路：</p>
<ol>
<li><p>读入csv文件，并为标题行添加“最终成绩”</p>
</li>
<li><p>计算平均分并添加到这一行的末尾，保留2位小数</p>
</li>
<li><p>把这一行的数据存到列表中</p>
</li>
<li><p>把刚才的内容逐行写入新的csv文件，注意这里要在之前那个文件关闭之前完成</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line"><span class="keyword">with</span> open (<span class="string">'成绩单.csv'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv=csv.reader(f)</span><br><span class="line">    headers = next(f_csv)</span><br><span class="line">    headers.append(<span class="string">'最终成绩'</span>)</span><br><span class="line">    lists = []</span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> f_csv:</span><br><span class="line">        avg = <span class="number">0.22</span>*int(row[<span class="number">1</span>])+<span class="number">0.18</span>*int(row[<span class="number">2</span>])+<span class="number">0.6</span>*int(row[<span class="number">3</span>])</span><br><span class="line">        row.append(avg)</span><br><span class="line">        row[<span class="number">4</span>]=str(<span class="string">'&#123;:.2f&#125;'</span>.format(row[<span class="number">4</span>]))</span><br><span class="line">        lists.append(row)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'新成绩单.csv'</span>,<span class="string">'w'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> s:</span><br><span class="line">        s_csv=csv.writer(s)</span><br><span class="line">        s_csv.writerow(headers)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> lists:</span><br><span class="line">            s_csv.writerow(row)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-7</title>
    <url>/2020/04/16/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-7/</url>
    <content><![CDATA[<p>这一课讲python中函数和模块的使用。</p>
<a id="more"></a>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><ol>
<li><p>函数定义时可以为参数指定默认值，这样没传参的时候就会用默认值，要先声明没默认值的参数，再声明有默认值的。</p>
</li>
<li><p>调用函数时可以直接指明参数值（<code>mysum1(score1 = 88, score2 = 79)</code>)，不指明的参数写前面，指明的放后面。</p>
</li>
<li><p>指针（*）形式传递可变参数，以元组形式打包多出来的参数，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum2</span><span class="params">(a,b,*c)</span>:</span></span><br><span class="line">	total=a+b</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> c:</span><br><span class="line">        total=total+n</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">print(my_sum2(<span class="number">1</span>,<span class="number">2</span>))				<span class="comment">#c=()	输出3</span></span><br><span class="line">print(my_sum2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))		<span class="comment">#c=(3,4,5)	输出15</span></span><br><span class="line">print(my_sum2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>))	<span class="comment">#c=(3,4,5,10,20)	输出45</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>双指针（**）形式传递可变参数，以字典形式打包多出来的参数，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum3</span><span class="params">(a,b,*c,**d)</span>:</span></span><br><span class="line">	total=a+b</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> c:</span><br><span class="line">        total=total+n</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">        total=total+d[key]</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">print(my_sum3(<span class="number">1</span>,<span class="number">2</span>))							<span class="comment">#c=() d=&#123;&#125; 输出3</span></span><br><span class="line">print(my_sum3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))					<span class="comment">#c=(3,4,5) d=&#123;&#125; 输出15</span></span><br><span class="line">print(my_sum3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,male=<span class="number">6</span>,female=<span class="number">7</span>))	<span class="comment">#c=(3,4,5) d=&#123;'male':6,'female':7&#125; 输出28</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><em>或*</em>的参数如果不位于形参列表的最后位置，则会使其后面声 明的参数为强制命名参数；使用一个星号而不带参数，也可导致强制命名参数。</p>
</li>
<li><p>列表、元组、字典可通过<em>和*</em>作为参数传递给函数。</p>
</li>
<li><p>形参复制了实参所指对象的引用</p>
</li>
</ol>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><ol>
<li>返回多个值时，是元组形式。</li>
</ol>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ol>
<li><p>局部变量全局变量和其他语言基本一致</p>
</li>
<li><p>只要在函数体内有赋值语句，不管在哪一行，这个变量就是局部变量，函数体内也只会用这个局部变量，而不是同名全局变量，例如下述代码会直接报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    print(var)</span><br><span class="line">    var=<span class="number">200</span></span><br><span class="line">fun()</span><br><span class="line"></span><br><span class="line">var=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    var+=<span class="number">1</span></span><br><span class="line">    print(var)</span><br><span class="line">fun()</span><br><span class="line"></span><br><span class="line">报错信息：local variable <span class="string">'var'</span> referenced before assignment</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数体内用全局变量，要声明<code>global</code></p>
</li>
<li><p>函数嵌套函数时，内层函数变量作用域只在内层，不影响外层，如果要内层用外层的，要声明<code>nonlocal</code></p>
</li>
</ol>
<h2 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h2><ol>
<li><p>递归</p>
</li>
<li><p>函数可以作为其他函数的参数</p>
</li>
<li><p>lambda匿名函数：实现行内函数 <code>lambda 形参列表:返回的结果</code></p>
<p>例如：<code>f=lambda x,y: x+y</code>，<code>f(12,34)=46</code></p>
</li>
<li><p>map函数：以把一个函数作用到可迭代对象（如列表）的每一个 元素。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">-2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">b=map(<span class="keyword">lambda</span> x: x+<span class="number">2</span>, a)</span><br><span class="line">print(b)	<span class="comment">#b是一个可迭代对象，print得到它的地址，for循环输出可知b=0,3,5</span></span><br><span class="line">c=map(abs, a)</span><br><span class="line">c=list(c)</span><br><span class="line">print(c)	<span class="comment">#c=[2,1,3]</span></span><br><span class="line">d=map(<span class="keyword">lambda</span> x,y: x+y, a,c)</span><br><span class="line">print(list(d))	<span class="comment">#输出[0,2,6]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>filter函数：筛选出可迭代对象中满足条件的元素，<code>filter( 返回bool类型的函数, 可迭代对象)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=filter(<span class="keyword">lambda</span> x: x&gt;<span class="number">0</span>, (<span class="number">-1</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">0</span>,<span class="number">5</span>))</span><br><span class="line">print(list(a))		<span class="comment"># [2,5]</span></span><br><span class="line">b=filter(str.isalpha, (<span class="string">'word'</span>,<span class="string">','</span>,<span class="string">'\n'</span>,<span class="string">'$'</span>,<span class="string">'1'</span>))</span><br><span class="line">print(list(b))		<span class="comment"># ['word']</span></span><br><span class="line">c=filter(<span class="literal">None</span>,(<span class="number">-1</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">0</span>,<span class="number">5</span>))</span><br><span class="line">print(list(b))		<span class="comment"># [-1,2,-3,5] 传入None时会把序列中的false值比如0、空值等都去掉</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>reduce函数：对可迭代对象的元素进行递归计算，<code>reduce( 带两个参数的函数, 可迭代对象)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=functools.reduce(operator.add,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>])</span><br><span class="line">print(a)	<span class="comment">#25</span></span><br><span class="line">b=functools.reduce(<span class="keyword">lambda</span> x,y:x+y,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>])</span><br><span class="line">print(b)	<span class="comment">#25</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h3><ol>
<li><p>对第二次作业进行函数封装，按功能封装成几个函数。</p>
<p>这个没啥说的，本来就是用函数写的。</p>
</li>
<li><p>利用map、filter、reduce、lambda函数，对一个元素为数字 字符串的列表，分别求出其中包含的所有奇数的乘积以及所有 偶数的乘积。</p>
<p>思路：首先要把列表<code>l</code>的元素从字符串转成整数，从而才能进行奇偶性判断和乘法运算，这里用<code>map</code>函数来完成；接下来用<code>filter</code>函数就可以把奇数和偶数分别放到两个列表中，最后用<code>reduce</code>函数即可进行乘法运算，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">l=[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'14'</span>,<span class="string">'20'</span>,<span class="string">'5'</span>,<span class="string">'7'</span>,<span class="string">'39'</span>,<span class="string">'150'</span>,<span class="string">'6'</span>]</span><br><span class="line">m=list(map(<span class="keyword">lambda</span> x: int(x), l))</span><br><span class="line">a=filter(<span class="keyword">lambda</span> x: x%<span class="number">2</span>==<span class="number">0</span>, m)</span><br><span class="line">b=functools.reduce(<span class="keyword">lambda</span> x,y:x*y,list(a))</span><br><span class="line">c=filter(<span class="keyword">lambda</span> x: x%<span class="number">2</span>==<span class="number">1</span>, m)</span><br><span class="line">d=functools.reduce(<span class="keyword">lambda</span> x,y:x*y,list(c))</span><br><span class="line">print(<span class="string">'偶数乘积是'</span>,b)</span><br><span class="line">print(<span class="string">'奇数乘积是'</span>,d)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一次作业第三题打印结果为24的表达式，我们通过嵌套循环 得到列表的全排列，试试采用递归函数求全排列。</p>
<p>思路：</p>
<ol>
<li><p>列表只有1个元素时，全排列就是列表本身；</p>
</li>
<li><p>列表有2个元素时，全排列是[a,b]和[b,a]；</p>
</li>
<li><p>列表有n个元素时，将第一个元素固定，对剩下n - 1个元素进行全排列。再将第一个元素依此与其他元素交换，对每次交换后剩下的n-1个元素进行全排列。对n-1个元素的全排列就是一个递归过程。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutations</span><span class="params">(l, start, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start==end:</span><br><span class="line">        print(l)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        i = start</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(start, end): </span><br><span class="line">            l[j], l[i] = l[i], l[j]</span><br><span class="line">            permutations(l, start + <span class="number">1</span>, end)</span><br><span class="line">            l[i], l[j] = l[j], l[i]            </span><br><span class="line">num=[<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>]</span><br><span class="line">permutations(num, <span class="number">0</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Privacy Policy in Online Social Network with Targeted Advertising Business</title>
    <url>/2020/04/15/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Privacy-Policy-in-Online-Social-Network-with-Targeted-Advertising-Business/</url>
    <content><![CDATA[<h2 id="在线社交网络隐私政策与定向广告业务"><a href="#在线社交网络隐私政策与定向广告业务" class="headerlink" title="在线社交网络隐私政策与定向广告业务"></a>在线社交网络隐私政策与定向广告业务</h2><a id="more"></a>
<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ol>
<li>社交网络提供商SNP利用用户信息实现定向投放广告，广告商付费</li>
<li>隐私政策：SNP应该利用的用户信息比例</li>
<li>用户、广告商、SNP——&gt;三阶段stackelberg博弈</li>
<li>更高的信息利用将阻碍用户展示信息，降低被利用信息的总量，并损害广告收入，基于用户信息等级与隐私策略之间的关联，进一步刻画出最优隐私策略。</li>
</ol>
<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><ol>
<li>广告商决定支付的广告费（更多数据意味着更精准投放——&gt;更高的广告费）：广告商如何在用户信息利用所限制的投放精准度的基础上进行广告投放，以实现预期收益的最大化?</li>
<li>用户决定在社交平台的活跃度（更好的隐私保护——&gt;更活跃）：在隐私受到侵犯的情况下，用户在社交活动中暴露自己的程度如何?</li>
<li>SNP决定隐私政策（广告费和用户活跃度的权衡）：SNP如何采取适当的隐私政策来最大化他的效用，包括社会网络效益和目标广告收入?</li>
</ol>
<h4 id="System-Model"><a href="#System-Model" class="headerlink" title="System Model"></a>System Model</h4><ol>
<li>用户，决定活跃度（在社交平台上发布的信息等级），收益三部分相加组成：<ol>
<li>网络收益：用户在社交平台上进行社交互动所得到的的收益，由用户自己的隐私等级和其他用户的隐私等级共同决定，这部分是一个对数函数（根据梅特卡夫定律决定函数形式）</li>
<li>隐私损失：由【用户提供信息的程度和SNP的隐私等级】对应的函数共同决定（相乘），是一个增函数</li>
<li>补贴：SNP鼓励用户在社交平台积极活跃，会提供固定的补贴，用户有一定概率拿到，拿到的概率由【用户提供信息的程度和SNP的隐私等级】对应的函数共同决定（相乘）</li>
</ol>
</li>
<li>广告商，决定广告费，收益两部分相乘组成：<ol>
<li>一个用户买该产品的净收益（考虑核算收入和生产成本）</li>
<li>目标用户看了广告以后买产品的概率，两部分相加组成：<ol>
<li>由【用户提供信息的程度和SNP的隐私等级】对应的概率</li>
<li>投放不精准的情况下（不能依靠SNP时）的先验概率（就是广告给不感兴趣的人放了之后这个人来买的概率）</li>
</ol>
</li>
<li>上述两部分相乘是一个用户带来的收益，广告商总收益是把所有目标用户的加起来，再减去支付给SNP的广告费</li>
</ol>
</li>
<li>SNP，决定隐私政策和目标广告费，收益三部分相加（减）组成：<ol>
<li>社交网络价值：用户活跃带来的收益，要去掉对用户活跃度的补贴</li>
<li>目标广告收益：单个用户的广告费*目标用户</li>
<li>隐私问题：出现隐私问题时所面临的金钱、名誉损失，有概率，泄露越多损失越大</li>
</ol>
</li>
<li>stackelberg博弈：<ol>
<li>第一阶段SNP考虑用户和广告商的决策来决定隐私等级和广告费</li>
<li>第二阶段用户根据隐私政策决定活跃度</li>
<li>第三阶段广告商根据用户信息和广告费决定是否投放广告</li>
</ol>
</li>
</ol>
<h4 id="Advertiser’s-Decision"><a href="#Advertiser’s-Decision" class="headerlink" title="Advertiser’s Decision"></a>Advertiser’s Decision</h4><ol>
<li>简单的让收益大于广告费，然后显然隐私政策越大（SNP泄露用户信息越多或用户自己暴露越多），广告商越容易挣钱</li>
</ol>
<h4 id="Users’-Behavior"><a href="#Users’-Behavior" class="headerlink" title="Users’ Behavior"></a>Users’ Behavior</h4><ol>
<li>多个用户之间的交互——&gt;多用户信息展示博弈——&gt;纳什均衡：所有用户都收益最大化</li>
<li>信息展示博弈具有超模性：博弈方行为是紧集，收益函数是连续函数且二阶导大于0——&gt;当其他玩家选择更高决策时，该玩家选择更高决策的效用增加得更多——&gt;一个玩家的最佳反应是其他玩家决策的一个非递减函数</li>
<li>所有用户活跃度从0开始，逐个根据其他用户的活跃度调整自己的来最大化收益，直到收敛——&gt;最小纳什均衡</li>
<li>均衡属性分析：<ol>
<li>假设用户效用总的来说是一个凸函数（活跃度越高，活跃度的提高所带来的收益越小，和超模性不冲突）</li>
<li>隐私损失函数是凹函数：越活跃，隐私损失越多</li>
<li>补贴函数是凸函数：越活跃，补贴增长越少</li>
<li>补贴要能弥补隐私损失函数和补贴函数的冲突比例，避免出现大家都是0的场面（从而都是0的场面不是纳什均衡）</li>
<li>处于NE时，隐私政策越高，用户收益越低，存在一个隐私政策阈值，小于这个值（只用很少一部分隐私），用户会选择完全暴露信息（活跃度=1），大于该值，活跃度&lt;1</li>
<li>当隐私政策小于阈值时，【用户提供信息的程度和SNP的隐私等级相乘】随隐私政策增加而增加；大于阈值时，【】随…增加而减小；直接来说就是，用户愿意完全暴露信息时，提取更多信息能更好地服务用户（或者说补贴等等综合下来最好），反之，则隐私提取越少越好了</li>
<li>如果两个用户对社交网络价值的判断相等，那么他们均衡解对应的活跃度也相等；如果不相等，价值判断高的，均衡解时的活跃度也更高；直接说就是，更看重社交价值的会更倾向于高活跃度</li>
</ol>
</li>
</ol>
<h4 id="SNP’s-Decision"><a href="#SNP’s-Decision" class="headerlink" title="SNP’s Decision"></a>SNP’s Decision</h4><ol>
<li>均衡解没有具体形式——&gt;用户均衡解和隐私政策之间的关系来说明SNP效用函数的单调性</li>
<li>广告商收入中的用户数量是离散的，且取决于隐私政策和广告费</li>
<li>将SNP效用函数拆开：<ol>
<li>广告费收益：单个用户广告费*用户个数（由用户活跃度均衡解、隐私政策和单用户广告费共同决定），通过对广告商效用函数的分析，找到固定隐私政策时最优的单用户广告费</li>
<li>社交网络收益—隐私问题：最优广告费作为隐私政策的函数代入，得到最优隐私政策</li>
</ol>
</li>
<li>最优广告费定价问题：<ol>
<li>把用户个数问题转化成了概率问题：广告商有多大概率向某用户投放广告</li>
<li>社交参数简化为两个值：一高一低</li>
</ol>
</li>
<li>隐私问题：<ol>
<li>社交参数依旧只有两个值，对应的均衡解的隐私政策阈值也是两个值</li>
<li>可以推导出效用函数的单调性</li>
<li>假设隐私问题函数是凹函数，广告商效用函数是凸函数，也就是隐私问题越严重，损失增长得会越多，广告商从中得到的收益增长越少——&gt;求导分析找最优隐私政策的特点</li>
</ol>
</li>
</ol>
<h4 id="Numerical-Result"><a href="#Numerical-Result" class="headerlink" title="Numerical Result"></a>Numerical Result</h4><ol>
<li>这部分很少，没说数值实验具体是怎么做的</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>game theory</tag>
        <tag>stackelberg博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-分片相关</title>
    <url>/2020/04/13/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-%E5%88%86%E7%89%87%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>关于区块链分片的几篇论文。</p>
<a id="more"></a>
<h2 id="1-RapidChain-Scaling-Blockchain-via-Full-Sharding"><a href="#1-RapidChain-Scaling-Blockchain-via-Full-Sharding" class="headerlink" title="1. RapidChain: Scaling Blockchain via Full Sharding"></a>1. RapidChain: Scaling Blockchain via Full Sharding</h2><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ol>
<li>分片目的：解除区块链性能和扩展性的限制</li>
<li>分片定义：将处理事务的开销分配给多个更小的节点组，这些组并行工作以最大限度地提高性能，同时显著地减少每个节点的通信、计算和存储，从而允许系统扩展到大型网络。</li>
<li>现有分片协议的问题：扩展性受限制、安全性</li>
<li>本文RapidChain：公链分片</li>
</ol>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><ol>
<li><p>节点分到不同的committees，区块和账本并行</p>
</li>
<li><p>系统中一共<code>n</code>个节点，则每个committee的大小为$m=c logn$，一共有$k=n/m$个committees，<code>c</code>是一个和安全有关的常数</p>
</li>
<li><p>优点：</p>
<ol>
<li>次线性通信：每个事务线性复杂度</li>
<li>高弹性：可以接受<code>1/3</code>的恶意节点</li>
<li>减少每个committee的开销和延迟</li>
<li>安全性：拜占庭容错</li>
<li>跨分片验证：committees通过路由机制发现其他committees</li>
<li>去中心化引导：新加入节点的设计</li>
</ol>
</li>
<li><p>RapidChain按固定时间周期推进，称为epoch，每个epoch结束时由被选中的reference committee（$C_R$)生成下一轮的随机数，该随机数让每个节点在下一轮开始时有新身份，并避免恶意节点的集中和节点共谋</p>
</li>
<li><p>对等发现和committee间的路由，存交易事务$t_x$的committee记作$C_{out}$</p>
</li>
<li><p>跨分片验证：$C_{out}$在生成区块记账之前会和input committee验证交易合法性</p>
</li>
<li><p>分片内共识：</p>
<ol>
<li>分片内成员用当前epoch的随机数选一个临时leader</li>
<li>leader用流言协议把区块发布给分片内所有节点</li>
<li>使用拜占庭协议（基于某论文的同步协议）确保所有节点同意同一个区块</li>
</ol>
</li>
<li><p>重新配置区块：每个epoch结束时由$C_R$产生，包含内容：</p>
<ol>
<li>下一轮的随机数</li>
<li>参与者列表和committee成员</li>
</ol>
<p>想参加下一轮的节点要在一定时间内解题PoW</p>
</li>
<li><p>这篇的related work部分之后可以参考</p>
</li>
</ol>
<h2 id="2-A-Secure-Sharding-Protocol-For-Open-Blockchains"><a href="#2-A-Secure-Sharding-Protocol-For-Open-Blockchains" class="headerlink" title="2. A Secure Sharding Protocol For Open Blockchains"></a>2. A Secure Sharding Protocol For Open Blockchains</h2><h4 id="Abstract-1"><a href="#Abstract-1" class="headerlink" title="Abstract"></a>Abstract</h4><ol>
<li>区块链有安全性，但规模很小，每秒处理3-7笔交易</li>
<li>ELASTICO：1/4拜占庭攻击，分为多个committees，每个处理自己的事务集合（称作分片）</li>
</ol>
<h4 id="Mehtod"><a href="#Mehtod" class="headerlink" title="Mehtod"></a>Mehtod</h4><ol>
<li>按算力分片</li>
<li>每个epoch流程：<ol>
<li>建立自己的公钥、IP并进行PoW，按公钥ID分为不同Committees</li>
<li>节点互相确认身份，记录自己committee有谁</li>
<li>committee内的共识：PBFT，带多数成员签名广播</li>
<li>最终共识广播：有一个final committee来进行合并（PBFT然后把接收的分片区块在committee内实现共识，然后全网广播）</li>
<li>产生下一轮的随机数，大家开始PoW，开始新的一轮</li>
</ol>
</li>
</ol>
<h2 id="3-A-Proof-of-Stake-Sharding-Protocol-for-Scalable-Blockchains"><a href="#3-A-Proof-of-Stake-Sharding-Protocol-for-Scalable-Blockchains" class="headerlink" title="3. A Proof of Stake Sharding Protocol for  Scalable Blockchains"></a>3. A Proof of Stake Sharding Protocol for  Scalable Blockchains</h2><ol>
<li><code>c</code>组，每组<code>n</code>个，一共<code>nc</code>个节点</li>
<li>普通节点组产生中间区块，发送给最终验证节点组</li>
<li>最终验证节点组产生最终区块，全网广播</li>
<li>每个epoch分为4步：<ol>
<li>分组，组内随机选leader，组内节点把身份信息发给leader，leader向其他组的leader广播</li>
<li>组内共识：一个交易随机分到某组，组内节点PoS，产生新的中间区块</li>
<li>最终验证组合并区块，组内PoS，产生最终区块并广播</li>
<li>t轮之后，刷新重组</li>
</ol>
</li>
</ol>
<h2 id="4-Ostraka-Secure-Blockchain-Scaling-by-Node-Sharding"><a href="#4-Ostraka-Secure-Blockchain-Scaling-by-Node-Sharding" class="headerlink" title="4. Ostraka: Secure Blockchain Scaling by Node Sharding"></a>4. Ostraka: Secure Blockchain Scaling by Node Sharding</h2><ol>
<li>采用UTXO、PoS</li>
<li>矿池、UTXO、区块链存储在被称为分片（shard）的几个机器上，机器可以扩展，每个分片的节点数量不一定一样</li>
<li>有一个机器称为 coordinator跟踪区块链并协调节点间的通信，可以要求某分片回滚到某区块链状态或开始新的链</li>
<li>分片有一个ID，由coordinator分配，决定该分片处理哪些事务</li>
<li>女巫分片：节点相同的分片</li>
<li>事务切分存储在对应分片上</li>
<li>总的来说就是有个类似路由器一样的机器来协调处理跨片事务，这篇基本上没看懂，以后有需要再看看</li>
</ol>
<h2 id="5-OptChain-Optimal-Transactions-Placement-for-Scalable-Blockchain-Sharding"><a href="#5-OptChain-Optimal-Transactions-Placement-for-Scalable-Blockchain-Sharding" class="headerlink" title="5. OptChain: Optimal Transactions Placement for Scalable Blockchain Sharding"></a>5. OptChain: Optimal Transactions Placement for Scalable Blockchain Sharding</h2><ol>
<li>新分片方式，最小化跨分片事务，动态事务分配，把相关和即将相关的事务分组到同一分片</li>
<li>对事务分片的依据：<ol>
<li>这样分是否减少了跨片事务</li>
<li>分片间的负载平衡</li>
</ol>
</li>
<li>TaN结构：UTXO模型的事务网络图结构</li>
<li>跨分片事务处理流程：<ol>
<li>用户创建跨分片事务，流言广播</li>
<li>几个UTXO所在的分片锁定UTXO并流言广播许可（或不许可）</li>
<li>接收事务的分片解锁UTXO并记账</li>
</ol>
</li>
<li>对事务分片的算法：<ol>
<li>TaN：把UTXO事务看做图里的节点，然后按图的拓扑结构分析出度和入度</li>
<li>T2S：用PageRank评分，判断节点加入哪个分片——&gt;尽可能减少跨分片事务</li>
<li>L2S：确认延迟，网络结构决定事务得到确认所需的时间——&gt;尽可能加快事务确认速度</li>
<li>T2S和L2S结合选择事务分片</li>
</ol>
</li>
</ol>
<h2 id="6-Poster-A-Proof-of-Stake-PoS-Blockchain-Protocol-using-Fair-and-Dynamic-Sharding-Management"><a href="#6-Poster-A-Proof-of-Stake-PoS-Blockchain-Protocol-using-Fair-and-Dynamic-Sharding-Management" class="headerlink" title="6. Poster: A Proof-of-Stake(PoS) Blockchain Protocol using Fair and Dynamic Sharding Management"></a>6. Poster: A Proof-of-Stake(PoS) Blockchain Protocol using Fair and Dynamic Sharding Management</h2><ol>
<li>每个epoch会重新分片并选择每个分片的block producers</li>
<li>在上一个epoch中，users用自己的信息和一部分资产注册成为validator（验证器），这个epoch开始以后，validator和事务被分成k个分片，分片规则为：<ol>
<li>验证器的地址和上一个区块的哈希值一起哈希然后对分片个数取余，即可得到验证器的分片</li>
<li>事务地址和…，即可得到事务的分片</li>
</ol>
</li>
<li>使用BFT-DPoS算法，在每个分片内选block producers：<ol>
<li>股权最大的成为该分片的producer</li>
<li>所有producers按顺序循环选总的producer</li>
<li>矿工可以投出与他们所持股份的平方根成比例的选票，而不是与所持股份成线性比例的选票。</li>
<li>根据BFT算法，分片的producer产生自己分片的区块，并由总producer合并广播</li>
</ol>
</li>
</ol>
<h2 id="7-SSChain-A-full-sharding-protocol-for-public-blockchain-without-data-migration-overhead"><a href="#7-SSChain-A-full-sharding-protocol-for-public-blockchain-without-data-migration-overhead" class="headerlink" title="7. SSChain: A full sharding protocol for public blockchain  without data migration overhead"></a>7. SSChain: A full sharding protocol for public blockchain  without data migration overhead</h2><ol>
<li>公链，拜占庭弹性，对事务分片和对状态分片，节点无需定期切换分片（避免数据冗余），使用UTXO</li>
<li><p>节点可以自由加入分片而无需刷新，为避免随之而来的51%攻击问题，本文提出了一个双层结构：</p>
<ol>
<li>根链验证分片的区块，避免恶意节点攻击，激励机制保证矿工愿意加入</li>
<li>分片维护不相交的分类帐并独立处理不相交的交易子集。</li>
<li>SSChain背后的关键思想是根链维护系统的安全性，而切分提高了吞吐量并减少了存储需求。</li>
</ol>
</li>
<li><p>同一分片内的交易有更低的确认延迟和更少的交易费用，进而鼓励用户片内交易</p>
</li>
<li>解耦事务验证和状态更新，拆分跨分片事务</li>
<li>激励机制：动态调节根链和分片的算力分配，根据参数可得到不同的吞吐量和安全性</li>
<li>跨分片事务：切分成分片内事务，或者由根链处理</li>
<li>根链：PoW，分类帐修剪机制</li>
<li>事务分片：<ol>
<li>事务地址包含比特币地址和分片ID</li>
<li>交易分类：<ol>
<li>inputs和outputs在一个分片内</li>
<li>inputs在一个分片内，outputs在不同分片</li>
<li>都在不同分片</li>
</ol>
</li>
<li>跨分片事务：<ol>
<li>交给根链——&gt;随分片增长会很难处理</li>
<li>鼓励用户在同一分片内创建新地址——&gt;跨分片变成同一分片</li>
<li>A+B——&gt;C的事务拆分成A——&gt;C和B——&gt;C（个人感觉这没用啊）</li>
</ol>
</li>
</ol>
</li>
<li>状态分片：一些节点储存整个区块链的状态而不是只存分片状态</li>
<li>市场激励机制：动态地调整切分和根链之间的哈希功率分配。在激励机制下，矿商可以自由选择最赚钱的碎片，从而避免了周期性的网络重组。有两个目的：<ol>
<li>为了维护系统安全，根链占用了整个网络的很大一部分算力。由于切分块是由根链网络验证的，恶意对手至少需要根链哈希能力的一半才能进行双倍开销攻击。</li>
<li>算力被鼓励平均分配到碎片中，这样每个碎片都可以正常工作。</li>
</ol>
</li>
</ol>
<h2 id="8-Trust-Based-Shard-Distribution-Scheme-for-Fault-Tolerant-Shard-Blockchain-Networks"><a href="#8-Trust-Based-Shard-Distribution-Scheme-for-Fault-Tolerant-Shard-Blockchain-Networks" class="headerlink" title="8. Trust-Based Shard Distribution Scheme for Fault-Tolerant Shard Blockchain Networks"></a>8. Trust-Based Shard Distribution Scheme for Fault-Tolerant Shard Blockchain Networks</h2><ol>
<li>TBSD：把恶意节点放到不同的分片，使用信任管理系统和遗传算法</li>
<li>定量衡量节点的信任度，对恶意节点进行信用惩罚</li>
<li>遗传算法找到最优分片方法，使得每个分片的信用度都差不多</li>
<li>总的来说信用系统分为5步：<ol>
<li>每一轮开始时，PoS选一个leader出块</li>
<li>全网广播验证区块，少数服从多数</li>
<li>SCO：节点信用表，由验证节点产生，上一步的验证结果作为信用评分的依据</li>
<li>LCR：根据SCO计算得到的相对信用分布矩阵</li>
<li>最终信用评估</li>
</ol>
</li>
<li>攻击模型：<ol>
<li>恶意节点成为leader</li>
<li>节点共谋</li>
<li>恶意节点行为不一致，一会儿诚实一会儿恶意</li>
</ol>
</li>
<li>分片过程：用GA</li>
</ol>
<h2 id="9-Two-Phase-Cooperative-Bargaining-Game-Approach-for-Shard-Based-Blockchain-Consensus-Scheme"><a href="#9-Two-Phase-Cooperative-Bargaining-Game-Approach-for-Shard-Based-Blockchain-Consensus-Scheme" class="headerlink" title="9. Two-Phase Cooperative Bargaining Game Approach for Shard-Based Blockchain Consensus Scheme"></a>9. Two-Phase Cooperative Bargaining Game Approach for Shard-Based Blockchain Consensus Scheme</h2><ol>
<li>分片后，进行议价博弈，事务总的来说平分给每个分片处理</li>
<li>有一个adjust shard负责确认，其他分片进行普通的挖矿</li>
<li>随机数分片，分片内共识：标准拜占庭一致协议，看起来是对节点分片</li>
<li>节点验证事务和参与共识的过程可看做两阶段博弈：<ol>
<li>事务分配问题</li>
<li>基于分片的共识机制</li>
</ol>
</li>
<li>讨价还价博弈这里没完全看懂，感觉就是分片和节点根据奖励和支出决定是否处理事务，上面的4.1里博弈方是分片，4.2的博弈方是区块链节点</li>
</ol>
<h2 id="A-Node-Rating-Based-Sharding-Scheme-for-Blockchain"><a href="#A-Node-Rating-Based-Sharding-Scheme-for-Blockchain" class="headerlink" title="A Node Rating Based Sharding Scheme for Blockchain"></a>A Node Rating Based Sharding Scheme for Blockchain</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>论文记录-Monoxide: Scale Out Blockchain with Asynchronous Consensus Zones</title>
    <url>/2020/04/07/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95-Monoxide%20Scale%20Out%20Blockchain%20with%20Asynchronous%20Consensus%20Zones/</url>
    <content><![CDATA[<h2 id="突破区块链不可能三角异步共识组"><a href="#突破区块链不可能三角异步共识组" class="headerlink" title="突破区块链不可能三角异步共识组"></a>突破区块链不可能三角异步共识组</h2><p>这篇没看完。</p>
<a id="more"></a>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ol>
<li>背景：加密货币在匿名在线支付方面很重要</li>
<li>问题：<ol>
<li>随用户和交易的增长，低吞吐量阻碍加密货币系统的扩展</li>
<li>每个节点复制整个网络的通信、存储和状态表示也阻碍了系统的扩展</li>
</ol>
</li>
<li>本文：<ol>
<li>Asynchronous Consensus Zones（异步一致网络）：分区域，不影响去中心化和安全性，每个区域独立并行，块内共识；</li>
<li>诸葛连弩系统：使得攻击单独的一个块的难度和攻击整个区块的难度一样大</li>
</ol>
</li>
</ol>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ol>
<li>TPS（每秒交易数）很低的原因在于区块按顺序建立，而网络延迟导致广播时间不能过短</li>
<li>每一个完整的节点都需要复制整个网络的通信、存储和状态表示，系统受限于硬件设备而无法扩展</li>
<li>综上可扩展的区块链要考虑：<ol>
<li>共识协议的可扩展性</li>
<li>通信、存储、计算和内存的资源使用</li>
<li>去中心化和安全性</li>
</ol>
</li>
<li>以太坊已提出分片的设计</li>
<li>本文异步一致网络：<ol>
<li>分区域，通过在多个独立和并行实例(或一致区域)中划分和处理工作负载来扩展区块链系统</li>
<li>整个网络划分为区域，每个区域负责自己那部分，只在区域内复制，挖矿竞争和交易确认等在区块间异步进行</li>
<li>挑战在于：<ol>
<li>跨区域事务的吞吐量</li>
<li>诚实矿工稀释带来的安全性问题</li>
</ol>
</li>
</ol>
</li>
<li>本文最终原子确认：跨区域事务由原子性分解为多个事务，每个事务涉及单独一个区域</li>
<li>本文诸葛连弩：矿工挖矿成功时可以在不同的区域里创建多个区块，其算力平均分配到各个区域，而攻击者的攻击算力同样也被分到了不同区域，因此攻击单独一个区域和攻击整个系统难度一样</li>
</ol>
<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>对比PoS和PoW，UTXO和账户余额</p>
<ol>
<li>影响区块链系统和共识协议性能的因素：一致性（共识）、通信、存储、表示</li>
<li>PoW耗费算力来竞争记账权，但是加密货币一定程度上有对应现实世界的价值；PoS由节点的股权（财富）来决定区块的产生；本文用PoW，但改PoS也行</li>
<li>加密货币有两种交易模型，UTXO和账户余额，以太坊用了后者（更支持智能合约），本文也用了后者，总之账户余额模型有很多优点</li>
</ol>
<h3 id="System-Design"><a href="#System-Design" class="headerlink" title="System Design"></a>System Design</h3><ol>
<li><p>跨区域事务的执行：</p>
<ol>
<li>区域A执行检查余额然后取钱（ withdraw operation），下一个该区域的区块就会更新余额状态等</li>
<li>区域A把存钱（ deposit operation ）打包成一个中继操作（ relay transaction ）发给区域B</li>
<li>区域B执行存钱操作，不需要检查余额</li>
<li>取钱只涉及区域A，存钱只涉及区域B，因此不需要进行区域间的确认等</li>
</ol>
</li>
<li><p>划分和命名（Partitioning and Naming）：</p>
<ol>
<li>用户地址被均匀划分为$2^k$个区域，一个区域由它的分片尺度k和区域索引s来识别</li>
<li>群swarm：参与相同数据集的复制的一组节点。全节点加入群从而广播信息和接收其他全节点的信息。比特币和以太坊系统只有一个群，大家都保存同样的信息。</li>
<li>本文有多个出于不同目的建立的群，采用分布式哈希表(DHT)进行群寻址和对等发现。</li>
<li>系统中有一个包含所有全节点的全局群，用于复制所有区域的最小公共信息。</li>
<li>在每个群内，全节点稀疏分布，使用gossip protocol广播信息</li>
<li>区域特定的群也用分片尺度k和区域索引s来识别</li>
</ol>
</li>
<li><p>单独一个区域：区域间计算和事务相互隔离、独立并行，随网络增长会创建新区域</p>
<ol>
<li>全节点或矿工有特定标识符来决定在哪个区域内工作</li>
<li>每个区域有自己的区块链</li>
<li>矿工只与同区域的PoW竞争记账权</li>
<li>全节点会忽略其他区域的事务消息</li>
</ol>
</li>
<li><p>最小化跨区域开销：</p>
<ol>
<li>系统在每个节点上维护一个分布式哈希表(DHT)</li>
<li>大多数通信用于复制未经确认的事务，并广播带有已确认事务的新块</li>
<li>获取未确认事务或新块对应的区域索引s后，系统在DHT中选择索引相同的节点，通过gossip protocol把事务和区块发给它们。</li>
<li>只把中继事务发给对应区域，而不是全网广播</li>
<li>用于形成链的最小化数据会被复制到所有区域（下一部分讨论）</li>
</ol>
<h3 id="Efﬁcient-Cross-Zone-Atomicity"><a href="#Efﬁcient-Cross-Zone-Atomicity" class="headerlink" title="Efﬁcient Cross-Zone Atomicity"></a>Efﬁcient Cross-Zone Atomicity</h3><ol>
<li>事务分为取钱（relay）和存钱（deposit）操作，分别在对应的区域进行验证</li>
<li>为避免分叉出现的问题：<ol>
<li>取钱验证一次</li>
<li>存钱验证一次</li>
<li>中继操作隔一定数量的区块后才被打包</li>
</ol>
</li>
</ol>
<h3 id="Defense-Per-Zone-Security"><a href="#Defense-Per-Zone-Security" class="headerlink" title="Defense Per-Zone Security"></a>Defense Per-Zone Security</h3><ol>
<li>允许矿工完成一次PoW在多个区域建立多个区块（区块网？），每个区域只能建立一个</li>
<li>参与诸葛连弩的矿工的算力没被稀释，这样攻击单独一个区域所需的算力仍然是50%</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-6</title>
    <url>/2020/04/01/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-6/</url>
    <content><![CDATA[<p>这一课讲第三方库的安装和使用，然后用<code>wordcloud</code>和<code>jieba</code>生成词云图和中文分词。没有课堂练习，只有一个在上次作业基础上的作业。</p>
<p>我是直接<code>pip</code>安装的，在安装<code>wordcloud</code>时，<code>pip install wordcloud</code>很快就装好了，但是<code>jieba</code>反复出错，最后指定清华镜像，<code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple jieba</code>，这样就飞快地安装好了。</p>
<a id="more"></a>
<h3 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h3><p>(4) 利用<code>wordcloud</code>结合<code>jieba</code>分别对李白（杜甫）诗歌内容中的字和词语进行可视化。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>上节课的作业完成后已经得到了处理好的诗歌字符串和字频统计<code>Counter</code>，那么接下来就可以用这两个变量来得到对应的词云图。</p>
<p>用<code>fit_words()</code>函数根据已经得到的计数器<code>poems_counter</code>生成的字典来制作字频的词云图片，用<code>generate()</code>函数对用<code>jieba</code>进行分词之后的<code>poems_text</code>生成词频的词云图片。在保存图片后可以用<code>PIL</code>中的<code>Image.open()</code>和<code>show()</code>来显示图片。对应的函数代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入库</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> wordcloud</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloud_character</span><span class="params">(poems_counter, name)</span>:</span></span><br><span class="line">    dict_character = dict(poems_counter)</span><br><span class="line">    <span class="comment"># 生成图像对应的遮罩，这样词云图就是按图像里非白色区域来填充的</span></span><br><span class="line">    mask = np.array(Image.open(name + <span class="string">'.jpg'</span>))</span><br><span class="line">    <span class="comment"># 根据图像生成颜色表，这样词云图的颜色就和图像一致了</span></span><br><span class="line">    color = wordcloud.ImageColorGenerator(mask)</span><br><span class="line">    <span class="comment"># 生成词云图变量，背景白色，random_state的值影响字在图中的分布，color_func设定词云颜色，mask设定图像遮罩，font_path指定字体，不指定的话中文没法显示</span></span><br><span class="line">    wc = wordcloud.WordCloud(background_color=<span class="string">"white"</span>, random_state=<span class="number">42</span>, color_func=color, mask=mask, font_path=<span class="string">'C:\Windows\Fonts\simsun.ttc'</span>)</span><br><span class="line">    <span class="comment"># 根据字典生成词云图的内容</span></span><br><span class="line">    wc.fit_words(dict_character)</span><br><span class="line">    <span class="comment"># 保存词云图</span></span><br><span class="line">    wc.to_file(name + <span class="string">"cloud_character.png"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloud_word</span><span class="params">(poems_text, name)</span>:</span></span><br><span class="line">    text = <span class="string">' '</span>.join(jieba.cut(poems_text))</span><br><span class="line">    mask = np.array(Image.open(name + <span class="string">'.jpg'</span>))</span><br><span class="line">    color = wordcloud.ImageColorGenerator(mask)</span><br><span class="line">    wc = wordcloud.WordCloud(background_color=<span class="string">"white"</span>, random_state=<span class="number">42</span>, color_func=color, mask=mask, font_path=<span class="string">'C:\Windows\Fonts\simsun.ttc'</span>)</span><br><span class="line">    <span class="comment"># 根据文本字符串生成词云图的内容</span></span><br><span class="line">    wc.generate(text)</span><br><span class="line">    wc.to_file(name + <span class="string">"cloud_word.png"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_pic</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="comment"># 打开图像</span></span><br><span class="line">    img1 = Image.open(name + <span class="string">"cloud_character.png"</span>)</span><br><span class="line">    img2 = Image.open(name + <span class="string">"cloud_word.png"</span>)</span><br><span class="line">    <span class="comment"># 显示图像</span></span><br><span class="line">    img1.show()</span><br><span class="line">    img2.show()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序部分</span></span><br><span class="line">cloud_character(counter_libai, <span class="string">'libai'</span>)</span><br><span class="line">cloud_character(counter_dufu, <span class="string">'dufu'</span>)</span><br><span class="line">cloud_word(text_libai, <span class="string">'libai'</span>)</span><br><span class="line">cloud_word(text_dufu, <span class="string">'dufu'</span>)</span><br><span class="line">show_pic(<span class="string">"libai"</span>)</span><br><span class="line">show_pic(<span class="string">"dufu"</span>)</span><br></pre></td></tr></table></figure>
<p>（最后生成的词云图是真的怪怪的……）</p>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-5</title>
    <url>/2020/03/31/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-5/</url>
    <content><![CDATA[<p>这一课讲的是字典和集合。</p>
<a id="more"></a>
<h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><ol>
<li><p>对于下列财经数据<code>lst</code>，如何构造公司代码和股票价格的字典<code>d</code>？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst=[(<span class="string">'AXP'</span>,<span class="string">'American Epress Company'</span>,<span class="string">'86.40'</span>),</span><br><span class="line">	(<span class="string">'BA'</span>,<span class="string">'The Boeing Company'</span>,<span class="string">'22.64'</span>),</span><br><span class="line">	(<span class="string">'CAT'</span>,<span class="string">'Caterpillar Inc.'</span>,<span class="string">'99.44'</span>),</span><br><span class="line">	(<span class="string">'CSCO'</span>,<span class="string">'Cisco System Inc.'</span>,<span class="string">'23.78'</span>),</span><br><span class="line">	(<span class="string">'CVX'</span>,<span class="string">'Chevron Corporation'</span>,<span class="string">'115.91'</span>)]</span><br><span class="line">d=&#123;<span class="string">'AXP'</span>:<span class="string">'86.40'</span>,<span class="string">'BA'</span>:<span class="string">'122.64'</span>,<span class="string">'CAT'</span>:<span class="string">'99.44'</span>,<span class="string">'CSCO'</span>:<span class="string">'23.78'</span>,<span class="string">'CVX'</span>:<span class="string">'115.91'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>答案：从列表构造字典，根据定义可以直接使用<code>d={a:c for a,b,c in lst}</code></p>
</li>
<li><p>如何把一个字典中的<code>key</code>和<code>value</code>互换？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=&#123;<span class="string">'blue'</span>:<span class="number">500</span>, <span class="string">'green'</span>:<span class="number">300</span>, <span class="string">'red'</span>:<span class="number">100</span>&#125;</span><br><span class="line">&#123;<span class="number">100</span>:<span class="string">'red'</span>, <span class="number">300</span>:<span class="string">'green'</span>, <span class="number">500</span>:<span class="string">'blue'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>答案：使用<code>items</code>属性即可，<code>new_d={value:key for key, value in d.items()}</code></p>
</li>
</ol>
<h3 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h3><ol>
<li>利用内置数据类型对李白和杜甫的诗歌进行分析，包括：</li>
</ol>
<p>(1)读入李白.txt，得到李白诗歌内容中的所有的汉字，并进一步得到其中的不重复汉字，最后打印所有汉字的个数、不重复汉字的个数、以及不重复汉字，打印汉字时要求每行10个汉字，汉字之间以2个空格分开。</p>
<p>(2)进一步利用字典进行李白诗歌的字频统计，即统计每个字出现的次数，并对字频进行归一化处理（即除以诗歌篇数），然后输出显示字频统计结果，输出显示时根据字频降序排列，只打印频率大于等于0.1的结果，并注意对齐。</p>
<p>(3)采用同上述相同的方法，得到杜甫诗歌的字频统计结果。在此基础上获得李白和杜甫的高频词集合（即频率大于等于0.1的汉字集合），利用集合操作进一步获得两位诗人都爱用的字、李白爱用但杜甫不爱用的字以及杜甫爱用而李白不爱用的字，并输出上述结果，输出时每行10个单词，汉字之间以2个空格分开。</p>
<p>说明：统计时不考虑题目、朝代、作者，只考虑诗歌内容。</p>
<p>作业思路：</p>
<p>首先是要读取txt文件，这里作业提示说用下述代码来读取文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'李白.txt'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    poems_text = f.read()</span><br></pre></td></tr></table></figure>
<p>此时整个文件的内容作为字符串存在<code>poems_text</code>中，并且每首诗之间有换行符，因此使用<code>poems_list = poems_text.splitlines()</code>将每首诗作为列表<code>poems_list</code>中的元素（字符串）存储。</p>
<p>接下来遍历列表元素，因为每首诗格式都是“标题 朝代 作者 诗歌内容”这样，所以对每个字符串查找作者名字，并只留存作者名字之后的字符串内容，就可以得到我们需要统计的诗歌内容，再去掉中文标点、英文标点和空格，就得到了一个处理好的诗歌内容列表，这部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(poems_list)):</span><br><span class="line">    index = poems_list[i].find(name)</span><br><span class="line">    poems_list[i] = poems_list[i][index + <span class="number">3</span>:]</span><br><span class="line">    poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, zhon.hanzi.punctuation))</span><br><span class="line">    poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, string.punctuation))</span><br><span class="line">    poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, <span class="string">' '</span>))</span><br></pre></td></tr></table></figure>
<p>这时<code>poems_num = len(poems_list)</code>即可得到诗歌总数，<code>poems_text = &#39;&#39;.join(poems_list)</code>即可得到处理好之后的字符串。然后进行统计。</p>
<p>我们使用<code>poems_counter = collections.Counter(poems_text)</code>可以得到一个<code>Counter</code>计数器，该计数器是一个字典，<code>key</code> 是字，<code>val</code>是该字出现的次数，按出现次数遍历这个计数器，并把<code>key</code>加入到集合<code>poems_set</code>中，当字频（<code>val/poems_num</code>）低于0.1时，break结束遍历，这样就得到了高频字的集合，这部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> poems_counter.most_common():</span><br><span class="line">    <span class="keyword">if</span> val / poems_num &lt; <span class="number">0.1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    poems_set.add(key)</span><br></pre></td></tr></table></figure>
<p>接下来通过集合运算就可以得到李白和杜甫的交集和差集了。</p>
<p>关于格式化输出，首先是输出诗歌本身的字数、不重复字数和不重复字，每10个换行，字中间是两个空格，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(name + <span class="string">'诗词中总共有'</span> + str(len(poems_text)) + <span class="string">'个汉字，其中不重复的汉字有'</span> + str(len(poems_counter)) + <span class="string">'个，具体如下：'</span>)</span><br><span class="line">print_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> poems_counter:</span><br><span class="line">    print(key, end=<span class="string">'  '</span>)</span><br><span class="line">    print_num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> print_num % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        print()</span><br><span class="line">print()</span><br></pre></td></tr></table></figure>
<p>接下来是字频统计的输出，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'字频统计信息如下：\n汉字---频率'</span>)</span><br><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> poems_counter.most_common():</span><br><span class="line">    <span class="keyword">if</span> val / poems_num &lt; <span class="number">0.1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">'&#123;&#125;\t &#123;&#125;'</span>.format(key, val / poems_num))</span><br></pre></td></tr></table></figure>
<p>最后是字频集合的输出，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> set:</span><br><span class="line">    print(i, end=<span class="string">'  '</span>)</span><br><span class="line">    print_num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> print_num % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        print()</span><br><span class="line">print()</span><br></pre></td></tr></table></figure>
<p>整体代码我把诗歌的预处理部分作为一个函数、诗歌输出作为一个函数、集合输出作为一个函数，最后主函数调用它们。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> zhon.hanzi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poems</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(name + <span class="string">'.txt'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        poems_text = f.read()</span><br><span class="line">    poems_list = poems_text.splitlines()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(poems_list)):</span><br><span class="line">        index = poems_list[i].find(name)</span><br><span class="line">        poems_list[i] = poems_list[i][index + <span class="number">3</span>:]</span><br><span class="line">        poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, zhon.hanzi.punctuation))</span><br><span class="line">        poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, string.punctuation))</span><br><span class="line">        poems_list[i] = poems_list[i].translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, <span class="string">' '</span>))</span><br><span class="line">    poems_num = len(poems_list)</span><br><span class="line">    poems_text = <span class="string">''</span>.join(poems_list)</span><br><span class="line">    poems_counter = collections.Counter(poems_text)</span><br><span class="line">    poems_set = set()</span><br><span class="line">    <span class="keyword">for</span> key, val <span class="keyword">in</span> poems_counter.most_common():</span><br><span class="line">        <span class="keyword">if</span> val / poems_num &lt; <span class="number">0.1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        poems_set.add(key)</span><br><span class="line">    <span class="keyword">return</span> poems_num, poems_text, poems_counter, poems_set</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_poem</span><span class="params">(name, poems_num, poems_text, poems_counter)</span>:</span></span><br><span class="line">    print(name + <span class="string">'诗词中总共有'</span> + str(len(poems_text)) + <span class="string">'个汉字，其中不重复的汉字有'</span> + str(len(poems_counter)) + <span class="string">'个，具体如下：'</span>)</span><br><span class="line">    print_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> poems_counter:</span><br><span class="line">        print(key, end=<span class="string">'  '</span>)</span><br><span class="line">        print_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> print_num % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            print()</span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">'字频统计信息如下：\n汉字---频率'</span>)</span><br><span class="line">    <span class="keyword">for</span> key, val <span class="keyword">in</span> poems_counter.most_common():</span><br><span class="line">        <span class="keyword">if</span> val / poems_num &lt; <span class="number">0.1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">'&#123;&#125;\t &#123;&#125;'</span>.format(key, val / poems_num))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_set</span><span class="params">(set)</span>:</span></span><br><span class="line">    print_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> set:</span><br><span class="line">        print(i, end=<span class="string">'  '</span>)</span><br><span class="line">        print_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> print_num % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            print()</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num_libai, text_libai, counter_libai, set_libai = poems(<span class="string">'李白'</span>)</span><br><span class="line">num_dufu, text_dufu, counter_dufu, set_dufu = poems(<span class="string">'杜甫'</span>)</span><br><span class="line">print_poem(<span class="string">'李白'</span>, num_libai, text_libai, counter_libai)</span><br><span class="line">print_poem(<span class="string">'杜甫'</span>, num_dufu, text_dufu, counter_dufu)</span><br><span class="line">s_both_love = set_libai &amp; set_dufu</span><br><span class="line">s_only_libai = set_libai - set_dufu</span><br><span class="line">s_only_dufu = set_dufu - set_libai</span><br><span class="line">print(<span class="string">'两位诗人都爱用的字有'</span> + str(len(s_both_love)) + <span class="string">'个，这些字为：'</span>)</span><br><span class="line">print_set(s_both_love)</span><br><span class="line">print(<span class="string">'李白爱用但杜甫不爱用的字有'</span>+str(len(s_only_libai))+<span class="string">'个，这些字为：'</span>)</span><br><span class="line">print_set(s_only_libai)</span><br><span class="line">print(<span class="string">'杜甫爱用但李白不爱用的字有'</span>+str(len(s_only_libai))+<span class="string">'个，这些字为：'</span>)</span><br><span class="line">print_set(s_only_dufu)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-4</title>
    <url>/2020/03/23/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-4/</url>
    <content><![CDATA[<p>这一课是讲字符串的，主要是几种字符串函数。</p>
<a id="more"></a>
<h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><ol>
<li><p>下面代码的运行结果是（）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">	print(i)</span><br><span class="line">	s.remove(i)</span><br></pre></td></tr></table></figure>
<p>A. 1 2 3 4 5（一个数字一行）</p>
<p>B. 1 3 5（一个数字一行）</p>
<p>答案：显然这里<code>s</code>是个列表，列表的<code>remove()</code>函数的作用是移除指定元素，只移除匹配到的第一个。按顺序看，最初列表是<code>s=[1,2,3,4,5]</code>，<code>for</code>循环访问列表的第一个元素，并输出<code>1</code>，接着移除<code>1</code>，这之后列表<code>s</code>的元素会整体往前挪一位，变成<code>s=[2,3,4,5]</code>，此时第一个元素变成<code>2</code>，第二个元素变成<code>3</code>，而<code>for</code>循环会去找列表的第二个元素，也就是跳过<code>2</code>访问<code>3</code>，输出并移除，变成<code>s=[2,4,5]</code>，然后输出并移除第三个元素<code>5</code>。</p>
<p>所以最后输出的是<code>1 3 5</code>，选B。</p>
</li>
<li><p>下列操作的结果是（）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">'!..Hi!!!.'</span></span><br><span class="line">s.strip(<span class="string">'!.'</span>)</span><br></pre></td></tr></table></figure>
<p>A. ‘.Hi!!!’        B. ‘.Hi!!!.’        C. ‘!..Hi!!’        D. ‘Hi’</p>
<p>答案：字符串的<code>strip</code>函数是移除字符串左右两边的指定字符元素，如果没指定就移除空格，然后遇到第一个不是指定元素的时候就停止移除操作，并且指定元素不会连起来看，也就是这里的<code>!</code>和<code>.</code>是会被看做两个元素，而不是一个完整的字符串，因此移除的时候并不是找连续的<code>!.</code>，而是移除左右两边所有<code>!</code>和<code>.</code>，也就是选D。</p>
</li>
<li><p>用一行代码把字符串<code>s=&#39;  abcdbacbaab&#39;</code>中的<code>b</code>去掉。</p>
<p>答案：首先可以用字符串中的翻译函数，将所有<code>b</code>翻译成空字符，也就是<code>s.translate(str.maketrans(&#39;&#39;, &#39;&#39;,&#39;b&#39;))</code>。最直接的方法是用字符串的<code>replace</code>函数，将<code>b</code>替换成空字符，即<code>s=s.replace(&#39;b&#39;,&#39;&#39;)</code>。</p>
</li>
<li><p>判断两个单词s1和s2是否构成字谜：即s1和s2的字母和个数相同，只是顺序不同，如cinema何iceman，要求只用一行代码。</p>
<p>答案：如果不要求只用一行代码，那办法有很多了，现在要求只用一行代码，因此只能采用字符串的<code>sorted()</code>函数，该函数会返回一个排好序的字符串，因此可以通过<code>sorted(s1)==sorted(s2)</code>来判断两个字符串是否构成字谜。</p>
</li>
<li><p>如何将<code>s=&#39;d,f,a,c,b,d,g,e,a,f&#39;</code>中的字母进行排序，得到新的字符串<code>s=&#39;a,a,b,c,d,d,e,f,f,g&#39;</code>？</p>
<p>答案：直接来说就是要把原字符串中的<code>,</code>去掉，剩下的字符串按字母顺序排序，然后再把<code>,</code>加回来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">'d,f,a,c,b,d,g,e,a,f'</span> </span><br><span class="line">s1=s.replace(<span class="string">','</span>,<span class="string">''</span>) </span><br><span class="line">s2=sorted(s1) </span><br><span class="line"><span class="string">','</span>.join(s2)</span><br></pre></td></tr></table></figure>
<h3 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h3><ol>
<li><p>在第一课练习的基础上，判断一个字符串是否是回文串（规则更宽松）：</p>
<p>例如：Madam, I’m Adam                 True</p>
<p>A man, a plan, a canal, Panama!                True</p>
<p>客上天然居，居然天上客.                True</p>
<p>答案：我的思路是把字符串里所有的标点和空格去掉，然后把所有字母都转成小写字母，最后用之前写好的函数来判断字符串是否是回文串。 <code>string.punctuation</code>中存有所有标点符号，因此可以将字符串中所有的<code>string.punctuation</code>替换成空字符，从而去掉标点；空格同理；<code>casefold()</code>函数可以使字符串中所有的字符都变成小写。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindromic4</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> num == num[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_space_punc</span><span class="params">(s)</span>:</span></span><br><span class="line">    s_1=s.translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, string.punctuation))</span><br><span class="line">    s_2=s_1.translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, <span class="string">' '</span>))</span><br><span class="line">    s_3=s_2.casefold()</span><br><span class="line">    <span class="keyword">return</span> s_3</span><br><span class="line">    </span><br><span class="line">s1 = <span class="string">"Madam, I'm Adam"</span></span><br><span class="line">s2 = <span class="string">"A man, a plan, a canal, Panama!"</span></span><br><span class="line">s3 = <span class="string">"客上天然居，居然天上客."</span></span><br><span class="line"></span><br><span class="line">print(is_palindromic4(del_space_punc(s1)))</span><br><span class="line">print(is_palindromic4(del_space_punc(s2)))</span><br><span class="line">print(is_palindromic4(del_space_punc(s3)))</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入一个字符串a和字符串b，查找b在a中的所有位置并输出显示。</p>
<p>例如：请输入一个字符串：abcdeabcdeab</p>
<p>请输入另一个字符串：ab</p>
<p>输出0 5 10</p>
<p>答案：直接一些的想法是遍历字符串检索<code>a</code>，然后看下一个字符是否是<code>b</code>，不过百度之后发现可以直接用正则匹配，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">a = input(<span class="string">'请输入一个字符串：'</span>)</span><br><span class="line">b = input(<span class="string">'请输入另一个字符串：'</span>)</span><br><span class="line">print([i.start() <span class="keyword">for</span> i <span class="keyword">in</span> re.finditer(b,a)])</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计一篇文章（看成一个长字符串）中单词的个数，以及文章中不同单词的个数及列表，最后输出显示。（备注：单词的不同时态 以及单复数都看成是不同的单词）。字符串为变量speech，<code>speech=&#39;&#39;&#39;  Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal. Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battle-field of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this. But, in a larger sense, we can not dedicate -- we can not consecrate -- we can not hallow -- this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us -- that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion -- that we here highly resolve that these dead shall not have died in vain -that this nation, under God, shall have a new birth of freedom -- and that government of the people, by the people, for the people, shall not perish from the earth.&#39;&#39;&#39;</code></p>
<p>答案：受上一题的影响，这里也考虑用正则匹配来判断有多少个单词，并把单词放到一个列表中，再根据列表建立字典从而输出词频。统计词频可以用<code>collections.Counter</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">speech=<span class="string">'''  Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal. Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battle-field of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this. But, in a larger sense, we can not dedicate -- we can not consecrate -- we can not hallow -- this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us -- that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion -- that we here highly resolve that these dead shall not have died in vain -that this nation, under God, shall have a new birth of freedom -- and that government of the people, by the people, for the people, shall not perish from the earth.'''</span></span><br><span class="line">words=re.findall(<span class="string">r'[a-zA-Z]+'</span>,speech)</span><br><span class="line">count=len(words)</span><br><span class="line">print(<span class="string">'单词出现次数：'</span>,count)</span><br><span class="line">list2 = collections.Counter(words)</span><br><span class="line">print(dict(list2))</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Let-s-Build-A-Simple-Interpreter笔记-8</title>
    <url>/2020/03/23/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-8/</url>
    <content><![CDATA[<p>还没开始看，看完再写。</p>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Let-s-Build-A-Simple-Interpreter笔记-7</title>
    <url>/2020/03/15/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-7/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part7/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/02/02/lets-build-a-simple-interpreter-part-07/" target="_blank" rel="noopener">翻译</a></p>
<p>（这次翻译又出现了一些不影响理解的小问题。课程代码越来越长，我决定改一下文档结构，不在一开始放整块代码了。）</p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这一课的知识点格外多。</p>
<h4 id="抽象语法树和解析树"><a href="#抽象语法树和解析树" class="headerlink" title="抽象语法树和解析树"></a>抽象语法树和解析树</h4><ol>
<li><p>在之前的代码中，词法分析结束后进行语法分析的同时就完成了运算，这种 interpreter 被称为语法导向解释器 (syntax-directed interpreter)，对于更复杂的语法结构，我们需要建立一个中间表示（intermediate representation, IR），我们的 parser 会 负责构建 IR 而 interpreter 会用来解释由 IR 所代表的输入。一般来说会用树来构建IR。</p>
</li>
<li><p>解析树（有时叫做具体语法树）是一个根据我们的语法定义来表示一门语言的句法结构的树形结构。它基本上展示了你的 <code>parser</code> 如何识别语言结构或者， 换句话说，它展示了你语法的开始符号怎么派生出该编程语言中一个特定的字符串的。</p>
</li>
<li><p>抽象语法树（AST）是我们的解释器和未来编译器项目的中心数据结构。</p>
</li>
<li><p>如下图，分别是的AST和解析树。</p>
<p><img src="https://github.com/kun-bin/image/blob/master/lsbasi_part7_ast_01.png?raw=true" alt="AST和解析树对比"></p>
</li>
<li><p>简单来说，AST就是把操作数放到叶节点，操作符放到中间节点和根节点，操作符节点在树中的高度可以体现运算优先级，括号改变优先级也是通过改变操作符的高度。</p>
</li>
<li><p>具体到代码，首先要构建一个AST类，目前这个类里什么也没有，就只是用来让别的类继承。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AST</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>接下来要定义这个树的节点类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二元操作符类，继承AST</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, left, op, right)</span>:</span></span><br><span class="line">		self.left = left</span><br><span class="line">		self.token = self.op = op</span><br><span class="line">		self.right = right</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 整数类，继承AST</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">		self.token = token</span><br><span class="line">		self.value = token.value</span><br></pre></td></tr></table></figure>
<p><code>Token</code>这个类和前几课里的完全一致。</p>
<p>到此为止，我们就创建好AST的基本结构了，接下来可以通过赋值的方式一点点创建一个解析式的AST，例如<code>2*7+3</code>的AST：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立加号和乘号的Token</span></span><br><span class="line">mul_token = Token(MUL, <span class="string">'*'</span>)</span><br><span class="line">plus_token = Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"><span class="comment"># 先建立乘法操作符的节点</span></span><br><span class="line">mul_node = BinOp(</span><br><span class="line">    <span class="comment"># 左边是第一个乘数</span></span><br><span class="line">    left=Num(Token(INTEGER, <span class="number">2</span>)),</span><br><span class="line">    <span class="comment"># 是乘法</span></span><br><span class="line">    op=mul_token,</span><br><span class="line">    <span class="comment"># 右边是第二个乘数</span></span><br><span class="line">    right=Num(Token(INTEGER, <span class="number">7</span>))</span><br><span class="line">)</span><br><span class="line"><span class="comment">#建立加法操作符的节点</span></span><br><span class="line">add_node = BinOp(</span><br><span class="line">    <span class="comment"># 左边是刚才进行的乘法节点</span></span><br><span class="line">    left=mul_node,</span><br><span class="line">    <span class="comment"># 中间是加号</span></span><br><span class="line">    op=plus_token,</span><br><span class="line">    <span class="comment"># 右边是加数</span></span><br><span class="line">    right=Num(Token(INTEGER, <span class="number">3</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>把上述内容合并到之前的代码中，在<code>Lexer</code>得到词法单元后，不是直接进行运算，而是建立AST，即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parse</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        和之前一样</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        和之前一样</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        和之前一样</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">		<span class="keyword">if</span> token.type == INTEGER:</span><br><span class="line">            self.eat(INTEGER)</span><br><span class="line">            <span class="comment"># 之前是return token.value</span></span><br><span class="line">	    	<span class="keyword">return</span> Num(token)</span><br><span class="line">		<span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">            self.eat(LPAREN)</span><br><span class="line">            <span class="comment"># 之前是value = self.expr()</span></span><br><span class="line">            node = self.expr()</span><br><span class="line">            self.eat(RPAREN)</span><br><span class="line">            <span class="comment"># 之前是return value</span></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 之前是value = self.factor()</span></span><br><span class="line">		node = self.factor()</span><br><span class="line">		<span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">            	self.eat(MUL)</span><br><span class="line">                <span class="comment"># 之前有value *= self.factor()求值</span></span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">            	self.eat(DIV)</span><br><span class="line">                <span class="comment"># 之前有value /= self.factor()求值</span></span><br><span class="line">	    	node = BinOp(left=node, op=token, right=self.factor())</span><br><span class="line">        <span class="comment"># 之前是return value</span></span><br><span class="line">		<span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 之前是value = self.term()</span></span><br><span class="line">        node = self.term()</span><br><span class="line">		<span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">		    token = self.current_token</span><br><span class="line">	    	<span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">				self.eat(PLUS)</span><br><span class="line">                <span class="comment"># 之前有value += self.factor()求值</span></span><br><span class="line">	    	<span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">				self.eat(MINUS)</span><br><span class="line">                <span class="comment"># 之前有value -= self.factor()求值</span></span><br><span class="line">	    	node = BinOp(left=node, op=token, right=self.term())</span><br><span class="line">        <span class="comment"># 之前是return value</span></span><br><span class="line">		<span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.expr()</span><br></pre></td></tr></table></figure>
</li>
<li><p>总结一下就是，原本求值的地方，现在改为不断给<code>node</code>赋值，而<code>node</code>则层层嵌套，最终可以表达出AST。</p>
</li>
<li><p>以<code>7 + 3 * (10 - 1)</code>为例，看这份代码：</p>
<ol>
<li><code>parse</code>调用<code>expr()</code>，进入<code>expr</code>；</li>
<li><code>expr</code>调用<code>term</code>，<code>term</code>调用<code>factor</code>，发现是<code>INTEGER</code>，于是返回<code>Num(token(INTEGER,7))</code>作为<code>node</code>，<code>term</code>发现接下来不是乘除法，于是直接返回<code>node</code>，回到<code>expr</code>，该节点类型以下简写为<code>Num(7)</code>；</li>
<li><code>expr</code>发现接下来是加法，于是<code>node</code>变为<code>BinOp(left=Num(7), op=Token(PLUS, &#39;+&#39;), right=self.term())</code>，再次调用<code>term</code>；</li>
<li><code>term</code>调用<code>factor</code>得到<code>Num(3)</code>，接下来是乘法，于是这里要返回给第三步中<code>expr</code>的<code>right</code>的东西变成了<code>BinOp(left=Num(3), op=Token(MUL, &#39;*&#39;), right=self.factor())</code>，显然又要调用<code>factor</code>；</li>
<li><code>factor</code>判断接下来的左括号，于是调用<code>expr</code>处理，内容和上面的类似，会返回<code>BinOp(left=Num(10), op=Token(MINUS, &#39;-&#39;), right=Num(1))</code>给第四步的<code>right</code>；</li>
<li>以此类推，最终<code>parse</code>中得到的是<code>node=BinOp(left=Num(7), op=Token(PLUS, &#39;+&#39;), right=BinOp(left=Num(3), op=Token(MUL, &#39;*&#39;), BinOp(left=Num(10), op=Token(MINUS, &#39;-&#39;), right=Num(1))))</code>。</li>
</ol>
</li>
</ol>
<h4 id="遍历树求值"><a href="#遍历树求值" class="headerlink" title="遍历树求值"></a>遍历树求值</h4><ol>
<li><p>在得到AST之后，就要开始求值了，我们采用后序遍历的方法来遍历AST进行运算。</p>
<ol>
<li><p>前序遍历：<strong>根</strong>左右</p>
</li>
<li><p>中序遍历：左<strong>根</strong>右</p>
</li>
<li><p>后序遍历：左右<strong>根</strong></p>
</li>
<li><p>显然前中后是指根节点的遍历输出顺序，如下图的树，前序遍历的输出结果是：1-&gt;2-&gt;4-&gt;6-&gt;7-&gt;3-&gt;5，中序遍历是4-&gt;6-&gt;7-&gt;2-&gt;1-&gt;5-&gt;3，后序遍历是7-&gt;6-&gt;4-&gt;2-&gt;5-&gt;3-&gt;1</p>
<p><img src="https://github.com/kun-bin/image/blob/master/visit.png?raw=true" alt="一棵树"></p>
</li>
<li><p>对应到AST中，就是先访问<code>node</code>的<code>left</code>，得到一个结果，再访问<code>right</code>，得到另一个结果，最后访问中间的<code>op</code>，进行运算，伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="comment"># for every child node from left to right</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.children:</span><br><span class="line">		visit(child)</span><br><span class="line">    <span class="comment"># 指加减乘除等运算操作</span></span><br><span class="line">    &lt;&lt;postorder actions&gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>有时可能三种遍历都需要进行一些操作，因此伪代码改为：</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(node)</span>:</span></span><br><span class="line">    &lt;&lt; preorder actions &gt;&gt;</span><br><span class="line">    left_val = visit(node.left)</span><br><span class="line">    &lt;&lt; inorder actions &gt;&gt;</span><br><span class="line">    right_action = visit(node.right)</span><br><span class="line">    &lt;&lt; postorder actions &gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体来实现的时候首先要有<code>NodeVisitor</code>类：</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeVisitor</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        method_name = <span class="string">'visit_'</span> + type(node).__name__</span><br><span class="line">        visitor = getattr(self, method_name, self.generic_visit)</span><br><span class="line">        <span class="keyword">return</span> visitor(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generic_visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">		<span class="keyword">raise</span> Exception(<span class="string">'No visit_&#123;&#125; method'</span>.format(type(node).__name__))</span><br></pre></td></tr></table></figure>
<p>   <code>getattr(object, name, default)</code>函数的作用是，返回<code>object</code>这个变量的<code>name</code>属性，如果没有<code>name</code>则返回<code>default</code>，如果用这个函数的时候没有指明<code>default</code>，那么当<code>name</code>属性不存在时会报错。</p>
<p>   <code>f.__name__</code>的作用是返回<code>f</code>的函数名。</p>
<p>   在这段代码中，首先<code>method_name</code>是当前节点<code>node</code>对应<code>Token</code>的<code>type</code>，接下来返回该<code>NodeVisitor</code>对象的<code>method_name</code>属性，如果不存在则报错。具体来说，当<code>node</code>类型是<code>BinOp</code>时，会返回<code>visit_BinOp(node)</code>，而<code>node</code>类型是<code>Num</code>时，则返回<code>visit_Num(node)</code>。</p>
</li>
<li><p>接下来看我们的解释器<code>Interpreter</code>类，它继承了<code>NodeVisitor</code>：</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(NodeVisitor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parser)</span>:</span></span><br><span class="line">		self.parser = parser</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_BinOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node.op.type == PLUS:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) + self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == MINUS:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) - self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == MUL:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) * self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == DIV:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) / self.visit(node.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Num</span><span class="params">(self, node)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> node.value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">interpret</span><span class="params">(self)</span>:</span></span><br><span class="line">        tree = self.parser.parse()</span><br><span class="line">        <span class="keyword">return</span> self.visit(tree)</span><br></pre></td></tr></table></figure>
<p>   首先是解释器的初始化，我们将<code>parser</code>得到的AST传入<code>Interpreter</code>。</p>
<p>   接下来访问二元运算符节点的函数，该函数逻辑很简单，就是判定传入的<code>node</code>对应的<code>op</code>类型是什么，然后访问其左右节点，最后进行运算。</p>
<p>   最后是访问整数节点的函数，该函数负责将节点的<code>value</code>返回。</p>
<p>   这里要总结一下<code>node</code>这个变量，因为<code>python</code>里不需要指定变量类型，会动态决定，实际上这里的<code>node</code>有两个可能，当它是叶节点的时候，它是整数，也就是<code>Num(Token)</code>类型，在<code>visit</code>函数后会返回并执行<code>visit_Num</code>函数；而当它是中间节点和根节点时，就变成操作符，也就是<code>BinOp(left, op, right)</code>类型，在<code>visit</code>函数后会返回并执行<code>visit_BinOp</code>函数。</p>
</li>
<li><p>当调用解释器的<code>interpret</code>函数时，首先进入<code>visit</code>函数，判定是操作符，转入<code>visit_BinOp</code>函数，再判断运算类型，并访问左右节点直到得到一个返回值，最后进行运算得到结果。</p>
</li>
<li><p>总结一下，整个流程是：parser 从 lexer 中 得到 token 然后返回生成的 AST 给 interpreter 进行遍历并解释执行所给输入。</p>
</li>
</ol>
<h4 id="递归下降"><a href="#递归下降" class="headerlink" title="递归下降"></a>递归下降</h4><p>一个 <strong>递归下降parser</strong> 就 是一个自顶向下的 parser，它使用一组递归过程来处理输入。自顶向下反映了 parser 从 构建解析树的顶部结点开始逐渐构建更低的结点这一事实。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>写一个翻译器（提示：node visitor），它接收一个算术表达式作为输入并打印出它的后缀形式，即逆波兰式(Reverse Polish Notation, RPN)。例如，如果翻译器接收的输入是 表达式 <code>(5 + 3) * 12 / 3</code> 则输入应该是 <code>5 3 + 12 * 3 /</code> 。答案在<a href="https://github.com/rspivak/lsbasi/blob/master/part7/python/ex1.py" target="_blank" rel="noopener">这儿</a>，不过要先自己解决再看啊。</p>
<p>我的想法是：逆波兰式输出顺序实际上就是这一课遍历的顺序，因此只需要在现有的<code>visit_BinOp</code>和<code>visit_Num</code>加上<code>print</code>就行，注意这里因为是后序输出，<code>BinOP</code>需要先<code>visit(left)</code>和<code>visit(right)</code>，再<code>print(op.value)</code>，代码修改如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_BinOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> node.op.type == PLUS:</span><br><span class="line">        tmp = self.visit(node.left) + self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MINUS:</span><br><span class="line">        tmp = self.visit(node.left) - self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MUL:</span><br><span class="line">        tmp = self.visit(node.left) * self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == DIV:</span><br><span class="line">        tmp = self.visit(node.left) // self.visit(node.right)</span><br><span class="line">    print(node.op.value, end=<span class="string">' '</span>)</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Num</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    print(node.value, end=<span class="string">' '</span>)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br></pre></td></tr></table></figure>
</li>
<li><p>写一个翻译器（node visitor），它接收一个算术表达式作为输入并将它打印为 LISP 风 格的记法，即 <code>2 + 3</code> 变成 <code>(+ 2 3)</code> 及 <code>(2 + 3 * 5)</code> 变成 <code>(+ 2 (* 3 5))</code> 。你 可以在<a href="https://github.com/rspivak/lsbasi/blob/master/part7/python/ex2.py" target="_blank" rel="noopener">这儿</a>打到答案，但在查看之前还是要先尝试自己解决。</p>
<p>这是要前序遍历输出，也就是先输出<code>op.value</code>，再进行<code>visit(left)</code>和<code>visit(right)</code>，和练习1相比，就是把<code>visit_BinOp</code>中的<code>print(node.op.value, end=&#39; &#39;)</code>放到最前面。</p>
</li>
</ol>
<p>（这俩练习的答案和我想的还有点不太一样……不过问题不大……）</p>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Let-s-Build-A-Simple-Interpreter笔记-6</title>
    <url>/2020/03/12/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-6/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part6/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/02/01/lets-build-a-simple-interpreter-part-06/" target="_blank" rel="noopener">翻译</a></p>
<p><a href="https://www.oschina.net/translate/lsbasi-part6" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = (</span><br><span class="line">    <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'LPAREN'</span>, <span class="string">'RPAREN'</span>, <span class="string">'EOF'</span></span><br><span class="line">)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        self.type = type</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'Token(<span class="subst">&#123;self.type&#125;</span>, <span class="subst">&#123;repr(self.value)&#125;</span>)'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "4 + 2 * 3 - 6 / 2"</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Lexer error'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.text):</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        value = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            value += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'('</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(LPAREN, <span class="string">'('</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">')'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(RPAREN, <span class="string">')'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.error()</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Interpreter error'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""factor : INTEGER | LPAREN expr RPAREN"""</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == INTEGER:</span><br><span class="line">            self.eat(INTEGER)</span><br><span class="line">            <span class="keyword">return</span> token.value</span><br><span class="line">        <span class="keyword">elif</span> self.current_token.type == LPAREN:</span><br><span class="line">            self.eat(LPAREN)</span><br><span class="line">            value = self.expr()</span><br><span class="line">            self.eat(RPAREN)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">        value = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token_type = self.current_token.type</span><br><span class="line">            <span class="keyword">if</span> token_type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                value *= self.factor()</span><br><span class="line">            <span class="keyword">elif</span> token_type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                value /= self.factor()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        calc&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1))</span></span><br><span class="line"><span class="string">        22</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">        term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        value = self.term()</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token_type = self.current_token.type</span><br><span class="line">            <span class="keyword">if</span> token_type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                value += self.term()</span><br><span class="line">            <span class="keyword">elif</span> token_type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                value -= self.term()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.expr()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            print()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> len(text.strip()):</span><br><span class="line">            interpreter = Interpreter(Lexer(text))</span><br><span class="line">            print(interpreter.parse())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这一课在加减乘除的基础上加入了括号，而括号里的内容又可以看做是一个新的加减乘除表达式，即如下语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr   : term   ((PLUS | MINUS) term)*</span><br><span class="line">term   : factor ((MUL | DIV) factor)*</span><br><span class="line">factor : INTEGER | LPAREN expr RPAREN</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>expr</code>和<code>term</code>没有任何变化，而<code>factor</code>则多了一种可能：<code>(expr)</code>，因此需要作出以下修改：</p>
<ol>
<li><code>Lexer</code>部分添加左右括号的返回；</li>
<li><code>Interpreter</code>现在分成了两个分支，字符类型是<code>INTEGER</code>时，和之前的一样，返回该字符的<code>value</code>；字符类型是左括号时，则返回该括号里的<code>expr</code>的值，并把右括号也读过去。</li>
</ol>
<p>这样的递归语法，称之为递归下降解释器。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>如本文的描述，写一个你自己版本的算术表达式解释器。记住：重复是学习之母。</p>
<p>试着回顾一下整个代码的思路：</p>
<ol>
<li><p>代码除了<code>main()</code>以外，有3个<code>class</code>，分别是<code>Token</code>、<code>Lexer</code>、<code>Interpreter</code>。</p>
</li>
<li><p><code>Token</code>是最基础的词法单元，有两个成员变量：<code>type</code>和<code>value</code>，此外有初始化和输出的函数。</p>
</li>
<li><p><code>Lexer</code>是词法分析器，成员变量为：<code>text</code>（完整的语句）、<code>pos</code>（当前读取到语句位置的索引）、<code>current_char</code>（当前读取出的字符），成员函数为：<code>error</code>（报词法错误）、<code>advance</code>（往后读取一个新字符）、<code>skip_whitespace</code>（跳过空格）、<code>integer</code>（把连续的数字字符转成整数返回）、<code>get_next_token()</code>（返回当前词法单元）。</p>
</li>
<li><p><code>Interpreter</code>是语法解释器，成员变量为：<code>lexer</code>（词法分析器）、<code>current_token</code>（当前处理的词法单元），成员函数为：<code>error</code>（报语法错误）、<code>eat()</code>（往后处理下一个词法单元）、<code>factor</code>、<code>term</code>、<code>expr</code>三个都是语法图里的内容，最后加了一个<code>parse</code>返回<code>expr()</code>。</p>
</li>
</ol>
<p>大致就是这样了。</p>
</li>
</ol>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><p>这一课没有这一部分。</p>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-3</title>
    <url>/2020/03/11/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-3/</url>
    <content><![CDATA[<h3 id="知识点记录"><a href="#知识点记录" class="headerlink" title="知识点记录"></a>知识点记录</h3><p>这次上课有一些是以前不太了解的知识点。</p>
<a id="more"></a>
<h5 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h5><p>包括字符串、列表、元组、字节序列。</p>
<ol>
<li><p>索引访问：</p>
<p>有<code>n</code>个元素的数组，索引范围是<code>[0, n-1]</code>或<code>[-n, -1]</code>，也就是说，除了常规的类似其他语言中数组的下标索引方式，我们还可以通过<code>-1</code>来逆序访问。这在某些时候是很方便的一个操作，比如判断回文字符串。</p>
</li>
<li><p>遍历访问：</p>
<p>遍历也是用<code>for</code>循环，不过和其他语言不同的是，这里<code>for</code>循环中的<code>i</code>类型很随意，可以是<code>1, 2, 3, ...</code>也可以是元组、字符等，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'hello'</span>:</span><br><span class="line">	print(c)</span><br></pre></td></tr></table></figure>
<p>这里的<code>c</code>是字符，最终会把<code>h</code>, <code>e</code>, <code>l</code>, <code>l</code>, <code>o</code> 逐行输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">6</span>)]</span><br><span class="line">	print(t,t[<span class="number">0</span>],t[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>这里的<code>t</code>是元组，最终输出是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>,<span class="number">2</span>) <span class="number">1</span> <span class="number">2</span></span><br><span class="line">(<span class="number">3</span>,<span class="number">4</span>) <span class="number">3</span> <span class="number">4</span></span><br><span class="line">(<span class="number">5</span>,<span class="number">6</span>) <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>切片</p>
<p>序列<code>s</code>可以通过<code>s[i:j:k]</code>来截取其中的一部分，<code>i</code>是起点，<code>j</code>是终点，<code>k</code>是步长，注意这里的起点终点都可以是负数，结合上文可知，<code>s[::-1]</code>实际上就是序列的逆序。注意这个切片并不会改变序列<code>s</code>。想要将切片的下标信息保存下来，我们可以使用<code>slice(i:j:k)</code>函数。这里如果越界了也不会报错。</p>
</li>
<li><p>连接和重复</p>
<p>连接<code>+</code>：<code>s1+s2</code></p>
<p>重复<code>*</code>：<code>s*n</code> 或者 <code>n*s</code></p>
<p>增量赋值：<code>+=</code>和<code>*=</code></p>
<p>元组不可以<code>+=</code>序列，但是反过来序列<code>+=</code>元组是没问题的。</p>
</li>
<li><p>成员关系操作</p>
<p><code>in</code>和<code>not in</code>可以判断一个元素是否在序列中。</p>
<p><code>s.count(value)</code>可以统计<code>value</code>在序列<code>s</code>中出现的次数。</p>
<p><code>s.index(value, [start, [stop]])</code>查找value在序列指定范围 <code>[start,stop)</code>中第一次出现的下标。</p>
</li>
<li><p>序列内置函数</p>
<p><code>len</code> 单纯求序列长度</p>
<p><code>sorted</code>对序列排序并返回排序后的列表，不改变原始序列</p>
<p><code>reversed</code>逆序，不改动原序列，返回反向迭代器</p>
<p><code>max</code>和<code>min</code>求最大值和最小值，要求元素类型都一样</p>
<p><code>sum</code>序列求和，要求不能有非数字</p>
<p><code>enumerate</code>返回元素为<code>元组(计数，元素)</code> 的迭代器</p>
<p><code>zip</code>拼接多个对象<code>iter1、iter2…</code>的元素， 返回一个迭代器，其元素为各对象元素组成的元组。</p>
<p><code>all</code>和<code>any</code>判断序列的元素是否全部和部分为True</p>
</li>
<li><p>序列类型转换</p>
<p><code>str</code> <code>list</code> <code>tuple</code> <code>bytes</code> <code>bytearray</code>可以从字面意义看出是转成什么类型。</p>
</li>
<li><p>的</p>
</li>
<li><p>序列拆分</p>
<p><code>变量1,变量2,…,变量n = 序列</code>这样的赋值语句，可以把序列中的元素拆开赋值给前面的变量，不过类型要统一，比如序列中有元组，那前面对应位置的变量也要写成元组的形式。</p>
<p><code>*变量</code>的形式，可以把多个元素打包赋值给一个变量，但是只能出现一次。</p>
<p>可以用临时变量<code>_</code>来占位从而将指定位置的元素赋值给某个变量，例如<code>_, b, _ = (1, 2, 3)</code>就是把<code>2</code>赋值给<code>b</code>。</p>
</li>
</ol>
<h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><ol>
<li><p><code>del</code>删除元素，赋值修改元素</p>
</li>
<li><p><code>s.append(x)</code> 把<code>x</code>追加到<code>s</code>末尾</p>
</li>
<li><p><code>s.clear()</code> 删除所有元素</p>
</li>
<li><p><code>s.copy()</code> 复制</p>
</li>
<li><p><code>s.extend(t)</code> 和上面的<code>s.append(x)</code>是一样的，区别在于，<code>append</code>把<code>x</code>作为一个整体加到末尾，而<code>extend</code>把<code>x</code>作为一个新的列表合并到<code>s</code>的末尾。</p>
</li>
<li><p><code>s.insert(i,x)</code>插入</p>
</li>
<li><p><code>s.pop([i])</code>返回并移除下标为<code>i</code>的元素，<code>i</code>省略时默认为最后一个元素</p>
</li>
<li><p><code>s.remove(x)</code>移除列表中第一次出现的<code>x</code></p>
</li>
<li><p><code>s.reverse()</code>列表反转</p>
</li>
<li><p><code>s.sort()</code>列表排序</p>
</li>
<li><p>列表解析表达式：处理可迭代对象并生成结果列表，具体格式为<code>[express for i_1 in 可迭代对象1…for i_N in 可迭代对象N [if condition] ]</code></p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">[i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line">[(x+y,x*y) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表解析生成字典和集合</span></span><br><span class="line">a = [(<span class="string">'小黑'</span>,<span class="string">'领导'</span>,<span class="number">30000</span>),(<span class="string">'小白'</span>,<span class="string">'职员'</span>,<span class="number">10000</span>),(<span class="string">'小蓝'</span>,<span class="string">'职员'</span>,<span class="number">5000</span>)]</span><br><span class="line">&#123;i[<span class="number">0</span>]:i[<span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> a&#125;</span><br><span class="line"><span class="comment"># output: &#123;'小黑': 30000, '小白': 10000, '小蓝': 5000&#125;</span></span><br><span class="line">&#123;i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i[<span class="number">2</span>]&gt;=<span class="number">10000</span>&#125;</span><br><span class="line"><span class="comment"># output: &#123;'小白', '小黑'&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><ol>
<li><p>已知一选手的各评委得分<code>score = [95, 85, 89, 88, 86, 95, 89, 98, 85, 75, 80]</code>，运用序列的各项操作求该选手的得分，计算规则：去掉一个最高分和一个最低分，剩下的分数计算平均分。</p>
<p>最直接的思路就是整体求和然后减去最大的和最小的再算平均值，也就是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = [<span class="number">95</span>, <span class="number">85</span>, <span class="number">89</span>, <span class="number">88</span>, <span class="number">86</span>, <span class="number">95</span>, <span class="number">89</span>, <span class="number">98</span>, <span class="number">85</span>, <span class="number">75</span>, <span class="number">80</span>]</span><br><span class="line">s = (sum(score) - max(score) - min(score)) / (len(score) - <span class="number">2</span>)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断一个字符串是否是回文串：<code>a = &#39;abcdcba&#39;  b = &#39;abcdefg&#39;</code></p>
<p>这个题有很多思路，最快的办法就是用前面提到的<code>s[::-1]</code>来实现逆序，即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindromic4</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> num == num[::<span class="number">-1</span>]</span><br><span class="line">a = <span class="string">'abcdcba'</span></span><br><span class="line">b = <span class="string">'abcdefg'</span></span><br><span class="line">print(is_palindromic4(b))</span><br></pre></td></tr></table></figure>
<p>也可以选择把字符串转成<code>list</code>或者<code>tuple</code>然后使用<code>reverse</code>函数来实现逆序。即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list(a)==list(reverse(a))</span><br><span class="line">tuple(a)==tuple(reverse(a))</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码执行后的<code>s</code>是（）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = [<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line">s.append([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">s.extend(<span class="string">'34'</span>)</span><br><span class="line">s.extend([<span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">s.insert(<span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line">s.insert(<span class="number">10</span>, <span class="number">8</span>)</span><br><span class="line">s.pop(<span class="number">2</span>)</span><br><span class="line">s.remove(<span class="string">'a'</span>)</span><br><span class="line">s[<span class="number">4</span>:] = []</span><br><span class="line">s.reverse()</span><br></pre></td></tr></table></figure>
<p>对照每个函数的作用可以很容易判断出最后的结果是<code>[&#39;4&#39;,&#39;3&#39;,[1,2],7]</code></p>
</li>
</ol>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol>
<li><p>使用<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>,<code>**</code>运算符和数字<code>2</code>,<code>3</code>,<code>4</code>,<code>5</code>，构造一个表达式，该表达式中上述4个数字和3种不同运算符各用一次，使得表达式的结果为24，打印出满足条件的表达式。</p>
<p>提示：</p>
<p>(1)构建表达式字符串，然后用内置函数<code>eval</code>计算该字符串 ，例如<code>eval(&#39;3*4/2+5&#39;)</code>返回<code>11.0</code>； </p>
<p>(2)两字符串可通过”+”连接成一个字符串，如<code>’he’+’llo’</code>会 得到<code>’hello’</code>； </p>
<p>(3)本题关键在于求排列，排列有多种实现方式，例如循环。</p>
<p>根据提示很容易想到一个思路：把数字的全排列和运算符的取3个排列分别列出来，然后逐一组合成字符串，使用<code>eval</code>计算结果，如果是24，就输出。查找资料后发现<code>python</code>有一个算排列的库函数<code>itertools.permutations(s, n)</code>，该函数返回列表<code>s</code>中取<code>n</code>个元素的排列结果，该结果也是一个列表，也就是说我们可以通过该函数得到数字和运算符的排列结果，并<code>for</code>循环遍历，将它们组成计算表达式并求结果，然后输出。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">op = [<span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'*'</span>, <span class="string">'/'</span>, <span class="string">'**'</span>]</span><br><span class="line">num = [<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.permutations(num, <span class="number">4</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> itertools.permutations(op, <span class="number">3</span>):</span><br><span class="line">        s = i[<span class="number">0</span>] + j[<span class="number">0</span>] + i[<span class="number">1</span>] + j[<span class="number">1</span>] + i[<span class="number">2</span>] + j[<span class="number">2</span>] + i[<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> float(eval(s)) == <span class="number">24.0</span>:</span><br><span class="line">            print(s)</span><br></pre></td></tr></table></figure>
<p>此外，<code>python</code>中完成24点游戏的思路还有很多很多，复杂一些的办法可以是构造二叉树，然后遍历节点。</p>
</li>
<li><p>输入一个列表，然后删除该列表中的重复的元素，要求删除重复元素后还保持原排序，最后输出结果。例如，输入列表 <code>[0, 1, 1, 1, 3, 0, 3, 2]</code>，输出 <code>[0, 1, 3, 2]</code>。</p>
<p>这个题也有很多思路，比如逐个比较等。有一种很便捷的方法是，对输入列表生成字典，这样就按顺序去掉了重复元素，再将字典的<code>key</code>转成列表即可，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = eval(input(<span class="string">'请输入一个列表：'</span>))</span><br><span class="line">list2 = dict.fromkeys(list1)</span><br><span class="line">list3 = list(list2.keys())</span><br><span class="line">print(list3)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Let-s-Build-A-Simple-Interpreter笔记-5</title>
    <url>/2020/03/09/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-5/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part5/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/30/lets-build-a-simple-interpreter-part-05/" target="_blank" rel="noopener">翻译</a></p>
<p><a href="https://www.oschina.net/translate/lsbasi-part5" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, MUL, DIV, EOF = (</span><br><span class="line">    <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'EOF'</span></span><br><span class="line">)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, PLUS, MINUS, MUL, DIV, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '+', '-', '*', '/', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'Token(<span class="subst">&#123;self.type&#125;</span>, <span class="subst">&#123;repr(self.value)&#125;</span>)'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 * 5", "12 / 3 * 4", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Lexer error'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.text):</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        value = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            value += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.error()</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Interpreter error'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""factor : INTEGER"""</span></span><br><span class="line">        value = self.current_token.value</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">        value = self.factor()</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            <span class="keyword">if</span> self.current_token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                value *= self.factor()</span><br><span class="line">            <span class="keyword">elif</span> self.current_token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                value /= self.factor()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        calc&gt;  14 + 2 * 3 - 6 / 2</span></span><br><span class="line"><span class="string">        17</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">        term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        value = self.term()</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            <span class="keyword">if</span> self.current_token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                value += self.term()</span><br><span class="line">            <span class="keyword">elif</span> self.current_token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                value -= self.term()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.expr()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            print()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(text.strip()):</span><br><span class="line">            interpreter = Interpreter(Lexer(text))</span><br><span class="line">            result = interpreter.parse()</span><br><span class="line">            print(result)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这一课讲的是运算结合性和优先级的处理。</p>
<h4 id="什么是结合性"><a href="#什么是结合性" class="headerlink" title="什么是结合性"></a>什么是结合性</h4><p>当一个操作数（比如 7+3+1 中的 3）两边都有加号时，我们需要一个规则来决定哪个运算符作用于 3，根据经验，是左边的加号起作用（也就是先计算7+3），因此我们把加号看做是左结合的。类似地，减、乘、除也都是左结合的。</p>
<h4 id="什么是优先级"><a href="#什么是优先级" class="headerlink" title="什么是优先级"></a>什么是优先级</h4><p>当一个操作数（比如 7 + 5 <em> 2 中的5）两边有不同的运算符时，先进行运算的那个运算符优先级较高，比如我们说运算符\</em>比+先取运算符，*就有较高的优先级。</p>
<p>在一个表达式中有相同优先级的运算符出现时，我们就使用结合性惯例从左到右执行。</p>
<h4 id="构建语法和写解释器"><a href="#构建语法和写解释器" class="headerlink" title="构建语法和写解释器"></a>构建语法和写解释器</h4><p>以算术表达式为例，优先级列表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>优先级</th>
<th>结合性</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>左结合</td>
<td>+, -</td>
</tr>
<tr>
<td>1</td>
<td>左结合</td>
<td>*, /</td>
</tr>
</tbody>
</table>
</div>
<p>从优先级表构建语法：</p>
<ol>
<li>对于每一个优先级定义一个非终结符。这个非终结符的生成式的 body 应该由本优先级的算术运算符和更高优先级的非终结符组成。</li>
<li>对表达式的基本单元(在我们的例子中是 INTEGER)新建一个额外的非终结符 <code>factor</code>. 一般原则就是如果你有 N 级优先级，你一共会需要 N+1 非终结符：每个优先级一个再 加上基本单元的一个。</li>
</ol>
<p>具体来说我们现在有2个优先级，因此会有3个非终结符，优先级为2的对应<code>expr</code>，优先级为1的对应<code>term</code>，最后是<code>factor</code>。</p>
<p><code>expr</code>要表达包含<code>term</code>的加减运算，即：<code>expr: term((PLUS|MINUS)term)*</code></p>
<p><code>term</code>则是包含<code>factor</code>的乘除运算，即：<code>term； factor((MUL|DIV)factor)*</code></p>
<p>最后<code>factor</code>是基本单元，即：<code>factor: INTEGER</code></p>
<p>然后就是和上一课一样的步骤写代码了。</p>
<p>（总的来说这一课没有什么新知识，但是我还是不能不看教程自己写…）</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>根据本文的描述凭记忆写出一个解释器，不要参考文中的代码。为你的解释器写一些测试，确保它们可以通过。</p>
<p>我太菜了所以并没法凭记忆写一个解释器，于是我开始照着代码抄一下，并很快发现就算是照抄我也会出错…</p>
<p>主要错误如下：</p>
<ol>
<li><code>else</code>后面忘了加<code>:</code>；</li>
<li>某个地方的赋值(<code>=</code>)一个不注意就写成了相等(<code>==</code>)；</li>
<li><code>while self.current_char is not None and self.current_char.isdigit():</code>以及前面判断空格的那个类似的语句，<code>is not None</code>一定要放前面，如果反过来，在当前字符是空的时候，执行<code>isdigit()</code>和<code>isspace()</code>就会报错了，所以要先判定不为空。</li>
</ol>
<p>我好菜啊.jpg</p>
</li>
<li><p>扩展这个解释器来处理包含括号的算术表达式，使得你的解释器可以对嵌套很深很深的算术表达式进行求值如：7 + 3 * (10 / (12 / (3 + 1) - 1))</p>
<p>这个我的想法是要设定一下括号的结合性，左括号是右结合而右括号是左结合，但是不会写。</p>
<p>看了下一课发现是要写递归语法分析，所以放下一课来写吧。</p>
</li>
</ol>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>一个操作符是左结合的是什么意思？</p>
<p>是指当数字左右两边都有该运算符时，数字取左边的运算符。</p>
</li>
<li><p>操作符加减是左结合的还是右结合的？乘除呢？</p>
<p>都是左结合。</p>
</li>
<li><p>操作符加是否比操作符乘有更高的优先级？</p>
<p>否，乘的优先级更高。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-2</title>
    <url>/2020/03/04/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-2/</url>
    <content><![CDATA[<ol>
<li><p>下面程序的运行结果是（    ）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">		<span class="keyword">if</span> i == j == <span class="number">1</span>；</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			print(i, <span class="string">'----'</span>, j)</span><br></pre></td></tr></table></figure>
<p>A.    0 —— 0                B.    0 —— 0<br>​        0 —— 1                       0 —— 1<br>​        0 —— 2                       0 —— 2<br>​        1 —— 0                       1 —— 0<br>​        2 —— 0<br>​        2 —— 1<br>​        2 —— 2</p>
</li>
</ol>
<a id="more"></a>
<p>答案：A（我怀疑这题的选项对齐在网页上显示会出问题，不过懒得改了）</p>
<p><code>break</code>的中断只会断一层，也就是说这个代码在<code>i=j=1</code>的时候，属于<code>j</code>的循环会中断，<code>j=2</code>和<code>j=3</code>将跳过，直接开始<code>i=2, j=0</code>然后继续循环，也就是A选项。</p>
<ol>
<li><p>下面程序的运行结果是（    ）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">		<span class="keyword">if</span> i == j == <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			print(i, <span class="string">'----'</span>, j)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>A.    0 —— 0                B.    0 —— 0<br>​        0 —— 1                       0 —— 1<br>​        0 —— 2                       0 —— 2<br>​        1 —— 0                       1 —— 0<br>​        2 —— 0<br>​        2 —— 1<br>​        2 —— 2</p>
</li>
</ol>
<p>答案：B</p>
<p>这里首先要学习的是<code>python</code>与其他语言中不太一样的<code>else</code>用法，在其他语言中，<code>else</code>只搭配<code>if</code>来做条件判断，而<code>python</code>中有<code>for... else...</code>、<code>while...else...</code>和<code>try...else...</code>的用法，具体来说，在<code>for</code>循环中如果有并触发了<code>break</code>，则<code>for</code>循环后的<code>else</code>语句不会被执行，如果没触发或者没有，则会执行<code>else</code>分支的语句；在<code>while</code>循环中，也是如此，<code>break</code>不执行或不存在的时候，就会执行<code>else</code>语句，而如果执行了<code>break</code>就不会执行<code>else</code>；<code>try</code>中的用法则是当<code>try</code>块中的语句正常执行完毕就会执行<code>else</code>分支。</p>
<p>其次，<code>continue</code>在循环中是用来跳过这次循环并开始下一次循环，比如在<code>j=1</code>的时候<code>continue</code>，则<code>j=1</code>中剩下的语句不执行，但是会开始执行<code>j=2</code>，而不是像<code>break</code>那样跳出<code>j</code>的循环去执行<code>i</code>的循环。</p>
<p>分析这个代码，这个<code>else</code>分支是<code>j</code>的循环对应的，也就是说<code>i=0,j=x</code>时，没触发<code>break</code>，每次都会执行<code>else</code>中的<code>continue</code>，也就是说此时最后一行的打断<code>i</code>的循环的<code>break</code>不会执行；在<code>i=j=1</code>的时候<code>j</code>的循环<code>break</code>了，那么<code>else</code>分支不会执行，就会执行到最后一行的<code>break</code>，从而打断<code>i</code>的循环，程序直接结束，也就是B选项。</p>
<p>课后作业：</p>
<ol>
<li>利用random库，随机出100道两个数的加、减口算题。要求 ： (1)a+b或者a-b，a、b和得数范围均为[0,100]；(2)如果是加法运算，要求有进位；如果是减法运算，要求有退位；(3)在屏幕上打印出结果，每一行显示4道题，注意对齐。示例如下。（示例就不放了总之就是100个加减法运算题，加法有进位减法有借位，输出是格式化的）</li>
</ol>
<p>这个本来是不难的，随机生成两个100以内的数字然后随机决定加减法就行，但是还必须有进位和退位。</p>
<p>一开始的思路是，先随机生成第一个数字<code>a</code>，然后再随机生成<code>0</code>和<code>1</code>来决定加减法，接下来如果是加法，就生成一个在<code>a</code>到<code>100-a</code>之间的数字<code>b</code>，如果是减法，就生成一个在<code>1</code>到<code>a</code>之间的数字<code>b</code>，这两个分支中，如果<code>b</code>不符合进位或者退位，就重新生成，也就是一个<code>while</code>循环。</p>
<p>按这个思路写好运行以后就发现了问题，那个<code>while</code>循环有时候会一直循环下去就是找不到符合进位或退位的数字<code>b</code>，这是因为一开始的数字<code>a</code>如果不合适，那什么数字也没法实现进位或者退位，比如加法中，个位数如果是<code>0</code>，这个数字还不是<code>90</code>，则无论如何也不会遇到进位；而减法中，这个数字如果个位是<code>9</code>，题目又要求不会出现负数的减法，那无论如何都不可能有借位运算。也就是说，先决定加减法，再生成一个恰当的数字<code>a</code>，它要符合一些条件，接着生成一个恰当的数字<code>b</code>，也要符合一些条件。</p>
<p>具体来说，数字<code>a</code>要符合：</p>
<pre><code>    1. 如果是加法，则个位数不是0，或这个数不是90，且范围在1到90之间；
     2. 如果是减法，则个位数不是9，且范围在10到100之间。
</code></pre><p>数字<code>b</code>要符合：</p>
<pre><code>    1. 如果是加法，则小于`100-a`，且个位数之和大于10，或十位数之和大于10；
    2. 如果是减法，则小于`a`，且个位数比`a`的个位数大，或十位数比`a`的十位数大。
</code></pre><p>最后就是格式化输出，然后就结束了，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">    bool = random.randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> bool == <span class="number">0</span>:</span><br><span class="line">        a = random.randint(<span class="number">1</span>, <span class="number">90</span>)</span><br><span class="line">        <span class="keyword">while</span> a != <span class="number">90</span> <span class="keyword">and</span> a % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            a = random.randint(<span class="number">1</span>, <span class="number">90</span>)</span><br><span class="line">        b = random.randint(<span class="number">1</span>, <span class="number">100</span> - a)</span><br><span class="line">        <span class="keyword">while</span> ((a % <span class="number">10</span> + b % <span class="number">10</span>) &lt; <span class="number">10</span>) <span class="keyword">and</span> ((a // <span class="number">10</span> + b // <span class="number">10</span>) &lt; <span class="number">10</span>):</span><br><span class="line">            b = random.randint(<span class="number">1</span>, <span class="number">100</span> - a)</span><br><span class="line">        print(<span class="string">'&#123;:&lt;2&#125; + &#123;:&lt;2&#125;='</span>.format(a, b), end=<span class="string">"\t\t"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a = random.randint(<span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">while</span> a % <span class="number">10</span> == <span class="number">9</span>:</span><br><span class="line">            a = random.randint(<span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line">        b = random.randint(<span class="number">1</span>, a)</span><br><span class="line">        <span class="keyword">while</span> ((b % <span class="number">10</span>) &lt;= (a % <span class="number">10</span>)) <span class="keyword">and</span> ((b % <span class="number">100</span>) &lt;= (a % <span class="number">100</span>)):</span><br><span class="line">            b = random.randint(<span class="number">1</span>, a)</span><br><span class="line">        print(<span class="string">'&#123;:&lt;2&#125; - &#123;:&lt;2&#125;='</span>.format(a, b), end=<span class="string">"\t\t"</span>)</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">4</span> == <span class="number">3</span>:</span><br><span class="line">        print(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<p>补充一下关于<code>print</code>格式化输出的内容：</p>
<p><code>python</code>中的<code>print</code>函数有一个<code>end</code>参数，当直接<code>print</code>而没有<code>end</code>时，默认换行；当<code>end=&quot;&quot;</code>时，就不自动换行了；当<code>end=XXX</code>时，在<code>print</code>后，会接着有<code>XXX</code>，比如上面代码的<code>\t\t</code>，也不自动换行。</p>
<p>在<code>C</code>语言中，可以通过<code>prints(&quot;%d, %d&quot;, a, b)</code>来实现输出<code>a, b</code>，并通过<code>%x.yd</code>（比如<code>%5.3d</code>)来控制输出长度和精度，而<code>python</code>中有类似的用法，即<code>str.format()</code>，其基本语法是通过<code>{}</code>和<code>:</code>来代替<code>%</code>。<code>&#39;{:&lt;2} - {:&lt;2}=&#39;.format(a, b)</code>这样的语句含义是：把<code>a</code>和<code>b</code>按默认顺序填入前面的花括号，并把长度控制为2个字符且左对齐。</p>
<p><code>format()</code>的用法很多。</p>
<p>可以接受不限个数和顺序的参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">"&#123;&#125; &#123;&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)    <span class="comment"># 不设置指定位置，按默认顺序</span></span><br><span class="line"><span class="string">'hello world'</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;0&#125; &#123;1&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">'hello world'</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;1&#125; &#123;0&#125; &#123;1&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">'world hello world'</span></span><br></pre></td></tr></table></figure>
<p>可以指明参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"网站名：&#123;name&#125;, 地址 &#123;url&#125;"</span>.format(name=<span class="string">"菜鸟教程"</span>, url=<span class="string">"www.runoob.com"</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过字典设置参数</span></span><br><span class="line">site = &#123;<span class="string">"name"</span>: <span class="string">"菜鸟教程"</span>, <span class="string">"url"</span>: <span class="string">"www.runoob.com"</span>&#125;</span><br><span class="line">print(<span class="string">"网站名：&#123;name&#125;, 地址 &#123;url&#125;"</span>.format(**site))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过列表索引设置参数</span></span><br><span class="line">my_list = [<span class="string">'菜鸟教程'</span>, <span class="string">'www.runoob.com'</span>]</span><br><span class="line">print(<span class="string">"网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;"</span>.format(my_list))  <span class="comment"># "0" 是必须的</span></span><br></pre></td></tr></table></figure>
<p>可以向<code>format</code>传入对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssignValue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">my_value = AssignValue(<span class="number">6</span>)</span><br><span class="line">print(<span class="string">'value 为: &#123;0.value&#125;'</span>.format(my_value))  <span class="comment"># "0" 是可选的</span></span><br></pre></td></tr></table></figure>
<p>数字格式化输出的完整形式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数字</th>
<th>格式</th>
<th>输出</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.1415926</td>
<td>{:.2f}</td>
<td>3.14</td>
<td>保留小数点后两位</td>
</tr>
<tr>
<td>3.1415926</td>
<td>{:+.2f}</td>
<td>+3.14</td>
<td>带符号保留小数点后两位</td>
</tr>
<tr>
<td>-1</td>
<td>{:+.2f}</td>
<td>-1.00</td>
<td>带符号保留小数点后两位</td>
</tr>
<tr>
<td>2.71828</td>
<td>{:.0f}</td>
<td>3</td>
<td>不带小数</td>
</tr>
<tr>
<td>5</td>
<td>{:0&gt;2d}</td>
<td>05</td>
<td>数字补零 (填充左边, 宽度为2)</td>
</tr>
<tr>
<td>5</td>
<td>{:x&lt;4d}</td>
<td>5xxx</td>
<td>数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td>10</td>
<td>{:x&lt;4d}</td>
<td>10xx</td>
<td>数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td>1000000</td>
<td>{:,}</td>
<td>1,000,000</td>
<td>以逗号分隔的数字格式</td>
</tr>
<tr>
<td>0.25</td>
<td>{:.2%}</td>
<td>25.00%</td>
<td>百分比格式</td>
</tr>
<tr>
<td>1000000000</td>
<td>{:.2e}</td>
<td>1.00e+09</td>
<td>指数记法</td>
</tr>
<tr>
<td>13</td>
<td>{:&gt;10d}</td>
<td>13</td>
<td>右对齐 (默认, 宽度为10)</td>
</tr>
<tr>
<td>13</td>
<td>{:&lt;10d}</td>
<td>13</td>
<td>左对齐 (宽度为10)</td>
</tr>
<tr>
<td>13</td>
<td>{:^10d}</td>
<td>13</td>
<td>中间对齐 (宽度为10)</td>
</tr>
</tbody>
</table>
</div>
<p><code>^</code>,<code>&lt;</code>, <code>&gt;</code> 分别是居中、左对齐、右对齐，后面带宽度， <code>:</code> 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。<code>+</code> 表示在正数前显示 <code>+</code>，负数前显示 <code>-</code>； （空格）表示在正数前加空格。</p>
<p>此外，还可以转进制输出，<code>b</code>、<code>d</code>、<code>o</code>、<code>x</code> 分别是二进制、十进制、八进制、十六进制。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">'&#123;:b&#125;'.format(11) --&gt; 1011</span><br><span class="line">'&#123;:d&#125;'.format(11) --&gt; 11</span><br><span class="line">'&#123;:o&#125;'.format(11) --&gt; 13</span><br><span class="line">'&#123;:x&#125;'.format(11) --&gt; b</span><br><span class="line">'&#123;:#x&#125;'.format(11) --&gt; 0xb</span><br><span class="line">'&#123;:#X&#125;'.format(11) --&gt; 0XB</span><br></pre></td></tr></table></figure>
<ol>
<li>编写程序，求解所有由两个四位数组成的亲和数。（如果两个正整数a和b满足：a的所有真因数（除本身以外的因数）之和等于b，同时b的所有真因数之和等于a，则称a，b是一对亲和数 。）</li>
</ol>
<p>思路是先写一个算真因数之和的函数，接着写两层循环，第一层<code>a</code>是1000到9999，第二层<code>b</code>是1000到<code>a</code>，然后调用函数判断<code>a</code>和<code>b</code>的真因数之和是否符合条件。一个整数<code>n</code>的真因数之和是很好计算的，只需要遍历1到<code>n//2+1</code>看是否整除<code>n</code>，然后把整除的累加一下，就可以了。</p>
<p>但是实际运行的时候，发现这样搞真的很慢，要等好久才会出结果，这是因为两层<code>for</code>循环，每次都要算两个真因数的和，而这也是一层循环，再加上<code>python</code>本身就效率很低，速度就格外慢了，因此最好的办法是能去掉一层循环，或者有什么库可以飞快地计算真因数之和。</p>
<p>然后在查资料的过程中，看到了另一种亲和数的定义：先求出数字<code>n</code>所有真因数之和<code>a</code>，然后再求出数字<code>a</code>所有真因数之和<code>b</code>。如果<code>a!= b</code> 且<code>n==b</code>，则<code>a</code>、<code>b</code>、<code>n</code>都是亲和数。</p>
<p>也就是说，可以只写一层循环<code>a</code>，计算<code>a</code>的真因数之和<code>b</code>，再计算<code>b</code>的真因数之和<code>sum_b</code>，如果<code>a=sum_b</code>，则符合条件输出一下，反之就直接继续下一次循环，算真因数之和的部分没有变化。这样循环少了一层，运算速度快了好多。</p>
<p>此外，看到一个不是用取余，而是用除法和整除结果来判断是否是因数的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d</span><span class="params">(n)</span>:</span>  <span class="comment">#计算数字n所有真因数之和</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n/i == float(n//i):</span><br><span class="line">            res += i</span><br><span class="line">    <span class="keyword">return</span>(res)</span><br></pre></td></tr></table></figure>
<p>猜测<code>python</code>中的除法、整除、取余可能有运算时间的差别，不过应该不大。</p>
<p>最后代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算一个数的真因数和</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_factor</span><span class="params">(n)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            sum += i</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">1000</span>, <span class="number">9999</span>):</span><br><span class="line">    b = sum_of_factor(a)</span><br><span class="line">    <span class="keyword">if</span> b &lt;= a:</span><br><span class="line">        sum_b = sum_of_factor(b)</span><br><span class="line">        <span class="keyword">if</span> sum_b == a:</span><br><span class="line">            print(a, b)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s Build A Simple Interpreter笔记[4]</title>
    <url>/2020/02/28/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-4/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part4/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/28/lets-build-a-simple-interpreter-part-04/" target="_blank" rel="noopener">翻译</a></p>
<p>(这个翻译里有个别地方翻译错了……)</p>
<p><a href="https://www.oschina.net/translate/lsbasi-part4" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, MUL, DIV, EOF = <span class="string">'INTEGER'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'EOF'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, MUL, DIV, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '*', '/', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 * 5", "12 / 3 * 4", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid character'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line">            self.error()</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return an INTEGER token value.</span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> token.value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string">        expr   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = self.factor()</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                result = result * self.factor()</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                result = result // self.factor()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        lexer = Lexer(text)</span><br><span class="line">        interpreter = Interpreter(lexer)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h4 id="正则表达"><a href="#正则表达" class="headerlink" title="正则表达"></a>正则表达</h4><p>虽然课程内容里没有过多涉及这部分，但还是复习一下。从<a href="https://www.runoob.com/regexp/regexp-syntax.html" target="_blank" rel="noopener">这里</a>复制的</p>
<h5 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h5><p>指不会显示在文本中的字符，主要用于控制文本显示格式，例如换行、分页等。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\cx</td>
<td>匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><p>指正则匹配规则中比较特殊的一些标记。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>$</td>
<td>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。</td>
</tr>
<tr>
<td>( )</td>
<td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符 \n 之外的任何单字符。</td>
</tr>
<tr>
<td>[</td>
<td>标记一个中括号表达式的开始。</td>
</tr>
<tr>
<td>\</td>
<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。</td>
</tr>
<tr>
<td>{</td>
<td>标记限定符表达式的开始。</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>指明两项之间的一个选择。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h5><p>指限定表达式匹配次数的符号。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配前面的子表达式任意次，可以是零次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody>
</table>
</div>
<p>例如：<code>/[1-9][0-9]*/</code>是指第一位是1-9的某个数字，后面有任意多个0-9的数字，也就是正整数。</p>
<h4 id="上下文无关语法-BNF"><a href="#上下文无关语法-BNF" class="headerlink" title="上下文无关语法/BNF"></a>上下文无关语法/BNF</h4><ol>
<li><p>由一系列规则组成，被称为产生式；</p>
</li>
<li><p>一条规则由一个非终结符(叫做 <strong>head</strong> 或 生成式的 <strong>左边</strong>)，一个分号，和一系列终结 符和/或非终结符(叫做 <strong>body</strong> 或 <strong>右边</strong>)组成；</p>
</li>
<li><p>第一条规则左边的非终结符被叫做 <strong>开始符号</strong>；</p>
</li>
<li><p>通过语法派生出算术表达式的方式 为：首先从开始符号开始，然后反复地使用所包含的非终结符的规则替换该终结符， 直到生成一个只包含终结符的句子。语法能组成的句子构成了一门语言。</p>
<p>例如：一个只有乘除法的计算表达式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr   : factor ((MUL|DIV) factor)*</span><br><span class="line">factor : INTEGER</span><br></pre></td></tr></table></figure>
<p>有两条规则，其中，<code>expr</code>是开始符号，<code>expr</code>和<code>factor</code>这样的变量是非终结符，<code>MUL</code>、<code>DIV</code>、<code>INTEGER</code>这样的<code>token</code>是终结符。</p>
<p>解读该语法：</p>
<ol>
<li><code>expr</code> 是一个<code>factor</code>后面可选地跟一个乘或除运算符再跟另一个<code>factor</code>，后面也相应可选地跟一个乘或除运算符再跟另一个<code>factor</code>，如此重复。</li>
<li><code>factor</code>是一个整数。</li>
</ol>
</li>
</ol>
<h4 id="语法转代码的规则"><a href="#语法转代码的规则" class="headerlink" title="语法转代码的规则"></a>语法转代码的规则</h4><ol>
<li><p>对于语法中定义的每个规则<code>R</code>，将它做成一个有相同名字的方法，对该规则的引用就变成了一个方法调用：<code>R()</code>。该方法的方法体遵循该规则的步骤，过程中使用相同的准则。</p>
</li>
<li><p>多选一 <code>(a1|a2|aN)</code> 变成 <code>if-elif-else</code>语句。</p>
</li>
<li><p>可选组 <code>(...)*</code> 变成一个可以执行 0 或多次的<code>while</code>循环。</p>
</li>
<li><p>每个<code>Token</code>指针<code>T</code>变成一个 <code>eat</code> 方法调用: <code>eat(T)</code>。<code>eat</code> 方法的工作是：当它匹配到当前的 <code>lookahead</code> 就消耗掉它，然后从<code>lexer</code>中得到一个新<code>token</code>并将它赋值给内部变量 <code>current_token</code>。</p>
<p><img src="https://github.com/kun-bin/image/blob/master/lsbasi_part4_rules.png" alt="语法转换代码示例"></p>
<p>以上面的语法为例：</p>
<ol>
<li><p><code>factor</code>只有一个终结符，所以直接<code>eat()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.eat(INTEGER)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>expr</code>规则体开始的 <code>factor</code> 引用 变成了对 <code>factor()</code> 方法的调用。可行组 <code>(...)*</code> 变成了一个 <code>while</code> 循环，多选一 <code>(MUL|DIV)</code> 变成了一个 <code>if-elif-else</code> 语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.factor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">		token = self.current_token</span><br><span class="line">		<span class="keyword">if</span> token.type == MUL:</span><br><span class="line">	    	self.eat(MUL)</span><br><span class="line">	    	self.factor()</span><br><span class="line">		<span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">	    	self.eat(DIV)</span><br><span class="line">	    	self.factor()</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<p>现在的代码整体是这样的：分为三个<code>class</code>，第一个<code>Token()</code>来定义符号类型，第二个<code>Lexer()</code>是词法分析器，用来把字符串分割成符合词法规则的词法单元并返回，比如跳过空格、把连续的数字拼凑成一个整数等，第三个<code>Interpreter()</code>是语法解释器，按顺序读入词法单元并按语法规则完成运算。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>写一个语法来描述包含任意数量的 <code>+</code>,<code>-</code>, <code>*</code>, 或<code>/</code>操作符的算术表达式。这个语法需要能够派生出像  <code>2 + 7 * 4</code>, <code>7 - 8 / 4</code>, <code>14 + 2 * 3 - 6 / 2</code> 等等这样的表达式。</p>
<p>这里要考虑运算优先级的问题，所以把乘除法作为一个单元，加减法作为另一个单元，加减法是高一级的，这样乘除法会被作为一个整体来优先运算，语法规则如下：（其实这里偷看了下一章的答案）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr: term((ADD|MINUS)term)*</span><br><span class="line">term: factor((MUL|DIV)factor)*</span><br><span class="line">factor: INTEGER</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用这个语法，写一个可以对包含任意数量的 <code>+</code>,<code>-</code>, <code>*</code>, 或<code>/</code>操作符的算术表达式求值的解释器。你们解释器需要能够处理像 <code>2 + 7 * 4</code>, <code>7 - 8 / 4</code>, <code>14 + 2 * 3 - 6 / 2</code> 等等这样的表达式。</p>
<p>首先在添加加法和减法的符号定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在开头添加定义</span></span><br><span class="line">INTEGER, MUL, DIV, EOF, ADD, MINUS = <span class="string">'INTEGER'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'EOF'</span>, <span class="string">'ADD'</span>, <span class="string">'MINUS'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Lexer()的get_next_token()添加词法判断</span></span><br><span class="line"><span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">	self.advance()</span><br><span class="line">	<span class="keyword">return</span> Token(ADD, <span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">	self.advance()</span><br><span class="line">	<span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br></pre></td></tr></table></figure>
<p>接着把上一题写的语法规则转成代码表达，和课程内容类似，<code>factor()</code>部分不变，<code>term()</code>部分是课程中的<code>expr()</code>，<code>expr()</code>部分实际上是把乘除改成加减的<code>term()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.eat(INTEGER)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.factor()</span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">		token = self.current_token</span><br><span class="line">		<span class="keyword">if</span> token.type == MUL:</span><br><span class="line">	    	self.eat(MUL)</span><br><span class="line">	    	self.factor()</span><br><span class="line">		<span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">	    	self.eat(DIV)</span><br><span class="line">	    	self.factor()</span><br><span class="line">	    	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.term()</span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (ADD, MINUS):</span><br><span class="line">		token = self.current_token</span><br><span class="line">		<span class="keyword">if</span> token.type == ADD:</span><br><span class="line">	    	self.eat(ADD)</span><br><span class="line">	    	self.term()</span><br><span class="line">		<span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">	    	self.eat(MINUS)</span><br><span class="line">	    	self.term()</span><br></pre></td></tr></table></figure>
<p>接下来就是把课程示例代码中的<code>expr()</code>改成<code>term()</code>，然后仿照着写新的<code>expr()</code>了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新的expr()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string">    expr   : term   ((ADD | MINUS) term)*</span></span><br><span class="line"><span class="string">    term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">    factor : INTEGER</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    result = self.term()</span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (ADD, MINUS):</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == ADD:</span><br><span class="line">            self.eat(ADD)</span><br><span class="line">            result = result + self.term()</span><br><span class="line">        <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">            self.eat(MINUS)</span><br><span class="line">            result = result - self.term()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>感受是语法规则写出来以后代码就很好写了。</p>
</li>
</ol>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>什么是上下文无关语法（语法）？</p>
<p>上下文无关文法（英语：context-free grammar，缩写为CFG），在计算机科学中，若一个形式文法<code>G = (N, Σ, P, S)</code> 的产生式规则都取如下的形式：<code>V-&gt;w</code>，则谓之。其中 <code>V∈N, w∈(N∪Σ)*</code> 。上下文无关文法取名为“上下文无关”的原因就是因为字符 V 总可以被字串 w 自由替换，而无需考虑字符 V 出现的上下文。一个形式语言是上下文无关的，如果它是由上下文无关文法生成的。</p>
<p>上下文无关文法重要的原因在于它们拥有足够强的表达力来表示大多数程序设计语言的语法；实际上，几乎所有程序设计语言都是通过上下文无关文法来定义的。另一方面，上下文无关文法又足够简单，使得我们可以构造有效的分析算法来检验一个给定字串是否是由某个上下文无关文法产生的。例子可以参见LR 分析器和LL 分析器。</p>
<p>BNF（巴克斯-诺尔范式）经常用来表达上下文无关文法。</p>
<p>（百度百科复制的）</p>
</li>
<li><p>这个语法有几条规则/生成式？（指例子里的那个乘除法的图）</p>
<p>2条。</p>
</li>
<li><p>什么是终结符？（指出图片中的所有终结符）</p>
<p><code>INTEGER</code>这种的</p>
</li>
<li><p>什么是非终结符？（指出图片中的所有非终结符）</p>
<p><code>expr</code>这种的</p>
</li>
<li><p>什么是一条规则的 head？（指出图片中所有的 head/左边）</p>
<p>最左边的</p>
</li>
<li><p>什么是一条规则的 body？（指出图片中所有的 body/右边）</p>
<p>右边的部分</p>
</li>
<li><p>什么是一个语法的开始符号？</p>
<p>最一开始那个</p>
</li>
</ol>
<p>（2.12开始写的文档，2.28才写完……）</p>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>python课程记录-1</title>
    <url>/2020/02/26/python%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-1/</url>
    <content><![CDATA[<ol>
<li><p>为了给变量x, y, z 赋初值5，下面正确的赋值语句是（）<br>A. xyz=5                    B. x=5 y=5 z=5<br>C. x=5, y=5, z=5        D. x=5;y=5;z=5<br>E. x=y=z=5                 F. x,y,z=5<br>G. x,y,z=5,5,5</p>
<p> [DEG]<br> 没什么说的，运行一下就知道哪个对哪个错了。</p>
</li>
<li><p>x是一个两位数的整数，现将该两位数的个位和十位数字交换，例如13变成31，正确的表达式是（）<br>A. (x%10)*10+x/10           B. (x%10)//10+x/10<br>C. (x/10)%10+x//10          D. (x%10)*10+x//10</p>
<p> [D]<br> 这里要区分“/”和“//”，前者是不取整数的除法，后者是取整，例如7/3=2.333，而7//3=2。</p>
</li>
</ol>
<a id="more"></a>
<p>课后练习：</p>
<ol>
<li>编写程序1：提示输入姓名和出生年份，输出姓名和年龄。运行 结果如：<br>​        请输入你的姓名：<strong><em>张三</em></strong><br>​        你好，张三<br>​        请输入你的出生年份：<strong><em>1999</em></strong><br>​        你好，张三，你今年19岁了。</li>
</ol>
<p>这个很简单了，就是普通的输入输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = input(<span class="string">"请输入你的姓名："</span>)</span><br><span class="line">print(<span class="string">"你好，"</span>, name)</span><br><span class="line">age = input(<span class="string">"请输入你的出生年份："</span>)</span><br><span class="line">print(<span class="string">"你好，"</span>, name, <span class="string">"你今年"</span>, <span class="number">2020</span>-int(age), <span class="string">"岁了"</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>编写程序2： 三角形的三条边长为3、7、9，计算三角形的三个角（提示：余弦定理）</li>
</ol>
<p>这个也还是很简单，虽然我忘了三角形的边角关系公式，不过没关系，百度有。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">a = <span class="number">3</span></span><br><span class="line">b = <span class="number">7</span></span><br><span class="line">c = <span class="number">9</span></span><br><span class="line">A = math.acos((math.pow(c, <span class="number">2</span>) + math.pow(b, <span class="number">2</span>) - math.pow(a, <span class="number">2</span>)) / (<span class="number">2</span> * b * c))</span><br><span class="line">B = math.acos((math.pow(c, <span class="number">2</span>) + math.pow(a, <span class="number">2</span>) - math.pow(b, <span class="number">2</span>)) / (<span class="number">2</span> * a * c))</span><br><span class="line">C = math.acos((math.pow(a, <span class="number">2</span>) + math.pow(b, <span class="number">2</span>) - math.pow(c, <span class="number">2</span>)) / (<span class="number">2</span> * b * a))</span><br><span class="line">print(<span class="string">"弧度值："</span>, A, B, C)</span><br><span class="line">print(<span class="string">"角度值："</span>, math.degrees(A), math.degrees(B), math.degrees(C))</span><br></pre></td></tr></table></figure>
<ol>
<li><p>编写程序3：对猜数字游戏的程序进行如下修改：</p>
<ol>
<li>由用户键盘输入秘密数的上限和下限。</li>
<li>现有的程序每次只能玩一局，对此进行修改，玩完一局后自动进入下一局。</li>
<li>退出游戏时打印用户总共玩的局数（没玩完的局不算），如果局数不为0，则还需打印每一局的猜测次数。</li>
</ol>
</li>
</ol>
<p>这个看起来复杂，但就是条件说的不清楚而已，总的来说要求是用户输入数字的时候玩猜数字，反之结束游戏，然后输出一下统计结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">count &#x3D; 0</span><br><span class="line">number &#x3D; []</span><br><span class="line">a &#x3D; input(&quot;请输入一个整数下限：&quot;)</span><br><span class="line">while a.isdigit():</span><br><span class="line">    b &#x3D; input(&quot;请输入一个整数上限：&quot;)</span><br><span class="line">    secret &#x3D; random.randint(int(a), int(b))</span><br><span class="line">    print(&quot;我有一个&quot;, a, &quot;-&quot;, b, &quot;的秘密数，想要猜出它？请按数字键并回车；如果不想猜了，可按非数字键并回车或直接回车。&quot;)</span><br><span class="line">    inputStr &#x3D; input(&quot;你猜是？&quot;)</span><br><span class="line">    number.append(0)</span><br><span class="line">    while inputStr.isdigit():</span><br><span class="line">        guess &#x3D; int(inputStr)</span><br><span class="line">        number[count] +&#x3D; 1</span><br><span class="line">        if guess &lt; secret:</span><br><span class="line">            print(&quot;小了&quot;)</span><br><span class="line">        elif guess &gt; secret:</span><br><span class="line">            print(&quot;大了&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;Bingo! 你猜对啦！这个数就是&quot;, secret)</span><br><span class="line">            print(&quot;继续玩下一局！&quot;)</span><br><span class="line">            count +&#x3D; 1</span><br><span class="line">            break</span><br><span class="line">        inputStr &#x3D; input(&quot;你猜是？&quot;)</span><br><span class="line">    a &#x3D; input(&quot;请输入一个整数下限：&quot;)</span><br><span class="line">print(&quot;再见，下次玩！&quot;)</span><br><span class="line">print(&quot;你一共玩了&quot;, count, &quot;局&quot;)</span><br><span class="line">for i in range(0, count):</span><br><span class="line">    print(&quot;第&quot;, i + 1, &quot;局猜测次数为&quot;, number[i])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s Build A Simple Interpreter笔记[3]</title>
    <url>/2020/02/01/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-3/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part3/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/26/lets-build-a-simple-interpreter-part-03/" target="_blank" rel="noopener">翻译</a></p>
<p><a href="https://www.oschina.net/translate/lsbasi-part-3" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, PLUS, MINUX, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '+', '-', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">        Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">        Token(PLUS, '+')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'Token(<span class="subst">&#123;self.type&#125;</span>, <span class="subst">&#123;repr(self.value)&#125;</span>)'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 + 5", "12 - 5 + 3", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        <span class="comment"># current token instance</span></span><br><span class="line">        self.current_token = <span class="literal">None</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="comment"># Lexer code                                             #</span></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the 'pos' pointer and set the 'current_char' variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.text):</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        value = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            value += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.error()</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="comment"># Parser / Interpreter code                              #</span></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return an INTEGER token value."""</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> token.value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter."""</span></span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.get_next_token()</span><br><span class="line">        result = self.term()</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                result += self.term()</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                result -= self.term()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.error()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            print()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        interpreter = Interpreter(text)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这一课实现了多个数字的加减操作，思路大致和我想的差不多，不过循环条件是“当前字符是加号或减号”。</p>
<p>引入了句法图的使用和句法分析的概念。</p>
<blockquote>
<p>parser 只是识别出结构并保证它符合某些规范，interpreter 在 parser 成功识别后对表达式进行求值。</p>
</blockquote>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>画一张只包含乘除法的算术表达式句法图，例如“7 <em> 4 / 2 </em> 3”。不开玩笑，拿只钢笔 或铅笔试试。</p>
<p>和加减法的句法图一样。</p>
</li>
<li><p>修改计算器的源代码使它解释只包含乘除法的算术表达式，如“7 <em> 4 / 2 </em> 3”。</p>
<p>把代码里的加减换成乘除就行。</p>
</li>
<li><p>从头写一个可以处理如“7 - 3 + 2 - 1”这样算术表达式的解释器。使用任何你喜欢的语 言都可以，只靠自己，不要参考例子。做这件事时，想想都需要包含的组件：lexer 获取 输入并把它转化为 token 流，parser 从 lexer 提供的 token 流中识别结构， interpreter 在 parser 成功识别到一个合法的算术表达式之后求得其结果。把这些连起 来。花点时间把你学到的知识转化为一个可以运行的算术表达式解释器。</p>
<p>因为我别的语言都不太会，所以决定用C语言。本以为，这是个非常简单的事情，没想到写了两天，我好难过啊T_T</p>
<p>第一天发现根本没法不看python代码直接写，这说明我对整个算法流程都还不熟悉，只知道大概原理，没法自己实现，然后开始照着python代码写。这个过程中还发现我对C语言也不太熟悉，很多东西都记不清了，尤其是字符串数组和指针，实际上我到现在也没搞明白<code>char *str</code>和<code>char str[]</code>什么时候用哪个、怎么用。</p>
<p>第二天，也就是今天（20200202），我决定全用<code>char str[100]</code>这种，但还是有各种各样的问题，不过都渐渐解决了。然后花了一个多小时，才发现最大的问题在于C语言的字符串操作完全不能直接用<code>=</code>之类的方式搞，要用<code>strcpy</code>和<code>strcmp</code>，然后又是一个多小时，才发现我把<code>strcpy(new,old)</code>写成了<code>strcpy(old,new)</code>，然后第三个一小时，发现我上一步有两个用了<code>strcpy</code>的没改过来，还把一个<code>while</code>里的<code>==</code>写成了<code>=</code>。我怕是个傻子吧……</p>
<p>总之，现在写完了，能正常运行出结果。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#define SWAP(a,b) (a)^&#x3D;(b);(b)^&#x3D;(a);(a)^&#x3D;(b)</span><br><span class="line"></span><br><span class="line">char INTEGER[100]&#x3D;&quot;INTEGER&quot;;</span><br><span class="line">char PLUS[100]&#x3D;&quot;PLUS&quot;;</span><br><span class="line">char MINUS[100]&#x3D;&quot;MINUS&quot;;</span><br><span class="line">char END[100]&#x3D;&quot;EOF&quot;;</span><br><span class="line">int i&#x3D;1;</span><br><span class="line"></span><br><span class="line">struct Token		&#x2F;&#x2F;词法单元</span><br><span class="line">&#123;</span><br><span class="line">	char type[100];	&#x2F;&#x2F;类型，可以是integer、plus、minus和end</span><br><span class="line">	char value[100];	&#x2F;&#x2F;值，可以是数字，+，-，eof</span><br><span class="line">&#125;;</span><br><span class="line">struct Intepreter		&#x2F;&#x2F;解释器</span><br><span class="line">&#123;</span><br><span class="line">	int pos;			&#x2F;&#x2F;索引</span><br><span class="line">	char current_char;	&#x2F;&#x2F;当前字符</span><br><span class="line">	char text[100];		&#x2F;&#x2F;输入的字符串</span><br><span class="line">	Token token;		&#x2F;&#x2F;当前词法单元</span><br><span class="line">&#125;;</span><br><span class="line">Intepreter intepreter;</span><br><span class="line">int error()			&#x2F;&#x2F;输错符号的报错</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Invalid syntax&quot;);</span><br><span class="line">	exit(100);</span><br><span class="line">&#125;</span><br><span class="line">Intepreter init(char text[100])	&#x2F;&#x2F;初始化解释器</span><br><span class="line">&#123;</span><br><span class="line">	Token tmp;</span><br><span class="line">	tmp.type[100]&#x3D;&#123;&#125;;</span><br><span class="line">	tmp.value[100]&#x3D;&#123;&#125;;</span><br><span class="line">	Intepreter intepreter;</span><br><span class="line">	strcpy(intepreter.text,text);</span><br><span class="line">	intepreter.pos&#x3D;0;</span><br><span class="line">	intepreter.current_char&#x3D;text[intepreter.pos];</span><br><span class="line">	strcpy(intepreter.token.type,tmp.type);</span><br><span class="line">	strcpy(intepreter.token.value,tmp.value);</span><br><span class="line">	return intepreter;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;索引后移一位改变当前字符</span><br><span class="line">Intepreter advance()</span><br><span class="line">&#123;</span><br><span class="line">	intepreter.pos+&#x3D;1;</span><br><span class="line">	if (intepreter.pos&gt;&#x3D;strlen(intepreter.text))</span><br><span class="line">	&#123;</span><br><span class="line">		intepreter.current_char&#x3D;&#39;\0&#39;;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		intepreter.current_char&#x3D;intepreter.text[intepreter.pos];</span><br><span class="line">	&#125;</span><br><span class="line">	return intepreter;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;跳过空格</span><br><span class="line">void skip_whitespace()</span><br><span class="line">&#123;</span><br><span class="line"> 	while(intepreter.current_char&#x3D;&#x3D;&#39; &#39;)</span><br><span class="line">    &#123;</span><br><span class="line">        intepreter&#x3D;advance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#x2F;&#x2F;返回整数词法单元</span><br><span class="line">int integer()</span><br><span class="line">&#123;</span><br><span class="line"> 	int result&#x3D;0;</span><br><span class="line"> 	while (intepreter.current_char&gt;&#x3D;&#39;0&#39; &amp;&amp; intepreter.current_char&lt;&#x3D;&#39;9&#39;)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		result&#x3D;result*10+(intepreter.current_char-&#39;0&#39;);</span><br><span class="line"> 		intepreter&#x3D;advance();</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用来取词法单元</span><br><span class="line">Token get_next_token()</span><br><span class="line">&#123;</span><br><span class="line">	Token token;</span><br><span class="line">	while(intepreter.current_char!&#x3D;&#39;\0&#39;)</span><br><span class="line">	&#123;</span><br><span class="line">		if(intepreter.current_char&#x3D;&#x3D;&#39; &#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			skip_whitespace();</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(intepreter.current_char&gt;&#x3D;&#39;0&#39; &amp;&amp; intepreter.current_char&lt;&#x3D;&#39;9&#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			strcpy(token.type,INTEGER);</span><br><span class="line">			itoa(integer(),token.value,10);</span><br><span class="line">			return token;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(intepreter.current_char&#x3D;&#x3D;&#39;+&#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			intepreter&#x3D;advance();</span><br><span class="line">			strcpy(token.type,PLUS);</span><br><span class="line">			strcpy(token.value,&quot;+&quot;);</span><br><span class="line">			return token;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(intepreter.current_char&#x3D;&#x3D;&#39;-&#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			intepreter&#x3D;advance();</span><br><span class="line">			strcpy(token.type,MINUS);</span><br><span class="line">			strcpy(token.value,&quot;-&quot;);</span><br><span class="line">			return token;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			error();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	strcpy(token.type,END);</span><br><span class="line">	strcpy(token.value,&quot;EOF&quot;);</span><br><span class="line">	return token;</span><br><span class="line">&#125;</span><br><span class="line">void eat(char type[100])</span><br><span class="line">&#123;</span><br><span class="line">	if (strcmp(intepreter.token.type,type)&#x3D;&#x3D;0)</span><br><span class="line">	&#123;</span><br><span class="line">		intepreter.token &#x3D; get_next_token();</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		int a &#x3D; error();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int term()</span><br><span class="line">&#123;</span><br><span class="line">    Token token;</span><br><span class="line">    strcpy(token.type,intepreter.token.type);</span><br><span class="line">    strcpy(token.value,intepreter.token.value);</span><br><span class="line">    eat(INTEGER);</span><br><span class="line">    return atoi(token.value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;用来算表达式</span><br><span class="line">int expr()</span><br><span class="line">&#123;</span><br><span class="line">	int result&#x3D;0;</span><br><span class="line">	Token token;</span><br><span class="line">	intepreter.token&#x3D;get_next_token();</span><br><span class="line">    result&#x3D;term();</span><br><span class="line">    while ((strcmp(intepreter.token.type,PLUS)&#x3D;&#x3D;0)||(strcmp(intepreter.token.type,MINUS)&#x3D;&#x3D;0))</span><br><span class="line">    &#123;</span><br><span class="line">        strcpy(token.type,intepreter.token.type);</span><br><span class="line">        strcpy(token.value,intepreter.token.value);</span><br><span class="line">        if (strcmp(token.type,PLUS)&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            eat(PLUS);</span><br><span class="line">            result&#x3D;result+term();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (strcmp(token.type,MINUS)&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            eat(MINUS);</span><br><span class="line">            result-&#x3D;term();</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            error();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char text[100];</span><br><span class="line">	printf(&quot;calc&gt;&quot;);</span><br><span class="line">	scanf(&quot;%s&quot;, &amp;text);</span><br><span class="line">	intepreter&#x3D;init(text);</span><br><span class="line">	int result&#x3D;expr();</span><br><span class="line">	printf(&quot;result is %d\n&quot;,result);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>什么是句法图？</p>
<p><strong>句法图</strong> 就是程序语言句法规则的图形表示。基本上，句法图从视觉上向 你展示了在你的程序语言中哪些语句是允许的哪些是不允许的。</p>
</li>
<li><p>什么是句法分析？</p>
<p>从 token 流中识别组合的过程叫 <strong>parsing</strong>。</p>
</li>
<li><p>什么是句法分析器？</p>
<p>解释器或编译器中执行parsing的部分叫 <strong>parser</strong>。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>各种平台遇到过的error处理方式</title>
    <url>/2020/01/31/%E5%90%84%E7%A7%8D%E5%B9%B3%E5%8F%B0%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84error%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>记录一下之前的一些问题。</p>
<a id="more"></a>
<ol>
<li><p>平台：visiual studio<br>error LNK2026: 模块对于 SAFESEH 映像是不安全的<br>解决方法：属性 - &gt; 链接器 - &gt; 附加选项输入 /SAFESEH:NO - &gt; 应用</p>
</li>
<li><p>平台：visiual studio<br>error C4996: ‘fopen’: This function or variable may be unsafe. Consider using fopen_sinstead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help   for details.<br>1&gt;f:\program files (x86)\microsoft visual studio 12.0\vc\include\stdio.h(211) : 参见“fopen”的声明<br>解决方法：预处理器加入_CRT_SECURE_NO_WARNINGS</p>
</li>
<li><p>平台：visiual studio<br>error C2664: “int MessageBoxW(HWND,LPCWSTR,LPCWSTR,UINT)”: 无法将参数 2 从“const char [17]”转换为“LPCWSTR”<br>解决方法：项目菜单-&gt;属性-&gt;配置属性-&gt;常规-&gt;项目默认值-&gt;字符集从unicode改为未设置</p>
</li>
<li><p>平台：visiual studio<br>error LNK2019: 无法解析的外部符号 _main，该符号在函数 ___tmainCRTStartup 中被引用<br>解决方法：右击项目，打开“属性”页，链接器-&gt;系统-&gt;子系统-&gt;/subsystem:windows。如果是刚开始默认的是/subsystem:windows则改为/subsytem:console</p>
</li>
<li><p>平台：visiual studio<br>error LNK2019: 无法解析的外部符号 <strong>imp</strong>timeGetTime@0，该符号在函数 “void __cdecl TimerInit(void)” (?TimerInit@@YAX<br>解决方法：将winmm.lib打入“附加依赖项”</p>
</li>
<li><p>平台：visiual studio<br>fatal error LNK1123: 转换到 COFF 期间失败: 文件无效或损坏<br>解决方法：右键-&gt;工程属性-&gt;配置属性-&gt; 清单工具-&gt;输入和输出-&gt;嵌入清单，选择[否]</p>
</li>
<li><p>突然发现github上的图片打不开，具体来说就是博客里插入了上传到github的图，但是加载不出，这时需要修改hosts文件，如下：</p>
<p>打开路径C:\Windows\System32\drivers\etc下的hosts文件，在最后加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GitHub Start </span><br><span class="line">192.30.253.112    github.com </span><br><span class="line">192.30.253.119    gist.github.com</span><br><span class="line">151.101.184.133    assets-cdn.github.com</span><br><span class="line">151.101.184.133    raw.githubusercontent.com</span><br><span class="line">151.101.184.133    gist.githubusercontent.com</span><br><span class="line">151.101.184.133    cloud.githubusercontent.com</span><br><span class="line">151.101.184.133    camo.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars0.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars1.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars2.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars3.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars4.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars5.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars6.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars7.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars8.githubusercontent.com </span><br><span class="line"> # GitHub End</span><br></pre></td></tr></table></figure>
</li>
<li><p>opencv读取图像释放资源时报错：</p>
<p><code>[ WARN:1] global C:\projects\opencv-python\opencv\modules\videoio\src\cap_msmf.cpp (674) SourceReaderCB::~SourceReaderCB terminating async callback</code></p>
<p>修改代码如下：<code>cap = cv2.VideoCapture(0, cv2.CAP_DSHOW)</code></p>
</li>
<li><p>pycharm更新了一下，然后导入包的时候会有<code>unresolved reference issue</code>的提示，但是能正常运行，就只是看起来不好看。</p>
<p>解决方案：<del><a href="https://www.jianshu.com/p/9555310f1920" target="_blank" rel="noopener">有一个</a>说<code>File</code> → <code>Settings</code> → <code>Editor</code> → <code>File Types</code> → <code>Ignore files and folders</code>，干掉框框中的：<code>__init__.py;</code>，然后：<code>OK</code>等待重新文件扫描。但是我打开看了以后发现我的框里并没有<code>__init__.py</code>。于是就<code>File</code> → <code>Invalidate Caches / Restart</code>，选择<code>Invalidate and Restart</code>，等待重新扫描库文件。这之后就好了。</del>并没有解决问题，算了反正不影响运行，就这样吧。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>无分类项</category>
      </categories>
      <tags>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s Build A Simple Interpreter笔记[2]</title>
    <url>/2020/01/31/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part2/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/25/lets-build-a-simple-interpreter-part-02/" target="_blank" rel="noopener">翻译</a></p>
<p><a href="https://www.oschina.net/translate/build-a-simple-interpreter-part-2" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: 'INTEGER', 'PLUS', 'MINUS', or 'EOF'</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '+', '-', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of class instance</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'Token(<span class="subst">&#123;self.type&#125;</span>, <span class="subst">&#123;self.value&#125;</span>)'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 + 5", "12 - 5", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        <span class="comment"># current token instance</span></span><br><span class="line">        self.current_token = <span class="literal">None</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Error parsing input'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the 'pos' pointer and set the 'current_char' variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.text):</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line">            self.error()</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Parser / Interpreter</span></span><br><span class="line"><span class="string">        expr -&gt; INTEGER PLUS INTEGER</span></span><br><span class="line"><span class="string">        expr -&gt; INTEGER MINUS INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># set current token to the first token from the input</span></span><br><span class="line">        self.current_token = self.get_next_token()</span><br><span class="line">        <span class="comment"># we expect the current token to be an integer</span></span><br><span class="line">        left = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="comment"># we expect the current token to be either a '+' or '-'</span></span><br><span class="line">        op = self.current_token</span><br><span class="line">        <span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">            self.eat(PLUS)</span><br><span class="line">        <span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">            self.eat(MINUS)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">        <span class="comment"># we expect the current token to be an integer</span></span><br><span class="line">        right = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="comment"># after the above call the self.current_token is set to</span></span><br><span class="line">        <span class="comment"># EOF token</span></span><br><span class="line">        <span class="comment"># at this point either the INTEGER PLUS INTEGER or</span></span><br><span class="line">        <span class="comment"># the INTEGER MINUS INTEGER sequence of tokens</span></span><br><span class="line">        <span class="comment"># has been successfully found and the method can just</span></span><br><span class="line">        <span class="comment"># return the result of adding or subtracting two integers,</span></span><br><span class="line">        <span class="comment"># thus effectively interpreting client input</span></span><br><span class="line">        <span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">            result = left.value + right.value</span><br><span class="line">        <span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">            result = left.value - right.value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call with 'input'</span></span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        interpreter = Interpreter(text)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这个处理方式和我想的不太一样…</p>
<p>整体逻辑是：</p>
<ol>
<li><code>get_next_token</code>是词法分析器，输入一个字符串，逐一输出词法单元，比如输入<code>32 + 5</code>，输出的流应该是<code>Token(INTEGER, 32) -&gt; Token(PLUS, +) -&gt; Token(INTEGER, 5)</code>。<br>这个词法分析器用到的辅助函数为<code>advance()</code>，<code>skip_whitespace()</code>和<code>interger()</code>，其中<code>advance()</code>让索引后移一位，<code>skip_whitespace()</code>跳过空格，<code>interger()</code>把连续的数字变成一个完整的数字。注意这里如果是多位数中间有空格，多位数会被拆成两个数字，比如<code>32 3</code>会被判断为<code>32</code>和<code>3</code>，而不是<code>323</code>。<br>词法分析过程中会遇到以下几种情况：(1)空格，要跳过空格，循环继续运行，分析下一个字符；(2)结束符，直接返回<code>EOF</code>对应的<code>token</code>；(3)数字，循环终止，连后面的几位数字字符一起变成一个数字，返回对应的<code>token</code>；(4)是<code>+</code>或者<code>-</code>，索引移到下一位，循环终止，返回运算符对应的<code>token</code>。<br>分析几个辅助函数：<ol>
<li><code>advance()</code>，索引<code>pos</code>后移一位，当前字符<code>current.char</code>的值变为新索引对应的字符。</li>
<li><code>skip_whitespace()</code>，循环调用<code>advance()</code>直到当前字符不是空格。</li>
<li><code>integer()</code>，先声明一个初始为空字符串的<code>result</code>，然后循环把<code>current.char</code>加到<code>result</code>这个字符串里，接着<code>advance()</code>移动到下一位，直到当前字符不是数字。</li>
</ol>
</li>
<li><code>expr()</code>是用来计算表达式的，判断词法分析后的词法单元是否符合规则，然后根据规则来计算结果。辅助函数为<code>eat()</code>，用来判断当前词法单元是否符合规则。</li>
</ol>
<p>以输入<code>32 + 5</code>为例分析整个流程：</p>
<ol>
<li><p>首先运行的是<code>main()</code>，获取输入字符串，存到<code>text</code>中（<code>line116</code>)，并用<code>text</code>初始化<code>interpreter</code>这个解释器类(<code>line121</code>)，此时，<code>interpreter.text</code>就是我们输入的字符串，<code>interpreter.pos</code>是初始值<code>0</code>，<code>self.current_token</code>是初始值<code>None</code>，<code>self.current_char</code>是<code>interpreter.text</code>这个字符串数组下标为<code>pos=0</code>对应的字符，也就是<code>3</code>。</p>
</li>
<li><p>接下来<code>line122</code>调用了表达式计算器<code>expr()</code>，而<code>expr()</code>的第一行调用了词法分析器<code>get_next_token()</code>，因为字符3是数字，所以要去调用<code>integer()</code>函数，并返回一个类型为<code>INTEGER</code>、值为函数结果的<code>TOKEN</code>。<br>在执行完<code>integer()</code>并返回之前，<code>pos=0</code>，<code>current_token=None</code>，<code>current_char=3</code>。</p>
</li>
<li><p>进入<code>integer()</code>函数，最初<code>result</code>是空字符串，<code>current_char=3</code>符合循环条件，进入<code>while</code>循环，<code>result</code>变成<code>3</code>（是字符串格式）,调用<code>advance()</code>，接下来先让索引后移，即<code>pos=1</code>，此时还没移到最后一位，更新<code>current_char=text[pos]=text[1]=2</code>。此时还符合循环条件，<code>result</code>把新的<code>current_char</code>加上，变成<code>32</code>（字符串格式），再次<code>advance()</code>，调用完后，<code>pos=2</code>，依旧没移到最后一位，<code>current_char=text[2]=空格</code>。这时不满足循环条件了，循环结束，返回字符串<code>result</code>对应的数字也就是32。</p>
</li>
<li><p>然后回到<code>get_next_token()</code>，它已经有返回值了，返回给之前的<code>expr()</code>中的<code>self.current_token</code>，这是我们得到的第一个词法单元，是我们要计算的表达式的左值，将它存到<code>left</code>中，之后可以使用<code>left.value</code>来访问它的值，这之后就调用<code>eat()</code>看该值是不是一个<code>INTEGER</code>，如果是，就再次调用<code>get_next_token()</code>继续分析下一个单元，反之则报错。很显然此时<code>current_token</code>是<code>(INTEGER,32)</code>，符合要求，进入<code>get_next_token()</code>。</p>
</li>
<li><p><code>get_next_token()</code>判断此时<code>current_char</code>是空格，因此执行<code>skip_whitespace()</code>。</p>
</li>
<li><p>在<code>skip_whitespace()</code>中，<code>current_char</code>满足循环条件，进入循环体，调用<code>advance()</code>，<code>pos=3</code>，<code>current_char=text[3]=+</code>，循环结束，回到<code>get_next_token()</code>，执行<code>continue</code>，也就是继续进行词法判断。</p>
</li>
<li><p>由于<code>current_char</code>是<code>+</code>，在对应的<code>if</code>分支中，执行<code>advance()</code>，<code>pos=4</code>,<code>current_char=text[4]=空格</code>，然后把<code>+</code>对应的<code>token</code>返回到<code>expr()</code>中。</p>
</li>
<li><p><code>expr()</code>把新得到的<code>token</code>存入<code>op</code>，并通过<code>eat()</code>判断该<code>token</code>是否是一个加号或者减号。此时是加号，又开始了<code>get_next_token()</code>。</p>
</li>
<li><p>这次<code>get_next_token()</code>首先进入空格分支，跳过空格后，<code>pos=5</code>，<code>current_char=5</code>，进入数字分支，执行<code>integer()</code>。<code>integer()</code>中和第三步一样，最终返回数字5，再回到<code>get_next_token()</code>，返回5对应的<code>token</code>给<code>expr()</code>，存在<code>right</code>中。</p>
</li>
<li><p>此时，我们已经完成了词法分析，得到了<code>(INTEGER, 32) -&gt; (PLUS, &#39;+&#39;) -&gt; (INTEGER, 5)</code>的词法结构。由于<code>OP</code>对应的类型是<code>PLUS</code>，对<code>left.value</code>和<code>right.value</code>执行加法，存入<code>result</code>并返回。</p>
</li>
<li><p>再回到<code>line122</code>，<code>result</code>已经得到了结果，<code>line123</code>输出该结果，程序运行结束。</p>
</li>
</ol>
<p>也就是说，在计算表达式结果的函数中调用词法分析器，判断词法分析的结果是否符合规则，如果符合规则，就按规则继续运行。在计算器函数中，只会出现<code>token</code>类型的变量，而词法分析函数会负责把词法单元打包成<code>token</code>交给计算器。</p>
<blockquote>
<p>在解释一个表达式之前，你需要知道它是哪种组合，比如相加或相减。这是 <code>expr</code> 方法本质上做的事： 它从 <code>get_next_token</code> 方法得到的 token 流中找到结构，然后解释它识别出的组合，产 生算术表达式的结果。<br>从 token 流中查找结构，或者说从 token 流中识别组合，的过程叫做 <strong>parsing</strong>. 解释器 或编译器中执行这部分任务的叫 <strong>parser</strong>.<br>现在你知道解释器的 <strong>parsing</strong> 和 <strong>解释</strong> 都在 <code>expr</code> 方法中了── <code>expr</code> 方法首先尝 试从 token 流中识别（即parse） INTEGER -&gt; PLUS -&gt; INTEGER 或 the INTEGER -&gt; MINUS -&gt; INTEGER 组合，在成功识别到（即parsed）其中一个组合时，该方法就解释执行 它并返回给调用者两个整数相加或相减的结果。</p>
</blockquote>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>扩展计算器以处理两个整数相乘</p>
</li>
<li><p>扩展计算器以处理两个整数相除</p>
<p>前两个都很简单，仿照加法减法的代码复制改写就行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运算符声明</span></span><br><span class="line">INTEGER, PLUS, MINUS, MULTIPLY, DIVIDE, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MULTIPLY'</span>, <span class="string">'DIVIDE'</span>, <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get_next_token()</span></span><br><span class="line"><span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">	self.advance()</span><br><span class="line">	<span class="keyword">return</span> Token(MULTIPLY, <span class="string">'*'</span>)</span><br><span class="line"><span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">	self.advance()</span><br><span class="line">	<span class="keyword">return</span> Token(DIVIDE, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># expr()</span></span><br><span class="line"><span class="comment"># 修改读取运算符</span></span><br><span class="line">op = self.current_token</span><br><span class="line"><span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">	self.eat(PLUS)</span><br><span class="line"><span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">	self.eat(MINUS)</span><br><span class="line"><span class="keyword">elif</span> op.type == MULTIPLY:</span><br><span class="line">	self.eat(MULTIPLY)</span><br><span class="line"><span class="keyword">elif</span> op.type == DIVIDE:</span><br><span class="line">	self.eat(DIVIDE)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	self.error()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改计算结果那里</span></span><br><span class="line"><span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">	result = left.value + right.value</span><br><span class="line"><span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">	result = left.value - right.value</span><br><span class="line"><span class="keyword">elif</span> op.type == MULTIPLY:</span><br><span class="line">	result = left.value * right.value</span><br><span class="line"><span class="keyword">elif</span> op.type == DIVIDE:</span><br><span class="line">	result = left.value / right.value</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	self.error()</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改代码以使它可以解释包含任意个数字的加减操作，如“9 - 5 + 3 + 11”</p>
<p>这个也不难。此时的词法结构是<code>INTEGER -&gt; 循环[OP -&gt;INTEGER]</code>，在<code>expr()</code>里首先读取并<code>eat()</code>第一个词法单元，<code>result</code>先等于这个单元的值，接下来用<code>while</code>进行两个词法单元为一组的循环，直到读取到<code>EOF</code>，每个循环里，<code>result</code>与新的<code>INTEGER</code>进行加减运算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改expr()</span></span><br><span class="line">result = left.value</span><br><span class="line"><span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">	op = self.current_token</span><br><span class="line">	<span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">		self.eat(PLUS)</span><br><span class="line">	<span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">		self.eat(MINUS)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		self.error()</span><br><span class="line">	right = self.current_token</span><br><span class="line">	self.eat(INTEGER)</span><br><span class="line">	<span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">		result += right.value</span><br><span class="line">	<span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">		result -= right.value</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		self.error()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>什么是 lexeme？<br>lexeme 是组成 token 的一个字符序列。（这个词翻译过来是<strong>词位</strong>或<strong>词素</strong>）<br><code>token</code>和<code>lexeme</code>的关系类似于类和实例（或者对象）之间的关系。举例来说，变量<code>a</code>和<code>b</code>，它们属于同一种<code>token</code>：<code>identifier</code>，而<code>a</code>的<code>lexeme</code>是<code>a</code>，<code>b</code>的<code>lexeme</code>是<code>b</code>。每个关键字是一种<code>token</code>。<code>token</code>可以附带一个值属性，例如变量<code>a</code>，调用<code>gettoken()</code>时，会返回一个<code>identifier</code>类型的<code>token</code>，其值属性是<code>a</code>。</p>
</li>
<li><p>在 token 流中找到结构的过程叫什么？或者这么问，在 token 流中识别出特定组合的过程叫什么？<br>parsing（翻译是语法分析或句法分析）</p>
</li>
<li><p>解释器（编译器）做 parsing 工作的部分叫什么？<br>parser（也就是语法分析器）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s Build A Simple Interpreter笔记[1]</title>
    <url>/2020/01/30/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/23/lets-build-a-simple-interpreter-part-01/" target="_blank" rel="noopener">翻译</a></p>
<p>上一个翻译页面凉了，找了一个<a href="https://www.oschina.net/translate/build-a-simple-interpreter-part-1" target="_blank" rel="noopener">新的翻译</a></p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, PLUS, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, '+', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">        Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">        Token(PLUS, '+')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3+5"</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        <span class="comment"># current token instance</span></span><br><span class="line">        self.current_token = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Error parsing input'</span>)    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        text = self.text    </span><br><span class="line">        <span class="comment"># is self.pos index past the end of the self.text ?</span></span><br><span class="line">        <span class="comment"># if so, then return EOF token because there no more</span></span><br><span class="line">        <span class="comment"># input left to convert into tokens</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(text) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)    </span><br><span class="line">        <span class="comment"># get a character at the position self.pos and decide</span></span><br><span class="line">        <span class="comment"># what token to create based on the single character</span></span><br><span class="line">        current_char = text[self.pos]    </span><br><span class="line">        <span class="comment"># if the character is a digit then convert it to</span></span><br><span class="line">        <span class="comment"># integer, create an INTEGER token, increment self.pos</span></span><br><span class="line">        <span class="comment"># index to point to the next character after the digit,</span></span><br><span class="line">        <span class="comment"># and return the INTEGER token</span></span><br><span class="line">        <span class="keyword">if</span> current_char.isdigit():</span><br><span class="line">            token = Token(INTEGER, int(current_char))</span><br><span class="line">            self.pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> token    </span><br><span class="line">        <span class="keyword">if</span> current_char == <span class="string">'+'</span>:</span><br><span class="line">            token = Token(PLUS, current_char)</span><br><span class="line">            self.pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> token    </span><br><span class="line">        self.error()    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""expr -&gt; INTEGER PLUS INTEGER"""</span></span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.get_next_token()    </span><br><span class="line">        <span class="comment"># we expect the current token to be a single-digit integer</span></span><br><span class="line">        left = self.current_token</span><br><span class="line">        self.eat(INTEGER)    </span><br><span class="line">        <span class="comment"># we expect the current token to be a '+' token</span></span><br><span class="line">        op = self.current_token</span><br><span class="line">        self.eat(PLUS)    </span><br><span class="line">        <span class="comment"># we expect the current token to be a single-digit integer</span></span><br><span class="line">        right = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="comment"># after the above call the self.current_token is set to</span></span><br><span class="line">        <span class="comment"># EOF token    </span></span><br><span class="line">        <span class="comment"># at this point INTEGER PLUS INTEGER sequence of tokens</span></span><br><span class="line">        <span class="comment"># has been successfully found and the method can just</span></span><br><span class="line">        <span class="comment"># return the result of adding two integers, thus</span></span><br><span class="line">        <span class="comment"># effectively interpreting client input</span></span><br><span class="line">        result = left.value + right.value</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call with 'input'</span></span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        interpreter = Interpreter(text)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol>
<li>词法分析(lexical analysis)：把输入字符串拆分成 token 的过程。解释器中做这个工作的部分被称为 <strong>词法分析器</strong>(lexical analyzer)，简称 <strong>lexer</strong> ，也被称作  <strong>scanner</strong> 或 <strong>tokenizer</strong> 。</li>
<li>在完成词法分析后，解释器需要验证token序列是否符合期望的序列，如果符合，则进行一些运算，不符合则抛出异常。</li>
</ol>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><ol>
<li>目的是执行一位数的加法运算，整体逻辑是，先取第一个字符，判断是否是数字，如果是，就把这个数字存在<code>left</code>中，然后取第二个字符，判读是否为加号，如果是，再继续取第三个字符，判断是否为数字并把数字存在<code>right</code>中，接下来就可以计算<code>left.value + right.value</code>了。整个过程中字符的移动依靠一个名为<code>pos</code>的变量，它作为索引，每当取完一个字符，<code>pos</code>的值就会<code>+1</code>，这样直到最后一个字符。</li>
<li><code>Token</code>类构造了一个结构为<code>(类型, 值)</code>的变量，当我们访问某个<code>Token</code>类型的变量<code>v</code>时，可以通过<code>v.type</code>来获取它的类型，通过<code>v.value</code>获取它的值。</li>
<li><code>Interpreter</code>类是我们的解释器类型，其中<code>get_next_token()</code>函数可以从字符串中取一个字符，判断该字符类型是数字还是<code>+</code>，并返回正确的<code>Token</code>结构，比如是数字，就返回<code>Token(INTEGER, int(current_char))</code>，然后索引(<code>pos</code>)往后挪一位，如果既不是数字也不是加号，比如是空格，就会报错，如果已经到最后一位了，会返回<code>EOF</code>。</li>
<li>接下来的<code>eat()</code>函数，参数是判断现在取出来的字符<code>type</code>是否符合设想的<code>type</code>，如果符合，就调用<code>get_next_token()</code>取下一个字符；反之，就输出错误信息。</li>
<li>然后<code>expr()</code>函数用来按顺序从头到尾逐个读取字符，在<code>eat()</code>的帮助下判断整体结构是否符合词法要求（比如这里的要求是<code>INTEGER -&gt; + INTEGER</code>）并执行运算。</li>
<li>最后的<code>main()</code>，将输入的字符串存到<code>text</code>中，并用<code>text</code>初始化类型为<code>Interpreter</code>的变量<code>interpreter</code>，接下来调用<code>interpreter.expr()</code>进行计算，结果存放到<code>result</code>中并输出。</li>
</ol>
<h4 id="python相关"><a href="#python相关" class="headerlink" title="python相关"></a>python相关</h4><ol>
<li><p>python命名规则：以下划线开头的标识符是有特殊意义的。以单下划线开头例如<code>_foo</code> 代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 <code>from xxx import</code> 而导入。<br> 以双下划线开头的 <code>__foo</code> 代表类的私有成员，以双下划线开头和结尾的 <code>__foo__</code> 代表 Python 里特殊方法专用的标识，如 <code>__init__()</code> 代表类的构造函数。</p>
</li>
<li><p>python中的<code>main()</code>函数：python程序按顺序执行，而不是像之前学过的语言那样先找<code>main()</code>然后从<code>main()</code>开始，执行过程中遇到<code>def</code>代码块会先跳过，每个代码块需要保持相同的缩进。</p>
<p> 例如：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># code1</span></span><br><span class="line">print(<span class="string">"test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    str = <span class="string">"function"</span></span><br><span class="line">    print(str)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"main"</span>)</span><br><span class="line">    foo()</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">test</span><br><span class="line">main</span><br><span class="line">function</span><br><span class="line"></span><br><span class="line"><span class="comment"># code2</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    print(<span class="string">"Hello python !!!"</span>)    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_print</span><span class="params">()</span>:</span>  </span><br><span class="line">        print(<span class="string">"in func_print"</span>)   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>  </span><br><span class="line">        print(<span class="string">"In main"</span>)    </span><br><span class="line">    main()  </span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">Hello python !!!</span><br><span class="line">In main</span><br><span class="line"></span><br><span class="line"><span class="comment"># code3</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"Hello python !!!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_print</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"in func_print"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"In main"</span>)</span><br><span class="line"></span><br><span class="line">        func_print()</span><br><span class="line">main()</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">Hello python !!!</span><br><span class="line">In main</span><br><span class="line"><span class="keyword">in</span> func_print</span><br><span class="line"></span><br><span class="line"><span class="comment">#code4</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"Hello python !!!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_print</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"in func_print"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"In main"</span>)</span><br><span class="line"></span><br><span class="line">	func_print()</span><br><span class="line">main()</span><br><span class="line"><span class="comment"># output </span></span><br><span class="line">Hello python !!!</span><br><span class="line"><span class="keyword">in</span> func_print</span><br><span class="line">In main</span><br></pre></td></tr></table></figure>
</li>
<li><p>python中的<code>__name__</code>：<code>__name__</code>是python的一个内置类属性，它天生就存在于一个 python 程序中，代表对应程序名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test()</span><br><span class="line">	print(__name__)</span><br><span class="line">test</span><br></pre></td></tr></table></figure>
<p>直接运行temp2.py 时：<code>__name__=&quot;__main__&quot;</code>，在其它程序中导入temp2.py，则：<code>__name__=&quot;temp2.py&quot;</code>，所以<code>__name__</code>的主要作用就是用来区分，模块是直接被运行还是被导入。</p>
<p>实际使用时，我们会把测试模块时要执行的语句放到<code>if __name__ == &#39;__main__&#39;:</code>这个代码块里，这样测试的时候能看到测试结果，而调用的时候，测试语句不会被执行，也就不用删除测试语句。</p>
</li>
</ol>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>修改代码使得允许输入多位整数，例如<code>12+3</code></p>
<p>多位数不一定是几位数，也就是说我们在得到输入之前无法判断整个字符串第几位是什么类型，但是整体结构一定是<code>连在一起的数字 + 连在一起的数字</code>，因此考虑用<code>while</code>循环读取数字，在当前字符不是数字的情况下跳出循环去读取<code>+</code>，然后继续循环读数字，直到读取出<code>EOF</code>，字符串结束。具体来说是声明<code>left</code>和<code>right</code>两个数字并初始化为0，然后<code>left</code>存第一位数字，接下来乘10+第二位数字，再乘10+第三位数字，依次循环；<code>right</code>也是这样。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改expr()</span></span><br><span class="line">left = right = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> self.current_token.type == <span class="string">'INTEGER'</span>:    </span><br><span class="line">	left = left * <span class="number">10</span> + self.current_token.value    </span><br><span class="line">	self.eat(INTEGER)</span><br><span class="line"><span class="comment"># 中间几行代码省略</span></span><br><span class="line"><span class="keyword">while</span> self.current_token.type != <span class="string">'EOF'</span>:</span><br><span class="line">	right = right * <span class="number">10</span> + self.current_token.value</span><br><span class="line">	self.eat(INTEGER)</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加一个跳过空白符的方法，使你的计算器可以处理包含空白符的输入如<code>12 + 3</code></p>
<p>我们要增加一个<code>Token</code>类型用来识别空格，然后在<code>expr()</code>中读取到空格时就调用<code>eat()</code>来跳过，我们假设空格不会出现在一个多位数的中间（比如<code>1 2 3</code>就会报错)。</p>
<p>具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在代码开始的地方加</span></span><br><span class="line">SPACE = <span class="string">'SPACE'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在get_next_token()里加</span></span><br><span class="line"><span class="keyword">if</span> current_char == <span class="string">' '</span>:</span><br><span class="line">	token = Token(SPACE, current_char)</span><br><span class="line">	self.pos += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在expr()的数字和操作符的前后加</span></span><br><span class="line"><span class="keyword">while</span> self.current_token.value == <span class="string">' '</span>:</span><br><span class="line">	self.eat(SPACE)</span><br></pre></td></tr></table></figure>
<p><strong>这里存在一些问题需要改进</strong>：</p>
<ol>
<li>应该可以想办法跳过多位数中间的空格，也就是直接忽略所有空格；</li>
<li>个人认为不应该在<code>expr()</code>这个函数中出现对字符类型的判断，应该是在<code>expr()</code>中逐位后移，这个过程中调用其他函数来处理忽略空格等情况，也就是说上一个的<code>while</code>循环也不太合适，但是我暂时没想到怎么改，就先这样吧，反正功能上没问题。之后学到正则相关的地方可能会有新的思路。</li>
</ol>
</li>
<li><p>修改代码使得它可以处理<code>-</code>而非<code>+</code>的情况</p>
<p>这个类似于空格，也是要添加一下，我的做法是直接把<code>+</code>和<code>-</code>统一成类型为<code>OP</code>值为对应字符的<code>TOKEN</code>，然后在<code>expr()</code>中最后运算的时候，判断该变量的值是什么，再执行对应的运算。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件开头的PLUS = 'PLUS'修改为</span></span><br><span class="line">OP = <span class="string">'OP'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改get_next_token()</span></span><br><span class="line"><span class="keyword">if</span> current_char == <span class="string">'+'</span> <span class="keyword">or</span> current_char == <span class="string">'-'</span>:</span><br><span class="line">	token = Token(OP, current_char)</span><br><span class="line">	self.pos += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改expr()</span></span><br><span class="line"><span class="keyword">if</span> op.value == <span class="string">'+'</span>:</span><br><span class="line">	result = left + right</span><br><span class="line"><span class="keyword">if</span> op.value == <span class="string">'-'</span>:</span><br><span class="line">	result = left - right</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   <strong>下一课的内容说明了我的想法全是错的…暴风哭泣</strong></p>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>什么是解释器？</p>
<p>解释器把高级语言逐行转译执行。</p>
</li>
<li><p>什么是编译器？</p>
<p>编译器把高级语言翻译成低级语言，再一起执行。</p>
</li>
<li><p>解释器和编译器的区别是什么？</p>
<p>一个是一边翻译一边执行，一个是翻译完再执行。</p>
</li>
<li><p>什么是 token？</p>
<p>有类型的值的对象</p>
</li>
<li><p>将输入拆分成 token 的过程叫什么？</p>
<p>词法分析</p>
</li>
<li><p>解释器中做词法分析的部分叫什么？</p>
<p>词法分析器(lexical analyzer)</p>
</li>
<li><p>解释器或编译器的这个部分还有什么其他常见的名字？</p>
<p>scanner 或 tokenizer</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo + next + github配置blog</title>
    <url>/2020/01/30/hexo-next-github%E9%85%8D%E7%BD%AEblog/</url>
    <content><![CDATA[<h2 id="安装各种东西"><a href="#安装各种东西" class="headerlink" title="安装各种东西"></a>安装各种东西</h2><ol>
<li>node.js：<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js官网链接</a> 点击下载安装即可。</li>
<li>Git： <a href="https://www.git-scm.com/download/win" target="_blank" rel="noopener">Git官网链接</a> 点击下载安装即可。</li>
<li>deployer-git： 命令行里输入<code>npm install hexo-deployer-git --save</code>。</li>
<li>Hexo：<ol>
<li>准备好一个用于存放博客文件的文件夹（比如Github），在该文件夹的根目录下运行刚才装完git以后会出现的git-bash.exe（这里其实直接用cmd进入命令行然后进入博客文件夹也可以）；</li>
<li>输入命令<code>npm install -g hexo-cli</code></li>
</ol>
</li>
</ol>
<a id="more"></a>
<h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><ol>
<li>创建Hexo工程：接着刚才那个命令输入<code>hexo init blog</code>，这里会在这个文件夹下新建一个blog文件夹，如果把blog换成其他名字也是可以的。</li>
<li>新建Post：命令行里进入blog文件夹（<code>cd blog</code>），输入<code>hexo new “HelloWorld”</code>，这里会在 <strong>/blog/sources/_post/</strong> 目录下生成 <strong>HelloWorld.md</strong> 文件，可以进去打开编辑内容，在之后想写新博客也是通过这个命令生成文件，或者直接把写好的博客文件放到该目录下。</li>
<li>生成静态文件：命令行里输入<code>hexo generate</code>，也可以简单地写成<code>hexo g</code>。这样就使用 <strong>Hexo</strong> 引擎将 <strong>Markdown</strong> 格式的文件解析成可以使用浏览器查看的 <strong>HTML</strong> 文件，<strong>HTML</strong> 文件存储在 <strong>blog/public</strong> 目录下。</li>
<li>运行Hexo服务器：命令行里输入<code>hexo server</code>，也可以简写成<code>hexo s</code>。这时命令行会有一些提示，其中有个地址，一般是<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，在浏览器里打开这个地址，就能看到博客网站是什么样的了。不过这个时候还只是一个本地博客。</li>
</ol>
<h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p><strong>Hexo</strong> 提供了默认主题 <strong>landscape</strong>，主题的位置在 <strong>blog -&gt;themes</strong> 文件夹下。主题根据自己喜好可以在网上找到，通过 <strong>Git</strong> 进行相应的下载。接下来以Next主题为例。</p>
<ol>
<li>还是在blog文件夹下，命令行里输入<code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code>，这里是用<code>git clone</code>把<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">next主题</a>下载并存放到themes -&gt; next 文件夹里。需要注意的是，<code>git clone</code>这个命令下载起来特别慢，但浏览器直接去github下载的话速度还行，所以也可以直接下载解压改文件夹的名字并放到对应的地方。</li>
<li>修改 <strong>/blog/config.yml</strong> 文件，将其中的 <strong>theme</strong> 改成 <strong>next</strong>。如果文件夹的名字不是next，或者用了其他主题等，这里的theme改成对应的文件夹名字就行。</li>
<li>接下来可以输入<code>hexo g</code> 和<code>hexo s</code>来查看新的本地博客。</li>
</ol>
<h2 id="建立Github博客"><a href="#建立Github博客" class="headerlink" title="建立Github博客"></a>建立Github博客</h2><ol>
<li><p>在<a href="https://github.com/" target="_blank" rel="noopener">Github官网</a>注册账号并登陆，点首页右上角的加号新建一个仓库(Repository)，仓库的名字为用户名.github.io（比如我的是kun-bin.github.io），这里一定要是这个格式，不然之后没法直接访问博客网站。然后其他的都是默认内容，点create repository就可以了。如果仓库名字输入错了，之后可以在github上这个仓库页面的setting选项中修改。</p>
</li>
<li><p>打开 <strong>/blog/config.yml</strong>文件修改deploy 属性(注意“：”之后有空格 ) 否则配置失败。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;kun-bin&#x2F;kun-bin.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>注意这里repository要替换成自己的仓库地址。</p>
</li>
<li><p>初始化本地仓库：在blog文件夹下的命令行输入<code>git init</code></p>
</li>
<li><p>连接远程仓库：命令行接着输入<code>git remote add origin https://github.com/kun-bin/kun-bin.github.io.git</code>，这里记得把地址改成自己的仓库地址，第一次的时候会要求输入github的账号密码。</p>
</li>
<li><p>发布博客页面：命令行里输入<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>，这等于一次性执行了清空、刷新、部署三个命令，此时在浏览器里已经可以通过<code>用户名.github.io</code>访问博客了，在github的这个仓库里也能看到<strong>/blog/public</strong>文件夹里的内容。</p>
</li>
<li><p>可选：<code>hexo d</code>只是把public文件夹中的内容（也就是静态网页）传到了github的仓库里，应该还可以建立分支把博客配置文件整个传到github上，不过我没做这一步。</p>
</li>
</ol>
<h2 id="关于next主题的配置"><a href="#关于next主题的配置" class="headerlink" title="关于next主题的配置"></a>关于next主题的配置</h2><p>目前在blog文件夹里有一个config.yml文件，我们称之为站点配置文件；而在themes/next文件夹里也有一个config.yml文件，称之为主题配置文件。</p>
<ol>
<li><p>基本信息：打开站点配置文件，找到site模块，可以修改博客标题、作者、描述、语言等等信息，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">subtitle: 副标题</span><br><span class="line">description: 描述</span><br><span class="line">author: 作者</span><br><span class="line">language: 语言（简体中文是zh-Hans）</span><br><span class="line">timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写）</span><br></pre></td></tr></table></figure>
</li>
<li><p>菜单配置：初始网页只有两个菜单：home和archive，可以打开主题配置文件，找到menu模块，把需要的菜单前面的#删了，并注意把||<strong>前面</strong>的空格删了，不然可能会点了菜单以后报错（类似Cannot GET /tags/%20/这样的错）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /|| home                          <span class="comment">//首页</span></span><br><span class="line">  archives: /archives/|| archive          <span class="comment">//归档</span></span><br><span class="line">  categories: /categories/|| th           <span class="comment">//分类</span></span><br><span class="line">  tags: /tags/|| tags                     <span class="comment">//标签</span></span><br><span class="line">  about: /about/|| user                   <span class="comment">//关于</span></span><br><span class="line">  <span class="meta">#schedule: /schedule/|| calendar        <span class="comment">//日程表</span></span></span><br><span class="line">  <span class="meta">#sitemap: /sitemap.xml|| sitemap        <span class="comment">//站点地图</span></span></span><br><span class="line">  <span class="meta">#commonweal: /404/|| heartbeat          <span class="comment">//公益404</span></span></span><br></pre></td></tr></table></figure>
<p>这里||后面的单词是指菜单对应的图标，可以自己修改。此外，日程表那个模块，因为实际上调用的是谷歌日历，国内显然没法用，所以不建议使用。</p>
</li>
<li><p>建立菜单对应的页面：还是在blog文件夹下打开命令行，输入<code>hexo new page &quot;categories&quot;</code>，然后在~/blog/source 文件夹中即可看到categories文件夹，打开里面的index.md文件，设置如下（注意：后面要加空格）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2020-01-30 08:54:26</span><br><span class="line">type: &quot;categories&quot;</span><br></pre></td></tr></table></figure>
<p>tags页面也是一样的方式来建立。</p>
</li>
<li><p>主题风格：一共有四个风格可以选择，打开主题配置文件 找到<code>Scheme Settings</code>，把想用的风格前面的#去掉，比如我这里用了Mist。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line">scheme: Mist</span><br><span class="line"><span class="comment"># scheme: Pisces</span></span><br><span class="line"><span class="comment"># scheme: Gemini</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>侧栏设置：侧栏设置包括：侧栏位置、侧栏显示与否、文章间距、返回顶部按钮等等，打开主题配置文件 找到<code>sidebar</code>，按自己的喜好选择，把想要的那一项的#去掉或者false改成true即可。</p>
</li>
<li><p>头像设置：主题配置文件找到<code>avatar</code>，修改avatar后面的路径为自己头像的路径，头像文件要放到<code>themes/next/source/images</code>中，比如头像文件名为<code>header.jpg</code>，就把那一行写成<code>avatar: /images/header.jpg</code>。如果前面有#就去掉#。</p>
</li>
<li><p>添加搜索：</p>
<ol>
<li><p>还是blog文件夹的命令行里，输入<code>npm install hexo-generator-searchdb --save</code>。</p>
</li>
<li><p>打开站点配置文件找到<code>Extensions</code>在下面添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搜索</span></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  <span class="built_in">limit</span>: 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开主题配置文件找到<code>Local search</code>，将<code>enable</code>设置为<code>true</code>。</p>
</li>
</ol>
</li>
<li><p>还有很多能配置的，比如侧边栏头像下面有github链接，点击页面出现爱心符号，博客背景动态变化等，可自行搜索。</p>
</li>
</ol>
<h2 id="关于ayer主题的配置"><a href="#关于ayer主题的配置" class="headerlink" title="关于ayer主题的配置"></a>关于ayer主题的配置</h2><p>今天（2021.02.26）为了让网页中的公式能稍微好一些，我换了一个新主题<a href="https://shen-yu.gitee.io/2019/ayer/" target="_blank" rel="noopener">ayer</a>。</p>
<ol>
<li><p>安装：在博客文件夹的目录下进命令行输入<code>git clone https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer</code>，如果因为网络原因等问题导致GitHub没法用，可以改用码云：<code>git clone https://gitee.com/mirrors/ayer.git themes/ayer</code>；</p>
</li>
<li><p>博客配置文件中的主题改成<code>ayer</code>；</p>
</li>
<li><p>进主题配置文件进行自己需要的修改，比如调整logo、友情链接、启用公式等等；</p>
</li>
<li><p>需要注意的是，这个主题的分类（categories）、标签（tags）等文件和next主题稍微不一样，需要改一下，以分类为例，进入<code>...\source\categories</code>文件夹，可以看到一个<code>index.md</code>文件，打开以后无论里面有什么内容，都彻底改成以下的：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-01-30 08:54:26</span><br><span class="line">type: "categories"</span><br><span class="line">layout: "categories"</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>相应地，其他用到的文件夹里的<code>index.md</code>也这样改。</p>
</li>
<li><p>安装好以后进行<code>hexo clean</code>等等操作，就可以看到新主题的博客了，不过可能和我的屏幕尺寸有关，在文章页面中，固定的目录栏有些靠右，以至于目录显示不完整，而浮动的目录栏有些靠左了，会挡住正文，当目录很长时，文章几乎没法看了。这时需要打开主题中对目录栏的配置，<code>\themes\ayer\source-src\css\_partial</code>文件夹中的<code>tocbot.styl</code>文件，第一部分<code>.tocbot</code>的<code>right</code>属性从<code>-28rem</code>改成<code>-25rem</code>，这样固定目录栏就相对偏左一些，能显示完整了；第六部分<code>.is-position-fixed</code>的<code>right</code>属性从<code>6rem</code>改成<code>0</code>，这样浮动目录栏就会贴着右边，从而不挡左边了；</p>
</li>
<li><p>按上面这个操作改完以后发现网页的显示并没有变化，接着打开<code>\themes\ayer\source\dist</code>文件夹中的<code>main.css</code>文件，然后直接搜索<code>-28rem</code>或者<code>tocbot</code>等关键词，找到以后把<code>-28</code>和<code>6</code>改成合适的数值（<code>-25</code>和<code>0</code>），重新部署网站就会发现目录栏变合适了。</p>
</li>
</ol>
<h2 id="GitHub风格日历、标签云、分类雷达图的配置"><a href="#GitHub风格日历、标签云、分类雷达图的配置" class="headerlink" title="GitHub风格日历、标签云、分类雷达图的配置"></a>GitHub风格日历、标签云、分类雷达图的配置</h2><p>由于next主题的css文件是swig格式，而网上查到的GitHub日历等都是ejs格式的，因此在用next主题时没能成功配置好日历等；改用Ayer主题后，该主题就是ejs格式的，因此现在添加了日历等内容。这一部分所有涉及到的下载链接都是在别人网站里复制的，如果链接失效可以直接在网上搜文件名来下载，也可以在我的GitHub项目中的主题文件里找已经修改和配置好的相关内容。</p>
<h3 id="需要下载配置的文件"><a href="#需要下载配置的文件" class="headerlink" title="需要下载配置的文件"></a>需要下载配置的文件</h3><ol>
<li><p>下载<a href="https://pan.miaodrew.workers.dev/Drew/web/js/echarts.min.js?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">echarts.min.js</a>，放到主题文件夹中的<code>\source\js</code>文件夹中，</p>
</li>
<li><p>下载<a href="https://pan.miaodrew.workers.dev/Drew/web/css/matery.css?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">matery.css</a>，放到主题文件夹中的<code>\source\css</code>文件夹中。</p>
</li>
<li><p>打开<code>\layout\_partial\head.ejs</code>文件，在<code>head</code>标记中添加一行：</p>
<p><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/matery.css&quot;&gt;</code></p>
<p>这一行直接加到<code>&lt;head&gt;</code>的下一行就好，在我的文件里是加到了第10行，如下图：</p>
<p><img src="https://i.loli.net/2021/02/27/hAeoFcx8wIYlL2S.png" alt="image-20210227182758974"></p>
</li>
</ol>
<h3 id="GitHub风格日历"><a href="#GitHub风格日历" class="headerlink" title="GitHub风格日历"></a>GitHub风格日历</h3><ol>
<li><p>下载<a href="https://pan.miaodrew.workers.dev/Drew/web/ejs-hexo/post-calendar.ejs?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">post-calendar.ejs</a>，放到<code>\layout\_widget</code>文件夹中，如果没有这个文件夹就自己新建一个。</p>
</li>
<li><p>打开<code>post-calendar.ejs</code>文件，看第7行的内容是否为<code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/echarts.min.js&quot;&gt;&lt;/script&gt;</code>，如果不是则改成这样。</p>
</li>
<li><p>在打算添加文章日历的地方，输入以下这行代码</p>
<p><code>&lt;%- partial(&#39;_widget/post-calendar&#39;) %&gt;</code></p>
<p>例如我要加到归档页面（<code>archive</code>），就打开<code>\layout\archive.ejs</code>文件，进行添加。不过Ayer主题的这个文件里就下面这行内容：</p>
<p><code>&lt;%- partial(&#39;_partial/archive&#39;, {pagination: config.archive, index: true}) %&gt;</code></p>
<p>如果直接在这一行前面或者后面添加日历代码，显示效果会不太好，而且会被左边的侧栏挡住，因此找到<code>\layout\_partial\archive.ejs</code>文件，在添加日历代码的时候可以多尝试几个位置，看哪个合适。我打算把日历放到“归档”这两个字的下面，文章列表的上面，于是整个文件的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section class&#x3D;&quot;outer&quot;&gt;</span><br><span class="line">  &lt;% if (theme.ads &amp;&amp; theme.ads.length !&#x3D; 0)&#123; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;ads&#39;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;% if (theme.broadcast.enable &amp;&amp; pagination &#x3D;&#x3D; 2)&#123; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;_partial&#x2F;broadcast&#39;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;article class&#x3D;&quot;articles&quot;&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">    var title &#x3D; &#39;&#39;;</span><br><span class="line">    if (page.category) title &#x3D; page.category;</span><br><span class="line">    if (page.tag) title &#x3D; &quot;#&quot; + &quot;&amp;nbsp&quot; + page.tag;</span><br><span class="line">    if (page.archive) &#123;</span><br><span class="line">      if (page.year) title &#x3D; page.year + (page.month ? &#39;&#x2F;&#39; + page.month : &#39;&#39;);</span><br><span class="line">      else title &#x3D; __(&#39;archive_a&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;% if (pagination !&#x3D;&#x3D; 2)&#123; %&gt;</span><br><span class="line">    &lt;h1 class&#x3D;&quot;page-type-title&quot;&gt;&lt;%- title %&gt;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">    &lt;% if (pagination &#x3D;&#x3D; 2)&#123; %&gt;</span><br><span class="line">    &lt;% page.posts.each(function(post)&#123; %&gt;</span><br><span class="line">    &lt;%- partial(&#39;article&#39;, &#123;post: post, index: true&#125;) %&gt;</span><br><span class="line">    &lt;% &#125;) %&gt;</span><br><span class="line">  &lt;&#x2F;article&gt;</span><br><span class="line">  &lt;% &#125; else &#123; %&gt;</span><br><span class="line">  &lt;% var last; %&gt;</span><br><span class="line">  &lt;% page.posts.each(function(post, i)&#123; %&gt;</span><br><span class="line">  &lt;% var year &#x3D; post.date.year(); %&gt;</span><br><span class="line">  &lt;% if (last !&#x3D; year)&#123; %&gt;</span><br><span class="line">  &lt;% if (last !&#x3D; null)&#123; %&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;% last &#x3D; year; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;_widget&#x2F;post-calendar&#39;) %&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;archives-wrap&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;archive-year-wrap&quot;&gt;</span><br><span class="line">      &lt;a href&#x3D;&quot;&lt;%- url_for(config.archive_dir + &#39;&#x2F;&#39; + year) %&gt;&quot; class&#x3D;&quot;archive-year&quot;&gt;&lt;%&#x3D; year %&gt;&lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;archives&quot;&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">      &lt;%- partial(&#39;archive-post&#39;, &#123;post: post, even: i % 2 &#x3D;&#x3D; 0&#125;) %&gt;</span><br><span class="line">      &lt;% &#125;) %&gt;</span><br><span class="line">      &lt;% if (page.posts.length)&#123; %&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">  &lt;% if (page.total &gt; 1)&#123; %&gt;</span><br><span class="line">  &lt;nav class&#x3D;&quot;page-nav&quot;&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        var prev_text &#x3D; theme.nav_text.page_prev;</span><br><span class="line">        var next_text &#x3D; theme.nav_text.page_next</span><br><span class="line">      %&gt;</span><br><span class="line">    &lt;%- paginator(&#123;</span><br><span class="line">        prev_text: prev_text,</span><br><span class="line">        next_text: next_text</span><br><span class="line">      &#125;) %&gt;</span><br><span class="line">  &lt;&#x2F;nav&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;&#x2F;section&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后呈现的效果如下：</p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/02/27/sXmQr18FJ6HtNko.png" alt="image-20210227184135159"></p>
<h3 id="标签云"><a href="#标签云" class="headerlink" title="标签云"></a>标签云</h3><ol>
<li><p>下载<a href="https://cdn.jsdelivr.net/gh/InfiniteYinux/cloud@2.44/Hexo/themeConfig/tag-cloud.ejs" target="_blank" rel="noopener">tag-cloud.ejs</a>，放到<code>\layout\_widget</code>文件夹中，如果没有这个文件夹就自己新建一个。</p>
</li>
<li><p>打开<code>tag-cloud.ejs</code>，和前面那个日历一样，检查是否有<code>&lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%- theme.jsDelivr.url %&gt;&lt;%- theme.libs.js.echarts %&gt;&quot;&gt;&lt;/script&gt;</code>，如果有则替换为<code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/echarts.min.js&quot;&gt;&lt;/script&gt;</code>。如果没有就忽略。</p>
</li>
<li><p>在需要添加标签云的地方，输入代码：<code>&lt;%- partial(&#39;_widget/tag-cloud&#39;) %&gt;</code></p>
</li>
<li><p>例如我要将这个添加到原本的标签页面，则找到<code>\layout\tags.ejs</code>文件，添加标签云代码。需要注意的是，Ayer主题本身会在这个页面自动生成标签，因此需要把<code>tags.ejs</code>文件中原本的标签内容那行去掉，整个文件改成了以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section class&#x3D;&quot;outer&quot;&gt;</span><br><span class="line">  &lt;% if (site.tags.length)&#123; %&gt;</span><br><span class="line">    &lt;h1 class&#x3D;&quot;page-type-title&quot;&gt;&lt;%&#x3D; __(&#39;tags&#39;) %&gt;&lt;&#x2F;h1&gt;</span><br><span class="line">	&lt;%- partial(&#39;_widget&#x2F;tag-cloud&#39;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;&#x2F;section&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此外，标签云本身的标题和Ayer主题中的标题会重复显示，而我更喜欢Ayer本身那个标题，所以编辑了<code>tag-cloud.ejs</code>文件，把第25行的<code>&lt;i class=&quot;fas fa-tags&quot;&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;&lt;%= __(&#39;postTagTitle&#39;) %&gt;</code>中的<code>postTagTitle</code>改成了空格，之所以没直接去掉这一行，是因为觉得空一行好看一些。</p>
</li>
<li><p>整体效果如图，和Ayer主题本身的标签相比，要好看一些。标签的颜色也可以在<code>tag-cloud.ejs</code>文件中自行修改。<img src="https://i.loli.net/2021/02/27/il6UtNjZsCkqozK.png" alt="image-20210227185130174"></p>
</li>
</ol>
<h3 id="分类雷达图"><a href="#分类雷达图" class="headerlink" title="分类雷达图"></a>分类雷达图</h3><ol>
<li><p>下载<a href="https://pan.miaodrew.workers.dev/Drew/web/ejs-hexo/category-radar.ejs?rootId=0AAjrE2SiYnTaUk9PVA" target="_blank" rel="noopener">category-radar.ejs</a>，放到<code>\layout\_widget</code>文件夹中，如果没有这个文件夹就自己新建一个。</p>
</li>
<li><p>依旧是检查替换<code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/echarts.min.js&quot;&gt;&lt;/script&gt;</code>，如果没有就忽略。</p>
</li>
<li><p>在需要添加分类雷达图的地方，输入代码：<code>&lt;%- partial(&#39;_widget/category-radar&#39;) %&gt;</code></p>
</li>
<li><p>例如我要添加到原本的分类（<code>category</code>）页面，就找到<code>\layout\categories.ejs</code>，这里我不打算去掉原本的分类内容，因此不删除原本的代码，直接添加雷达图代码，修改后的文件整体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section class&#x3D;&quot;outer&quot;&gt;</span><br><span class="line">  &lt;% if (site.categories.length)&#123; %&gt;</span><br><span class="line">    &lt;h1 class&#x3D;&quot;page-type-title&quot;&gt;&lt;%&#x3D; __(&#39;categories&#39;) %&gt;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;categories-box&quot;&gt;</span><br><span class="line">      &lt;%- list_categories() %&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;_widget&#x2F;category-radar&#39;) %&gt;</span><br><span class="line">&lt;&#x2F;section&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果觉得这个雷达图和主题格格不入，想给它加个边框，则可以在刚才的<code>categories.ejs</code>文件最开头的地方粘贴以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">        #contentss &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">        width: 800px;</span><br><span class="line">        height: 1200px;</span><br><span class="line">        max-height: 1200px;</span><br><span class="line">        margin-bottom: 15px;</span><br><span class="line">        margin-top: 15px;</span><br><span class="line">        text-align: center;</span><br><span class="line">        border: 0;</span><br><span class="line">        border-radius: 10px;</span><br><span class="line">        color: rgba(0, 0, 0, .87);</span><br><span class="line">        background: #fff 50%;</span><br><span class="line">        background-size: cover;</span><br><span class="line">        box-shadow: 0 15px 35px rgba(50, 50, 93, .1), 0 5px 15px rgba(0, 0, 0, .07);</span><br><span class="line">        margin:0 auto;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p>然后下面的雷达图代码修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;contentss&quot;&gt;</span><br><span class="line">&lt;%- partial(&#39;_widget&#x2F;category-radar&#39;) %&gt;&lt;&#x2F;div&gt;&#96;或者&#96;&lt;%- partial(&#39;_widget&#x2F;post-calendar&#39;) %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>边框的大小样式颜色等等可以自行修改。不过Ayer主题不加边框就挺合适了，因此我没加。</p>
</li>
<li><p>整体效果如下（这个截图是一开始没注意，把雷达图加到了标签页面，但是不影响雷达图的展示；此外，很显然分类名字过长就会显示不完整，这应该和雷达图的大小有关，懒得改了）：</p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/02/27/4TRVLa5sFIzktBX.png" alt="image-20210227190056808"></p>
<h2 id="如何发布新的博客"><a href="#如何发布新的博客" class="headerlink" title="如何发布新的博客"></a>如何发布新的博客</h2><ol>
<li><p>在blog文件夹的命令行里输入<code>hexo new &quot;标题&quot;</code>，然后进入<strong>/blog/sources/_post/</strong>找到对应的markdown文件就可以开始写了，也可以直接在这个文件夹下新建一个markdown文件，然后添加对应的文件头。写博客的时候根据需求在文件头里填写tags和categories的信息，然后hexo会自动建立好tags和categories的内容并给文章分类。</p>
<p>文件头信息如下编写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>写好以后保存，然后还是blog文件夹的命令行，输入<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>，就发布成功了。</p>
</li>
<li><p>如果一个文章想设置多个标签，那么在编写文件头信息的时候，要按下面的方式写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line">	- tag1</span><br><span class="line">	- tag2</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>这里<code>tags:</code> 后面一定要换行，下面的<code>-</code>后面注意有空格。</p>
</li>
</ol>
<h2 id="一些后续问题"><a href="#一些后续问题" class="headerlink" title="一些后续问题"></a>一些后续问题</h2><p>今天（2020.03.16）突然发现当博客内容多起来以后，首页会有翻页，而翻页图标显示是乱的，查了一下发现要改<code>/Blog/themes/next/layout/_partials/pagination.swig</code>这个文件，内容整体替换成下面的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;%- if page.prev or page.next %&#125;</span><br><span class="line"> <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"pagination"</span>&gt;</span></span><br><span class="line">   &#123;&#123;</span><br><span class="line">     paginator(&#123;</span><br><span class="line">       prev_text: '<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-angle-left"</span> <span class="attr">aria-label</span>=<span class="string">"'+__('accessibility.prev_page')+'"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>',</span><br><span class="line">       next_text: '<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-angle-right"</span> <span class="attr">aria-label</span>=<span class="string">"'+__('accessibility.next_page')+'"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>',</span><br><span class="line">       mid_size: 1,</span><br><span class="line">       escape: false</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SSH登录配置"><a href="#SSH登录配置" class="headerlink" title="SSH登录配置"></a>SSH登录配置</h2><p>每次<code>hexo d</code>的时候都要输入用户名和密码会很麻烦，所以今天做了一下这个。</p>
<ol>
<li><p>首先进入博客目录比如<code>C:\Users\LiKun\Documents\GitHub\blog</code>，在这个目录下右键然后打开git bash，如果右键没这个选项那就去开始菜单之类的地方打开git bash然后一点点切目录；</p>
</li>
<li><p>输入<code>ls -al ~/.ssh</code>检查目前是否有已经生成过的密钥文件，这个命令会输出<code>.ssh</code>里的文件，如果其中有<code>id_rsa.pub</code>或者<code>id_dsa.pub</code>，那就直接看第五步，如果这俩都没有就继续第三步；</p>
</li>
<li><p>输入<code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code>，这里注意把自己的邮箱替换进去，看到提示<code>Enter file in which to save the key (/c/Users/you/.ssh/id_rsa):</code>时，直接按回车；</p>
</li>
<li><p>然后会要求输入密码，这个密码要记住，在第一次使用该ssh密钥时系统会要求输入它，也就是说后面会用，<strong>不过这里有个坑</strong>；</p>
</li>
<li><p>输入<code>clip &lt; ~/.ssh/id_rsa.pub</code>，即可把密钥内容复制到剪贴板，或者自己进<code>.ssh</code>找到密钥文件复制也行；</p>
</li>
<li><p>浏览器打开Github页面，右上角头像那里的下拉菜单有个Settings，点开以后左边找到<code>SSH and GPG keys</code>，点开以后右边的界面会列出目前所有的密钥，如果之前没做过那这里是空的；</p>
</li>
<li><p>SSH Keys那里点<code>New SSH Key</code>，名字随便设置，密钥部分粘贴第五步复制的那个，然后保存；</p>
</li>
<li><p>接下来回博客目录，找到<code>_config.yml</code>，也就是站点配置文件，把最下面<code>deploy</code>属性中的<code>repository:</code>内容修改成<code>git@github.com:你的name/你的username.github.io.git</code>的样子，比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:likun1208/likun1208.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>这里有的地方也把<code>repository:</code>写成<code>repo:</code>，应该都行。</p>
</li>
<li><p>然后命令行里<code>hexo d</code>，会要求输入之前第四步里的那个密码；</p>
</li>
<li><p>我本来以为，第四步那个密码是输入一次之后就不用再输入的，然而尝试几次以后发现是每次都要输入，查了很多网页，有说配置ssh的config文件，有说修改host，总之都不太对，最终才发现，这一切都是因为第四步设置了密码，如果第四步不设置密码，一路按回车，就没有任何问题了！ssh似乎没提供修改密码的方式，所以就需要重新输入<code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code>，生成新的密钥文件并复制，然后去github的settings那里删旧密钥加新密钥，其他配置不用改动。</p>
</li>
</ol>
<h2 id="分支同步"><a href="#分支同步" class="headerlink" title="分支同步"></a>分支同步</h2><p>今天研究了一下把博客所有文件上传到github仓库的一个分支，这样可以在多个电脑上同步写博客而不需要用U盘来回复制。首先，如果前面没有自己定义分支的名字，那么我们的网站内容是存放在<code>master</code>分支的，在这一步，我们会新建一个<code>hexo</code>分支，来存放博客文件（指主题文件和博客markdown文件等）。具体来说，当我们需要在多个电脑之间迁移博客时，会受影响的文件如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">文件（夹）</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">scaffolds/</td>
<td style="text-align:center">博客文章的模版</td>
</tr>
<tr>
<td style="text-align:center">source/</td>
<td style="text-align:center">所有博客文章，以及about、tags、categories等page</td>
</tr>
<tr>
<td style="text-align:center">themes/</td>
<td style="text-align:center">网站的主题</td>
</tr>
<tr>
<td style="text-align:center">.gitignore</td>
<td style="text-align:center">在push时需要忽略的文件和文件夹</td>
</tr>
<tr>
<td style="text-align:center">_config.yml</td>
<td style="text-align:center">站点配置文件</td>
</tr>
<tr>
<td style="text-align:center">package.json</td>
<td style="text-align:center">依赖包的名称和版本号</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>在github网站上找到自己的博客项目，新建<code>hexo</code>分支，并设置为主分支；</p>
</li>
<li><p>在本地博客文件夹里打开git bash，输入<code>git clone git@github.com:用户名/用户名.github.io.git</code>，把<code>hexo</code>分支复制到本地，这里的用户名请自行替换；</p>
</li>
<li><p>在博客文件夹里找到<code>.gitignore</code>文件，如果没有这个文件就自己新建一下，注意这个文件开头就是<code>.</code>，整个名字就是<code>.gitignore</code>，然后打开它里面写入以下内容，表示同步的时候忽略这些文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules&#x2F;</span><br><span class="line">public&#x2F;</span><br><span class="line">.deploy*&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的<code>.git</code>文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了；</p>
</li>
<li><p>然后在git bash里输入以下命令，即可完成<code>hexo</code>分支的上传：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit –m &quot;add branch&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>这里的add branch可以改成其他内容，表示这次上传的说明注释；</p>
</li>
<li><p>到此就完成了上传，这样换电脑以后，按照前面的内容把git和hexo以及其他相关东西都安装配置好以后，通过git把这个项目文件下载到本地，就又可以编辑博客了；</p>
</li>
<li><p>如果多个电脑同时在写博客，时不时需要同步博客内容，就不需要<code>git clone</code>下载整个文件，只需要<code>git pull</code>把远程文件同步到本地即可；</p>
</li>
<li><p>总结一下就是，每次写博客之前，首先<code>git pull</code>把github上的博客内容下载到本地；写完新的内容，首先进行<code>hexo clean, hexo g, hexo d</code>把内容渲染成网页并发布，接着<code>git add ., git commit -m &quot;description&quot;, git push</code>把新增和修改的内容也上传到github，这样就可以实现白天在实验室写，晚上回宿舍写的操作了；</p>
</li>
<li><p>以上操作也可以通过github的桌面版程序来完成，还挺方便。</p>
</li>
</ol>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://segmentfault.com/a/1190000018761324" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018761324</a></p>
<p><a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">https://www.jianshu.com/p/3a05351a37dc</a></p>
<p><a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502" target="_blank" rel="noopener">https://blog.csdn.net/nightmare_dimple/article/details/86661502</a></p>
<p><a href="https://blog.csdn.net/lihangll/article/details/103335246" target="_blank" rel="noopener">https://blog.csdn.net/lihangll/article/details/103335246</a></p>
<p><a href="https://www.cnblogs.com/xinxiandong/p/3867505.html" target="_blank" rel="noopener">https://www.cnblogs.com/xinxiandong/p/3867505.html</a></p>
<p><a href="https://blog.csdn.net/hhgggggg/article/details/77853665" target="_blank" rel="noopener">https://blog.csdn.net/hhgggggg/article/details/77853665</a></p>
<p><a href="https://blog.csdn.net/xiaomengzi_16/article/details/98847298" target="_blank" rel="noopener">https://blog.csdn.net/xiaomengzi_16/article/details/98847298</a></p>
<p><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762</a></p>
<p><a href="https://blog.csdn.net/White_Idiot/article/details/80685990" target="_blank" rel="noopener">https://blog.csdn.net/White_Idiot/article/details/80685990</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1597223" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1597223</a></p>
<p><a href="https://cndrew.cn/2020/03/03/calender/" target="_blank" rel="noopener">https://cndrew.cn/2020/03/03/calender/</a></p>
]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
